/*
	© 2019 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2018.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2019 年度。
\version r115
\author FrankHB <frankhb1989@gmail.com>
\since build 818
\par 创建时间:
	2019-01-02 01:00:32 +0800
\par 修改时间:
	2019-03-11 16:33 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2019
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2019-01:

report.impl:
Unifying parameter type has been reviewd.
	This basically judges whether a forwarding reference parameter or a non-reference (object) parameter used in a specific context.
	The rationale is previously published as an answer at https://stackoverflow.com/questions/21035417/is-the-pass-by-value-and-then-move-construct-a-bad-idiom/53825424#53825424.
		A core notion of judgement for whether style used is "ignorable" of the cost, to ensure there is no unacceptable overhead while having the pros of non-reference parameters.
		If and only if the ignorable condition is true in the context, unifying (non-reference parameter) is preferred.
	The non-reference (object) types are applied to callable parameters in operations concerned with callable wrappers.
		This is consistent to 'std::function', 'ystdex::function' and similar types.
		Class templates like 'ystdex::expanded_caller', 'YSLib::GHEvent', 'YSLib::GEvent' and their helpers like 'ystdex::make_expanded' have been adjust consistent with this style.
			Previously, the constructors of the instantiated classes might have different styles used. The inconsistecy has now been fixed.
			It also saves several 'ystdex::decay_t' template instantation and it further reduces bloat of internal templated code using such types before decaying.
				For 'YSLib::GHEvent', this also makes internal operations for equality have more consistent types in different cases.
			For caller sites passing values to such operations, the forwarding calls have to been modified for efficiency and avoidance of unexpected copies of arguments being passed.
				This is mostly by changing 'yforward' to 'std::move'.
				Note 'ystdex::expanded_caller' is special in some cases, as it does not necessarily used as a holder-like wrapper.
					For caller site in NPLA1, this is better changed to 'ystdex::lref'. However, 'ystdex::expanded_caller' currently does not support qualifiers other than 'const'.
						So 'ref-qualifiers' are not respected in the calls.
						This is known and documented in the comments.
	Note constructors of 'ystdex::any' are not the same, as it does not assume the parameter object having ignorable cost during passing like the wrappers above.
WG21 P0541 has been implemented now, as it is approved in the current working paper of the standard.
	The major change is adding the pair initialization with uses-allocator construction recursively.
	Other change includes simplification on allocators.
		For 'pmr::polymorphic_allocator', it is simplified even when used with Microsoft VC++, which has no support yet.
		There is nothing to do with 'scoped_allocator_adaptor' because it is not introduced in 'ystdex'.
	The implementation is somewhat tricky.
		Since it needs to work without inferred trailing return type indroduced in ISO C++14, the declarations of implmentations are broken down in pieces when necessary.
		The implementation reveals some fixes on buggy 'ystdex::is_invocable' and related traits (while the 'std' implementations in libstdc++ is correct).
			The cv-qualified recursive instantiation will not work because of types mismatched in different declarations and function body in the implementation.
				The bug in the traits wronly used the functional declarator as the template arguments internally, which dropped qualifiers unexpectedly.
				For the similar reason, the already removed 'std::result_of' does not qualify to be used here.
			Another bug is that missing SFINAE in 'ystdex::is_invocable_r' and 'ystdex::is_nothrow_invocable_r'.
				The bug in 'ystdex::is_invocable_r' is caused by incomplete type handling.
					See also https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65760 for the similar bug.
				The bug 'ystdex::is_nothrow_invocable_r' has more concerns on 'noexcept' test.
				These bugs are not directly concerned here, but since the bug of 'ystdex::is_invocable_r' makes constructors of 'ystdex::function' not conforming as 'std::function', they are also fixed together.
		There are also multiple implementation issues.
			Mostly issues will not be problems without recursive pair support.
			At least for platform Android, libstdc++ is lack of the resolution of WG21 N4387, i.e. the conditionally EXPLICIT constructor of 'std::pair', so there needs additional workaround.
			For platform DS, G++ 8.1 complaints weirdly with an error on use of deleted defaulted function.
				The error is triggered when instantiating the event map lookup ('emplace_hint') in YFramework module YSLib::UI::YWidgetEvent after the feature here is implemented.
					See also LWG 2397, whose resolution is conditionally used here.
				The error is similar to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88368.
					However, because it is on instantiating 'YSLib::ValueHolder<std::_Tuple_impl<2, std::tuple<YSLib::ValueObject&&>&&>>' so there is no way to insert the proposed workaround.
				Clang++ 7.0 does not has the problem.
				It is unknown why this bug is not on platform MinGW (G++ 7.3), Android (G++ 5.3) (after other workarounds), and Linux (G++ 8.2), despite that the bugzilla issue also does not locate the root of the bug precisely.
					Note the header <tuple> is exactly same between platforms MinGW and DS.
				For interface used by 'YSLib::ValueObject' implementation, there is room to implement.
					The user code may be broken if 'ystdex::any' constructors are not SFINAE-friendly after the 'ystdex::any' initialization involving the allocator calling with 'ystdex::uninitialized_construct_using_allocator'.
						The template default arguments for SFINAE are tricky.
							They are carefully coded to avoid infinite recursion on deducing the template parameters.
							As there can be static assertions in value holders, non-holders are checked to ensure they are not the template argument of the holders.
					To use the SFINAE-friend 'ystdex::any' constructors, 'ystdex::any_ops::construct' and holders 'init' static member function templates are also tuned to be SFINAE-friendly.
					For use of 'ValueObject' with SFINAE-friendly constructions, 'ystdex::boxed_value' is also improved with SFINAE-friendly constructors.
					It can be still broken when 'std::tuple<const ValueObject&>' (rather than 'std::tuple<ValueObject&>') used with instantaiation of 'ystdex::uses_allocator_construction_args'.
						This is broken by SFINAE check in infinite recursion of 'std::tuple' constructor for multiple elements, which should fail in this case.
						This only breaks non-C++17 modes (with GNU extensions or not) in G++ and Clang++.
							It has nothing to do with 'std::invoke'.
							It should have nothing to do with CWG 1227, as C++14 modes also fail.
				As the workaround, nonthrowing check is intercepted for 'std::_Tuple_impl' instances used for 'ystdex::boxed_value'.
				Other workaround includes preventing nested (in template parameters) 'YSLib::ValueHolder' instances constructed in 'ValueObject'.
					This is not guarded by the compiler version condition checks because behavior of avoiding nested 'YSLib::ValueHolder' should be uniform for all implementations.

$2019-03:

report.impl:
Pointer holder in module YSLib::Core::YObject is reworked.
	Semantic properties on lifetime have changed.
		Based on clarification of allowing exception in holder 'get' function in module YStandardEx::Any, getting an object may throw an exception if the object is not existed.
		Since the getter may throw, some 'ystdex::any' API as well as 'GetObject' overloads for 'ValueObject' do not have noexcept-specifier any longer.
	For weak pointers ('NPL::weak_ptr' instances), the getter can throw on expired now.
	However, the 'type' function in the pointer holder still does not throw. But the behavior is also changed.
		Now it does not reilies on owner judgement.
		For weak pointers, it does not need to get strong pointers to get the type.
			An expired value might lead to 'void' type previously. This is changed to getting 'void' only when the pointer value is null despite the owner.
			User code should be careful in this case.

////

