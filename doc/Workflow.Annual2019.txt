/*
	© 2019 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2018.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2019 年度。
\version r189
\author FrankHB <frankhb1989@gmail.com>
\since build 818
\par 创建时间:
	2019-01-02 01:00:32 +0800
\par 修改时间:
	2019-03-17 08:04 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2019
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2019-01:

report.impl:
Unifying parameter type has been reviewd.
	This basically judges whether a forwarding reference parameter or a non-reference (object) parameter used in a specific context.
	The rationale is previously published as an answer at https://stackoverflow.com/questions/21035417/is-the-pass-by-value-and-then-move-construct-a-bad-idiom/53825424#53825424.
		A core notion of judgement for whether style used is "ignorable" of the cost, to ensure there is no unacceptable overhead while having the pros of non-reference parameters.
		If and only if the ignorable condition is true in the context, unifying (non-reference parameter) is preferred.
	The non-reference (object) types are applied to callable parameters in operations concerned with callable wrappers.
		This is consistent to 'std::function', 'ystdex::function' and similar types.
		Class templates like 'ystdex::expanded_caller', 'YSLib::GHEvent', 'YSLib::GEvent' and their helpers like 'ystdex::make_expanded' have been adjust consistent with this style.
			Previously, the constructors of the instantiated classes might have different styles used. The inconsistecy has now been fixed.
			It also saves several 'ystdex::decay_t' template instantation and it further reduces bloat of internal templated code using such types before decaying.
				For 'YSLib::GHEvent', this also makes internal operations for equality have more consistent types in different cases.
			For caller sites passing values to such operations, the forwarding calls have to been modified for efficiency and avoidance of unexpected copies of arguments being passed.
				This is mostly by changing 'yforward' to 'std::move'.
				Note 'ystdex::expanded_caller' is special in some cases, as it does not necessarily used as a holder-like wrapper.
					For caller site in NPLA1, this is better changed to 'ystdex::lref'. However, 'ystdex::expanded_caller' currently does not support qualifiers other than 'const'.
						So 'ref-qualifiers' are not respected in the calls.
						This is known and documented in the comments.
	Note constructors of 'ystdex::any' are not the same, as it does not assume the parameter object having ignorable cost during passing like the wrappers above.
WG21 P0541 has been implemented now, as it is approved in the current working paper of the standard.
	The major change is adding the pair initialization with uses-allocator construction recursively.
	Other change includes simplification on allocators.
		For 'pmr::polymorphic_allocator', it is simplified even when used with Microsoft VC++, which has no support yet.
		There is nothing to do with 'scoped_allocator_adaptor' because it is not introduced in 'ystdex'.
	The implementation is somewhat tricky.
		Since it needs to work without inferred trailing return type indroduced in ISO C++14, the declarations of implmentations are broken down in pieces when necessary.
		The implementation reveals some fixes on buggy 'ystdex::is_invocable' and related traits (while the 'std' implementations in libstdc++ is correct).
			The cv-qualified recursive instantiation will not work because of types mismatched in different declarations and function body in the implementation.
				The bug in the traits wronly used the functional declarator as the template arguments internally, which dropped qualifiers unexpectedly.
				For the similar reason, the already removed 'std::result_of' does not qualify to be used here.
			Another bug is that missing SFINAE in 'ystdex::is_invocable_r' and 'ystdex::is_nothrow_invocable_r'.
				The bug in 'ystdex::is_invocable_r' is caused by incomplete type handling.
					See also https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65760 for the similar bug.
				The bug 'ystdex::is_nothrow_invocable_r' has more concerns on 'noexcept' test.
				These bugs are not directly concerned here, but since the bug of 'ystdex::is_invocable_r' makes constructors of 'ystdex::function' not conforming as 'std::function', they are also fixed together.
		There are also multiple implementation issues.
			Mostly issues will not be problems without recursive pair support.
			At least for platform Android, libstdc++ is lack of the resolution of WG21 N4387, i.e. the conditionally EXPLICIT constructor of 'std::pair', so there needs additional workaround.
			For platform DS, G++ 8.1 complaints weirdly with an error on use of deleted defaulted function.
				The error is triggered when instantiating the event map lookup ('emplace_hint') in YFramework module YSLib::UI::YWidgetEvent after the feature here is implemented.
					See also LWG 2397, whose resolution is conditionally used here.
				The error is similar to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88368.
					However, because it is on instantiating 'YSLib::ValueHolder<std::_Tuple_impl<2, std::tuple<YSLib::ValueObject&&>&&>>' so there is no way to insert the proposed workaround.
				Clang++ 7.0 does not has the problem.
				It is unknown why this bug is not on platform MinGW (G++ 7.3), Android (G++ 5.3) (after other workarounds), and Linux (G++ 8.2), despite that the bugzilla issue also does not locate the root of the bug precisely.
					Note the header <tuple> is exactly same between platforms MinGW and DS.
				For interface used by 'YSLib::ValueObject' implementation, there is room to implement.
					The user code may be broken if 'ystdex::any' constructors are not SFINAE-friendly after the 'ystdex::any' initialization involving the allocator calling with 'ystdex::uninitialized_construct_using_allocator'.
						The template default arguments for SFINAE are tricky.
							They are carefully coded to avoid infinite recursion on deducing the template parameters.
							As there can be static assertions in value holders, non-holders are checked to ensure they are not the template argument of the holders.
					To use the SFINAE-friend 'ystdex::any' constructors, 'ystdex::any_ops::construct' and holders 'init' static member function templates are also tuned to be SFINAE-friendly.
					For use of 'ValueObject' with SFINAE-friendly constructions, 'ystdex::boxed_value' is also improved with SFINAE-friendly constructors.
					It can be still broken when 'std::tuple<const ValueObject&>' (rather than 'std::tuple<ValueObject&>') used with instantaiation of 'ystdex::uses_allocator_construction_args'.
						This is broken by SFINAE check in infinite recursion of 'std::tuple' constructor for multiple elements, which should fail in this case.
						This only breaks non-C++17 modes (with GNU extensions or not) in G++ and Clang++.
							It has nothing to do with 'std::invoke'.
							It should have nothing to do with CWG 1227, as C++14 modes also fail.
				As the workaround, nonthrowing check is intercepted for 'std::_Tuple_impl' instances used for 'ystdex::boxed_value'.
				Other workaround includes preventing nested (in template parameters) 'YSLib::ValueHolder' instances constructed in 'ValueObject'.
					This is not guarded by the compiler version condition checks because behavior of avoiding nested 'YSLib::ValueHolder' should be uniform for all implementations.

$2019-03:

report.impl:
Pointer holder in module YSLib::Core::YObject is reworked.
	Semantic properties on lifetime have changed.
		Based on clarification of allowing exception in holder 'get' function in module YStandardEx::Any, getting an object may throw an exception if the object is not existed.
		Since the getter may throw, some 'ystdex::any' API as well as 'GetObject' overloads for 'ValueObject' do not have noexcept-specifier any longer.
	For weak pointers ('NPL::weak_ptr' instances), the getter can throw on expired now.
	However, the 'type' function in the pointer holder still does not throw. But the behavior is also changed.
		Now it does not reilies on owner judgement.
		For weak pointers, it does not need to get strong pointers to get the type.
			An expired value might lead to 'void' type previously. This is changed to getting 'void' only when the pointer value is null despite the owner.
			User code should be careful in this case.
NPL objects involved with pointer holders are effected by the change of pointer holder in module YSLib::Core::YObject.
	Values of Weak references in the past would be more troblesome as the values without strong reference is recognized as 'void' rather than concrete type.
		So, there would be simply wrong value rather than the 'YSLib::bad_weak_ptr' exception thrown, if no other strong reference is kept.
		The only example is 'ContextHandler' used as the default object by the call of 'NPL::A1::Forms::DefineWithRecursion'.
	This is now changed to improve the interoperbility.
		See the discussions of pointer holder modification for weak pointers above for reasons.
	Keeping some strong references elsewhere is however difficult after the whole evaluation without special handling using centralized storage (e.g. in 'NPL::ContextNode').
Internal recursive thunk as the part of implementation of function 'NPL::A1::Forms::DefineWithRecursion' is reworked.
	To allow identifying the situation of cyclic references, default objects still use weak references, but the behavior is slightly changed. See the discussions concerned with pointer holders above.
	Now newly bound variables are stable, i.e. they do not be restored to another values in the call of 'NPL::Forms::DefineWithRecursion' after the evaluation of the expression as the binding source.
		This ensures references to these variables do not go out of their lifetime unexpectedly.
		After defining, the default objects are recovered as thunks which access the environment by name for the real caller when called.
			This allows check and exceptions can be thrown on failure.
	Expired 'weak_ptr<ContextNode>' value in a default object is a corruptied value.
		This is now handled generally by by improved implementation in modules NPL::NPLA and NPL::NPLA1 with API provided by module NPL::NPLA.
		If the default object is corruptied and called, it would throw a different exception ('bad_weak_ptr') from default ones.
			This is undefined behavior in the object language.
				The current behavior is for ease of debugging.
				Although it will not changed frequently, the behavior is not guaranteed stable.
	Implementation of operative '$defrec!' (by 'Forms::DefineWithRecursion') is revised.
		To avoid undefined behavior caused by recursive reference with ownership, the weak reference of target bindings is kept.
		The environment access to recursive binding is now delayed with symbol access to the locked-on-access environment, to allow more error checked (in case of already undefined behavior specified in the object language), e.g. by throwing 'bad_weak_ptr'.
		Since the environment enclosing the bound variables does not have strong reference to the object, it should be careful to save the environment in the binding with 'lock-current-environment', rather than 'get-current-environment', if necessary.
	The implementation difference is significant especailly when 'NPL::LiftToReturn' does not lift reference at first by 'NPL::LiftTermRefToSelf' (now removed).
		The lift makes it essentially deep copies the shared value (configured by pointer holders) of bound variables.
			See the values of shared variable '$aux' in the following cases.
		Case 1 (an alternative derivation of '$sequence'):
			$def! $sequence
				($lambda (&cenv) ($lambda #ignore $vau/e cenv body env
					$if (null? body) inert (eval (cons $aux body) env))
					($setrec! cenv $aux $vau/e (weaken-environment cenv)
						(&head .&tail) env
						$if (null? tail) (eval head env) (($lambda #ignore
							(eval (cons $aux tail) env)) (eval head env)))
				)
				(() make-standard-environment);
			$sequence "a" "b";
			The case above will not work without deep copy in 'NPL::LiftToReturn' of the shared values if '$aux' is not stable.
				Alternatively, lift specifically configured in implementation of 'cons' or wrapping '$aux' with a native deep copy identity function for both occurences is also OK.
		Case 2 (an invalid derivation of '$sequence'):
			$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (() copy-environment) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (() copy-environment) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))))
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));
			$sequence "a" "b";
			The derivation is invalid because of cyclic references, which implies undefined behavior in NPLA1.
				With the deep copy (likewise in Case 1), it will occasionally work as the '$aux' is unshared before calling.
					With modification of '$defrec!' with delayed environment access, it does not work.
				Without the deep copy and '$defrec!' modification, it also does not work.
					It will access invalid memory by TCO in the call using the shared value hold by '$aux'.
					It will access invalid memory or infinitely recursively reenters the host function (value of 'NPL::ContextHanlder') of '$aux'.
						Whether to reenter depends on the implementation details of 'NPL::Forms::DefineWithRecursion'.
				The applicative 'deshare' is provided to restore the deep copy locally. It is not needed in most cases.
			The workable derivation is:
				$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (make-environment (() lock-current-environment) (() copy-environment)) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (make-environment (() lock-current-environment) (() copy-environment)) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))
					)
				)
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));

////

