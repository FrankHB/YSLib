/*
	© 2019 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2018.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2019 年度。
\version r357
\author FrankHB <frankhb1989@gmail.com>
\since build 818
\par 创建时间:
	2019-01-02 01:00:32 +0800
\par 修改时间:
	2019-06-23 10:16 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2019
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2019-01:

report.impl:
Unifying parameter type has been reviewd.
	This basically judges whether a forwarding reference parameter or a non-reference (object) parameter used in a specific context.
	The rationale is previously published as an answer at https://stackoverflow.com/questions/21035417/is-the-pass-by-value-and-then-move-construct-a-bad-idiom/53825424#53825424.
		A core notion of judgement for whether style used is "ignorable" of the cost, to ensure there is no unacceptable overhead while having the pros of non-reference parameters.
		If and only if the ignorable condition is true in the context, unifying (non-reference parameter) is preferred.
	The non-reference (object) types are applied to callable parameters in operations concerned with callable wrappers.
		This is consistent to 'std::function', 'ystdex::function' and similar types.
		Class templates like 'ystdex::expanded_caller', 'YSLib::GHEvent', 'YSLib::GEvent' and their helpers like 'ystdex::make_expanded' have been adjust consistent with this style.
			Previously, the constructors of the instantiated classes might have different styles used. The inconsistecy has now been fixed.
			It also saves several 'ystdex::decay_t' template instantation and it further reduces bloat of internal templated code using such types before decaying.
				For 'YSLib::GHEvent', this also makes internal operations for equality have more consistent types in different cases.
			For caller sites passing values to such operations, the forwarding calls have to been modified for efficiency and avoidance of unexpected copies of arguments being passed.
				This is mostly by changing 'yforward' to 'std::move'.
				Note 'ystdex::expanded_caller' is special in some cases, as it does not necessarily used as a holder-like wrapper.
					For caller site in NPLA1, this is better changed to 'ystdex::lref'. However, 'ystdex::expanded_caller' currently does not support qualifiers other than 'const'.
						So 'ref-qualifiers' are not respected in the calls.
						This is known and documented in the comments.
	Note constructors of 'ystdex::any' are not the same, as it does not assume the parameter object having ignorable cost during passing like the wrappers above.
WG21 P0541 has been implemented now, as it is approved in the current working paper of the standard.
	The major change is adding the pair initialization with uses-allocator construction recursively.
	Other change includes simplification on allocators.
		For 'pmr::polymorphic_allocator', it is simplified even when used with Microsoft VC++, which has no support yet.
		There is nothing to do with 'scoped_allocator_adaptor' because it is not introduced in 'ystdex'.
	The implementation is somewhat tricky.
		Since it needs to work without inferred trailing return type indroduced in ISO C++14, the declarations of implmentations are broken down in pieces when necessary.
		The implementation reveals some fixes on buggy 'ystdex::is_invocable' and related traits (while the 'std' implementations in libstdc++ is correct).
			The cv-qualified recursive instantiation will not work because of types mismatched in different declarations and function body in the implementation.
				The bug in the traits wronly used the functional declarator as the template arguments internally, which dropped qualifiers unexpectedly.
				For the similar reason, the already removed 'std::result_of' does not qualify to be used here.
			Another bug is that missing SFINAE in 'ystdex::is_invocable_r' and 'ystdex::is_nothrow_invocable_r'.
				The bug in 'ystdex::is_invocable_r' is caused by incomplete type handling.
					See also https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65760 for the similar bug.
				The bug 'ystdex::is_nothrow_invocable_r' has more concerns on 'noexcept' test.
				These bugs are not directly concerned here, but since the bug of 'ystdex::is_invocable_r' makes constructors of 'ystdex::function' not conforming as 'std::function', they are also fixed together.
		There are also multiple implementation issues.
			Mostly issues will not be problems without recursive pair support.
			At least for platform Android, libstdc++ is lack of the resolution of WG21 N4387, i.e. the conditionally EXPLICIT constructor of 'std::pair', so there needs additional workaround.
			For platform DS, G++ 8.1 complaints weirdly with an error on use of deleted defaulted function.
				The error is triggered when instantiating the event map lookup ('emplace_hint') in YFramework module YSLib::UI::YWidgetEvent after the feature here is implemented.
					See also LWG 2397, whose resolution is conditionally used here.
				The error is similar to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88368.
					However, because it is on instantiating 'YSLib::ValueHolder<std::_Tuple_impl<2, std::tuple<YSLib::ValueObject&&>&&>>' so there is no way to insert the proposed workaround.
				Clang++ 7.0 does not has the problem.
				It is unknown why this bug is not on platform MinGW (G++ 7.3), Android (G++ 5.3) (after other workarounds), and Linux (G++ 8.2), despite that the bugzilla issue also does not locate the root of the bug precisely.
					Note the header <tuple> is exactly same between platforms MinGW and DS.
				For interface used by 'YSLib::ValueObject' implementation, there is room to implement.
					The user code may be broken if 'ystdex::any' constructors are not SFINAE-friendly after the 'ystdex::any' initialization involving the allocator calling with 'ystdex::uninitialized_construct_using_allocator'.
						The template default arguments for SFINAE are tricky.
							They are carefully coded to avoid infinite recursion on deducing the template parameters.
							As there can be static assertions in value holders, non-holders are checked to ensure they are not the template argument of the holders.
					To use the SFINAE-friend 'ystdex::any' constructors, 'ystdex::any_ops::construct' and holders 'init' static member function templates are also tuned to be SFINAE-friendly.
					For use of 'ValueObject' with SFINAE-friendly constructions, 'ystdex::boxed_value' is also improved with SFINAE-friendly constructors.
					It can be still broken when 'std::tuple<const ValueObject&>' (rather than 'std::tuple<ValueObject&>') used with instantaiation of 'ystdex::uses_allocator_construction_args'.
						This is broken by SFINAE check in infinite recursion of 'std::tuple' constructor for multiple elements, which should fail in this case.
						This only breaks non-C++17 modes (with GNU extensions or not) in G++ and Clang++.
							It has nothing to do with 'std::invoke'.
							It should have nothing to do with CWG 1227, as C++14 modes also fail.
				As the workaround, nonthrowing check is intercepted for 'std::_Tuple_impl' instances used for 'ystdex::boxed_value'.
				Other workaround includes preventing nested (in template parameters) 'YSLib::ValueHolder' instances constructed in 'ValueObject'.
					This is not guarded by the compiler version condition checks because behavior of avoiding nested 'YSLib::ValueHolder' should be uniform for all implementations.

$2019-03:

report.impl:
Pointer holder in module YSLib::Core::YObject is reworked.
	Semantic properties on lifetime have changed.
		Based on clarification of allowing exception in holder 'get' function in module YStandardEx::Any, getting an object may throw an exception if the object is not existed.
		Since the getter may throw, some 'ystdex::any' API as well as 'GetObject' overloads for 'ValueObject' do not have noexcept-specifier any longer.
	For weak pointers ('NPL::weak_ptr' instances), the getter can throw on expired now.
	However, the 'type' function in the pointer holder still does not throw. But the behavior is also changed.
		Now it does not reilies on owner judgement.
		For weak pointers, it does not need to get strong pointers to get the type.
			An expired value might lead to 'void' type previously. This is changed to getting 'void' only when the pointer value is null despite the owner.
			User code should be careful in this case.
NPL objects involved with pointer holders are effected by the change of pointer holder in module YSLib::Core::YObject.
	Values of Weak references in the past would be more troblesome as the values without strong reference is recognized as 'void' rather than concrete type.
		So, there would be simply wrong value rather than the 'YSLib::bad_weak_ptr' exception thrown, if no other strong reference is kept.
		The only example is 'ContextHandler' used as the default object by the call of 'NPL::A1::Forms::DefineWithRecursion'.
	This is now changed to improve the interoperbility.
		See the discussions of pointer holder modification for weak pointers above for reasons.
	Keeping some strong references elsewhere is however difficult after the whole evaluation without special handling using centralized storage (e.g. in 'NPL::ContextNode').
Internal recursive thunk as the part of implementation of function 'NPL::A1::Forms::DefineWithRecursion' is reworked.
	To allow identifying the situation of cyclic references, default objects still use weak references, but the behavior is slightly changed. See the discussions concerned with pointer holders above.
	Now newly bound variables are stable, i.e. they do not be restored to another values in the call of 'NPL::Forms::DefineWithRecursion' after the evaluation of the expression as the binding source.
		This ensures references to these variables do not go out of their lifetime unexpectedly.
		After defining, the default objects are recovered as thunks which access the environment by name for the real caller when called.
			This allows check and exceptions can be thrown on failure.
	Expired 'weak_ptr<ContextNode>' value in a default object is a corruptied value.
		This is now handled generally by by improved implementation in modules NPL::NPLA and NPL::NPLA1 with API provided by module NPL::NPLA.
		If the default object is corruptied and called, it would throw a different exception ('bad_weak_ptr') from default ones.
			This is undefined behavior in the object language.
				The current behavior is for ease of debugging.
				Although it will not changed frequently, the behavior is not guaranteed stable.
	Implementation of operative '$defrec!' (by 'Forms::DefineWithRecursion') is revised.
		To avoid undefined behavior caused by recursive reference with ownership, the weak reference of target bindings is kept.
		The environment access to recursive binding is now delayed with symbol access to the locked-on-access environment, to allow more error checked (in case of already undefined behavior specified in the object language), e.g. by throwing 'bad_weak_ptr'.
		Since the environment enclosing the bound variables does not have strong reference to the object, it should be careful to save the environment in the binding with 'lock-current-environment', rather than 'get-current-environment', if necessary.
	The implementation difference is significant especailly when 'NPL::LiftToReturn' does not lift reference at first by 'NPL::LiftTermRefToSelf' (now removed).
		The lift makes it essentially deep copies the shared value (configured by pointer holders) of bound variables.
			See the values of shared variable '$aux' in the following cases.
		Case 1 (an alternative derivation of '$sequence'):
			$def! $sequence
				($lambda (&cenv) ($lambda #ignore $vau/e cenv body env
					$if (null? body) inert (eval (cons $aux body) env))
					($setrec! cenv $aux $vau/e (weaken-environment cenv)
						(&head .&tail) env
						$if (null? tail) (eval head env) (($lambda #ignore
							(eval (cons $aux tail) env)) (eval head env)))
				)
				(() make-standard-environment);
			$sequence "a" "b";
			The case above will not work without deep copy in 'NPL::LiftToReturn' of the shared values if '$aux' is not stable.
				Alternatively, lift specifically configured in implementation of 'cons' or wrapping '$aux' with a native deep copy identity function for both occurences is also OK.
		Case 2 (an invalid derivation of '$sequence'):
			$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (() copy-environment) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (() copy-environment) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))))
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));
			$sequence "a" "b";
			The derivation is invalid because of cyclic references, which implies undefined behavior in NPLA1.
				With the deep copy (likewise in Case 1), it will occasionally work as the '$aux' is unshared before calling.
					With modification of '$defrec!' with delayed environment access, it does not work.
				Without the deep copy and '$defrec!' modification, it also does not work.
					It will access invalid memory by TCO in the call using the shared value hold by '$aux'.
					It will access invalid memory or infinitely recursively reenters the host function (value of 'NPL::ContextHanlder') of '$aux'.
						Whether to reenter depends on the implementation details of 'NPL::Forms::DefineWithRecursion'.
				The applicative 'deshare' is provided to restore the deep copy locally. It is not needed in most cases.
			The workable derivation is:
				$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (make-environment (() lock-current-environment) (() copy-environment)) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (make-environment (() lock-current-environment) (() copy-environment)) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))
					)
				)
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));
Memory safety of NPL environment is taken cared.
	Anchors in 'NPL::A1::Forms::BindParameter' are fixed.
		This fixes a bug that releasing TCO frames too eary.
		They were wrongly referred to TCO temporary, which is not the cases used in the referent implied by the reference values.
		To support the fix, 'NPL::A1::Forms::MatchParameter' now has more additional parameters to indicate the anchor pointer.
	Additional check for memory safety based on environment anchor reference counts in NPLA is added.
		The check is performed in the destructor of 'NPL::Environment'.
			The check get reference count of anchor and ensure it is expected. Otherwise, it issues an error message by logging (via 'YTraceDe', not the logger in 'NPL::ContextNode').
			Since there is no specific order of destruction of bindings in the environments, this is not reliable in general.
				It should be OK to leave the dead anchor pointers (in the destructor of the environment binding recored) since they are essentially the weak references without accesses.
				Removal of the order requirements would also increase performance.
				And it will cost too much to add a specified order for each bindings record in the environments.
				So, it is normally only useful to aid debugging.
			The anchor of temporary bound by the '&' sigil for reference operands in the TCO impmlementation of 'NPL::A1::BindParameter' will cause significantly lot of false positive check failures.
				Because the source environment of referent is not traceable in the function, the anchor in the references are not accurate.
					Without the fixes above, there can be many false positive results.
					With the fixes above, there can be still a few false positive results shown on the cases having references in the environment which is introduced as the local environment of some caller.
						These were exactly buggy without the fixes having nothing to do with the actual bug.
				However, this is still necessary for safety of TCO within nested function calls.
					At least 'NPL::A1::ReduceOrder' does require the parent frames not being released too early, which in turns relying on the count introduced here.
				Ideally the anchor should be passed from the real referent.
					However, this is not always possible unless that all objects have the anchors.
					The current design does not use anchors for tracing all objects.
						Only environments and reference values in the object language have anchors.
						Otherwise, it needs too many resources and it is not even a good choice for debug builds.
							If such capability is needed, a tracing GC would do better in general (except that the determinism of finalization should be cared additionally).
			For performance and the correctness reason above, this is not enabled by default.
				This can be enabled by change the definition of the new macro 'NPL_NPLA_CheckEnvironmentReferenceCount' in the header of the module NPL::NPLA to control the conditional inclusion.
					The macro is in the header to get less restrictions on the implementation and to prevent possible warnings of unused code as well.
		Since the dead environment references are allowed to be preserved elsewhere, direct check at destruction of environment have false positive results.
		More precise check is still at environemnt destruction, but it distinguishes anchor reference counts from environment references vs. term references.
			The basic idea is to store another reference count to indicate the different source, i.e. 'NPL::EnvironmentReference' vs. 'NPL::TermReference'.
				To minimize the change, the unused anchor value is now changed to store the secondary reference count, and 'NPL::EnvironmentReference' are modified to have explicit reference count maintenance code with friendship of the anchor value interface.
				This is not efficient, anyway.
			The check is then added to ensure all remained anchor references are from 'NPL::EnvironmentReference'.
		The check is then used to find bugs in the current implementation.
		For non-TCO implementations, everything is OK.
		There are several failure cases without tail rewriting being enabled:
			1. $let ();
			2. list*% ();
			3. ($lambda% (x) x) ();
			4. ($vau% (x) #ignore x)();
			5. ($lambda (x) forward x) ();
			6. ($lambda (x) ($lambda (y) idv y) x) ();
			7. for-each-ltr ($lambda .) (list ());
			8. map-reverse ($lambda .) (list ());
			9. $def! l list (); ($lambda ((&x .)) x) l;
		While some of the cases (3 and 4) are indeed undefined behavior, a few others are really interesting.
			The cases 1, 2 and 5 is the real bug, whose fix is to reorder the cleanup of TCO action records.
				The order is significant, but there is still uncertainty not properly handled before.
				This fixes many cases like case 1 and 2 above, and all errors shown in the loading stage of the module NPL::Dependency are cleanup.
			The case 6 is caused by order of components removal in the same frame.
				Note the name 'idv' is somewhat insignificant (as it can be any unary function compatible with the argument), for example the following are also problematic:
					6a. ($lambda (x) ($lambda (y) id y) x) ();
					6b. ($lambda (x) ($lambda (y) ++ y) x) "";
				And even with an empty body, it is still problematic:
					6c. ($lambda (x) ($lambda (y)) x) ();
					6d. ($lambda (x) ($lambda (.)) x) ();
				But the following variants are OK:
					6e. ($lambda (x) ($lambda (.) ()) x) ();
					6f. ($lambda (x) ($lambda (y) y) x) ();
					6g. ($lambda (x) ($lambda (y) (idv y)) x) ();
					6h. $def! foo $lambda% (z) z; ($lambda (x) ($lambda (y) foo y) x) ();
					6i. ($lambda (x) ($lambda (y) ($lambda% (z) z) y) x) ();
				This is fixed by explicitly clear of the components in the frame before the removal.
			The case 7, 8 and 9 are caused by the bug of '&' reference using wrong anchor from 'NPL::BindParameter'.

$2019-04:

report.impl:
Several designs of NPLA have been revised.
	The reference type ('NPL::TermReference') now supports xvalues.
		This is achieved by additional metadata as the internal data members of 'NPL::TermReference'.
		The metadata is organized as the tag type 'NPL::TermReference::Tags'.
			Member functions with 'bool' parameter are updated to use this type instead.
		The constructors with inference of the metadata is also updated.
			Now the arguments keep the tags using 'NPL::TermToTag'.
	Value category are identified by metadata only in references.
		Currently objects in environments are not general available in the object language except for a few operations like 'resolve-identifier' in NPLA1.
		The type of object 'x' is like 'decltype((x))' in the host language, in despite of 'decltype(x)' having possible different result.
		Now the reference type 'NPL::TermReference' has more tag.
		For temporary objects bound to references, the metadata is needed in 'NPL::TermNode' as well.
			The tag type is now lifted as the bitmask scoped enumeration 'NPL::TermTags'.
			An index enumeration 'NPL::TermTagIndices' is also provided to avoid magic values in the enumerators in 'NPL::TermTags'.
	'NPL::EvaluateIdentifier' is fixed to ensure results are lvalues.
		Other resolution are not directly subject to the value of variable.
		This is carefully designed to keep the applicative 'forward' work.
			There are two dependencies of the implementation as the prerequisitions of this change.
				First, the applicative 'first%' is needed to changeto prevent invalid 'forward' call in the old implementation.
				Second, operatives of the '$let' family are now split like '$lambda' and '$lambda%'.
					The old implementations would not work without the change because 'forward' call cannot correctly get the value category of the final return value when it contains the lvalues bound directly as objects in the parameter list.
					On the ohter hand, in old implementations with old rules, it would not treat such resolved parameters as lvalues.
			For performance, a native implementation is also added.
		The result of 'lvalue?' for the reference from environment are always '#t'.

$2019-05:

report.impl:
The simplified Chinese translation (in locale zh-CN) of terms has been reconsidered, but nothing has been decided to change yet.
	The translation of term 'complete' for types has been reconsidered to change to '完全' from '完整' ('完全类型' from '完整类型' for 'complete type', '不完全类型' from '不完整类型' for 'incomplete type').
		The current translation is consistent to some canonical sources, including the standard GB/T 15727-94.
			The documentation of Microsoft Visual Studio has the same use of 'incomplete type', e.g. https://docs.microsoft.com/zh-cn/cpp/c-language/incomplete-types?view=vs-2019.
			The diagnostic messages of Microsoft VC++ are also the same on 'incomplete type'.
			This is also used in some other notable online documents like https://zh.cppreference.com/w/cpp/language/type.
		However, the consisdered replacment is consistent with other sources.
			It is consistent with most mathematical concepts and the usual translations of phrases widely used in computer science like "NP-complete problem".
				A second mathematical replacement is '完备'. This is not considered here. 
			It is consistent with diagnostic messages in GCC.
				The characters '不完全' for 'incomplete' are also exactly same in locale zh-TW.
					However, some translations in locale zh-CN is considered somewhat in the zh-TW flavor, e.g. '提领' instead of '解引用' for 'dereference'. So, this is considered not quite precisely reflecting the actual popular use in zh-CN.
				The characters '不完全' for 'incomplete' are also exactly same in locale ja, e.g. '不完全型' for 'incomplete type'.
			There is an entry of '不完全类型' in Chinese Wikipedia, e.g. https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B.
				However, the content is mostly about partial classes in C#.
				As the time of writing, the only other entry of translation available is https://de.wikipedia.org/wiki/Partielle_Klasse, which has nothing about incomplete types of C/C++.
					The English tranlation is at https://en.wikipedia.org/wiki/Class_%28computer_programming%29#Partial. This is again has nothing to do with incomplete types.
		As concluded, the replacement use is not considered canonical in locale zh-CN. Nothing is changed.
	The translation of term 'full expression' in locale zh-CN is still '完全表达式'.
		The tranlsation of 'full' is originally kept distinct to 'complete'.
			As the latter is not changed, it is kept.
		There is also no good (intuitive and widely used) replacement other than '完全' or '完整' find.
		Further, the prase is hyphened in recent working draft of ISO C++.
			This change makes it quite contextually specific to limited C++ specification text.
				The use in YSLib documentation (notably, the glossory used in wiki pages and in NPL documents) is then not necessary to keep the use as exact as the C++-style.
			This is gramatically (in English) not necessary, though.
		Note that the current "full-expression" in ISO C++ draft has other problems, see https://github.com/cplusplus/draft/issues/2885.
Self assignment is supported in several applicatives in NPLA1.
	The old '<-%' did not handle this at all.
		It is now fixed in 'assign%!'.
	The old behavior of 'NPL::A1::Forms::SetFirstRef' actually did not allow self-assignment by documented '\warning' command in the Doxygen comments.
		It is too error-prone to involve undefined behavior, as there is no easy way to make sure the parameter is of an rvalue reference implying not aliasing like in C++, so it is subject to be changed.
		To be consistent with 'assign%!', the self-assignment is handled simlarly.
			Note arbitrary cyclic reference check is still not present.

$2019-06:

report.impl:
Several NPLA1 improvements are made, including some critical bug fixes related to the PTC guarantee.
	A bug of dynamic environment capture in vau abstraction causing PTC guarantees broken has been fixed.
		The bug causes '#ignore' not being ignored in the creation of the combiner.
		Instead, a dynamic environment named "#ignore" is bound in the newly created environment before evaluation of the vau abstraction body in the call of the combiner.
			This breaks PTC because currently named dynamic environments are not collected by the TCO frame compression algorithm.
				With the fact about the fundamental role of vairous vau abstractions, the bug also breaks almost all non-native derivations in NPLA1.
				Even despite the guarantee, asymptotic memory consumption behavior between native and non-native lambda abstractions differs, which should be unexpected.
			This is actually weaker than what Kernel guarantees in RnRK.
				However, klisp also leaks here, e.g. by '($sequence ($define! $f ($vau () #ignore (($f)))) (($f)))'.
			With the fix, at least the non-native derivation of lambda abstractions behave normally. For example:
				$defl! f () () f; () f;
				$defl! f () () (unwrap f); () f;
			The following cases are also fixed regardless of native derivations are used or not:
				$defv! $f () #ignore () $f; () $f;
				$defv! $f () #ignore () (wrap $f); () $f;
	NPLA1 now enforced clearer rules on temporary lifetime. Notably, the operative '$sequence' is clearified with intended behavior on temporary lifetime.
		This was underspecified at the first glance of the specifiation of the operative.
		However, there is a real bug of native implementation of '$sequence' and it is now fixed.
			The general temporary rules to assert full expressions on parameters were only effective for combiner "application", thus it should have make the parameters sequenced, which was not implemented in the native implementation.
			And anyway, native and non-native derivations should have the same observable behavior (e.g. with destructors of hosted objects called), whatever the expected behavior should be.
	NPLA1 TCO implementation is simplified to avoid a bug on the collection operation of the orphan temporary object cleanup.
		The old implementation collect the temporary object unconditionally during the vau handler calls. This is illogical in general.
			It would break the following case:
				$defl! |> (&f &g) $lambda/e% ($bindings/p->environment ((() make-standard-environment)) (&f (forward f)) (&g (forward g))) (&x) (forward g) ((forward f) (forward x));
				$defl! double (n) * n 2;
				$defl! increment (n) + n 1;
				(|> (|> (|> double double) increment) double) 5;
			The compressor would access invalid parent environment collected previously by the orphan temporary object cleanup.
		The new scheme uses more less aggressive orphan temporary object cleanup, but a simpler temporary object store at first in the binding code in the vau handler calls.
			Since the temporary binding has been involved with 'TermTags::Temporary' on terms directly, no other temporary objects are need to be saved.
			Now there is no difference in TCO and non-TCO implementations to store the operands.
		The old implementation is still kept for exposition only.
			Note it is still problematic with following cases even when the orphan temporary object cleanup is disabled during the vau handler calls:
				$defl! f (n) ($vau (x) d eval x d) (f n); f ();
			While the following case is good to TCO:
				$defv! $f (x) d eval x d; $defl! f (n) $f (f n); f ();
		The orphan temporary object cleanup is also disabled in the reduction of by 'A1::ReduceAgain'.
			It might be replaced for a saner and simpler implementation in future.

////

