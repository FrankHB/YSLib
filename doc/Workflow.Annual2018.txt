/*
	© 2017 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2018.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2018 年度。
\version r91
\author FrankHB <frankhb1989@gmail.com>
\since build 818
\par 创建时间:
	2018-02-27 22:36:36 +0800
\par 修改时间:
	2018-05-23 15:22 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2018
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2018-02:

report.impl:
Term lifting at end of returning from closure is reconsidered.
	The no-op (instead of lifting) returning of term is the copy elision (unconditionally).
		It is equivalent to returning by reference, which can be dangerous.
		It is not always detectable reliably without tracing lifetime of all objects since the referenced term may be not hold by 'shared_ptr', etc.
	Term lifting is necessary to be kept to maintain the return value of lvalues sane without introducing dangling references.
		Removing lifting would change too much.
		This is a breaking change. The code would behave wrongly if no value copy is added.
		To remove with well-behaved code, it needs explicitly using value copy function to reintroduce the lifting again for returned value.
			Keeping same semantics by calling value copy may be verbose, so new combiner constructor variants which exactly retain the old behavior may be introduced in future for convenience.
	Term lifting needs some magic to work with tail call optimization.
		Becuase the inserted lifting operation is the tail context, direct switching to next continuation will change the semantics.
		Since it is idempotent operation, it need only occur before the next continuation only once.
			If it has already existed, it should be already in the tail context.
	The conbiners '$and?' and '$or?' can not be directly implemented without new conbiner constructor.
		Since lvalue reference is always be lifted (i.e. lvalue-to-rvalue conversion), the result would not be reference, even the reference here is safe.
			Here all retained reference can only be from the operand, which is safe for lvalues, so lifting would be overkill.
		Without lifting, it can be expressed by other primitives like in Kernel.
			Even the G1b guideline is not enforced in NPLA1, consistency is still important.
		This is to be changed in future by providing conbiner constructor other than '$vau'.

$2018-05:

$report.impl:
Several DS buidling problem concerned with compatibility issues in devkitPro has been addressed.
	The update of libnds 1.6.0 changes minor internal interfaces, which has been adapted in module 'YCLib.NativeAPI'.
	The update of devkitARM r46 changes libgloss I/O interface in newlib, using 'void*' instead of 'int' as internal representation of file descriptor.
		Module 'YCLib_(DS).DSIO' is adapted to use 'void*' type file handle instead of raw file descriptor.
			This also reduces casts between pointers and 'int'.
	The ndstool distributed with devkitARM r46 and later versions has added DSi ROM generation, which would cause problems.
		This is not documented.
			See https://github.com/devkitPro/ndstool/commit/18d3c00df65a2b7a9c9f0312eaac518678869345 for the change.
		It would now generate DSi ROM when both ARM7 and ARM9 object files are ELF objects by default.
			It seems there is no option is supported to override the behavior directly except adding '-h' option to indicate the required header size.
			See also https://github.com/devkitPro/ndstool/issues/7.
		DSi ROM cannot be handled steadily on DeSmuME.
			In fact it is not supported currently, in version 0.9.11.
				See http://wiki.desmume.org/index.php?title=Faq#What_does_DeSmuME_emulate_and_on_what_systems.3F.
				Although there can be chances to work occasionally (with ELF objects packaged directly, see below), it does not function well.
					For instance, font loading would fail at 'FT_NewFace' with unknown format error, while the previous reading operations seem to be normal.
			Nevertheless, even the newest official stable release would support DSi, the version used to test in YSLib (without disabling homebrew capability) would still not support DSi.
				So DSi ROM generation need to be disabled.
		Removal 'objcopy -O binary' and using ELF object to be packaged directly instead of raw binary ARM7/ARM9 image may change the result.
			At least one removal in either ARM7 or ARM9 has to be existed, to enforce the new versions of ndstool generating DS ROM instead of DSi ROM (with "unitcode" value 0 instead 2 in the header).
			Note that since devkitARM r46, raw images generated by 'objcopy -O binary' do not work at all, so single removal is not enough.
				It would lead to white screen on DeSmuME, even it is a DS (not DSi) ROM.
				It would also bloat significantly (the arm7/arm9 file size, about ~100x of .nds file) in resulted ROM file.
		Note all devkitProm versions after r45 has same problem above (even with newer libnds).
			Thus, the only viable solution with updated devkitARM is to change the makefiles without 'objcopy -O binary' operations and using '-h 0x200' in the 'ndstool' command.
				Note that ELF objects can work with old ndstool, so using an old version of ndstool can also work.
			The good news is it would eventually make the binary size in resulted ROM file smaller.
				It would bloat ~35KiB by removal 'objcopy -O binary' (though much smaller than raw images with devkitARM r46).
				But with recompilation of FreeType2 with new toolchain, it would save ~80 KiB.

////

