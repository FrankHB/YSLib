/*
	© 2018-2019 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2018.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2018 年度。
\version r831
\author FrankHB <frankhb1989@gmail.com>
\since build 818
\par 创建时间:
	2018-02-27 22:36:36 +0800
\par 修改时间:
	2019-06-12 14:12 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2018
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2018-02:

report.impl:
Term lifting at end of returning from closure is reconsidered.
	The no-op (instead of lifting) returning of term is the copy elision (unconditionally).
		It is equivalent to returning by reference, which can be dangerous.
		It is not always detectable reliably without tracing lifetime of all objects since the referenced term may be not hold by 'shared_ptr', etc.
	Term lifting is necessary to be kept to maintain the return value of lvalues sane without introducing dangling references.
		Removing lifting would change too much.
		This is a breaking change. The code would behave wrongly if no value copy is added.
		To remove with well-behaved code, it needs explicitly using value copy function to reintroduce the lifting again for returned value.
			Keeping same semantics by calling value copy may be verbose, so new combiner constructor variants which exactly retain the old behavior may be introduced in future for convenience.
	Term lifting needs some magic to work with tail call optimization.
		Becuase the inserted lifting operation is the tail context, direct switching to next continuation will change the semantics.
		Since it is idempotent operation, it need only occur before the next continuation only once.
			If it has already existed, it should be already in the tail context.
	The conbiners '$and?' and '$or?' can not be directly implemented without new conbiner constructor.
		Since lvalue reference is always be lifted (i.e. lvalue-to-rvalue conversion), the result would not be reference, even the reference here is safe.
			Here all retained reference can only be from the operand, which is safe for lvalues, so lifting would be overkill.
		Without lifting, it can be expressed by other primitives like in Kernel.
			Even the G1b guideline is not enforced in NPLA1, consistency is still important.
		This is to be changed in future by providing conbiner constructor other than '$vau'.

$2018-05:

$report.impl:
Several DS buidling problem concerned with compatibility issues in devkitPro has been addressed.
	The update of libnds 1.6.0 changes minor internal interfaces, which has been adapted in module YCLib::NativeAPI.
	The update of devkitARM r46 changes libgloss I/O interface in newlib, using 'void*' instead of 'int' as internal representation of file descriptor.
		Module 'YCLib_(DS).DSIO' is adapted to use 'void*' type file handle instead of raw file descriptor.
			This also reduces casts between pointers and 'int'.
	The ndstool distributed with devkitARM r46 and later versions has added DSi ROM generation, which would cause problems.
		This is not documented.
			See https://github.com/devkitPro/ndstool/commit/18d3c00df65a2b7a9c9f0312eaac518678869345 for the change.
		It would now generate DSi ROM when both ARM7 and ARM9 object files are ELF objects by default.
			It seems there is no option is supported to override the behavior directly except adding '-h' option to indicate the required header size.
			See also https://github.com/devkitPro/ndstool/issues/7.
		DSi ROM cannot be handled steadily on DeSmuME.
			In fact it is not supported currently, in version 0.9.11.
				See http://wiki.desmume.org/index.php?title=Faq#What_does_DeSmuME_emulate_and_on_what_systems.3F.
				Although there can be chances to work occasionally (with ELF objects packaged directly, see below), it does not function well.
					For instance, font loading would fail at 'FT_NewFace' with unknown format error, while the previous reading operations seem to be normal.
			Nevertheless, even the newest official stable release would support DSi, the version used to test in YSLib (without disabling homebrew capability) would still not support DSi.
				So DSi ROM generation need to be disabled.
		Removal 'objcopy -O binary' and using ELF object to be packaged directly instead of raw binary ARM7/ARM9 image may change the result.
			At least one removal in either ARM7 or ARM9 has to be existed, to enforce the new versions of ndstool generating DS ROM instead of DSi ROM (with "unitcode" value 0 instead 2 in the header).
			Note that since devkitARM r46, raw images generated by 'objcopy -O binary' do not work at all, so single removal is not enough.
				It would lead to white screen on DeSmuME, even it is a DS (not DSi) ROM.
				It would also bloat significantly (the arm7/arm9 file size, about ~100x of .nds file) in resulted ROM file.
		Note all devkitProm versions after r45 has same problem above (even with newer libnds).
			Thus, the only viable solution with updated devkitARM is to change the makefiles without 'objcopy -O binary' operations and using '-h 0x200' in the 'ndstool' command.
				Note that ELF objects can work with old ndstool, so using an old version of ndstool can also work.
			The good news is it would eventually make the binary size in resulted ROM file smaller.
				It would bloat ~35KiB by removal 'objcopy -O binary' (though much smaller than raw images with devkitARM r46).
				But with recompilation of FreeType2 with new toolchain, it would save ~80 KiB.

$2018-06:

$report.impl:
TCO (tail call optimization) algorithm in NPLA1 to support PTC (proper tail call) has been carefully revised and further enhanced.
	Since the host language (C++) as the source language does not support PTC, TCO is necessary anyway to the support of PTC.
		Although it is optionally enabled in the current source by conditional inclusion, the object language NPLA1 mandates it in conforming implementations.
			So this is the default configuration.
			Other configurations are not always tested and not guaranteed to work.
	The call here can be an ordinary function call (a β-reduction of λ/vau-abstraction) or an underlying evaluation in 'eval' form.
		As usual, calls do not interleave, to avoid introduce of parallelism in simplest cases of design.
			This also means in users' view there is only one call being active simultaneously.
			This also simplified the implementation to worry about concurrent access, although the design is actually able to be extended to support it.
			If needed, parallelism can be added by threading and other means in future.
		This design supports mixture of asynchronous and ordinary synchronous handlers of calls once the asynchronous calls are properly guarded by some synchronization mechanism.
			The abstraction of such handlers are called as actions.
			In a specific context for reduction, depending on the configuration, an action can be either synchronous, or asynchronous. 
				Sometimes there has to be different implementations for synchronous and asynchronous uses of an action.
			An action can be represented by various data structures.
				A notable example is the data structure used as the handler in TCO, see below.
		Within TCO, calls happen as a sequence implemented using an asynchronous style in the source language.
			This works like CPS (continuation passing style), except the continuation is stored in the context, rather than being passed by parameters in the source language.
				Note this does not imply a rewrite of CPS form which is used in various compilers of typical functional languages.
			A asynchronous handler stored in the context ('NPL::ContextNode') is a reducer (of the type 'NPL::Reducer').
				An action represented by the reducer implies an internal continuation being executed in the context.
					The continuation is used with some other states in the context, like 'SkipToNextEvaluation'.
					This is to be extended to implement first-class continuations in the object language (NPLA1) accepting parameters not in the 'Reducer' type.
		Other kinds of calls may be introduced by derived implementations.
			This design does not include them.
			Modification may be necessary.
	TCO operates on potentially active record frames.
		A record frame consists of an environment and optional other components.
		The active frame is the frame whose environment is introduced by the active call (i.e. the call still not returned).
			As parallelism is exluded in the discussion above, there is only one active call at any time.
			The environment component of the active frame is the environment object in the current context object.
			The optional components include the function prvalue (as the temporary object) and the additional environment holding the temporary operand object, which are saved in the TCO action.
				The function prvalue is based on the function object determined by the implementation of 'NPL::A1::ReduceCombined' and the guard object after the compression (see below).
					The function object here is the context handler representing the optional function prvalue of the combining form.
					If the prvalue does not exist (when the function is a lvalue stored elsewhere), the context handler is empty.
				Similarly, the operand has to be saved to avoid dangling references binding to it.
					The difference to the function prvalue is it would be added immediately after the frame switch and before the next action of actual function call.
					The operand is transferred in the form of environment object so it can be collected, see below.
		Other frames are owned by the TCO action, which represents a special kind of actions to handle the probably optimizable tail call specifically.
			They are inactive and basically introduced by other formerly active calls.
				Some of them are definitely inactive, and they are the targets to be safely removed during TCO.
			However, some frames can own objects referenced by the active frame so they cannot be definitely inactive.
				They have to be preserved to keep the memory safety.
		The representation of a frame is not necessarily always same.
			But for simplicity, all frames preserved in a TCO action are in two forms.
				The first form is like other non-TCO frames, called guarded frame, representing the continuation of the TCO action.
					It is stored in a guard object of type 'NPL::A1::EnvironmentGuard', providing strong exception safety.
				The other is the frame solely stores the resources.
					These resources make the frame having the correspondence to the active frame, which also has 3 components. But the storage form and the order of them are not required to be same.
					The components are the function prvalue, the frame environment and the additional environment holding the temporary operand object.
				There is most one valid guarded frame in one TCO action.
					There is exactly one valid guarded frame if the action initialized with a valid next action (in 'Context::Current') as well as a different environment (always true in case of TCO) for the next action.
				There are zero or more valid non-guarded frames when there is a valid guarded frame. They are stored in the frame record list.
				During the reduction performed in the TCO action (implemented in 'operator()' of the action), non-guarded frames would be removed in the reverse order of insertion. Guarded frame would be switched and destroyed after all non-guarded frames have been removed.
					This process resembles the LIFO stack frames built by environment switching during ordinary nested function calls (as well as evaluation of 'eval' with operands).
					Conventionally, the frame record list pops the front frame at first. Environment to be added into the list caused by environment switching is also insert in the front place if the guarded frame exists (otherwise it should be placed as the guarded frame).
						Thus old frames lives longer are place in back. Guarded frame is the last frame (living logest) and it is virtually the one-past-end element of the list in sense of lifetime (although it is actually held out of the list).
			No other frame representations for other cases are specified yet.
		During TCO, zero or more incative frames would be found and removed, with the permission of nondeterminism about lifetime of objects in the inactive frames granted by the semantic rules of the object language.
			During the removal of an inactive frame, if the environment is previously uniquely referenced, the environment in the frame is destroyed, so resources are reclaimed.
				The objects held in the binding within the environment of the frame shall be destroyed to enforce there is no resource leak.
					This is ensured implictly by the destruction of the environment.
				The parantage of remained object shall also be maintained to avoid behavior not allowed by the semantic rules of the object language.
					This needs additional explicit operations before the destruction.
				This indicates the environment is collected.
				Not all environments in inactive frames are to be collected, because they may have reachable objects, i.e. objects referenced by active frame.
			The candidate inactive frames to be removed are found by the check operation against inactive frames specifically.
				The check is performed each time when there is a new frame being activated.
					Zero or more old frames are to be removed as the result of the check.
					The resources of these frames are thus collected when needed, i.e. when there is no object not owned by the environment holding the reference of the environment.
			The removal of TCO frames shall keep the parentage of environments properly as per the language rules.
	Routine containing TCO is entered once during some operations at tail contexts with environment switching.
		Currently, function calls in vau handlers and 'eval' reductions are the direct audience.
			Other PTC can be composed with these cases.
		The input contains a guard object holding the environment of previous action in the context.
			The environment was switched before enter of the routine and the old one would be the one stored in the guard.
			This guarantees strong exception safety.
		The operation initiates TCO shall create a TCO action if it is not existed as the next action; otherwise it shall maintain the members of an existed TCO action properly, especially the frames stored in the action.
			Only when the next action is a TCO action and the input guard is valid (holding an environment), TCO can be performed.
			The operation shall make the guard object stored in the TCO action to be the input guard on creation of the TCO action, or add it in the frame record list of existed TCO action after TCO.
		If there has been already a valid guarded frame in the stored guard object, TCO check is needed; otherwise, the input guard is simply installed by assignment to the stored guard object.
		TCO check and recource removal are performed immediately before the insertion of the guard object for an existed TCO action.
			Each time it performs only one turn of check. It shall colloect more resources as possible, to prevent them leaked before tail contexts are met later again.
				The guard object would not be collected before the next turn of check, as it holds the newly deactivated frame.
				It can be collected only after the frame switch would not be rollback by an exception.
				The strong exception safety of the collection for it is difficult to achieve, so keep it as-is, and it can be collected in next turn if necessary.
			The frame record list holds all frames after previous turns of collection (if any).
			The new frame would held by the input guard be inserted at the beginning of the list.
		In order to check frames, TCO tests whether the frames saved in the frame record list can be safely removed when the provided guard object lives long enough until the TCO action is reduced via its 'operator()'.
			This is done by searching environments with no reference from others in active frames on the frame record list.
			The objects being seached is a set of environment, called candidate search set, defined by following rules:
				The environment in the guard object is the root of search.
				All direct and indirect parents of the root which can be determined in finite time is also in the set.
					The determination dependes on module NPL::NPLA. In current design, there is no nondeterminism in parantage, and all search operations shall terminate in finite time.
				No other object are in the set.
			The operation to determine the candidate search set is tracing.
			After tracing determine the objects to be collected in the candidate search set, objects are collected if necessary.
			Both tracing and collection of environent objects not in the frame record list are handled by record compressor.
				Record compressor maintains a common state, called trace record, upon the candidate search set.
					Trace record consists of three parts.
						The first is reachable set indicating the known active objects not to be collected.
							It is represented as a set of refereces to environment objects, with initial value of single root environment, i.e. the reference to environment object as the active frame.
						The second is the universe standing for candidate search set and correspoinding tracing reference count used by tracing for each candidate.
							It is represented as a map from reference to environment object to a count.
							It is initially empty and will be updated by the process of search.
							All other references to the searched environment objects are considered exteranl references of the environment.
						The last is a list holding the ownership of objects to be collected.
							The collection would be finally in the destruction of the compressor.
							It is represented as a vector of shared pointers to environment object.
								If it is needed to specify order of destruction in future, it can be a deque.
				Once an environment is finally searched, the tracing references held in trace record and the reference counts provided by the references are used to be determined whether it is safe to be removed.
					There are two kinds of reference provided by the environment are considered.
						Strong reference is represented in type of 'shared_ptr<Environment>', or the reference shared ownership with the weak pointer in an 'EnvironmentReference' object.
							It is allowed to be 0 because the environment object can keep alive to use 'shared_from_this' to get a new strong reference.
						Weak reference is the reference holding an anchor object of the environment object, in type 'NPL::EnvironmentReference'.
							The weak reference count is the reference count of the anchor object, which equals to the number of live weak references plus the one in environment object itself, so the minimum value is 1.
					Total reference count to an object is defined as sum of strong and weak reference count minus 1, or the sum minus 2 when there is a temporary strong reference is retained (to get the strong reference count) via 'shared_from_this' call.
					All reference counts except 'use_count' result of 'shared_ptr<Environment>' are not exposed as public features of object language.
						However, they are steday for the purpose here to illustrate the algorithms involved in TCO.
					The trace state would be sufficient to determine whether a candidate in candidate search set is an external reference or not in search.
					When the strong reference count reaches to zero, the object would be automatically destroyed.
						So simply avoid to keep redundant strong reference away would be sufficient to make objects collected.
						Otherwise, if the strong reference shows the object is not uniquely held by the frame record list, the environment reference is removed.
							As the environment reference is also held elsewhere, the environment is not collected. 
					Otherwise, if no external objects hold (weak) reference to the environment, the environment reference is needed to be removed.
						The environment is then collected once.
						The trace is used to maintain the data determining whether objects being traced are held externally.
						The referent (the referenced object) is to be collected in following 2 cases:
							When the weak reference count is 1 and the strong reference count is 0 or 1, the environment is not shared. If it is not also reachable (i.e. referenced directly or indirectly by some external objects), it is an orphan.
							When the weak reference count is same to the weak count in the universe but not the reachable set, there is no external references, i.e. no external objects are known to hold reference to the environment.
				Each basic operation of collection is concerned with 2 environment objects: the destination and the source.
					The destination is the environment object to be collected.
					Before the collection, the parent of environment should be settled so the parantage can be maintained.
					The source is the object to receive new parent. All other members of source are not touched.
					Sometimes, before setting the parent of source object, bindidngs lived both in source and destination are deduplicated.
						The deduplication is simply to remove all bindings in the destination with same names in source.
							The object lifetime would be altered. It shall be only used following the semantic rules of object language.
						Sometimes the source and destination can have same bindings when the destination is the only parent of the source. If deduplicated, destination can be empty and be then collected.
							This typically exists like frames created by recursive function calls, which is a majority source of need of TCO.
							It is necessary for elements in the frame record list because the referent cannot be removed otherwise.
								The result of emptiness is important because an nonempty environment cannot be removed.
								Also note moving destination bindings to merge to the source is not feasible in general.
									The only exception is the case that name resolution can be proved not effected (in search order, etc.) by it, which is too complicated and not worthy in general.
				The compressor provides methods to add references before further operations.
					The methods are to determine the universe.
					A count is set to each entry of universe as the total reference to the object.
					The parameters are called roots, as the entry of traverse described below.
						The first root is strong and other roots are weak.
						The first root shall be the reference to the environment of active frame.
						Only strong root is considered reachable initially. Weak roots are specifically interested because they are held internally and addtional reference count fixes are needed, see the description of tracing algorithm below.
				The compressor provides a "compress" method to be called after added all interested reference.
					The interested references forms the universe. All references out of universe are considered external, and the object referenced by an external reference is not to be collected.
					The method compresses frames by tracing and removal of orphaned environment objects (defined below).
						An orphaned environment object is an environment object not referenced by any external references. It is safe to be collected.
						The orphaned environment object is determined by traverse of specified environment objects (called roots) and their parent environment objects directly and indirectly.
						The search is basically performed in depth-first manner, from the roots specified previously as the parameter of adding operations before the compression.
					Each step of search enumerates the parent of current searched environment using the order same to name resolution and update the common state.
						As environment object and their parents are in a acyclic data structure, there is no cycle during the traverse.
						The traverse enumerates parents of environments by types as they provide different ownership of environment objects.
					The compression consists of 2 stages, tracing and moving.
					There are following steps of tracing operations to be performed as the 1st stage of compression:
						All objects in the universe is traversed once and the corresponding count is decremented.
							The value of counts before decrement operations shall be positive.
						For the roots specified in adding operations previously, further decrement the corresponding count.
							The value of counts before decrement operations shall still be positive.
							The roots are intended as the uniquely held environment in the frame record list. The value shall precisely decremented by 1.
						All resulted counts of 0 indicate the corresponding environment are orphaned (even with cycles across strong and weak references) and they are candidates to be collected unless they are otherwise reachable.
							For objects with count greater than 0, correspoinding references are moved to reachable set.
						All objects as direct or indirect parents of objects referenced in reachable set are also considered reachable. The correspoinding refrences are moved to reachable set.
							This process loops till there is no new references to reachable object found.
					There are following steps of moving operations to be performed as the 2nd stage of compression:
						Strong reference of remained references in universe are added to the collected set.
							This is used to keep the ownership of objects to be collected tentatively.
						The strong root is finally traversed and all remained objects fixes their parent properly to avoid collected objects occur in the parantage.
							During the operations of assignment parents, objects to be collected are still alive due to the collected set.
							After the traverse, object in the collected set would have reference count value 1.
				During destruction of the compressor, collected set would be destroyed eventually.
					The objects except the weak roots (if any) are finally collected here.
			For each turn of check, an object of record comprocessor is created using the reference to environment object in the active frame as root.
			The adding operation is then entered at least once to add all collectable environment into the universe.
				For strong root, it is not added in the universe set directly as it is not collectable, only the direct and indirect parents are added into the universe.
				For weak roots, the root itself is added into the universe as well as its direct and indirect parents.
				The first call using the reference to the environment in the current context object (as the active frame) to specify the strong root, thus its direct and indirect parents can be added into universe.
				The reference to environment in the guard object as the parameter then added.
				The temporary environment holding the operand is also added.
				Additional weak roots handling can be enabled by conditionally inclusion. As they are not used by default, they are disabled.
				The successive calls traverse frame record list to provide weak roots.
			After the adding operations, there is a try in loop for further compression operations, which traverses the frame record list.
				The order is from front to back, so the recently inserted frame is first to try.
				Each try in loop targets the current iterated reference as the referenced to be processed and consists of several operations:
					If the strong refrence count is not equal to 1 (either 0 or more), it is held elsewhere.
						The frame in the list is removed and the referent should remain alive.
					Otherwise, if the referent is orphaned, the frame is removed and the referent is collected.
					Otherwise, compression is performed with the reference being processed as the parameter.
						After compression, if the weak reference count is 2, it can be the processed reference and its sole parent.
							Note the compressor does not process the element of frame record list.
								Although The compressor should know the object because it is the parameter, it is hold by strong reference, so it should be never collected by the compressor.
								This is also the reason of cleanup of orphaned referent referenced by element of frame record list should exist above.
								Moreover, if the environment is duplicate (e.g. from a function call), it cannot be removed by the compressor as it is designed without deduplication of bindings.
								So they are further compressed by taking the processed referent as destination and the referent held by guard object as source.
							All duplication of source environment bindings in the destination environment are removed.
							If the resulted parent environment is empty, it is to be collected.
								The parent of destination environment is moved to the source 
				The condition is based on size of frame record list.
					If the size changed, there is at least one object in frame record list is collected.
					The try would be continued as there can be new orphaned object not in the list due to the removal of object in the list.
			After the above first try of loop, components of the frame element are processed if necessary.
				The environment component holding temporary object is cleaned up if it is uniquely referenced. 
				The function prvalue component of front element of frame record list is then set to empty.
					This is a hack that avoiding improper tail calls caused by a false positive external reference to the static environment object held in the temporary function object which is or is similar to a vau handler.
					Ideally, multiple temporary objects are allowed coexisted.
						Otherwise, the first element of frame is also useless, which is the status quo.
					However, there is no simple way to implement this keeping the vau handler interface hidden under the type-erased context handler API, whose object can be wrapped more than once, to precisely know which object of vau handler appertains the frame.
					There shall be no undefined behavior if correctly implemented.
						The static environment is still accessible after destroying the function object if referenced when the object kept alive (by one ore more strong reference).
						Otherwise, it is a program error of ill-use of weak reference.
			Then the "compress" method is called.
			A new element is then inserted into the frame record list. The newly inserted frame element is the active frame components except the envrionment, and the environment stored in the guard object.
			Finally, during the destruction of compressor, remained objects are collected.
	The process of TCO tracing, check and collection is somewhat like tracing GC, but not the same.
		The design here is conservative but accurate in collection.
			It always collect in certain points of execution. All information used by the collection is depending only on the external program state. The timing of collection is determinstic.
			It always achieve space complexity of activation records no worse than conventional stack-based memory allocation stratigies in implementations of ALGOL-like languages, while tracing GC do not have such guarantees.
			It does not move objects in memory, while some kinds of tracing GC may move objects, so there is no special operations needed for interoperations as object pinning provided by some kinds of tracing GC.
			The design here is always local, against to global GC used by default in some language implementations.
			The design here is specifically for frames, not arbitrary objects to be collected.
			The algorithm used for tracing can be similar to GC based on reference counts, but collecting with multiple roots and counting down to 1 rather than 0 (as the anchor always holds an instance contributing to the weak count).
				For example, see http://arctrix.com/nas/python/gc/.
		The design here does not offer optimized throughput by default, which is often aimed by a tracing GC.
		The design here is deterministic like pure reference counting GC, rather than a traditonal tracing GC which would collect periodically or heuristically, typically introducing nondeterministic.
		The trace here is lightweight comparing to the traces used by traditional tracing GCs.
			It is necessary to determine the universe (the set of all the objects can be collected) and as well as the lived object set, not only the live object subset in a traditional tracing GC.
			It is used to locally determine the candidate search set, not the reachable set to determine the state of arbitrary set of objects to be avoiding from collection.
				It remains valid in one turn of collection, and can be generated frequently. This also requires it to be lightweight to avoid overhead of collection.
			There is no need to have granulated trace as it is already local to particular set of operations, and thus substantially efficient unless the control hardly terminate and already consume a lot of resources in some deep nested tail context.
				This worst sort of cases should be very rare (at least far rarer than cases need PTC for ALGOL-style programs) in reality, although there is room to optimize in future.
	By adding tracing, indirectly referenced frames can be collected, notably, for cases of recursively creation and call of vau abstraction would still leak leak slowly of the created function objects, like:
		Case 1:
			$defl! f (n) ($vau (x y) env eval (list $sequence x y) (lock-environment env)) n (f (- n 1)); f 1;
		Case 2:
			$defl! f (n) ($vau (x y) env eval (list $sequence x y) env) n (f (- n 1)); f 1;
		Case 3 (derivation of '$sequence'):
			$def! $sequence
				($lambda (&cenv)
					($lambda #ignore $vaue cenv &body env
						$if (null? body) inert (eval (cons $aux body) env))
					($set! cenv $aux $vaue (weaken-environment cenv) (&head .&tail)
						env $if (null? tail) (eval head env)
							(($vau (&t) e ($lambda #ignore (eval t e))
								(eval head env)) (eval (cons $aux tail) env))))
				(make-environment (() get-current-environment));
			$defl! f (n) $sequence n (f (- n 1)); f 1;
			Note that this would not work even with growing instance of environment objects, before the tracing and collecting of indirect referent is supported here by the design above.

$2018-07:

$report.impl:
Currently, 'ystdex::basic_string' is modeled on 'std::experimental::basic_string'.
	Moving towards ISO C++ need to rebase 'std::basic_string' to reflect the modification in WG21 P0254R2.
	There have to be a 'ystdex::basic_string' to provide the changes instead of 'std::basic_string' to keep no ISO C++17 fetures are unconditionally relied on.
Use of inherited constructors are rechecked to interact without resolution from WG21 P0136R1.
	This is searched using regular expression pattern 'using (.+)\:\:\1' in the editor in VS 2017.
	Currently, resolution of WG21 P0136R1 (esp. for CWG 1941) is not relied on.
		Some of the inherited constructors may be effected with dependent types from template parameters.
			Currently, these class names matching the pattern are 'derived_entity', 'default_init_allocator' and 'path' in namespace 'ystdex' provided by YBase module YStandardEx.
			The only use of 'derived_entity' in user code is 'NPL::TokenValue' in module NPL::NPLA.
				This is not considered relying on P0136R1 because it is based on interface like 'std::basic_string', where there no issue is related directly.
				This changes after adoption of C++17 whose 'std::basic_string' having conditionally enabled constructor targetting to 'std::basic_string_view' instances.
					This should ideally be resolved before adapting 'string_view' on the new 'ystdex::basic_string', but nothing is required to be done yet, since new constructors of 'std::basic_string' is still compatible in semantics with substitution failure.
			No use of 'default_init_allocator' in user code is found.
			Class name 'path' is safe because due to 'ystdex::sequence_container_adaptor'. 
		All other use are safe except 'using u16string::u16string;' in class 'String' in module YSLib::Core::YString.
			This should also be handled like 'ystdex::basic_string' and 'NPL::TokenValue'.

$2018-08:

$report.impl:
Type of feature testing macro values are adjusted as WG21 P0941R2.
	This is more consistent with '__cplusplus'.
		Now it also supports implementations where the range of 'int' is not large enough to represent the values with a steady type ('long') instead of unspecified one of 'int' and 'long'.
		Alhough currently no configuration of such implementation is known to  work with this project yet
	This is processed in definition sites using regular expression pattern 'define __cpp_([a-z_]+) (\d+)' replaced by 'define __cpp_$1 $2L' in the editor in VS 2017.
		There are 27 matched cases.
	This is then done in use sites using regular expression pattern '__cpp_([a-z_]+) ((<|>)\=?) (\d{6})(?!L)' replaced by '__cpp_$1 $2 $4L' in the editor in VS 2017.
		There are 27 matched cases.
UNC (universal name convention) paths support is reconsidered.
	It is considered necessary to be a part of complete file system path implementation for Windows based on the fact that symbolic links in Windows should be able to handle UNC paths.
	The lack of UNC path support also makes YFramework initialization failure if the executable module is in remote host in LAN.
	The ISO C++17 <filesystem> does not mention any sorts of UNC paths, but implemenation in Windows can support smoothly.
		As the difference is conforming, relying on UNC paths cannot be portable in the sense of ISO C++.
			However, YSLib paths does rely on more abstract 'ystdex::path' templates, rather than <filesystem> API. Thus there is no such portability problems.
		The <filesystem> implementation in Microsoft VC++ 2017 seems has most complete support in current mainstream implementations.
			From the comments, root path prefixes '\\server\', '\\?\', '\\.\' and '\??\' are all explicitly supported.
		In contrast, current libstdc++ only handle double slash prefixes, while libc++ seems to have no support of special handling of root prefixes at all.
	Some other implementation may have different strategy of support feature sets.
		For example, DMD standard library does not handle some cases like NT device namespace (prefix '\\.\') as per the installed documentation.
	YSLib follows the complete implementation like Microsoft VC++ 2017 <filesystem>.
		However, the abstract 'ystdex::path' does not distinguish root directory from root path, so there are several other caveats.
			The root directory are direcly attached following the root name. The root path consist of optional root name and root directory.
			As the separater, root directory is omitted in the internal representation. Paths I/O (parsing and printing) should handle it properly.
		With aid of 'YSLib::IO::PathTraits', 'YSLib::IO::Path' has overriding settings over the 'ystdex::path' with default traits.
			To keep backward compability, as the special case, 'YSLib::IO::Path' allows empty root name which indicates an implicit root directory.
		No tilde expansion is performed (like UNIX implementation in DMD).

$2018-09:

$report.impl:
Functions to introduce abstraction forms in NPLA1 have been revised.
	The variants of "with environment" (or "with static environment" where "static" is always inferrable) are renamed.
		The new '/e' postfix is clearer to the previously used 'e' due to more explicit boundary with the word it follows.
		This follows the design of the Kernel language, which inturns follows practice of "call/cc" as short for "call-with-currect-continuation" in the Scheme language.
			The Kernel language chooses the short form. It is more preferred here as '/e' occurs more frequently in the codebase in derivation of fundamental functions.
		The change actually does not break the code in the project besides the YSLib implementation itself, since these low-level function names are not directly used in known user code (i.e. SHBuild installation scripts).
PTC implementation in NPLA1 has been revisited.
	A bug of scanning the shared frame environment in the loop is fixed.
		The bug wrongly removed other components in the frame.
			This would cause undefined behavior with environment locking, e.g. in evaluation of expression '$let/e (() make-environment) () 42'.
		The resolution of the bug also relies on removing the hack of collecting function prvalues (see below).
	Now hack of prvalue function collection is also removed.
		It seems at current it does not effect PTC typically.
		See $2018-06 for descriptions of original design.

$2018-10:

$report.impl:
Last reduction status interaction has been simplified in thunked code of NPLA and NPLA1 implementation.
	The status shared in evalation passes of a single evaluation now is placed as the last status in the context.
		This avoid additional allocation with 'shared_ptr<ReductionStatus>'.
	Note rewriting last status is unavoidable for thunked code even the reducer does not always relies on the result.
		Because there is no simple way to know what is the last status when it is needed in an asynchronous action, the last status has to be always kept and updated in time.
		This is true even when it can be predicated statically about which of the asynchronous actions need to use the previous status.
Retionale of reductions in NPLA1 (esp. implementation of 'A1::ReduceOnce') is restated here for clarity.
	Reductions implements evaluations.
		Some are underlying reductions for evaluation in one-to-one mapping style, with a spicific term.
		Others are hidden from evaluations, namely so-called "admistrative", provided by actions, i.e. reducers in NPLA.
			Reducers can be formed by evaluation passes provided in NPLA1 and hidden terms.
			Reducers can be formed from handlers not related to any concrete evaluations in the sense of the object language.
		Since an evaluation reduction sticks on the same term so when retried, so it is safe to skip remained administrative reductions.
	If reducible, the current action should have been properly set or cleared.
	In general, the reduction status cannot be cleared immediately because no simple way to guarantee the current action is the last one for an evaluation rather of administrative merely by the status.
	'ContextNode::Current' needs to be exposed to allow capture of current continuation.
	The status as a returning value of an action would inform propably existed enclosing invoker to retry a new turn of evaluation reductions if the current action is cleared.
		Otherwise it is to be ignored as per the condition of enclosing rewriting loop.
			Typically the loop is provided by a trampoline of synchronous caller, or top-level enclosing loop in NPLA context.
		The invoker of the action is either synchrnous or asynchrnous, either in evaluation or of admistrative.
	The returning value cannot be handled just (as the enclosed operation) by unconditionally retrying some specific operation, thus it reflects the control of administrative reductions.
	The status 'ReductionStatus::Retrying' indicates a request to skip the all remained administrative reductions.
		The skip is treated as attempt to switch to a new action, which should be in turn already properly set or cleared as the current action.
		'ReductionStatus::Retrying' can be the result of the last reduction derived from a call of 'A1::ReduceAgain'.
	For thunked (asynchronous) calls, both evaluation and admistrative reductions need to support continuation capture.
		There are several differences.
			As mentioned, the continuation for evaluations are directly capturable via the current action (i.e. 'ContextNode::Current'), but administrative ones are not.
			The continuation of an administrative reduction does not always expose a parmeter to be passed to support first-class continuation invocation.
			The boundary of actions is implied differently.
				In the evaluation case, it is addressed by the separation of current action and delimited actions in the context.
			The implementation of 'A1::ReduceOnce' does not use deleimited actions.
				The purpose is to avoid need of unwinding which introduce the necessity of delimited frame marks and frame walking in delimieted actions.
					Even this may be faster when properly implemented.
			Delimited actions are reserved to control primitives the in object language.
				For instance, "shift" and "reset" operations. See http://hjemmesider.diku.dk/~andrzej/papers/AC.ps.gz.
				They are not implemented yet.
Options of "strip" operation for linking has been modified to be saner.
	The command line option "-s" is only effective in linking stage of both G++ and Clang++.
		See https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options.
		See also https://clang.llvm.org/docs/ClangCommandLineReference.html#linker-flags.
	When command line option "-c" exists, the compiler driver does not link.
		See https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options.
		See also https://clang.llvm.org/docs/ClangCommandLineReference.html.
		G++ silently accepts "-s" as a compiler option Clang++ complains with warning [-Wunused-command-line-argument] if '-s' is specified in this case.
		To eliminate the warning, "-s" is not used for compiler option now.
			This seems also better for logical reasons.
		The command line option "-Wl,-s" is also valid for linking stage.
		The command line option "-s" is suspected to suppress relocation tables and it would interfere ASLR, but this does not matter currently.
			See https://stackoverflow.com/questions/14175040/effects-of-removing-all-symbol-table-and-relocation-information-from-an-executab.
			Support of additional command line options for ASLR ("-fpie", "-pie", etc.) are not provided by the scripts yet and they would not be rely on existence of "-s".
		So now strip command line option for compiler (defaulted as "-s") is removed from the build scripts.
			The linker command line option is preserved.
Context type of NPLA has been modified.
	'ContextNode' is now a polymorphic base class.
		'A1::ContextState' derived from it is for NPLA1.
			Passes previously in 'ContextNode' are also moved to 'A1::ContextState'.
		The separation serves better in SoC(Separation of Concers), and with 'ystdex::polymorphic_downcast' this actually perform better.
	New current state of next to-be-called term reference is provided in 'A1::ContextState', to have better support of first-class continuations.
		'ContextState::SetNextTermRef' is required be called in one of following cases:
			It is before list or leaf passes (in 'A1::ReduceOnce').
			It is before some other evaluation of subexpressions changing the active term being evaluated and the evaluation is allowed to be captured as a continuation in the object language.
			It is immediately after all actions of a non-tail evaluation.
				When following a tail call immediately, it can omit the operation since the reference is always overwritten later, if used.
		Then the called 'A1::Continuation::operator()' can read saved active term reference by calling 'ContextState::GetNextTermRef'.
The MSVC-specific attribute '__declspec(novtable)' has been supported in 'ydef.h' as 'YB_ATTR_novtable'.
	See $2013-09 report.impl for previous analysis.
		The requirements has been loosed to be more accurate on behavior.
	This is also supported in Clang++ since version 3.7, see http://releases.llvm.org/3.7.0/tools/clang/docs/AttributeReference.html.
		Now this would be ignored if for non-Microsoft ABI, see http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20150720/133747.html.
	It is considered that there can be a better name to 'vtable' in 'YB_ATTR_novtable' as it has been exposed too much implementation details, but nothing clearer is found yet.
	Use of the attribute will be adopted in future in YSLib code, notably, for YBase base classes and YFramework interface types.

$2018-11:

$report.impl:
Pool allocation has been implemented.
	The base implementation now is in "ystdex/memory_resource.h", which replaces and extends ISO C++17's <memory_resource> interface in a compatible manner.
	There are a few out-of-box implementations for reference.
		Microsoft VC++ 15.8.2 has provided the full implementation of ISO C++17 <memory_resource> with some LWG DR resolutions while libstdc++ and libc++ not (only with library fundamental TS interface).
		Boost.Container has another implementation (probably targetting library fundundamental TS currently), with some extensions.
		Some post-C++17 LWG issues define further interface change, e.g. LWG 3038. They are also implemented in Microsoft's implementation.
	Supported LWG resoultions are documented in the header file.
	The pool has a separated type, in spite of there are "std::unsynchronized_pool_resource" and "std::synchrnoized_pool_resource".
		The pool types are not guaranteed to deallocate upstream resource unless totally released.
			This is bad for long-running programs since it would likely lead to definitely memory leaks because the pools never shrink.
				On systems having virtual memory, it would like waste swap space; otherwise it would waste RAM a lot.
			Microsoft's implementation does not suffers from this, but it is not guaranteed portable.
			See also https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/MKBWu8yzTOA.
		The latter is inheriting the former publicly in Microsoft's implementation. This might be promatic.
		So anyway, a new type seems necessary. This is done separatedly even when Microsoft's implementation is available.
	Some implementation techniques not specified by the interface are used to improve performance for average cases.
		A stashed chunk pointer is used to avoid most cases of O(n) search of candidated chunks in allocation.
		An empty chunk pointer is used to cache the empty chunk, thus it avoids some unnecessary immediately reallocations when there is a chunk with all blocks deallcated recently.
		The heuristic strategy is used in the pool chunks.
			The growth factor is 2 is choosed mainly for simplicity.
				Not same to 'std::vector', since the chunks are not inteneded to be reused (like reallocation in 'std::vector'), 2 does not suffer from cache missing issues.
				See https://www.reddit.com/r/cpp/comments/2ezwee/stdvector_optimization_by_facebook/ about issues of vector reallocation.
		All of the above implementation details are similar or same to Microsoft's current implementation but different to Boost.Container's.

$2018-12:

$report.impl:
Deleter types for allocators have been reviewed. The idea of deleters has been considered in different proposals.
	See https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/rx8k-q7qeyI for the discussion.
		At least two of them are proposed to WG21, namely WG21 P0211 and WG21 P0316.
		And there are also prior arts in existed libraries.
		There are subtle differences among interface designs.
			Partial specialization for reference allocator types is in WG21 P0316, but not in other designs.
			The 'const' qualification changes among revisions of WG21 P0211.
			There is allocator access support (by 'get_allocator') in various designs, but not in WG21 P0211.
	The interface provided as 'ystdex::allocate_delete' in "ystdex/memory.hpp" has done different to these proposals.
		It actually is in line with libc++'s internal 'std::__allocator_destructor', which deallocates but not destroys objects allocated previously.
			This is actually indirectly mentioned in WG21 P0316 as internal details.
		The equivalent functionality to the 'std::unique_ptr' combined with and the deleter are proveded by guard pointer template 'std::__allocated_ptr' in libstdc++.
			As it is too specific for internal use, it is not adopted in 'ystdex'.
	The interface in 'ystdex' is now changed, but still not same to the existed designs.
		The old interface is renamed to 'ystdex::allocator_guard_deleter'. The old name 'ystdex::allocator_delete' is then used by new a class template with object destroying.
			To be consistent with other uses, the changed name proposed in WG21 P0211 is not adopted yet.
				This might change later if it is adopted in the standard draft.
			As the internal count is not in the 'ystdex::allocator_delete', they are separatedly implemented (without inheritance).
		Qualification and internal 'mutable' is preserved.
		Referenced allocator support is added, but without a partial specialization.
		Allocator access is preserved. Additional 'count' access is added for 'ystdex::allocator_guard_deleter'.
	Remained interface in the proposals like 'allocate_unique' is to be added in future.
The ABI concerned with 'std::aligned_storage' may differs in libstdc++ and other implementations on the same underlying platform (ISA).
	See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61458.
	This is perhaps better being done as well in YBase for the same reason to '__aligned_buffer' used internally in libstdc++.
	Minimization may be implementable.
		See https://github.com/WG21-SG14/SG14/commit/98baf1aeab for example.
		However, this approach is not taken for various reasons.
			As the result of the GCC issue, the current libstdc++ is still conforming and change is ABI-breaking.
			Change of the default template argument 'ystdex::align_storage' is not allowed by the policy of YBase, so if needed, new traits should be introduced anyway.
				This is disallowed because it does need implementation-specific knowledge. So it is essentially not portable out of a standard library implementation.
				It is also not intended to make 'ystdex::aligned_storage_t' and 'std::aligned_storage_t' behave differently for a same platform configuration.
			Any critical use of the buffer could use explcit alignment like '__aligned_buffer'.
Special handling of reference wrappers in constructor template with 1 value parameter in 'ystdex::any' has been removed.
	The removal of extension prevents the construction relying on concrete wrapper types by default.
	It also makes 'ystdex::any' having more consistent behavior of general erased type wrappers like 'boost::any', 'std::any', 'std::function' and so on.
	The behavior in 'any_ops::ref_handler' on copying is same to 'any_ops::value_handle' directly passing value.
		The only difference is to keep the ownership in the object or not.
		If external ownership is needed, 'any_ops::ref_handler' should be better explicitly used.
	Since reference wrappers are first-class object simulation of raw reference types, it should not be implying value copying by default, which undermines generality of the constructor to handle first-class objects.
		This is also problematic for mixture of use for different ownership schemes in single constructor signature.
Several alternative designs and implementations of 'std::function' have been reviewed.
	There are feature improvements and issues oncerned in current 'std::function'.
		The main reason is that implemenations of 'std::function' are lacked of allocator support in general, so replacements are needed.
			Allocator is planned to be used in NPL with 'YSLib::GHEvent', whose implementation is currently based on 'std::function'.
			By altering the underlying implementation, issues can be resolved in a flexible way.
				The impact of compatibility should be minimal.
					Behavior relying on these features are planned but not yet used.
					Use of 'function' is always qualified with 'std::' prefix in YSLib currently.
		LEWG 34, including multiple issues on 'std::function', targets C++20.
			Currently it is in the "DESIGN_REVIEW" status.
			See https://issues.isocpp.org/show_bug.cgi?id=34.
			WG21 N4348 proposes synchronization in interface.
				This is not in favor of both LEWG 34 and YSLib for violation of principle of zero overhead abstraction (cf. ISO TR 18015).
				See also discussions in WG21 P0045R0.
		Multiple potential feature improvements on 'operator()' are considered.
			Different qualification on 'operator()' is needed.
				WG21 P0045 proposes change of 'const' and other qualifiers on 'operator()'.
					This can be difficult due to ABI compatibility. It is not approved yet.
				Here other qualifiers concerned are ref-qualifiers and the 'noexcept' specifier where ISO C++17 'noexcept' type is supported.
			Narrow contracts on 'operator()' is needed.
		Noncopying wrappers are needed.
			WG21 P0288 proposes a replacement 'std::unqiue_function'.
		WG21 P0770 restates the 'noexcept' requirement on move of 'std::function'.
		Translation-time enhanced safety is appreciated.
			WG21 P0932 proposes the additional constraint on 'std::function' return to capture specific danling referernce error during translation.
	The reviewed replacements are needed to work around deprecation of allocation support of 'std::allocator' in WG21 P0302.
		As stated in the paper, the feature have not been implemented at all in libstdc++ (with even no concerned signatures at all) and libc++, while Microsoft VC++ has only limited support.
			And the support of Microsoft VC++ is to be removed, see https://github.com/aws/aws-sdk-cpp/issues/652.
		Library fundamental TS v3 (WG21 N4758) has been drafted with a new 'std::experimental::function' interface with 'erased_type' allocator support.
			This is mostly the right design.
			However, this is does not planned to be compatible in source level in YBase.
			As new 'function' is needed, there are other candidates to be analyzed.
	There are several source of alternatives. They are listed here for reference.
		WG21 P0288 mentions some implementation of 'unique_function'.
		Document of 'fu2' (with 'unique_funtion') in turn mentions other implementations.
			See https://github.com/Naios/function2.
		Some multiple dispatched function wrappers are collectively benchmarked at https://github.com/FrankHB/nano-signal-slot/tree/master/benchmark.
			They are mostly for multiple dispatching implementations and have been analyzed by this project previously.
			However, the base implementations can still be referenced.
			The upstream has migrated the benchmark to a new project, see https://github.com/NoAvailableAlias/signal-slot-benchmarks.
		More candidates are collected in https://github.com/jamboree/CxxFunctionBenchmark.
	For purpose of being the baseline of interface design and performance benchmark, 'std::function' implementations as well as ("preferred syntax") 'boost::function' should be considered.
		See ISO C++17 and https://www.boost.org/doc/html/function.html.
		They are mostly the same in the interface design.
		As the baseline, the candidates should support most features in 'std::function'.
			As the exception, the deprecated and unimplemented by most implementations allocator support in 'std::function' is not required.
			As another exception, some WG21 P0288 'unique_function'-like interface may not support copying by design.
				When not provided separatedly, it needs 'std::function'-like interface as the complement for need of copyable wrappers.
	Several decisions are made to be noted.
		The type erasure wrapper should be based on 'ystdex::any' for simplicity.
			The size of 'ystdex::any_storage' should be carefully tuned for performance.
		The interface like 'unique_function' is not separated in 'ystdex' because 'ystdex::any' can support noncopyable types.
		Multiple overloads is not planned to be supported in 'ystdex' as the overhead is not ignorable.
			The typical implementations use an overload table to support multiple overloads in type-erased wrappers.
			Actually WG21 P0045R0 has the feature but WG21 P0045R1 drops it.
			Examples are 'cxx_function::function' and 'fu2::function' (see below).
		Throwing (like 'std::bad_any_cast' in 'std::function') is intentionally avoid.
			For user code like 'YSLib::GHEvent', the exception is already handled.
				This can be further optimized by removal of the whole exception handling code once all calls on empty wrapper have been avoided.
			If needed, it can be added in user code.
		The parameteric design like 'fu2::function_base' for 'fu2::function' (see below) is not supported.
			So 'ystdex::function' will be a template simpler as specification of 'std::function'.
			Since many features are filtered out, there have been no need to parameteric the configurations.
		Wrapper view as 'std::function_ref' proposed by WG21 P0792 is not planned in near future.
			Almost all function warppers used in the user code are owning, or they are not interested in external owners.
				The view is not required currently.
			If needed, it can be added later.
	Candidates as primary references are listed.
		1. 'cxx_function::function' and 'cxx_function::unique_funtion' from https://github.com/potswa/cxx_function as reference implementations in WG21 P0288.
			Design in WG21 P0042 is not used.
				In particular, 'ystdex::any' does not follow the scheme of 'ErasureClass' proposed by WG21 P0042.
					'ErasureClass' is admitted "completely differerence" to 'std::experimental::any' implementation in libc++ and libstdc++.
						The implementations in latters are in turn more like to the implementation of 'ystdex::any'.
			Some designs in WG21 P0043 is concerned.
				It proposes seperation of container as a new interface.
					While sometimes useful, providing both interface does incur complexity of use.
					As the container behavior is not used in YSLib (particularly, not in NPL), the design is not adopted currently.
						The capability of interoperations between 'function' and 'function_container' in the underlying implemantion should still be considered.
						This is also fit for 'ystdex::any' with upcoming allocator support to be the base of 'ystdex::function'.
				The interface requirement about need of allocator stored in the function wrapper is reconsidered.
			Deprecation is not needed in YSLib because no deprecated behavior is relied on.
		2. 'fu2::function' and 'fu2::unique_function' from https://github.com/Naios/function2.
			The design fits the needs in YSLib quite well.
			Differentiating "weak destroy" from "destroy" in the implementation seems redundant.
	Other mostly feature-complete candidates are also listed here.
		1. 'func::function' from http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/function.h.
			This implementation may have undefined behavior concerned with strict alising.
			This implementation does not support move-only targets.
			The implementation to wrap pointer to members using 'std::mem_fn'.
				While conforming, this is usually inefficient with indirect wrappers.
				It is unspecified the result type of 'std::mem_fn' call, so there is no guarantee to further enable the result with small object optimization.
			When allocation is required, it unnecessarily forces using a copy of 'const' allocator object in the constructor.
			The implementation allows opt-out of wide contract (throwing exception) in call of 'operator()'.
			Calls in this implementation outperformed a lot in CxxFunctionBenchmark for calls.
				The null state is inlined, so there is no need to check whether the underlying callable object is null.
				The call table is directly weaved as function pointers, so there is less indirection and dispatching overhead.
					However, the space efficiency is low. When used heavily, it might harm cache locality. This does not identified by the benchmark (note the size of the object does not show this problem).
				Pointer to members are not benchmarked in CxxFunctionBenchmark so it is unknown the cost from 'std::mem_fn'.
		2. 'bsl::function' from https://github.com/bloomberg/bde/blob/master/groups/bsl/bslstl/bslstl_function.h.
			This implementation does not support different overloads of 'operator()'.
			This implementation does not throw on 'operator()' only when exception is disabled.
			This implementation support pre-C++11 language implementations.
				It has optional rvalue reference support.
				It simulates variadic template when it is not available (up to 13 arguments).
			This implementation uses multiple pointer objects as representation. The memory footprint concerns are documented within the code.
	Candidates lacking of required allocator support are listed here.
		1. 'stdex::function'.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/stdex.hpp.
			This implementation does not support move-only targets.
			Implementation of allocator usage does not support stateful allocators in 'stdex::function'.
				The destruction uses allocator copy and the allocator object is not lived with the 'function' object in its lifetime.
		2. 'generic::delegate' and 'gnr::forwarder' from https://github.com/user1095108/generic.
			'generic::delegate', marked obsoleted, originates http://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11.
				See https://github.com/user1095108/generic/blob/cd20bf0105735dede2f4542b71a6716b257d72f4/obsolete/delegate.hpp.
				See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/delegate.hpp.
				This implementation has specialization of 'std::hash'.
				This implementation does not support target access.
			'gnr::forwarder' seems a recent replacement.
				See https://github.com/user1095108/generic/blob/cd20bf0105735dede2f4542b71a6716b257d72f4/forwarder.hpp.
				See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/forwarder.hpp.
				This implementation supports target access by 'target', but without 'target_type'.
			Both implementations do not support allocators, move-only targets and different overloads of 'operator()'.
		3. 'embxx::util::StaticFunction' from https://github.com/arobenko/embxx.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/embxx/StaticFunction.h.
			This implementation does not support allocators, move-only targets and different overloads of 'operator()'.
			This implementation does not support target access and totally misses exception specifications.
		4. 'Function' from https://github.com/rigtorp/Function.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/Function-rigtorp.h.
			This implementation does not support allocators, move-only targets and different overloads of 'operator()'.
			The 'operator()' is not qualified by 'const'.
	Candidates lacking of functionality of 'std::function' (other than exception of missing of copying) are listed here.
		1. 'hpx::unique_function' from https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/util/unique_function.hpp.
				The 'target_type' is not support since https://github.com/STEllAR-GROUP/hpx/commit/655bac8440b2315882395a65a8c1741ddaa8de0c.
					This does not fit for the need of 'YSLib::GHEvent', but other interface would still be useful to reference.
				It also provides other metadata in https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/util/detail/basic_function.hpp, but there is no allocator support.
			The original link (in WG21 P0288) https://github.com/K-ballo/hpx/blob/master/hpx/util/detail/unique_function_template.hpp is dead.
		2. 'move_only_function' from the answer of https://stackoverflow.com/questions/28179817/how-can-i-store-generic-packaged-tasks-in-a-container.
			The implemantion includes common techniques used in implementing 'std::function' and other variants.
				It is simplified since SFINAE-friendly 'std::result_of' (proposed by WG21 N3462) is accepted in ISO C++14 and superseded by 'std::invoke_result_t' in ISO C++17.
			It also provides overloads of 'operator()' on 'const' and ref-qualifiers.
			However, as only a demonstration of 'unique_function'-like interface, it does not qualify to be used in industrial cases.
				It has no allocator support.
				Nor does it have target access.
				It does not support small object optimization and it also dispatches underlying operations inefficiently.
				It also totally misses exception specifications.
		3. 'fixed_size_function' from https://github.com/pmed/fixed_size_function.
			This implementation demonstrates the small object optimization already used in most other implementations.
			Otherwise, it does not qualify to be used in industrial cases.
				It provides no allocator support or move-only targets support, nor different 'operator()' overloads.
				Different to the 'std::function', its 'operator()' is not qualified at all.
				It also totally misses exception specifications.
		4. 'smallfun::SmallFun' from https://github.com/LoopPerfect/smallfunction.
			This implementation has similar issues of 'fixed_size_function'.
		5. 'fastdelegate::FastDelegate' from https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/clugston_styled/FastDelegate.h.
			As analyzed previously for 'YSLib::GHEvent' underlying implementation, this one relied on ABI-specific knowledge like internal components layout of pointer to members, which renders it not fit the use in YSLib.
				However, it should be considerably efficient for specifically targeted platforms.
				In fact, as shown in https://github.com/FrankHB/nano-signal-slot/tree/master/benchmark, the multiple dispatching wrapper based on it was the only one having more efficient calls in general compared to 'YSLib::GHEvent'.
					This would probably remain true for a long time.
			This does not pace up to ISO C++11 features like '&&' and it does not replace 'std::function'.
				CxxFunctionBenchmark does not include the test for it possibly for these reasons (as 'ssvu::FastFunc' below).
		6. 'ssvu::FastFunc'.
			See https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/QgvHF7YMi3o.
				It shows that the interface is not conforming as 'std::function' by missing well-formed constructions from target with convertible function signatures.
			See https://gist.github.com/SuperV1234/6462221.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/clugston_styled/FastFunc.hpp.
		7. 'folly::Function' from https://github.com/facebook/folly/blob/master/folly/docs/Function.md.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/folly/Function.h.
			Like proposed 'unique_function' in WG21 P0288, it does supports copy interface. Copyable types need 'std::function'-like interface as the complement.
			This implementation has overloads of qualified 'operator()' with 'noexcept' when supported, but otherwise all of the overloads are qualified as 'const'.
			This implementation does not support allocators and target access.
		8. 'stdext::inplace_function' from https://github.com/WG21-SG14/SG14/blob/master/Docs/Proposals/NonAllocatingStandardFunction.pdf.
			This is a draft proposal, but never being released (as WG21 P0419).
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/inplace_function.h.
			This design only support targets that do not need being allocated.
			This design does not support target access.
			The implementation has extra effort to minimize ABI difference caused by different implementation of 'std::aligned_storage_t'.
		9. 'multifunction' as an example of Boost.TypeErasue, from http://www.boost.org/doc/html/boost_typeerasure/examples.html#boost_typeerasure.examples.multifunction.
			This is promising about the way of conbination based on 'any', though it lacks most other interface from 'std::function' as well as specific resolutions of issues.
			The resulted interface is actually quite different to 'std::function'. It is placed here for exposition-only use.
Generic object type 'ystdex::any' has been optimized.
	The constructor now avoids unnecessary initializations of unused storage data member.
		The storage modifications are redundant when the constructors are correctly implemented.
		This improves performance a bit.
		Because 'constexpr' is needed for the default constructor, it has to be with explicitly initialized storage.
	The assignment operators are changed.
		They are specified in terms of 'swap' in ISO C++17 [any.assign], which is occasionally exactly the same (except the parameter name) to the old implementations.
		However, implementions (at least libstdc++ and Microsoft VC++, but not libc++) may use reset and move instead, granted by the valid but unspecified move-from state rules stated.
		Now assignment operators of 'ystdex::any' change similarly.
		These changes improve performance in heavy use (NPLA1 interpretation) of 'ystdex::any' as well as 'ystdex::function' instances based on it.
			Without the changes, use of 'ystdex::function' instead of 'std::function' in 'YSLib::GHEvent' is slow.
				This can be no less than 10% mesuared by intrcution fetch in release configuration of x86-64 Linux built by GCC 8.2.1, at least in NPLA1 case with mostly object language applicative calls.
					The used NPLA1 program is equivalent to '$defl! fib (&n) ($if (<=? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)))); iput (fib 17); exit'.
					The case is with 'int' arithmetic operations, applicatives 'iput' and 'exit' given by the implementation in the client code.
					The environment initialization has also a few minor initialization and bookkeeping in NPLA1 and native code.
				CxxFunctionBenchmark-derived tests (on 'function<int(int)>') does not find the differences.
			The performance is now comparable to 'std::function' previously.
	The underlying storage has been tuned.
		To reduce overhead of indirect calling in DLL/DSO, more member functions of 'ystdex::any' is put in the header instead of the "any.cpp".
			This is particular effective to be used as 'ystdex::function' base implementation.
			To the test case above, it can reduce 102% cost to 90%, with 'std::function' in 'YSLib::GHEvent' as the base line.
		The resulted storage is 2 words in typical implementations (e.g. 8 bytes in x86).
			This is larger than 'std::experiment::any' in libstdc++, but less than several others like Microsoft VC++'s.
			This is occasionally same to some other implementations, like https://github.com/emweb/wt/blob/master/src/Wt/cpp17/any/any.hpp.
		Note small object optimization may harm to overall throughput if not used properly.
			If the object is not small enough, it will have significant pressure on register files of the processor.
			This implies the size should be reasonably small.
			In fact, smaller size may perform better even it has addtional allocation cost.
				 Notably, the size of 'sizeof(ystdex::function<...>)' is 16, which equals the sum of size of 'ystdex::any' and the invoker.
				 As 'ystdex::any_storage' is 8 bytes, it is not engough to store a polymorphic holder with allocator pointer (which requires 12 bytes) in 'ystdex::any_storage'.
					The polymorphic holder has at least an overhead of 4 bytes of the virtual table pointer in both Microsoft and Itanium C++ ABI.
					The allocator pointer (an instance of 'std::unique_ptr') basically has 4 bytes for the pointer, and additional 4 bytes for the non-trivial allocator object (like a 'ystdex::polymorphic_allocator' instance used in 'YSLib::AllocatorHolder').
				 'YSLib::AllocatorHolder' requires 12 bytes as the polymorphic holder so it also cannot be stored locally.
				 However, even 'YSLib::YObject' has allocated more for 'YSLib::AllocatorHolder', it is still better because small 'ystdex::any_storage' benefits other cases.
	Allocator support has been added.
		The allocator design here also applies in implementing 'ystdex::function'.
		This is not same to the allocator type-erased model in library fundamental TS v3 (WG21 N4758) or WG21 P0987.
			It does not has 'allocator_type' nested type, and the member function 'swap' does not throw.
		It is considered that separately erased allocators like WG21 N4758 'std::experimental::function' is harmful.
			As 'ystdex::any' is used to implement 'ystdex::function', the concerns have been raised a while.
			The point is similar to WG21 P0043, as the container semantics have incur performance and other subtle ease of using issues.
			Some designs are different to WG21 P0043.
				The default constructor does not specify the behavior equivalent to the default allocator.
					It would be equivalent where the default allocator has same allocation behavior to 'new'.
						Note the allocation in the default allocator does not guarantee it has a single 'operator new' call, neither would it interact with class-scope 'operator new'.
				The copy of allocator object is required.
		The default cases (without explicit allocator specified in construction) can use 'pmr::default_memory_source'.
			It can actually be more efficient than raw 'new' in a sufficient long.
				Though no definite determinism, his can be related to cache efficiency.
			This is not applied because the cost in mandatory abstraction semantics is greater and this is not possible to optimized away because the memory resource can be set later.
				If memory resource is really needed, it should be constructed with a 'ystdex::pmr::polymorphic' instance.

////

