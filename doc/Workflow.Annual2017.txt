/*
	© 2017 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2017.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2017 年度。
\version r77
\author FrankHB <frankhb1989@gmail.com>
\since build 763
\par 创建时间:
	2017-01-27 16:01:59 +0800
\par 修改时间:
	2017-02-18 16:23 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2017
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2017-01:

report.impl:
Call expression of 'invoke' and its derivations like 'ystdex::invoke_nonvoid' is concerned.
	The left operand (pm-expression) of '.*' operator requires lvalue for build-in forms.
		The original form would accept non-lvalue left operand well-formed constructs, being distinct to the built-in operator rule.
	It is now changed to be aligned with built-in rule in 'ystdex::invoke'.
		It may being more friendly to catch bugs of wrong use.
		Now it is also same to the original proposal WG21 N4169 and the working draft WG21 N4606, without additional specification modification.
			Except for addtional of 'reference_wrapper' support is not included now.
				This was in the resolution of LWG 2219.
				See also N4170, though it seemed not to be accepted.
				It is likely to be supported in future in 'ystdex::invoke'.
		Note the original proposal N4169 seemed to miss this point.
			It was fixed in the referential implementation as https://github.com/tomaszkam/proposals/commit/8e9150acd1635f6cd33cb7db3f52e0c217538cd2.

$2017-02:

report.impl:
The 'TokenValue' type was introduced to eliminate non-terminated loop for reduction of delayed terms in 'EvaluateLeafToken' in build 753.
	Since delayed term evaluation would request retrying, it would be trapped in 'EvaluateLeafToken' again and thus it would loop forever if the term being evaluated was not changed.
	It was proved that allowing only 'TokenValue' rather than 'string' to be evaluated as tokens was an effective way for the purpose.
		'TokenValue' was a form of explicit unevaluated operands.
	However, the root cause was lack of proper normalization (i.e. 'Value' cleanup) after a successful reduction.
		This was fixed in build 755.
	The 'TokenValue' is still necessarily for ontology purpose, since token is not a simple lexeme in the design.
		There can be opportunities to insert some more semantic actions in this intermediate layer.
Some points about unevaluated expressions are concerned with the current implementation.
	There are different mechanisms to implement unevaluated expressions.
		As unevaluated expressions, 'DelayedTerm' is for general purposes after lexical analysis.
		'TokenValue' is different.
			It is used in lexical analysis passes.
			It is only for symbols, i.e. tokens to be evaluated, rather than arbitrary expressions.
			It is better on performance since no new terms have to be constructed during the evaluation.
		Transformation like 'TokenizeTerm' would be still preserved within a preprocessing pass in REPL contet for saparation of lexical phase from further evaluation.
	Unevaluated expressions can be explicitly evaluated in function 'A1::EvaluateIdentifier' in module 'NPL::NPLA1', with 'TokenValue' and 'DelayedTerm' processed differently.
		For 'TokenValue', it is done here directly rather than by wrapping in a new delayed term and than calling 'A1::EvaluateLeafToken' for 2 reasons:
			Const-correctness is needed on parameter with type of reference to 'ContextNode' and in other cases the 'A1::EvaluateIdentifier' function has no need to modify the context node.
			Performance of direct handling is better because wrapping a term in 'DelayedTerm' is more expensive and there is no good reason to do that.
		The evaluation of unevaluated 'TokenValue' does not check the possible infinite loop.
			It is the responsibility of users of the API to configure the evaluation passes properly to provide strong normalization property on name expression evaluation required by the specification of NPLA.

////

