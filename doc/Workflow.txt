/*
	© 2013-2020 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.txt
\ingroup Documentation
\brief 工作流汇总报告。
\version r3635
\author FrankHB <frankhb1989@gmail.com>
\since build 433
\par 创建时间:
	2013-07-31 01:27:41 +0800
\par 修改时间:
	2020-06-10 23:20 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2013-04:

report.anylatical:
Primative image formats should be supported: bmp, jpg, png.
Use non-GPL for license of FreeImage.

workflow.dev-dep:
For UI:
	(literal semantics, function mapping) -> NPL evaluator,
	UI layout manager -> UI designer,
	(concreate UI sessions, UI session manager) -> UI session shells,
	device abstraction -> platform surfaces,
	(YEGE, graphical layer adaptors) -> YSLib graphical APIs;

note.visual-stack:
Reconstruction of visual stack design should be considerable.
	currently: host screen/desktop layer - hosted window - YSLib screen device with back buffer/platform surface - Desktop;
	future: all layers handled via %IWidget derived class components;

todo.designated:
/ device-reqirement-analysis;
/ image-reqirement-analysis, round 2;

$2013-05:

report.impl:
See $known_issue_b406 @ Meta.txt.

dep.merge:
Microlua(github://microlua/MicroLua-Source) @ DS: considerable, shelved.
uLibrary @ DS: rejected. Quality questionable, not suitible for scope.
	From http://devkitpro.org/viewtopic.php?f=2&t=3192, WinterMute: "Please don't use uLibrary either, it's awful and you won't get support for it here either."

note.req-env:
WG21 N3476 is confirmend to be not needed currently.

$2013-06:

report.impl:
Resolved bug $known_issue_b223.

todo.ceased:
Base class 'noinstance' is not necessary. Use abstract class to stop create an object of a class.

todo.deferred:
$done.finished Updating dependencies of FreeImage.
	// To make binary change small.

note.design:
UI input/output events should be asymmetry, that is, input events are far more variant than output events. The reasons are:
	1. There are more unpredictable choices from user input than program output by the designer.
	2. The output is usually generated by few kinds of devices(video and audio), but the input is often from a lot more devices with different types and behavior.
	3. Though the input from variant devices can be multiplexed, they are almost always demultiplexed by the client, if used. No need to twist them together for both input and output events.

$2013-07:

dep.impl:
FreeType:
	Modules configuration:
	'HINTING_MODULES += autofit' is to be removed for no necessity of hinting and binary size.
	'AUX_MODULES += cache' is to be removed because only the header is used currently.
	Redundant, unused and invalid(dependency not satisfied) 'BASE_EXTENSIONS += ftfstype.c' is to be removed.
	'BASE_EXTENSIONS += ftstroke.c' is to be removed because currently not needed.
	'BASE_EXTENSIONS += ftsynth.c' is to be removed because this is the alpha interface(see the source) , and should be considered deployed in client code.
	Performance:
	Old version of FreeType source files are used for workaround. See $known_issue_b406 @ Meta.txt.

report.impl:
See $known_issue_b406 @ Meta.txt.
	Hotspot history in freetype2 repository: tt_face_get_metrics @ ttmtx.c:f5aa47b, tt_face_get_metrics @ ttgload.c:8744edf, TT_Get_Metrics @ ttgload.c:3ab770b.
There is no necessity for attatched events implemented as routed events like WPF built in GUI state of YSLib, because:
	1. Basically routed events fit view trees well.
	2. No no other trees used as part constructs for further UI modeling which have extra routes.
Though event forwarding with distinct source switched or attatched can be reasonable.
New UI event CursorOver and CursorWheel supported. Though no need for devices without mouse like DS, it is a plus to allow users raise such events.
Some bugs of screen coordinate conversion for MinGW32 fixed.
Wheel event issues:
	Scroll bars and listboxes now support CursorWheel event. More should be investigated.
	Now wheel event is available in the area of independent focus. Extended wheel event can be supported when cursor out of area of current widget(independent focus) like QQ2013 UI, but is depend on users.
Using seperated 'Fetch*' function to get static objects for:
	1. Runtime dependency can be decreased. If font cache is not needed, font directory is also not needed to be specified.
	2. It is good for statically-linked programs without need for initialization of all these objects. Binary image size can be decreased through link-time optimization if the unrelated interface is unused totally.
Some interfaces of 'Helper' are moved to 'YSLib'. Some(like 'FPSCounter') are still immature.
Win32 hosted Window enumeration:
	::EnumWindows and ::EnumChildWindows can not keep iteration state, so use ::GetWindow instead.
	Results of enueration the desktop are often too large for usual application.
G++ 4.8.1 wrongly accepted reopened namespace from non-line to inline. See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53402.
For loading image from file system using FreeImage:
	Non-ANSI filename for extension detection(i.e. for ::FreeImage_GetFIFFromFilename) is OK, because the extensions recognized are all ASCII representable.
	Unicode version of functions are invalid for non-Win32 platforms, so just do not use them.
	Do not use ::FreeImage_Load if the encoding of filename used by ::fopen is not specified.
For %::NTSTATUS error 'STATUS_CONTROL_C_EXIT'(0xC000013A) on Windows, it is expected when console window closed or Ctrl+C pressed.
Now focus would not be automatically released on widget destruction, allowing unspecified order of widget destruction being safly with no-op.
Mutal exclusion locking overhead is significant(about 5x lag) in current implementation on MinGW32 for both 'YCLib' input and 'Helper' rendering.
	Actually both cases cause lag similarly when in-thread message loop delay (currently in shell input handler) is removed:
		1. About 55~80 kHz(faked as kFPS) can be achieved after removal the loop delay (but ususlly lower than 70 kHz), and about 480~560 kHz after removal of locking for both cases. Only 170~240 kHz can be achieved after removal of input locking.
		2. In July, 2012 it could be at a peak of greater than 730 kHz. It is believed that the improvement of functionality has effect on this, though still not clear which part cause the overhead.
		3. Intel VTune Amplifier XE 2013 detects seconds of spin time before the removal of locking (for an about 10 second run) and almost none (0.010s) after the removal. The use of hardware concurrency is "idle" before and "poor" after.
	No simple way to improve:
		1. No lock-free swap primative supported by std::atomic directly because almost no hardware support: http://stackoverflow.com/questions/15460829/lock-free-swap-of-two-unique-ptrt.
		2. Not only pointers themselves, content pointed should be thread-safe.
		3. Fine-grained thread-safe access should be remained anyway.
		4. If code in contexts like 'InputManager' uses coarse-grained concurrency, user should be cautious for synchronization. It is error-prone (even if easy).

todo.deferred:
Handling FreeType error 0x26: "no charmap" and 0x40: "out of memory"(descriptions from "fterrdef.h").
Ability for selecting specific typefaces with such glyphs.
Native exceptions should be caught at proper boundary.

note.merge:
(FTGL, GLFW, FMOD) @ !DS: considerable, shelved.
Cairo: rejected.
	Reason from http://people.mozilla.com/~roc/Samsung/Mozilla2DGraphics.pdf.

$2013-08:

report.impl:
The YSLib project now prefers using alias-declarations over typedef declarations. Here's the rationale:
	1. The YSLib is try to use more ISO C++11 features aggresively when proper. Using aliases relax the complexity of many declarations, and reflects a kind of commonly accepted more natural syntax style, since the type name and identifier declared are separated clearly.
	2. A typedef declaration can introduce more than one identifier but an alias-declaration cannot. However, this can easily misleads the reader so really rarely being used, and never appears in the YSLib project.
	3. Typedef declaration of an anonymous class has no equivalent alias-declaration form, but it is also less commonly used in modern C++ (but not in C), and the YSLib project now deprecates this usage.
	4. There should be nothing different in general in other aspects. Though the current standard text is still using 'typedef', and for an implementation of both pre-C++11/C++11, keeping 'typedef' would save some '#ifdef' text, the YSLib project has no similar requirements.
	5. See https://groups.google.com/a/isocpp.org/forum/#!searchin/std-discussion/typedef/std-discussion/cwZ8HYQxxlM/Zzj4CTxSaskJ for the discussion of flavor in the ISO C++ standard text. No problems found for others even for using in standard proposals.
There is nothing cannot be implemented by ISO C++1y lambda-expressions which is able via std::bind, see http://stackoverflow.com/questions/17363003/why-use-stdbind-over-lambdas-in-c14.
For std::bind, pointers and reference wrappers arguments are almost always significant except for member function of a class type lvalue, 'std::ref(*this)' and 'this' is the same, while the YSLib code always preferred the latter(simpler). Note the difference is always significant for 'ystdex::any_iterator'.
For 32bpp '::HBITMAP', it seems that no pitch should be considered, i.e. the storage of pixels is contiguous.
Note that '::HBITMAP' data is raw bitmap compatible but not strict '::RGBQUAD', so the reserved 'rgbReserved' member can be used as alpha value.
It is believed that the data structure of input handling can hardly be modified by user code to adapt extended devices some platforms:
	For example, DS has no extended virtual key bit to differentiate more than one touch key. It is difficult for user to simulate this feature like high-level cursor event by design.
	So there is no need to always check the input is being with single key touched. This can be used at optimization of common GUI input state handling, etc.

dep.merge:
df.operators(https://github.com/d-frey/operators): considerable, shelved.

$2013-09:

report.impl:
The member function like 'std::string::c_str' cannot be wrapped in a function/function template because it returns temporary value.
Algorithm of circle rasterization in "http://cg.sjtu.edu.cn/lecture_site/chap2/mainframe224.htm" is wrong unless the circle is very small.
The type 'platform::Color' in module YCLib::Video of platform DS and MinGW32 is now comparable since it is implemented as an alias of class type which has an conversion function to integer type.
MSVC provides '__declspec(novtable)' for classes to ignore vfptr initialization in constructor and destructor as optimization. There are several conclusions:
	1. This is an optimization primarily for size, firstly appeared at Microsoft VC++ 5.0, see http://msdn.microsoft.com/en-us/magazine/cc301398.aspx.
	2. Some major implementations like G++ seem to have no equivalence currently.
	3. This should be only used with most derived class object, otherwise the behavior is undefined. See http://msdn.microsoft.com/en-us/library/k13k85ky.aspx. It is fit for interface types.
	4. This would made behavior of code in constructor of derived classes non-confoming to ISO C++ if any 'novtable' base class virtural function is called or RTTI is used. See http://stackoverflow.com/questions/1801258/does-using-declspecnovtable-on-abstract-base-classes-affect-rtti-in-any-way.
	5. '__declspec(novtable)' should be wrapped by YBase.
	6. It is not fit for every interface type in YFramework as default option. It is reasonable for some specific interface types which have furthur constraints.

$2013-10:

report.impl:
Host renderer on adjusting boundary of host windows:
	Since b448, the full validation is forced to keep the boundary of host window steady.
	The content would still be trembling on resizing by dragging the boundary.
	This effect is of about the same quality of resizing on a normal application window (e.g. Windows Explorer window).
	Note that several windows of application (e.g. the image and chat windows of Tencent QQ 2013, main window of Xunlei 7.9) seem to be using other way which can still cause the boundary itself be trembling on resizing. This is similar (or even worse) to previous revisions of YFamework.
The std::basic_string of current libstdc++ is still non-conforming to ISO C++11 which disallows use of reference counting/copy-on-write implementation due to ABI compatibility.
	See $ref b449 "libstdc++ std::basic_string conformance" for references.
	Using of libstdc++ vstring is proper if strict conformance is really needed.
		See $ref b449 "libstdc++ vstring" for references.
For type parameter of function template as generic algorithms or initialization of specific types like instances of std::function, there are several considerable factors to determine what form of parameter type should be used:
	1. For general cases, rvalue reference of type parameter should be used to enable move semantics/perfect forwarding as possible, except below.
	2. For algorithms accepting iterators, functor or smart pointer types, non-reference type parameters are preferred to explicitly make the interface has call-by-value(copy) semantics for parameters. If needed call-by-reference semantics, std::ref can be used. This is also consistent with interface of corresponding parts of the standard library(i.e. iterator libraries/algorithms libraries/callable wrappers).
	3. For some other function templates which has no obvious call-by-value semantics, do not use type parameter directly. Then think twice of lvalue-reference or rvalue-reference type parameters.
	4. It is OK for rvalue-reference type parameters used for general templates with large categroies(like "all input iterator types" or "all callable types"), because there are no obvious requirements of call-by-value semantics.
	5. It is also OK for some callable proxies like asynchronous handlers to have non-call-by-value semantics of the callable parameters types, like some other parts of interface of the standard library(e.g. constructor of std::thread) .
Use member initializers properly to eliminite need of initialization in constructor as possible unless the initializer is intended to be the implementation details or some internal interface which should not be depend on by users.
There is a bug about template parameter declaration of Clang++ 3.4, up to 2013-10-21:
	The template parameter declaration 'bool = {}' should be accecpted, because it can be reduced as: template-parameter → parameter-declaration → decl-specifier-seq declarator = initializer-clause, with initializer-clause is '{}'.
	However, Clang++ rejects this code wrongly, though 'bool = false' can be accepted.
	Actually this code is in the parameter-declaration-list of declaration of class template ystdex::bitseg_iterator in YStandard::Iterator.
	Because currently Clang++ is not formally supported as the available compiler to build YSLib, the workaround above is not adopted.

todo.deferred:
Wrapping '__declspec(novtable)' when '_MSC_VER >= 1100'.

dep.merge:
libmagic(https://github.com/glensc/file): rejected.
	This library implements a DSL(with BNF provided among the source files) for querying magic number database. It is heavyweight and too complex for freestanding implementations.
	Stripping the code of extended functionality(other than MIME detection needed by YFramework) out is difficult, because functions for printing and parameters for state passing are spread in the call graph deeply.
	For hosted implementations, operation system or desktop environment based implementations may provide alternative more benifical interfaces for integrating custom/user-specified information of content types.
	Also the depolying overhead of the magic databace files is significant.
	For these reasons, this library is not suitable for YFramework, though may be fit for the low level indirect implentation esp. on POSIX systems.

$2013-11:

report.impl:
Marco '_GLIBCXX_DEBUG' should be removed as default, even in debug configuration.
	The standard libray debugging interface introduced by macro '_GLIBCXX_DEBUG' of libstdc++ may be incompatible with libraries not built with this macro.
	Though YSLib libraries are built with debug-aware configuration, currently the dependent libraries are not.
	This particularly has effect on libFreeImage.a, which uses containers of C++ standard library internally. The instantialized template class across libraries are not the same, and not guaranteed to be binary compatible.
		This would cause some functions of YSLib::Adaptor::Image go wrong.
	Alternatively, if the debug interface of libstdc++ is needed, namespace 'std::__debug' can be explicitly used.
	Removed such debug interface can also lead to smaller binaries and a little more runtime performance for debug configurations.
The bug of 'bool = {}' is same to Microsoft VC++ 2013 as Clang++ 3.4(see $2013-10 report.impl).
ISO required 'std::FILE*' as an object type. Different to C++, (possible cv-qualified) void is object type.
	There exists actual C implementation with cv-void as 'std::FILE*'. For example, in the standard header from the CeGCC project it is 'void'.
Notes for disabling some Microsoft VC++ warning:
	Used project configuration (for YFramework) but not '#pragma' for clean code and making users have choice to decide further.
	C4520 warns about multiple constructors found for the same class.
		It would wrongly detect the situation of exactly one non-template default constructor and one default constructor template, which should be well-formed and safe.
	C4800 warns about coercion to 'bool' type.
		It is marked as a "performance warning" by MSDN, though the performance decrease almost never happened for modern C++ code with reasonable C++ implementation in reality. It might be useful for finding the (bad-style) mix use of built-in 'bool' and 'BOOL' or other integral types.
		MSDN also says it is by design to treat cast as same as coercion here. Keeping the solution recommended by adding '!= 0' effectively make code lengthy with actually no benifit, thus it simply not fit for modern C++ in most cases.
		In C++ (but not in C), coercion or cast to 'bool' is quite safe. Comparaing to null pointer value explicitly is OK, but not required. On the contrast, it might be standard way to test null pointer (but not compare to zero), particular in the ISO C++11 wording "contextually convertible to bool" as some requirements for types including pointers.
		Too bad copying '!= 0' or similar mouthy stuff ('!= nullptr') everywhere in C++ code.
The workaround of move constructor and %operator= for Microsoft VC++ 2013 is currently some slower than it should be with fully supported ISO C++11 implementation, because the 'noexcept' operator is missing, and non-throwing exception specification is not guaranteed to work everywhere.

$2013-12:

report.impl:
The reference-counted 'std::basic_string' implementation in libstdc++ is still not conforming to ISO C++11.
	See $2013-10 report.impl.
	See $ref b449 "libstdc++ std::basic_string conformance" for references.
	Though ABI has changed before, the string implementation is not included, and even other breaking changes like 'std::list::size' implementation are reverted: http://gcc.gnu.org/wiki/Cxx11AbiCompatibility.
	It seems that the ABI would not switched in near future, or at early as of GCC 4.9: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56166.
	Use libstdc++ '__gnu_cxx::__versa_string' from <ext/vstring.h> instead, if necessary.
		See $2013-10 report.impl.
		See $ref b449 "libstdc++ vstring" for references.
		Note no 'std::stringstream' counterpart, see: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56166#c4.
		Be cautious to performace decrese: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=54393.

$2014-01:

report.impl:
The MinGW.org and MinGW-W64 runtime can be distinguished by predefined macros, though version macros are not predefined:
	See http://sourceforge.net/mailarchive/forum.php?thread_name=CAEwic4b-B8%3DQ%3DSV2ptwO36SsCQW%2B6b0N%3DX41t3NHPoDQV%2BKeTw%40mail.gmail.com&forum_name=mingw-w64-public.
	See also http://sourceforge.net/p/predef/wiki/Compilers/.
There may be some wrong impression of border thickness due to the colors.
	It is easy to see the left vertical line of boundary of the checkbox is thicker in setting panel with violet background.
	When the panel background color is some lighter, here is no such illusion.
	Indeed they have the same thickness. It would be obvious after zoomed (esp. > 2x).
	Actually, no rendering code of checkbox has been changed.
Both the runtime from MinGW.org and MinGW-W64 support multiple versions of Microsoft VC++ library(MSVCRT). There are some issues:
	Different verstions of MSVCRT define different symbols with some subtle problems. So they should be same in different toolchain configurations for best compatibility.
		Both of them support at least version 6.0, which is probably the most wide-adopted by Microsoft Windows(they came by default install). The library filename is "msvcrt.lib" for Microsoft VC++, accordingly "msvcrt.dll" of the dynamic library and "libmsvcrt.a" as static library for both runtime.
			Though acceptable, but deployment depend on it is not good. The are not publicly guaranteed to be compatible within different versions of Windows.
		For newer versions, the dyanmic libraries name schema is "msvcrXX.dll", in which "XX" is the corresponding concatenated Microsoft VC++ main and minor version numbers. For example "msvcrt90.dll" is of VS2008.
			The architecture names (such as "x86" or "amd64") are not related of the filenames.
			They are required to be deployed along with the applications, or the end users might able to install corresponding version of Microsoft VC++ Redistributable Package.
		MinGW.org uses 6.0 as default. Things about MinGW-W64 are some complicated, see below.
		Currently MinGW.org's distribution has "libmsvcrt.a", "libmsvcp60.a"(the C++ runtime of Microsoft VC++ 6.0), and "libmsvcr70.a" to "libmsvcr100.a"(the whole "XX" are 70, 71, 80, 90, 100). It also has corresponding debug versions for latter, i.e. "libmsvcr70d.a" to "libmsvcr100d.a". No newer MSVCRT are supported.
		On the other hand, MinGW.org's distribution also has "libmsvcrt.a", "libmsvcp60.a", and "libmsvcr80.a" to "libmsvcr100.a", but neither other versions("libmsvcr70.a", "libmsvcr71.a") nor debug libraries. However, it has "libmsvcr110.a", which MinGW.org's does not supported.
	There is one extra library, "oldname.lib", to contains the original version of symbol names deprecated by Microsoft (such as POSIX-specific functions, because they are not strictly comforming to ISO C), to map to new names(usually added prefix underscore).
		They are also different in MinGW.org's and MinGW-W64's runtime. There are "libmoldname.a" and "libmoldnameXX.a"("XX" here is also the version numbers, see above) for the former, and only one "libmoldname.a" for the latter.
		See http://sourceforge.net/mailarchive/message.php?msg_id=30556805.
	Most notable problem is backward compatibility. For example if new "secure" functions(ISO TR 24731-1) like "scanf_s" are used, MSVCRT older than version 8.0 can not be used.
		Actually it is not version 6.0 of MinGW-W64's "libmsvcrt.a". It even exports "__gmtime32" comes from version 8.0.
	Both toolchains use the same built-in specs in compiler driver for use of these libraries, i.e. "-lmsvcrt".
		For better compatiblity, lirary not older than "libsvcrt80.a" should be put explicitly in the linker options to override the default linked "libmsvcrt.a".
		Allocation and deallocation should always be carefully matched within the boundary, i.e. make sure the allocation function and deallocation function for same storage are from the same library.
		Using 2 C runtime library and directly overriding symbols are dangerous.
			Note that libgcc, startfiles or some other library with "atexit" or thread-local storage can be involved with C runtime library's free storage allocation.
		Specs file can be used to specifying completely substition of the C runtime library. It is safer but less convenient.
	Both define the macro "__MSVCRT_VERSION__" in <_mingw.h> to control what version of MSVCRT used.
		If not explicitly specified (i.e. not defined "__MSVCRT_VERSION__" before inclusion of <_mingw.h> or through command line option), both would defined a hard-coded integer value.
		The default values in the libraries are different. It is "0x0600" in MinGW's but "0x0700" in MinGW-W64's.
		A subtle problem is, which not only effected by the version macro. One notable extra macro is "__STRICT_ANSI__", which introduced by several GCC compiler options like "-ansi" or "-pedantic".
		There is a horrible bug in the MinGW.org's <time.h>: if "__MSVCRT_VERSION__ >= 0x800" and "__STRICT_ANSI__" is also defined, then some ISO C functions like "time" are not declared.
			This directly caused <ctime> of libstdc++ (which has 'using ::time;', etc) unusable.
			Maybe more similar bugs, also in different headers.
	The "YFramework.dll" can compiled from b464 after some changes in "YCLib/FileSystem.cpp" but cannot be linked as DLL without changes of some project options.
		The error is of the unresolved symbol "_gmtime32", comes from "pngwrite.o" in "libFreeImage.a".
			It is introduced directly by a call of "gmtime" in function "png_convert_from_time_t" when the configure macro "PNG_CONVERT_tIME_SUPPORTED" is defined.
				The "PNG_CONVERT_tIME_SUPPORTED" configuration is not supported by every platforms, for example Windows CE.
				It is considerable to remove "PNG_CONVERT_tIME_SUPPORTED" in "pnglibconf.h". But it is not a fix for the problems here.
			Currently FreeImage is built with MinGW-W64 toolchain.
			Actually both toolchains can map "gmtime" to "_gmtime32".
			The reason of failure for MinGW.org is that "_gmtime32" is not contained by "libmsvcrt.a" of MinGW.org's, but do contained by MinGW-W64's.
	There are several optional version of MSVCRT containing "_gmtime32", but no one are proper for this scene.
		No MSVCRT 7.0 and 7.1 available for MinGW-W64 toolchain.
		The deployment of MSVCRT 8.0 and 9.0 makes a lot of trouble, if there is no manifest provided.
			For side-by-side assemblies, see http://msdn.microsoft.com/en-us/library/ms235624%28v=vs.80%29.aspx.
			For newer Microsoft VC++ deployment, see http://stackoverflow.com/questions/6623780/visual-c-2010-changes-to-msvc-runtime-deployment-no-more-sxs-with-manifest.
		For MSVCRT 10.0, symbols "_wstat", "_imp__findfirst" and "_imp__findnext" are not defined.
		No MSVCRT 11.0 or newer available for MinGW.org toolchain.
	Though rebuilt libraries are needed sooner or later, now it is better to have a fix in the project configurations.
		For maintaince reason, the configuration should be the same, without need for users to select one out of two set of configurations.
		Note that a value of "__MSVCRT_VERSION__" not less than 0x0800 causes bugs in MinGW.org's headers when "__STRICT_ANSI__" is defined.
			If this macro is set, only 0x0600 to 0x0700 can be used.
			This macro can be set explicitly to 0x0600 for compatibilities (also for library rebuild).
		For convenience and sanity, no manifest should be introduced.
			There is even no dependency on MSVCRT other than "libmsvcrt.a" in MinGW-W64. It is only to be compatible with the buggy MinGW.org runtime.
			Though introduced a newer dependency, it is somewhat acceptable. YFramework might use some features in that newer version of MSVCRT.
			To introduce manifest only for MinGW.org's compatibility is too expensive.
		Note that mix use of different versions of MSVCRT is dangerous.
		It is relatively safe to use a newer library together with older headers.
		So the final resolution is to implement a custom "_gmtime32" function for MinGW.org toolchain.
Currently object files compiled with '-ffunction-sections -fdata-sections' for GNU ld with '--gc-sections' doesn't work for MinGW PE-COFF targets. It might be fixed in future.
	See https://sourceware.org/bugzilla/show_bug.cgi?id=11539.
	See http://cygwin.com/ml/binutils/2012-08/msg00216.html.
	See http://sourceforge.net/mailarchive/forum.php?thread_name=CALc40c_v46OnoopJXWbPpQk651JAxWU3UYFmDJy998mPKzD9DA%40mail.gmail.com&forum_name=mingw-w64-public.
Skin is the top level of GUI an application's shell to reflect look and feel. For a reusable GUI toolkit, a visual style is a set of visualized features for UI elements, being a major part of the skin.
YFramework should implement the visual style support. It has been planned from very early reversions.
	Basically, the styles are not for each widgets. They are only effective to style-related widgets.
	The major interface is of namespace "YSLib::UI::Styles", providing abstraction to be stored within the GUI state.
	The previously implemented interface is the palette, which contains a vector of colors to be used in style-related widgets rendering.
	Now the visual style states should be implemented as sets of runtime swichable states.
		The style should be swichable by user code via the GUI state interface. It is the wrapper of the major interface.
		For convenience, the type "string" is used as the key to identify a style.
		It is intended that switching of styles should take effect on classes of widgets. For each paticular instance of widgets, it should be possibly doable to switch in future.
		Switching to a different style should be efficient. That means iteration of each widgets to modify the state is generally inacceptable.
		The basic idea is to bind each styled rendering process as an event handler with parameter type 'PaintEventArgs&&' and to be added to event 'Paint' of the target widget instance.
		The binding of event handler needs a type containing the common implmentation against to code bloat. If per widget style state can also supported here if necessary.
		There should be a way to identify the widget class types. Indexable RTTI type ('std::type_index') is preferred for convenience.
		Choice has been made for the lower layer of the implemention details:
			Static polymorphism is not feasible for some runtime-determinated properties.
			Both interface types(i.e. polymorphic classes having only pure virtual member functions) and manually indexing of handlers are feasible.
			Pros of interface types:
				It is flexible to describe complex details.
				Different sets of explicitly-typed shared state can be stored in the implementation directly.
				Type safety is easily gained through function signatures.
				Inheritance can reduce some common code.
			Cons of interface types:
				Probably more code to write. In the worst case, each interface type should provided to corresponding style-related widget class manually, being hard to reuse.
				Some extraordinary code bloats, linear complexity of total number of style-related widgets.
				Performance decreased for unnecessary virtual calls, though can be optimized away, but not guaranteed and likely not. Note that dispatch of event handler calls are already polymorphic in runtime through 'std::function'.
				It is difficult to use because the concrete interface type should be get statically. This causes it impossible to store all interface types for different widget classes together within the same GUI state without some tricks.
					Type erause or base interface type can be used. Both are expensive in performance and inconvenient to implement.
					Explicitly casts should be used for each binding, obviously inconvenient.
				The ABI is likely complex and not steady. Modifying interface of per class interface is very likely to leads to the user code to be built again.
			Pros of manually indexing of handlers:
				It is simple and direct for event handler binding.
				Code generation and performance is easier to control by the user.
				It is flexible and convenient to use.
				The ABI is likely simpler, and steady when no modification to the indices.
				Indices can have aliases through enumerator or 'const' object declarations.
			Cons of manually indexing of handlers:
				Some lower level details can not be exposed through the interface, which can be inconvenient to use.
				The handler type is limited to event 'Paint'. If needed, the major style interface should be modified.
				Shared states can be supported through the interface should be unique.
					If needed, some additional interface should be added to the GUI state.
					Type erasure or similar techniques can be used to get some intended effects.
				Almost no higher level of optimization at all. The implementation of the language is not aware to the indexing.
			For current requirements, the latter is better.
				It is easy to implement and use.
				It is not very hard to add functionality. Although if needed, the major interface might be modified, but not very probable.
				Indices are not needed to be assigned manually if using enumeration type.
ISO C++11 still uses copy elision for some cases as C++03. There are some special rules.
	See ISO C++11 12.8/31 for conditions.
	If these requirements are met, move constructor of a class can be selected by the overloading resolution without explicitly using 'std::move' or rvalue reference cast. See ISO C++ 12.8/32 for details.
	See also http://isocpp.org/blog/2012/12/quick-q-a-unique-ptr-is-not-copyable-so-why-can-i-return-one-by-value-stack.
Since now ISO C++11 is mandated '<::' to be distinguished as '<' and '::' but not '<:' and ':' if the consequence character is not '>' or ':' , no need to always add space to between '<' and '::'.
	G++ 4.7.1 has not supported.
	G++ 4.8.2 is conforming.

$2014-02:

report.impl:
Trailing path delimiters are allowed in YCLib::FileSystem.
	IEEE POSIX-1003.2 allowed trailing slashes.
		See http://mail-index.netbsd.org/tech-kern/2002/04/28/0016.html.
	Windows API 'FindFirstFile' does not expect trailing delimiters in pattern, so preprocessing of the path string is needed.
		Some implementations may only consider one delimiter. See 'diropen' implemented by MinGW.org.
Both slashes and backslashes can be supported as file system delimiter by Windows API.
	Adding prefix '\\?\' can ignore 'MAX_PATH' limitation and enable large path support.
		Not all API support it.
		Currently, YCLib do not explicitly use it.
	See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247%28v=vs.85%29.aspx.
There are some issues against aggresive optimization of moving an object in several contexts.
	For initialization of exception objects, the copy elision would not be performed.
		See WG21 N3690 comment CA 23 and CWG 1493.
		See also http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3771.pdf.
	Currently moving from returned object is tied closely to the criteria for copy elision.
		See WG21 N3690 comment US 13 and CWG 1579.
		Explicit use of 'std::move' can be a workaround.
		This issue was accepted.
	See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3852.html for WG21 N3690 comments list.
	There was no consensus for the suggested change for other contexts. See WG21 N3690 comment US 12.
	Therefore, explicitly use of 'std::move' and 'std::move_if_noexcept' only should occured when necessary.
	See also $2014-01 in this document.
'YSTest402r16.nds' cases DeSmuME 0.9.9 x64 crash for unknown reasons.

$2014-03:

report.impl:
Now for YSLib::UI, the default UI event handlers treat the senders to be processed instead of destination widgets where the identity of the sender and the destination widget is true.
	The old rules mean 'this == e.GetSender()' is always true for calling of some events in implementation of YSLib::UI.
		There is no guarantee or guidelines to specify either sender or destination widgets to be used actually in the handlers in or not in implementation of YSLib::UI.
	The new rules mean senders should always to be considered to be processed at first.
		Actually, the senders are the widgets to be process as possible as it can, i.e. if no dynamic cast needed, 'e.GetSender()' is used instead of '*this' in implementation of YSLib::UI.
	User-provided handlers now can use this assumption to transfer different senders.
	Note that for user-called event, 'this == e.GetSender()' might be false.
	For source different than destination like close button in 'DialogPanel' or widget in 'HoverUpdater', this transformation is obviously not correct for logical reason.
Note that default constructor of instances of 'std::chrono::duration' and similar types are defaulted.
	The underlying values might not always be initialized if there default-initialization is no initialization(see ISO C++ 8.5.3 for details).
	Use interface like 'std::chrono::duration_value::zero()' to get specific zero values.
	Currently there are several use of these types with explicitly default-initialization, which is indeterminated, but not direct used before assignment.
	Consider to use explicit initialization in class definitions to emphasize they are already initialized, if necessary.
Some event-based invalidation of "YSLib::UI::Control" class is removed.
	This is because these invaliadation operations are not always necessary. They are also harmful to performance when not needed.
	Even if the operation is handled, other handlers for painting with same or lower priority might need a more invalidation when more area should be invalidated.
	Invalidation should be performed for controls that painted with different look between focused and non-focused states.
		These controls are all style-related.
		They are "Thumb", "TextList", "ProgressBar", "DialogBox", "DialogPanel", and their derived classes.
			For derived classes, no explicit handlers need to be added. These base classes are directly derived from "Control".
	For "LostFocus" event, following cases are considered:
		For "DropDownList", no further invalidation is needed. The detacher has nothing to do with dropped down list itself.
		For "Menu", no further invalidation is needed. Only the hiding operations perform the invalidation, which is done in "MenuHost::HideRaw".
			But it should be used for focus border painting.
		For "TextBox", a further invalidation is needed and added in the handler for focus border painting.
			Note that the invalidation for caret is not enough.
	For "GotFocus" event, only one case is considered:
		For "Menu", further invalidation for showing is needed. It should be used also for focus border painting.
		For "TextBox", a further invalidation is needed and added as a new handler for focus border painting.

$2014-04:

report.impl:
Call by value or by rvalue refernce for a callable object, a call wrapper or an iterator might be significant different.
	For the notion of call wrappers, see ISO C++11 20.8.1, which was intially introduced in http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1673.html.
		A call wrapper "holds" a callable object, not necessarily "owns" a callable object. Be cautious for the lifetime of the underlying callable object.
	Note a call wrapper is MoveConstructible; a call wrapper can be not CopyConstructible; A simple call wrapper is CopyConstructible. See ISO C++11 20.8.2/4.
		Exceptions are strictly restricted to be thrown. No exception are allowed to be thrown in copying a simple call wrapper.
		For moved-only types (which is not CopyConstructible), it should be treated as forwarding call wrapper, i.e. passed as '_fCallable&&'.
		Otherwise, for simplicity, a callable object should be passed by '_fCallable', except when necessarily treated as forwarding call wrapper by design.
			Most uses of callable objects or call wrappers are plainly passed by value.
				Such as the function parameter of the constructor of 'std::function' with exact 1 parameter.
				The function templates in algorithm library accept callable objects or simple call wrappers passed by value.
			The are two important exceptions:
				The 1st parameter for 'std::bind'.
					The forwarding call wrapper should have been accepted by design.
					See LWG 817 for details.
				The 1st parameter for the constructor of 'std::thread'.
					The use cases and reasons are similar.
					See LWG 929 for details.
	As of ISO C++ 12.8/32, if the object designated as lvalue is a parameter, it would be firstly moved even if the copy elision criteria in ISO C++ 12.8/31 are not met.
		If used as forwarding of a passed by value callable object, no redundant 'std::move' should be used.
		See also $2014-01 and $2014-02 in this document.
	Similarly, in the standard library, the iteraors in the algorithms are passed by reference primarily.
	For simplicity in YSLib, if and only if noncopyable callable object is intendedly acceptable by design, pass-by-value '_fCallable' should always be used instead of '_fCallable&&'.
		This also means most callable objects should be CopyConstrictible.
		The major general exception is for forwarding function templates, which have templated function parameters like '_tParams&&...'. Some examples:
			General forwarding function templates like 'ystdex::seq_apply', 'ystdex::unseq_apply' and 'ystdex::call_projection::call' in YBase::StandardEx::Functional. They are used for reordering the evaluation as well as forwarding the parameters, so just behave as 'std::bind'.
			General forwarding call wrappers as 'ystdex::expanded_caller', also the helper 'ystdex::make_expanded', in YBase::StandardEx::Functional.
			Forwarding functions templates in YTest::Timing.
			Callers which use 'ystdex::expanded_caller' as underlying implementation in YSLib::Core::YEvent.
	For simplicity in YSLib, an iterator should be passed by value, unless it is an iterator adaptor to generally provide adaption for any other iterator types.
		The general iterator adaptors include, for example, 'ystdex::any_iterator' or 'ystdex::transformed_iterator'.
		All current declarations are conforming. No modification need to be performed.
Unless otherwise specified, the assumption of a resonably reliable C++ implementation should be used for YSLib.
	Differently to Boost, no defensive programing techniques are encouraged to be used to make a poor implementation work.
		Such as double-destruction protection on exception classes.
Rules for exception handling should be uniformed.
	Exceptions handling should generally make use of custom exception classes.
		Pay attention to implicitly declared special member funtions.
		The following rules are forced:
			Make sure no resource could leak.
			Make sure the destructor is virtual.
			Make sure the move constructor, if any, have no-throw guarantee.
		For YSLib, the exception objects should be MoveConstructible or at least CopyConstructible with trivially copy can be performed. See below for reasons.
	Boost exception handling guidelines are reviewed. See http://www.boost.org/community/error_handling.html.
		Note it is pre-ISO C++11.
		However, currently most of these rules are not used in YSLib.
			YSLib follows closely to ISO C++ standard library.
	It's good to make exception classes derived from 'std::exception'.
		YSLib follows this guideline.
		But no assumption should be make generally in user code.
	Virtual inheritance with tagging is not used as Boost library. Because:
		It is somewhat less efficient both in time and space.
			This is a minor reason, but it nodoubtly exists.
		It might be complex and error-prone.
		The tag dispatching is not always useful.
		States of context might be significant, data members in different subobjects stored in the same exception object may be used.
	There should be no exception thrown during copy-initialization of an exception object.
		Otherwise, 'std::terminate' would be called on copy-initialization failure in throw-expression.
		The stricter "not embedding" rule (Boost exception handling guideline 3) is only necessary when the move constructor is not usable.
			It is reasonable to avoid embedding a subobject without no-throw guarantee on copying into an exception object for pre-C++11 code.
		Make the exception object movable, ideally only the initially creation of the excetpion object is concerned with the copy failure.
		Note the replacing of copy by move operation based on copy elision criteria is not applicable for caught-by-value exception objects.
			See $2014-02 report.impl about non-mandantory of move exception objects.
		But anyway, for 'std::bad_alloc', even calling of 'std::terminate' is still probably acceptable. Note this handler can be set by 'std::set_terminate'.
		Some standard library classes, notably 'std::exception', are following this guideline. Some others are not guaranteed, like 'std::runtime_error', which uses object of 'std::string' as a constructor parameter.
		See also http://stackoverflow.com/questions/15831029/not-using-stdstring-in-exceptions.
		Because the YSLib exception objects are MoveConstructible or can be copied trivially, "not embedding" rule is not forced.
	Ideally the constructor used other than copy-initialization should throw no exceptions. But this is also not always true.
		Some standard library classes, notably 'std::exception', are following this guideline. Some others are not guaranteed, like 'std::runtime_error', whose constructors are without 'noexcept'.
		This guideline is also not forced on YSLib exception objects.
	The 'what' member function should be overriden only necessary.
		It is usually memroy-sensitive to format the message string.
		YSLib rarely override the 'what' member function.
	For both implemention and semantics reasons, do not use 'catch(...)' without rethrowing unless really necessary. See also Documentation::CommonRules @5.14.2.

$2014-05:

report.impl:
	Select carefully between 'const_iterator' and 'iterator' for ODR issue. See LWG 1214.
There are some similar measurement values for a given image with proper underlying image buffer, both are rectangular in sense of rasterization as pixels.
	Width is the magnitude of the logical image or buffer area in horizontal, or X-axis for 2D coordinates.
	Height is the magnitude of the logical image or buffer area in vertical, or Y-axis for 2D coordinates.
	Stride is generally the distance of two entities measured in a single unit.
		It can be the distance between two pixels in either horizontal or vertical of an image.
		For a buffer, the stride is the width of the buffer area.
			Usually it is in pixels.
			It could be sometimes in memory units(esp. bytes) , so being a synonym of the pitch of the buffer, see below.
	Pitch is a particular kind of measurement for a buffer in several different units.
		It is often the synonym of the stride, which is in pixels.
		It is more often measured in bytes for the underlying scanline of the contiguous memory area.
	E.g for stride vs. pitch: http://msdn.microsoft.com/en-us/library/windows/desktop/aa473780%28v=vs.85%29.aspx.
	See also: http://www.gamedev.net/topic/496278-pitch--stride-/.
	For images, it is clear the width is the same as the stride between horizontal edge of the pixels.
		In this sense the width is equal to the stride.
		However, usually only width is used to be clear.
	For image buffers, YSLib uses stride to refer the width in pixels, and pitch to refer the width in bytes, or bits if explicitly specified.
		The meaning of stride is harmonized with Android NDK API.
		The meaning of pitch is harmonized with FreeType.
It seems that ::eglSwapBuffers hangs in SharedBufferStack waitForCondition is a bug of Android platform or underlying Linux kernel.
	See: https://code.google.com/p/android/issues/detail?id=20833.

$2014-06:

report.impl:
There is nothing can be done with "channel '*' ~ Failed to receive dispatch signal.  status=-11" error log message from "NativeActivity" on Android.
	See https://code.google.com/p/android/issues/detail?id=41755.
		From http://ps3computing.blogspot.ca/2012/12/anr-application-not-responding.html.
			From http://stackoverflow.com/questions/18316046/when-build-with-latest-android-ndk-nativeactivity-spams-to-log-on-touch-events.
Behavior changed in ::ANativeWindow after Android 4.0 (API level >= 14), and different way to get native window size should be used.
	See http://www.klayge.org/2013/01/23/%E5%9C%A8android%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%99%B7%E9%98%B1/.
Call-by-value for parameter with object type for classes types should be refined when the overhead is significant.
	Not all class type object can be passed by value.
	Note that copy elision is not available. See $2014-04 report.impl for references.
	A notable exception is unifying assignment, when copy-and-swap idiom is needed and the move constructor is implemented with little overhead.
		See http://stackoverflow.com/questions/8968452/who-coined-the-term-unified-or-unifying-assignment-operator.
		Because at least one copy operation is performed, the parameter is needed.
		Since the swapping operation is inteneded to provide no-throw guarantee, there should be a non-throwing exception specification.
			Note that even if exception is thrown by initialization of the parameter, the exception-specification is not affected.
		The standard library is not using this style.
			See https://github.com/cplusplus/draft/wiki/Specification-Style-Guidelines#specifying-implicitly-generated-special-member-functions.
		For simplicity in YSLib (including YBase), using this style is preferred.
There are multiple issues for IME(Input Method Editor) support in Windows.
	Input methods are supported through IMM32, TSF(Text Service Framework) and CUAS(Cicero Unaware Application Support) APIs.
		IMM32 should be used for most compatibility for desktop enviornments.
			Though it is not supported in Windows Store apps, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh967425.aspx.
		TSF is a new set of API to substitute IMM32.
			Though only supported from Windows NT 6 systems, it can be used and suggested to be used in Windows Store apps by Microsoft.
			It may be superior in features and extensibility.
			It is not only about text input through keyboard devices. Other input methods and natural language technologies are also provided.
				This might cause troubles if only keyboard input processing is intended.
			The API is COM-based.
				This brings some complexity on code usage and library dependencies.
		CUAS is not as common as above other APIs.
			Since the XP tablet is not the target, it is mentioned only for minor subtle issues.
		YSLib now mainly uses IMM32. TSF is a candidate in future if the extra functionality is really needed.
	Asian IMEs of different languages behaves different.
		Now only Chinese IMEs are considered. General support should be added in future.
	Candidate and composite windows may be combined as a single window or not.
		For simplicity, now only the candidate window is directly touched in YSLib.
	Following to text input cursor/caret is a mess.
		All OS versions, IMEs and applications count.
		Different IMEs do not always obey the interface requirement.
			Chinese IMEs might ignore ::ImmSetCandidateWindow calls, so Win32 caret APIs have to be used.
		Behavior are not precisely equivalent. If the cursor switched by mouse when IME candidate window is shown, the IME candidate window can follow the cursor or not.
			For examples, tested with Baidu Pinyin IME 2.10.2.93:
				In contexts concerned with Win32 native edit controls, it follows. These at least include:
					Text fields in native common dialogs;
					Text fields (e.g. combo box to input path, text box to rename a file, etc.) in Windows Explorer except the search box (see below);
					Editor of Notepad;
					Editor of Visual Studio 2013.
					Text boxes of Code::Blocks svn9778 implemented by wxWidgets in Windows 2012 R2;
				In most other editors, it doesn't. These at least include:
					wxScintilla editor Code::Blocks 13.12 in Windows 7;
					wxWidgets text boxes of Code::Blocks 13.12 in Windows 7;
					Editor of EditPlus 3.60;
					Dialogs and text editor of Android Studio 0.6.1;
					Default editor control, address bar and search box of Firefox Nightly 33.0a in Windows 2012 R2;
				In some other contexts, it just disappears. These at least include:
					Search box in Windows Explorer;
					Search box in Windows Start Menu in Windows 7;
					Search box in Windows Start Screen in Windows 2012 R2;
					Default editor control, address bar and search box of Firefox Nightly 33.0a in Windows 7;
					Editor of MdCharm 1.0 in Windows 7.
				Note in some other contexts, the application is aware of IME with explicit visual effect(e.g. underlines), at least include:
					Dialogs and text editor of Android Studio 0.6.1.
				In Windows 2012 R2, wxScintilla editor of Code::Blocks svn9778 doesn't work at all, even before composing the input string). Seems a bug.
				In Windows 2012 R2, (Qt-based) editor of MdCharm 1.0 and text field in Konversation 1.5 make the candidate window following only when switch fast enough. Seems a bug.
			Currently YSLib chooses a simple implements that behaves like Scintilla of Code::Blocks as default, as well as disablility in Windows 2012 R2.
	See also comments in https://src.chromium.org/viewvc/chrome/trunk/src/ui/base/ime/win/imm32_manager.cc.

$2014-07:

report.impl:
The type of handles varied.
	For the prehistoric era lacking of Documentation::Workflow of YSLib, shell handles are of the opaque handle type 'HSHL'.
	From b175, 'GHHandle<YShell>' took place of 'HSHL'.
		The shell class 'YShell' is the interface, and should not be hidden.
	From b201, 'GHHandle' was renamed to 'GHandle'.
		Because the prefix 'H' was redundant with meaning of the 'Handle'.
	From b210, 'GHandle' was replaced by 'shared_ptr'.
		There was no need to reinvent the wheel of handle type.
		There was also no need to reinvent the wheel of things like 'shared_pointer_cast'.
			Though in Helper::ShellHelper, there are still some historical interfaces available. They are not deprecated, but also to be not encouraged to use.
		The sharing semantics should be explicit, as the interface.
			The 'shared_ptr' is currently an alias of 'std::shared_ptr' introduced by YSLib::Adaptor::YReference.
			Note that is not the reference counting. It is reserved to the implementation.
	Since b243, the base shell class 'YShell' was renamed to 'Shell'.
		Prefix of framework class prefix was restricted.
	As a handle type, directly use of methods of the pointee is not provided.
	However, since the 'shared_ptr<Shell>' is the public interface as well as the shell class itself, use of these method form shell is allowed.
		This rule also fit for types with similiarily explicit use of template-id and type-id, unless otherwise explicitly stated.
	In future, these types are going to be unchanged reasonably, unless some better interface is discussed and used.
Both libstdc++-4.8 and standard library of Microsoft VC++ 2013 have <memory> indirectly including <typeinfo> and <new>.
	This is the implementation details, which is not in the synopsis of the standard. Don't rely on it.
There are some implementation bugs related to std::enable_if.
	For example, in Microsoft VC++, there are several:
		http://connect.microsoft.com/VisualStudio/feedback/details/632440/bug-enable-if-got-c2893-error,
		http://connect.microsoft.com/VisualStudio/feedback/details/811603/weird-behavior-of-std-enable-if-t-produces-c2995-in-visual-c,
		http://connect.microsoft.com/VisualStudio/feedback/details/894682/c-std-enable-if-breaks-within-template-alias.
	In Microsoft VC++ 2013, 'ystdex::exclude_self_ctor_t' or its direct implementation (using std::enable_if_t) would be wrongly ignored.
		This would cause swapping a 'ystdex::pod_storage' leading to infinite recursive calls of constructor template, which makes ystdex::any unusable.
		Currently workaround is not researched, as of the buggy Microsoft VC++ 2013 is still temporaily supported only for successfully compiling YBase, but not for actually working.
	In Clang++, std::enable_if using with template parameter pack trapped into a bug http://llvm.org/bugs/show_bug.cgi?id=11723.
		Workaround: http://stackoverflow.com/questions/24454664/is-there-a-nicer-workaround-for-enable-if-bug-in-clang-bug-11723.
		YSLib didn't be involved in it yet.
For prefix comparison, implementation varies.
	The current implementation of 'ystdex::begins_with' has switched to using 'std::equal'. This gains the chance to be optimized such as using '__builtin_memcmp' in libstdc++.
		Note a length check is necessary.
			For most cases, even the lengths are checked it is even faster.
			The current implementation uses 'ystdex::string_length', which using 'size' member function for instances of 'std::basic_string'. It's generally fast.
	The old implementation implementation of 'boost::starts_with' uses naive comparing. It's stable but considered not as efficient as the method above.
	Comparing using 'std::mismatched' has also been considered. However, it has less chance to be optimized as 'std::equal'.
		For example, libstdc++-4.8 does not dispatching iterator tag to optimize 'std::mismatch' as it does with 'std::equal'.
		For boolean result checking whether the specified prefix exists or not, the position information returned by 'std::mismatch' is unnecessary.
	See http://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-string-starts-with-a-certain-string-and-convert-a-sub for a variety of implementations.
There are issues about LTO of gcc-4.9.
	See https://gcc.gnu.org/gcc-4.9/changes.html for details.
	Since gcc-ar from MSYS2 distribution has no plugin support, the default object generated by GCC 4.9 is not suited use.
	The flag '-ffat-lto-objects' is set for compatibility like previous version of GCC.
		If not set this option, undefined reference would be found and static linking would fail.
	As a result, the debug configurations have very significantly reduced of output size, i.e. about 1/5 for each binary file of YSLib.
		However, as been tested, GDB can't break in breakpoint any more. So it is still only fit for release configurations.
		See also http://sourceforge.net/p/mingw-w64/mailman/message/32551209/.
The SHBuild tool might encounter 0xC0000005 error.
	This issue probably occurs, may be very often.
	This is abnormal, but has the nothing to do with SHBuild itself. Currently SHBuild builds tasks with only a simple 'std::system' call.
	This issue can be seen if using ConEmu, but not cmd.exe.
		It should be a bug of Windows. See https://code.google.com/p/conemu-maximus5/wiki/MicrosoftBugs.
		Check "Inject ConEmuHk" as workaround, as suggested by the above page.
		Make sure ConEmu has been updated. As tested on Windows 2012 R2, ConEmu x64 140104 doesn't work even with this workaround, but ConEmu x64 140707 works well.
From the source of GCC LTO wrapper, the job server code is hard coded to call make.
	GNU make is actually expected since there seems rare similar support.
	It seems be OK to call with '-flto=jobserver' without GNU make.
On Windows, CPU usage is not the same in performance monitor(perfmon.exe) and task manager(taskmgr.exe). It's the normal case.
	In task manager the CPU usage is often higher than the CPU time in performance monitor.
		System idle process may take much.
	They use different ways. See http://social.technet.microsoft.com/Forums/en/perfmon/thread/0435e7c5-3cda-41a0-953e-7fa462fde03b.
	Task manager is not precise as perfomance monitor. There may have some bugs. See http://windowsitpro.com/windows/jsi-tip-8404-cpu-usage-task-manager-may-be-incorrect.
Distinguishing platforms should be care.
	The platform "Win32" is somewhat fuzzy.
		Win32 is initially for Windows that runs on 32-bit IA-32 or x86 systems.
			For example, Intel 80386.
				The perhaps most common architecture name correspondingly called "i386" on UNIX-like systems, but now superseded by newer like "i686", and Linux (which is initially targeting i386) dropped i386 support.
		Then Win32 also runs on systems being compatible with them, subsequently AMD64 and Intel EM64T, collectively called "x86_64" as the architecture name, or simply "x64".
		But "32" in "Win32" is not truely only describing the CPU architecture.
			Win16 can be run on Win32 by WOW(Windows on Windows), so a program targeting Win16 can still run on Win32. The 32-bit x86 is backward compatible with old 16-bit architecture, this is a necessary but not sufficient condition.
				The "system" directory of Win16 is called "system32" on Win32.
			What a Win32 program runs is called Win32 subsystem in Windows NT.
			And similarly, Win32 programs can be run on Win64, not only attributing to backward compatibility of x86_64 with x86.
				The "system" directory of Win64 is still called "system32", and it is still in Win32 subsystem.
			Win16 support has been abandoned by Win64.
			Windows on IA-64 (Itanium) do not be compatible with x86 Windows, but they might be also called "Win64".
			Windows on non-Intel platforms (i.e. ARM) are significantly different (as runtime environment), though they are also on 32-bit architecture (and Win32 subsystem), they are normally not called "Win32".
		Microsoft VC++ and some other C/C++ implementations predefined some macros to identify the system.
			The macro "_WIN32" is both defined for Windows versions targeting x86 and x64.
			The macro "_WIN64" is only defined for Windows versions targeting x64.
		Things even more complicated for MinGW platforms.
			MinGW is short of "minimal GNU on Windows", forked from Cygwin (Cygnus POSIX-compliant platform on Windows).
				It is firstly a set of GNU tools.
				Then a runtime.
				And finally a set of toolchain targeting x86 Win32, mostly identified as "i686-pc-mingw32", differentiated with Cygwin's "i686-pc-cygwin".
				It is not devoted for POSIX compliance like Cygwin does, but literally like "minimal", a workable environment to use GNU tools.
			Because unwilling of supporting x64 Windows targets, someone forked MinGW and named it MinGW-W64.
				The "w64" is the vendor name, but not the architecture name.
				The "32" in "mingw32" is also kept, and it is also not the architecure name.
				Things like "x86_64-w64-mingw32" seems to be a little weird, but it should be clear only the first one of triplet indicates the architecture.
			To not being confused, the original MinGW is called "MinGW.org".
				The base features are mainly compatible, though may be with different quality.
				The two library has different implemenation details and feature set in minority.
					For example, MinGW.org support BSD-variant "DT_*" macro while MinGW-W64 not.
				Currently they are both maintained, but by different people.
				Only MinGW-w64 is officially supported by GCC team (though as a secondary platform). The leader maintainer, Kai Tietz, has the commit permission of the official GCC repository.
				MinGW.org runtime is mainly maintained by Keith Marshall.
				They don't think same, e.g https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52015.
				For generally use, MinGW-W64 is recommended by YSLib.
				See also $2014-01 in this document.
			The MinGW-w64 targeting both x86 and x64 Windows. There even exists mixture, i.e. multilib support, or cross-compilers between x86 and x64 Windows editions.
			Do not be confused with MSYS.
				MSYS stands for "minimal system".
				It's larger than MinGW generally. It has shells and other base library dependencies (e.g. the MSYS runtime).
				Comparing to MinGW, it is more like Cygwin and a little heavyweight.
					MSYS shared code from Cygwin as the upstream.
					MSYS2 is more like Cygwin than original MSYS.
				The target triplet is also different, like "i686-pc-msys".
				To build and deploy programs in Windows, MinGW comes first rather than MSYS. Only when the compatiblity concerns, use MSYS might be proper.
			For MinGW targets, there are also predefined macros.
				The marco "_WIN32" and "_WIN64" are supported on both x86 and x64 editions of Windows and x64 Windows only, respectively.
				Similarly, there are macros "__MINGW64__" and "__MINGW32__".
					The macro "__MINGW32__" is supported by variety versions of MinGW like "mingw32" system name does.
					The macro "__MINGW64__" is only supported on x64 Windows with MinGW-W64.
		To detect these platforms by conditional macro definitions, the order is significant.
			The macro "_Win64" should be prior to "_Win32".
			Same as "__MINGW64__" to "__MINGW32__".
	To reduce misconception of MinGW platforms, the macro "YCL_MinGW" is now used to identify all MinGW platforms.
		As other macros "YCL_*" representing a general feature set, but not identifying the concrete platfroms.
		Old macro use of "YCL_MinGW32" should be smoothly migrated by simple renaming, because no significant difference is ever depended on.
		On the other hand, the macro "YCL_Win32" is not renamed to "YCL_Windows" or "YCL_Win", because Win32+Win64 are just not the whole world of Windows.
	The macro "YF_Platform_*" are still used for denoting the concrete platforms.
	The platform extension is for concrete platfroms.
		So no change should be made on directories.
			Just create "MinGW64" for new MinGW64 files.
		However, the header "MinGW32.h" might be migrated for all MinGW platforms in future. Other header may be shared for other Windows platforms.

$2014-08:

report.impl:
Initialization should be cared.
	There are several changes in ISO C++1y for initialization.
		For value-initialization, as per WG21 N3936, from the resolution of CWG 1301, the explicitly defaulted default constructors (declaring with '= default') are considered to ensure zero-initialization for classes without default constructor.
			See CWG 1301.
			It differentiates with explicitly deleted constructor (declaring with '= delete') or user-provided ones.
			Note for ISO C++11, The '= default' is not enough to ensure a value-initialized with no unitialized non-static data members. This is not intended.
			It seems G++ 4.8 and Clang++ 3.3 have implemented it, see http://stackoverflow.com/questions/24043897/c11-value-initialization-with-defaulted-default-constructor.
		List-initialization was also effected by CWG 1301.
			Aggregate initialization takes the first place for aggregates despite of default constructor.
			See http://stackoverflow.com/questions/23882409/c14-value-initialization-with-deleted-constructor.
	Note it is not enougth for arbitrary class type objects (even with '= default' constructor) using member declaration as 'T x{}' to ensure initialized.
		The defaulted default constructor does not ensure performing initialization for each data members in subobjects.
			As per WG21 N3936 8.4.2/5, the definition an explicitly defaulted special member function shall be provided as implicit definition.
			As per WG21 N3936 12.1, the implicitly defined default constructor performs initialization would be performed by a user-written default constructor for that class with no ctor-initializer and an empty compound-statement.
			As per WG21 N3936 12.6.2/8, a non-static data member without brace-or-equal-initializer in class definition and no mem-initializer in ctor-initializer can be default-initialized, which can be with no initialization at all.
		For example, when 'T' is 'std::atomic<int>'.
			Since it is explicitly stated "in an uninitialized state" in 29.6.5/4 in ISO C++11 and WG21 N3936, for ISO C compatible semantics.
	There are still ways to avoid redundant initiliazation of member data for default-initialization and value-initialization via default constructors (but perhaps not copy initialization).
		Several cases are significant, e.g. for containers as buffer.
			Since containers using allocators to construct elements, and at least the default allocator uses value-iniitialization to construct object, so it effects.
			Another solution is to provide user-provided allocators which provides 'construct' overriding the default implementation to eliminate unnecessary initialization.
				But this has effect on the container types, and may be not obvious enouth.
		The element type should usually be a class type declared like 'struct T {D data; T(){}};' where the data type D meets the requirements for container elements.
		This is somewhat complex but still feasible for many cases.
			However, G++ can produce code to perform zero-initialization.
				At least for 4.8.2 and 4.9.1, specifying the optimization option '-Og', '-O1' or above. But '-O0' is expected.
				It is not clear whether this behavior is intended.
The "template-parameter" can be a "template-parameter" thus being declared with "brace-init-list" in default argument for non-type parameter, but no similar synax is allowed for "template-argument".
	This is inconsistent, but precisely defined in ISO C++.
	Clang++ 3.4.2 still wrongly rejects the use of '= {}' for template non-type parameter 'bool' at template declarations. The diagnostics reads "expect expression".
It is intended to make the strong exception guarantee wider in whole YFramework::YSLib.
	All APIs should meet the basic guarantee, i.e. no resource would leak.
	However, currently not all APIs are convinced to be.
	Thus only GUI rendereing is documented as meeting the strong guarantee after reimplemented 'TextBox::Refresh' which could previously make the 'Text' property unspecified after an exception threw.
For types satisfying 'CopyConstructible' and 'Swappable' requirements but not 'CopyAssignable' requirement, a wrapper could be used to support additional assignment operation.
	For example, the closure types.
	See http://stackoverflow.com/questions/12672372/boost-transform-iterator-and-c11-lambda for example of usage.
	If 'Swappable' requirement is supported for the type, copy-and-swap idiom can be used to ensure strong exception safety guarantee.
	Otherwise, 'std::ref' can be used for local variables of type lacking of 'CopyAssignment' requirement support, as a workaround when the support is needed to be properly used.
		For example, like transformer of the 'boost::transform_iterator' or 'ystdex::transformed_iterator'.
Though it might probably a problem for 'std::make_shared' to enlarge the binary size of a file, but this is an implementation-specific problem.
	It seems now this has little impact on devkitPro r42 with optimization enabled.
	Thus the interface should be simpler.
	On the other hand, 'std::make_shared' providing opportunity to optimize the allocation, which is not done by naive 'new' and constructing.
	The 'ystdex::make_shared' is now only providing an extra overloading for instances of 'std::initializer_list' as parameter.
A bug found in 'FetchStringWidth' of module YSLib::Service::TextLayout in YFramework of b529.
	Wrong behavior is only observed behavior for release builds on menu widths.
		The 'release' configuration (statically linked) in platform 'MinGW32' shows a large with. All other release configuration seems to suggest a zero value of width.
	The reason is not clear and not further investigated yet.
		The libstdc++ code seems to be OK. Perhaps there are bugs in 'ystdex::make_transform' and so on, or there are bugs concerned with optimized code generation of G++.
Function 'cbegin' and 'cend' are preferred to 'begin' and 'end' in some cases.
	They are expected to return an iterator to indicate boundary of a range.
	These functions, as well as instances of corresponding function templates defined by ISO C++ [iterator.range] since C++11, are collectively for range access.
		Note 'cbegin' and 'cend' are defined since ISO C++14.
	The type of accessed range usually meets Container requirements.
		Instances of 'std::initializer_list' are excluded.
	Note that 'begin' and 'end' are usually 2 overloaded functions respectively.
		One is for const-qualified range, and the other is for cv-unqualified range.
		The 'auto' keyword cannot deduce the const-qualified version for cv-unqualified range.
	The 'cbegin' and 'cend' are only expected for const-qualified range.
		The 'auto' keyword is OK to deduce for const-unqualified range.
	In general, 'begin' and 'end' are friendly in compatibility aspect.
	However, 'cbegin' and 'cend' may be more precise and clear to show the intent.
	For associative containers, ISO C++ [associative.reqmts]/6 explicitly points out the 'iterator' and 'const_iterator' type can be same, and one can always use 'const_iterator' to avoid ODR violation.
	When the iterators indicating the range boundary are needed, the general rules are:
		Only use qualified-id of these names when really necessary.
		When using non-members, names with ADL (unqualified-id) are preferred.
		For range typed by type parameter in a template or in a macro, non-member templates are always preferred to member functions; otherwise, member functions are always preferred than non-member templates.
		For range typed by type parameter in a template or in a macro, if range with no 'cbegin' or 'cend' are intended to be excluded (e.g. SFINAE), 'cbegin' and 'cend' shall be used.
		Otherwise, if there is no 'cbegin' and 'cend' available, or non-const iterator is explicitly needed, 'begin' and 'end' shall be used.
		Otherwise, for implementation of functions by directly forwarding calls, corresponding names shall be used.
		Otherwise, 'cbegin' and 'cend' shall be used.
	There may exist some bugs for implementations.
		For example, https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60278.
		Use 'begin' and 'end' instead of 'cbegin' and 'cend' as workaround when necessary.
English allows bare passive clause, which omits the auxiliary verb (typically 'is').
	See http://en.wikipedia.org/wiki/English_passive_voice#Additional_passive_constructions.
	In YSLib, for English passive voice in assertion strings or titles, this form is preferred to canonical form (e.g. "file not found"), even in a separated sentence.
	For formal descriptions otherwise, auxiliary verbs should not be omitted.

$2014-09:

report.impl:
There is some confilicts in 'ForwardIterator' requirements onwards ISO C++11 with some iterator adaptor implementations.
	It requires that the iterator shall satisfy the 'DefaultConstructible' requirements.
		If the underlying iterator does not satisfy 'DefaultConstructible', it is hard to implement efficiently.
			However, if the underlying iterator does not satisfy 'ForwardIterator' requirements, an explicitly defaulted default constructor is enough.
	It requires that the 'reference' member should be a reference type.
		This is generally hard to implement for underlying iterator does not store a long-lived object as result.
		For example, 'boost::transform_iterator' is not strictly conforming to this.
			See $2014-08 for other issues related to iterator requirements and 'boost::transform_iterator'.
		This is a currently known problem, but not treated as a defect. See LWG 2107.
	To reasonably resolve these problems, 'ystdex::transformed_iterator' in YBase::StandardEx::Functional now provide a third template parameter to allow the user to specify the 'reference' type.
		If not explicitly specified, default argument 'void' is used, like 'use_default' in Boost iterator library.
			Note now it is not conforming to ISO C++ if 'ForwardIterator' requirements are required and the default argument is used.
		It is convenient and efficient for users to pass a callable object returning an object (rather than reference to a long-lived object) as transformer in default cases.
Keys of associative containers are const-qualified.
	This means they are usually readonly.
	It is important to make the strict weak ordering stable to guarantee the container to work.
	Nothing implied it would be OK to 'const_cast' it and back even the order is maintained. The implementation is free to cache the keys.
	The key is not free to modify. It leads to several problems.
		See http://stackoverflow.com/questions/3884572/how-to-modify-key-values-in-stdmap-container.
			This is also the same problem met in implementation of tree list in YFramework::YSLib::UI.
		See LWG 839 and LWG 1041.
		See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3645.pdf for proposal to resolve this issue (but not in the current standard).
		See http://stackoverflow.com/questions/5743545/what-is-the-fastest-way-to-change-a-key-of-an-element-inside-stdmap for the problem and the status of the paper above.
		The available resolustion are:
			First, to erase and re-insert the value.
				See http://stackoverflow.com/questions/3884572/how-to-modify-key-values-in-stdmap-container to the first method.
				This is generally not efficient for multiple keys/values.
				Function template 'ystdex::replace_value' has already reflect this resolution.
				Anothor implementation is http://www.codeproject.com/Articles/36326/How-To-Update-Your-Const-Key-Fields-in-a-Map-Multi. It is not preferred to 'ystdex::replace_key' because:
					It is for a range rather than a single element, so generally less efficient.
					It is limited to map types.
					It explicitly use 'key_comp'. This is unnecessary.
					It is for pre-ISO C++11, so no 'emplace_hint' is used to perform better.
			Second, to construct a new container then copy or move the elements e.g. by 'std::move'.
				See http://stackoverflow.com/questions/9585083/how-to-move-all-pairs-from-one-stdmap-to-another for examples.
				This is generally more efficient than the first method.
Implementations of clocks are cared.
	For Windows systems, QPC is preferred for high resolution uses.
		The related Windows APIs are fit for Windows 2000 or later, e.g. http://msdn.microsoft.com/en-us/library/windows/desktop/ms644904(v=vs.85).aspx.
		See http://stackoverflow.com/questions/22942123/is-queryperformancefrequency-acurate-when-using-hpet for some reasons.
		See http://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx for deteils.
		For Windows 8, the RTC is buggy to be reliable for overlocking benchmarking.
			See http://hwbot.org/news/9824_breaking_windows_8_benchmark_results_no_longer_accepted_at_hwbot/.
	In current libstdc++ (in inline namespace 'std::chrono::_V2' or somewhat earlier), the static 'now' function of clocks in <chrono> uses different configurations.
		The 'std::high_resolution clock' is alias of 'std::system_clock'.
		For 'std::system_clock', if '_GLIBCXX_USE_CLOCK_REALTIME' is not defined, it uses fallback 'std::time' call.
		For 'std::steady', if '_GLIBCXX_USE_CLOCK_MONOTONIC' is not defined, it uses one in 'std::system_clock'.
		Otherwise, both are implemented as following, respectively:
			If '_GLIBCXX_USE_CLOCK_GETTIME_SYSCALL' is defined, it is implemented as a system call.
			Otherwise, 'clock_gettime' is used.
		The libstdc++ for MinGW-W64 is implemented on top of 'clock_gettime' with corresponding clock id ('CLOCK_REALTIME' or 'CLOCK_MONOTONIC') in winpthreads.
			The winpthreads implementation uses different Win32 APIs to implement 'clock_gettime' for years.
				For 'CLOCK_REALTIME', 'GetSystemTimeAsFileTime' is used.
				For 'CLOCK_MONOTONIC', QPC APIs are used.
				For 'CLOCK_PROCESS_CPUTIME_ID', 'GetProcessTimes' is used.
				For 'CLOCK_THREAD_CPUTIME_ID', 'GetCurrentThread' is used.
				So it should be resonably high accurate at least for 'std::steady_clock' in <chrono>.
			It is tested to be significantly worse than 'boost::chrono' (using QPC APIs) on accuracy with 'i686-4.8.2-release-win32-dwarf-rt_v3-rev0.7z' even using 'std::steady_clock'.
				See http://sourceforge.net/p/mingw-w64/mailman/message/31672495/.
				However, the zero results can not be reproduced on Windows 2012 R2 x64 machine with current MSYS2 GCC 4.9.1.
					But it can be reproduced using 'std::system_clock' instead of 'std::steady_clock'.
					As per the libstdc++-v3 source in GCC repository, the reason seemed to be the 'std::steady_clock' is an alias before 'std::chrono::_V2' was introduced.
				See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63400 for the issue.
			As a side note, function '_pthread_time_in_ms' around inside winpthreads, which used '_ftime'.
				It is improved by a recent update in git master branch of MinGW-W64 winpthreads repository at 2014-09-27 02:00:15: "winpthread: use GetSystemTimeAsFileTime instead of _ftime".
					Quoted: First, _ftime is not present in all msvcrt versions, then, _ftime is the "current local time".
					The modified function was "_pthread_time_in_ms".
					This is certainly not updated in released version of MinGW distributions.
	See also http://nadeausoftware.com/articles/2012/04/c_c_tip_how_measure_elapsed_real_time_benchmarking#GetSystemTimeAsFileTimeandGetsystemTimePreciseAsFileTimenbsp for variable interfaces of getting the real time suited for benchmarking.
	YFramework implementation for getting real time in Windows is adjusted.
		Whether the timers in ISO C++11 standard library are usable or not, at least the multimedia timer APIs are no longer needed because the mainly targeting systems are rare to be the exception cases. So it is now removed.

dep.merge:
Boost.Trie(https://github.com/ithlony/Boost.Trie): tentatively rejected.
	This is a project of Boost GSoC 2013.
	Despite the whole Boost had been rejected before ($2012), it was probable to be accepted to merge. However, it is not proper now.
	It is not being actively developed for months.
	It was considered not peer review ready, see https://groups.google.com/d/topic/boost-devel-archive/KjerA9jlLbo for some details.
	There seems to be no documentation ready.
		No stable interface is clearly stated.
		No characteristics like complexity is clearly stated and ensured.
	The standard container like 'std::map' are used directly in the data structure as members.
		Though acceptable, just a note: many operations would be limited by the QoI of the standard library.
		Many operations would be more expansive than standard library calls, and often beated the purpose to introduce a trie (to replace a 'std::set' or 'std::unordered_set', etc).
		It is also not very memory-efficient, e.g. duplicate node sizes were stored.
tx-trie(https://code.google.com/p/tx-trie/): rejected.
	It is not being actively developed for years.
	It is for paticular string type and not templated.
	There exists quality problems, e.g. macro names pollution, directly used unqualified-id of C standard library functions, memory allocation, etc.
marisa-trie(https://code.google.com/p/marisa-trie/): considerable, tentatively shelved.
	It has some similar problems of interface like tx-trie. However, it seems to be fit for other use.

$2014-10:

report.impl:
Now ar from MSYS2 supports linker plugin.
	So removed '-ffat-lto-objects' option for compiler by defualt and use 'gcc-ar' to replace 'ar'.
		If use 'ar' with '-flto' enabled there would still be unresolved symbols.
	See $2014-07 for previous details.
Multiple tap operations are studied.
	This is ordinarily called "click".
		However, multiple click is often triggered at last tap down rather than up, like in Windows desktop or text controls.
		Otherwise it can be triggered on subsequent tap up events, e.g. image preview in Tencent QQ.
	The behavior may differs across platforms, see http://en.wikipedia.org/wiki/Double-click.
	For Windows, this is primarily for mouses. See register path: HKEY_CURRENT_USER/Control Panel/Mouse for settings.
	There is an area setting for allowed error with initial tap with subsequent ones.
		However, sometimes this is ignored and only precise subsequent (without any move) taps are allowed to avoid collision with dragging operations, e.g. for text selection.
	Triple click is to select text in a line in general, and mostly used by browsers and text editors, see http://en.wikipedia.org/wiki/Triple-click.
There is a bug on DST(daylight savings time) calculation on Windows CRT call of 'stat' family across file systems.
	This can cause strange bugs on file system caching.
		See comments in "src/fcstat.c"(previously in "src/fccache.c") from the FontConfig project(http://www.freedesktop.org/wiki/Software/fontconfig/).
		See https://bugzilla.gnome.org/show_bug.cgi?id=154968 Comment 30, also https://bugs.freedesktop.org/show_bug.cgi?id=8526.
	See http://www.codeproject.com/Articles/1144/Beating-the-Daylight-Savings-Time-bug-and-getting for details.
	See http://msdn.microsoft.com/en-us/library/windows/desktop/ms724290(v=vs.85).aspx for other general information.
	New CRT source "fstat.c" and "fstat64.c" from Microsoft VC++ 2013 shows that the implementation has been changed.
		The Win32 API 'FindFirstFile' was not used any longer.
		Also the code for Window Store App uses different APIs for time conversion.
			'FileTimeToSystemTime' and 'SystemTimeToTzSpecificLocalTime' was used instead of 'FileTimeToLocalFileTime' and 'FileTimeToSystemTime'.
				It is reasonable because some APIs is not available.
			It is uncleay why the desktop platform did not use these functions.
				These functions seems to be having good compatibility with enough precision.
				The possible difference of behavior between these platforms are to be investigated.
There are issues which make the flattened object files hardly be linked directly.
	The linked '.a' files are not the same as '.o' files.
		For statically linking they are OK.
		GNU ld complains about there is no index when trying to generate a DLL.
			Even after explicit 'ranlib' call, the result is the same.
			However, an archive linked directly with '.o' has no such problem.
	GNU ar supported linker script.
		See https://sourceware.org/binutils/docs/binutils/ar-scripts.html#ar-scripts for usage.
		It can be used to workaround this problem, but still cumbersome with limitation, e.g. no '+' can be in the name or the '.a' file.
		See also https://lists.gnu.org/archive/html/help-make/2008-03/msg00043.html.
	Thus it should generally directly be avoided. Direct use of '.o' to build shared library is preferred.
		The performace is also significantly better for directories containing a few source files, because less archives should be built and waiting before linking can be reduced.
Sometimes 'LANG=C' should be expicitly specified in the command line to prevent corrupted output from some tools built without NLS support.
	For example, 'ar' from MSYS2 does not play with zh-CN locale well, while 'gcc-ar' has no problem.

$2014-11:

report.impl:
There should be general no explicit exception-specification for destructors. However, exceptions of this rule are also allowed.
	In gerenal, throwing an exception in a destructor is thought to be bad practice.
		It would terminate the program during stack unwinding.
		There is no good way to distinct it in the implementation of a destructor.
			See http://www.gotw.ca/gotw/047.htm.
		ISO C++ standard library follows this practice by Destructible requirements which explictly forbids exception exceptions propagated out of the destructors.
	However, if the assumption of never throwing exception in stack unwinding is true, this is somewhat acceptable.
		See https://akrzemi1.wordpress.com/2011/09/21/destructors-that-throw/ and http://www.kolpackov.net/projects/c++/eh/dtor-1.xhtml.
		The root reason is that destructors are not necessarily used in RAII style.
		To be simple, this should still be avoid in most cases: do use destructor to reclaim resources but not to perform arbitrary operations.
	In ISO C++11 there is a subtle change in implictly specification for destructors.
		See https://akrzemi1.wordpress.com/2013/08/20/noexcept-destructors/.
		Do explicitly specify 'noexcept(false)' to allow throwing in destructors, if ultimately needed.
	WG21 N3166 proposed to add noexcept specification on destructors by default.
		This is not accepted by ISO C++11.
Note the 'std::reference_wrapper' is not equal to 'boost::reference_wrapper'.
	The latter is simpler. 'std::reference_wrapper' has more interface about nested types and 'operator()', thus it needs a compelete type as template argument, otherwise the behavior is undefined.
		See https://groups.google.com/a/isocpp.org/forum/?_escaped_fragment_=topic/std-discussion/_tavlfXkOrc#!topic/std-discussion/_tavlfXkOrc.
	Currently G++ 4.9 with libstdc++ allows the invalid use and would not detect the ODR violation.
	Microsoft VC++ denies this use with subtle diagnostics.
		See https://connect.microsoft.com/VisualStudio/feedback/details/750448/std-reference-wrapper-fails-with-undefined-types.
	YBase now has introduced 'ystdex::lref' to simulate 'boost::reference_wrapper' allowing incomplete type as template argument, among with 'ref' and 'cref'.
		Only limited interface is supported.
			Standard library interface inconsistent with incomplete template argument are not supported.
			Boost specific member 'get_pointer' is not supported.
			Specialization of 'wrapped_traits' is added.
			Constructor has overloaded to support conversion from 'std::reference_wrapper'.
				This allowed both instances of 'std::reference_wrapper' and 'ystdex::lref' to be the function argument type.
				To minimize dependencies, no further conversions is supported specially.
				If more generic interface is needed, SFINAE with 'ystded::wrapped_traits' can be used.
		The declaration 'ystdex::lref' is introduced in namespace "YSLib" by using-declarations in YSLib::Adaptor::YReference unconditionally. However, the 'std::ref' and 'std::cref' are not quite same.
			They clashed with names in 'std'.
			In library code they should be always used with qualified prefix, otherwise the ADL can make troubles when the behavior of found entity are not equivalent as expected.
				Note 'ystdex::ref' and 'ystdex::cref' are different with 'ystdex::make_*' for smart pointers.
					The latter ones are overlapped with their 'std::' counterparts (if any) because they exposing same kind of functionality and return same expected types.
					The use cases in templates where the ADL effects are rare. Even in these cases, prefix can be explicitly used.
					The difference about prefix in semantics is implementation details rather than interface requirements.
			They are easy to misused to construct a 'ystdex::lref' and passed it to function templates which only handles 'std::reference_wrapper' specially.
				For examples, as 'std::bind' arguments or 'operator()' is used. In these cases the 'std::' should be used explicitly.

$2014-12:

report.impl:
Keyboard input processing is complicated. There are a few key codes on Linux as options.
	See https://www.berrange.com/tags/key-codes/.
	See https://stackoverflow.com/questions/8737566/rolling-ones-own-keyboard-input-system-in-c-c.
Convention of term "stride" used by XCB image is coordinized with YSLib. (See also $2014-05.)

$2015-01:

report.impl:
Note that 'va_args' and 'va_end' cannot be encapulased using RAII/RRID.
	ISO C explicitly specified they shall match in a function.
	Since constructor and destructor are functions, they can not be used.
UAC is annoying for program which aquireing no administrator privilege but containing some patterns in filename e.g. 'patch.exe' or 'install.exe'.
	See https://github.com/bmatzelle/gow/issues/156.
The function 'std::quick_exit' is mostly a workaround of cleanup when the thread cancellation is not supported in C++.
	See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2440.htm.
	Do not register callbacks through 'std::at_quick_exit' unless the states of threads are all known.
		Note these callbacks shall not raise signals according ISO C11, otherwise the behavior is undefined.
	The similar thing also fit for 'std::exit' and 'std::atexit'.
		However, it is generally more difficult to avoid.
		In fact, current libgcc exploited 'atexit' to make the destructors to be called.
Win32 console would call 'ExitProcess' by default during window close or handling 'Ctrl+C', etc.
	See http://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx.
	This might probable not preferred because this call would mostly make the C/C++ runtime a mess.
	This call can inform the loaded DLLs to be terminated, but also might lead to deadlock when DLLs are not used properly.
	A clean call of 'TerminateProcess' on current process would be better if not all states of each thread are known.
		However, it would not touch the C/C++ runtime states, either.
	So C/C++ standard library functions or other runtime functions are generally preferred for C/C++ applications.
		Use 'SetConsoleCtrlHandler' function to change default behavior for the attached console.
			See http://msdn.microsoft.com/en-us/library/windows/desktop/ms686016(v=vs.85).aspx.
		YSLib now use it to workaround the unexpected behavior.
			The exit code 'STATUS_CONTROL_C_EXIT' is used for 'CTRL_C_EVENT' and 'CTRL_CLOSE_EVENT' to retain old behavior.
			For 'CTRL_BREAK_EVENT', 'CTRL_LOGOFF_EVENT' and 'CTRL_SHUTDOWN_EVENT' the same code is used, but not tested to be the same as original one.
Since 'ystdex::nptr' is exactly a wrapper but not a smart pointer, it is intended in <ystdex/utility.hpp> but not in <ystdex/memory.hpp>.
The function 'isatty' on POSIX compliant environments and '_isatty' is not the same.
	For POSIX compliant environments, '::isatty' returns whether the file descriptor is associated with a terminal.
		See http://pubs.opengroup.org/onlinepubs/009695399/functions/isatty.html.
	For Win32, '::_isatty' returns whether the file descriptor is associated with a character device.
		See http://msdn.microsoft.com/en-us/library/f4s0ddew.aspx.
	Use Win32 APIs to achieve the functionality of POSIX compliant 'isatty'.
		See http://stackoverflow.com/questions/3648711/detect-nul-file-descriptor-isatty-is-bogus.
	However, both function can exclude some cases not fit for terminal output.
Move-only parameter passing counts.
	See the discussion at http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html.
	Both 'T&&' or 'T' have cases. The former is probable more efficient and debugger-friendly, while the latter is simpler (both on coding and behavior).
		For 'T&&', the extra move is delayed to the client code. And there is possible to not move (or even not use) the argument at all.
		For 'T', the move operation is mandated by copy-initialization of the parameter.
	The implicit coding rules used by YSLib are not documentated then, so here is the summary.
		To use mandated move on certain move-only types which has predictable and acception perfomance on the move operation (e.g. instances of 'std::unique_ptr' with default deleter), 'T' is preferred.
		Otherwise, 'T&&' should be used.
	These cases was attented at long before.
		At least in September 2014, these rules were adopted.
			This is reflected by the modification on Documentation::CommonRules (Mercurial changeset 406, build 534; now Documentation::LanguageConvention).
			However, no actual code modification was taken (e.g. on 'YSLib::UI::Widget::SetRenderer').
		These rules are now updated to be more explicit in Documentation::LanguageConvention.
		In fact, 'YSLib::UI::Widget::SetRenderer' was modified in May 2013 (Mercurial changeset 278, build 406) for probable the same rules.
		Now 'YSLib::UI::Widget::SetView' is synchronized to be consistent. Both these functions needed the object of 'unique_ptr' instance always being used.
	For non move-only type, see $2014-04.
The duration (and potentially other instances of 'std::chrono' time types e.g. time points) parameters are now passed by value rather than by reference.
	In general, The default argument binding to reference type of parameter causes odr-used of the argument.
		If the argument is a static data member of class, either declared with const, constexpr or not, an extra definition out of class definition is required to obey ODR, otherwise the program is ill-formed.
		This is necessary by intention. Only value is actually used so lvalue-to-rvalue is expected, and odr-use is not required.
	To eliminate the requirement of extra definition, parameter of object type can be used directly instead of parameter reference type.
	However, the static data member of literal types designated with constexpr are used (rather than integral or enumeration types) it might not work.
		To be a constant-expression it should be a non-volatile glvalue performed lvalue-to-rvalue conversion.
			This is required "immediately" by ISO C++11.
			The requirement is relaxted by new working draft, but not all issues are resoved now.
			See http://stackoverflow.com/questions/23491781/when-is-a-variable-odr-used-in-c14.
		Implementations like MinGW G++ 4.9.1 or Clang++ 3.5.1 with both '-std=c++11' and '-std=c++14' are actually not treated them as constant expressions for such use, so the definition are not removed tentatively now.
		See WG21 N4296 5.20/2.7.1 about use for integral or enumeration types.
	For instance of duration used directly in YFramework, the underlying arithmetic types are predicatable, so the costs are generally known and acceptable.
		This may differ in the standard library or other cases (e.g. YBase), which use const lvalue reference of templated object types.
	To be consistently, all parameters use the same form.
	This is not necessary the case of 'YSLib::Drawing::Point' and other types of geometry in YFramework (esp. the cost of copy an object of 'YSLib::Drawing::Rect', for consistency in style), so they are not touched.

$2015-02:

dep.merge:
df.operators(https://github.com/d-frey/operators): partially merged.

report.impl:
The '+' or '+=' expression concerned with random access iterators should be noticed.
	ISO C++ has not required that the preconditions for these operations. However, this check is by original design.
		See http://www.sgi.com/tech/stl/RandomAccessIterator.html#1.
	Note out-of-bound pointer arithmetic is undefined behavior.
		See http://stackoverflow.com/questions/10473573/why-is-out-of-bounds-pointer-arithmetic-undefined-behaviour.
		Since the algorithms implemented to support random iterators are usually allowing pointers, it should be cautious to use these operations.
		Unless otherwise explicitly specified, YSLib uses the strict strategy, i.e. the code shall not use these operations to perform undefined behavior, unless the pointers are prevented to be instantiated intentionally.
		YBase also uses some strict boundary check (esp. assertions) on these operations in implementation of iterators.

$2015-03:

dep.merge:
OpenImageIO(http://www.openimageio.org/): tentatively rejected.
	This is a library focused on image I/O.
		It actually does more, e.g. provides some ISO C99 math functions and POSIX math macros, implementation of 'array_view', etc.
		It embeds some 3rd party code to support XML, SHA1, etc.
		It also encapsulates some system-dependent operations, e.g. threads.
			The threading operations depend on Boost.Thread.
		Its interface is in C++.
			This is good to avoid name clash.
			However, the quality is not always good.
				Error handling totally bypassed exceptions (except for throwing 'std::out_of_range' from 'array_view', etc), and uses thread-specific state instead.
					This is of generally bad style and can be hard to use.
			Sometimes the interface is necessarily bloated, e.g. 'ParamValueList' can actually be an type alias rather than a class.
		The headers are a bit mess.
			There are multiple headers in the same directory doing different works. Not all of them are aiming to image I/O.
			It is somewhat difficult to use it cleanly directly without referencing some use cases.
	The license is 3-clause BSD-like.
		Though 2-clause would be better, it is good to use.
	The binary code of static library is even slightly larger than that of FreeImage for MSYS2.
		It is in doubt to shrink without giving up some functionality.
	It is lacks of GIF support, which is used by YFramework.
		So at least at current, it can not replace FreeImage.

report.impl:
In general, the key state in the event argument of 'KeyDown' event should not be modified in the handler.
	Call of 'GUIState::UpdateChar' would once modify it.
		The key set was combined of multiple keys, which was modified by checked held state.
		This was wrong for a 'KeyDown' event not called by 'KeyHeld' handler.
		Class 'TextBox' was effected. It would occasionally behave normally if the key of least key index was pressed down at last.
			Since the key was determined by the first key index in the key set through call of 'FindFirstKeyInCategroy'.
			For example, right arrow after left arrow would be treated as left arrow but right arrow after left array would be normal, if the key index of the left arrow key is less than the one of right arrow key, which is the case of Win32 and many other platforms.
Be cautious with revision patcher script. Currently the pattern of reversion is hard coded.
	Only certain version number pattern is supported.
		Some versioned files like makefiles should still going to be maintained manully.
	Be cautious with the lines area counts.
		Most files are with the '\version' in first 20 lines, only 3 files are the exceptions: YBase::YDefinition, YFramework::YCLib::YModules, Tools::PredefinedMacroDetector::Main.
		All of them are not touched since the script was used.
		So nothing had been going wrong.
		Set 'PatchEnd' variable when necessary.
			The default value has been adjusted to '30' instead of '20' to cover all of current source files.
	Now version number pattern is restricted to mandate a prefixed number character in the version number.
		Thus the script it self would not be affected even the 'PatchEnd' is set to 30. It should also work for the readme file.
The Clang++ warning '-Wweak-vtables' is mainly for compiling performance.
	See http://lists.cs.uiuc.edu/pipermail/cfe-dev/2012-August/024020.html.
	See also http://stackoverflow.com/questions/23746941/what-is-the-meaning-of-clangs-wweak-vtables.
	G++ behave similarly, but Microsoft VC++ does not.
		See http://stackoverflow.com/questions/12024642/placing-of-external-virtual-tables.
	It is enabled by '-Weverything'.
	For client code this might be not important, so no problem to disable.
	However, for libraries with a lot of translation units or being depended deeply, it is better to turn it on.
		YSLib libraries should use these flags if possible.
		YFramework interface type now requires out-of-line destructor provided by user.
		Note to avoid '-Wdeprecated' warnings, the copy or move constructor should be defined.
			This might cause some trouble with '-Wextra' from G++ complaining aboud imlicit call of default constructor in devired classes if it is not explicit initialized.
				As a workaround, (a few) copy constructors now explicitly initialize the base interface subobjects.
Note that '__cplusplus' value is significant across different versions of implementations.
	Paticularly, '__cplusplus > 201103L' is not equivalent to '__cplusplus >= 201402L'.
		ISO C++ working draft did not specify any value between '201103L' and '201402L' for 'cplusplus'.
		However, there exists some implementations use these values.
			For example, some G++ versions uses '201300L' for C++1y mode.
				See https://gcc.gnu.org/ml/gcc-patches/2013-04/msg01452.html.
				MinGW G++ 4.9.1 from MSYS2 is tested and confimed the use of this value when specified '-std=c++14'.
			On the other hand, Clang++ 3.5.1 from MSYS2 uses '201402L' for '-std=c++14'.
		This is important for some feature detection conditions.
			As an example, 'constexpr' on C++14 'std::max' is supported differently by similar conditions.
				Libstdc++ only supports it through macro '_GLIBCXX14_CONSTEXPR' after version 4.9 when '__cplusplus >= 201402L'.
				Libc++ supports it with same condition through macro '_LIBCPP_CONSTEXPR_AFTER_CXX11' except for it can be disabled by define '_LIBCPP_HAS_NO_CXX14_CONSTEXPR'.
			As another example, C++14 'std::integer_sequence' is supported similarly.
				Libstdc++ 4.9 supports it when '__cplusplus > 201103L'.
				Libc++ supports it when '_LIBCPP_STD_VER > 11', effectively equivalent with '__cplusplus > 201103L''.
		YSLib uses it carefullly.
			For different senarios, these different conditions are distinguished.
			Currently the non-standard-compliant macros like '_LIBCPP_HAS_NO_CXX14_CONSTEXPR' are ignored.
			There would be some specific macros like libc++ to control it better in future.
			Utilization of '__has_feature' would be preferred. Note it would be supported by G++ 5, and Clang++ has already supported it.

$2015-04:

report.impl:
ISO C++14 does not allowed arbitiary expressions for template non-type arguments.
	Notably, 'std::integral_constant' using '()' converting to a value is not allowed in these context.
		This is too restrict and cause it can be used almost always with 'static_assert' declarations or 'noexcept' specifications.
	WG21 N4198 stated and resolved this problem.
		See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html.
		The resolution has been merged into working draft WG21 N4296.
	Note the use of '::value' are preferred in several contexts.
		Only certain expression related with 'std::integral_constant' should be considered for refactoring.
		For example, those 'seq_size' call in YBase.YStandardEx.Variadic and implementations of 'and_', 'or_', and 'not_' in YBase.YStandardEx.TypeOperation would not be touched even C++1z is accepted.
Copy constructor of exception classes is reviewed.
	See $2014-02 report.impl for basic rules.
	The standard don't restrict the stored subobjets of standard exception classes to allow optimization.
		See LWG 254.
		However, actual implementations may directly use reference-counted strings.
			See http://stackoverflow.com/questions/29052647/c11-introduced-exception-constructors-taking-const-char-but-why.
			See http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20140428/104370.html.

$2015-05:

report.impl:
Now 'ystdex::nptr' is moved to <ystdex/pointer.hpp> to be specifically categorized as the pointer-related interface.
	Also to implement by using <ystdex/operators.hpp> avoiding too many dependencies introduced to <ystdex/utility.hpp>.
	It is still not ideal to decouple the interface, because now <ystdex/iterator.hpp> is relying on this header. In future, some portion of code in latter would better placed in another new header.

$2015-06:

report.impl:
Binary size matters, particularly to platform DS.
	Substitution of FAT code by custom implementation in 'DSIO' instead of libfat may gain runtime performance, however, makes it worse.
		Informal test release build before substitution showed sizes varied.
			YSTest.nds shrinked 983 KiB to 978 KiB by the raw libfat source substitution because of compiler and linker optimization.
			It bloated to 985 KiB after the complicated ystdex::used_list_cache used instead of naive one.
			After introduced exception handling and some other refactoring tricks, it became 986 KiB.
			After adding some more error checking, it became 988 KiB.
		Use new cache implementation which reduced base class, it reduced to 986 KiB.
			The DSIO uses 'std::map' instead of 'std::unordered_map' as underlying map container.
			Note this also has effect on font cache and image processing cache, except for 'std::unordered_map' is kept because hash function is specified.
			This also made less memory footprint.

$2015-08:

report.impl:
According to ISO/IEC 9899 footnote 268, it is undefined behavior to call 'fseek(file, 0, SEEK_END)' for a binary stream.
	This is also existed in ISO/IEC 9899:TC3 (WG14/N1256) which is referenced by ISO C++11, and older version of ISO C.
	However, it is not mattered in POSIX-compliant systems. ISO C++ standard library streams are also not effected.
	See also http://stackoverflow.com/questions/5957845/using-fseek-and-ftell-to-determine-the-size-of-a-file-has-a-vulnerability.
It is a known issue that current GNU C++ frontend 'cc1plus' would crash when debug option('-g', -g1' or '-ggdb', etc) for some code with nested 'decltype' expression in trailing-return-type.
	Only tested for G++ from MSYS2 package 5.2.0-3. It is used to build stage 2 SHBuild.
		However, stage 1 SHBuild seems to be OK.
	See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67238.

$2015-09:

report.impl:
Be cautious to the fact that some POD structs without constructors might not be initialized without initializer.
	It is clear that only a few types in the standard library is dangerous for the reason, see below. The specification is usually clear enough to distinguish bugs from implementations and user code.
	To serve robustness and make some speicific error easy to be detected, the automatic object of these types should be initialized explicitly for other external libraries.
	To value-initilize these types, '{}' is recommended.
		Note the list-initialization rules is not the same in ISO C++11 and ISO C++14, but here the effect is same, except for the defect concerned below.
		Still be cautious that value-initialization might not be enough, until the resolution of CWG 1368 is adopted by the coding convention.
			For the hole of value-initialization (not initializing some data members), see CWG 1368.
				It has been fixed in the standard (draft before ISO C++14 published), see https://github.com/cplusplus/draft/commit/7eed4036396d73f7c75719808119d993e840ce8c.
			One of prominent example is using of 'std::atomic' instances.
				This actually caused observable bug with G++ since b399 in YSLib::Helper and was fixed at b499.
			As a workaround, instead of '{}', use '{{}}', etc.
Error handling based on error code should be restricted.
	Error codes are often hard-coded with very limited ability to be extended.
		Interface like ISO C++ <system_error> can make it better somehow.
	Error codes as return values is superseded in many scenes, esp. for code quality.
		Error codes have no force to urge user handling. Using 'catch' everywhere not properly is obviously bad style, but abandon an error code silently is too easy.
			This may be hard to detect.
		Error codes have monadic error neutrality like exceptions.
			This may make code verbose and full of semantic noise.
		They may still useful if return value is always checked by the users.
			For low-level interface, it might be better to provide routines with both exception handling and error codes support.
	Error codes stored as non-automatic objects cause more problems.
		They make functions using them not reentrant.
		Access of static objects may cause data race.
		They may make the optimization difficult, if not impossible.
			The C library <math.h> is a prominent example, although for floating-point arithmetic there are other environment issues.
		Particularly, 'errno' is considered harmful.
			The type 'int' is not extensible.
			The type 'int' is too broad to its meaning.
			The interface using errno is often poor.
				The purpose exposed by interface can be clearer by avoiding using plain 'int'.
			It should be avoided for these reasons, even if it is widely supported.
			Note that 'errno_t' has been removed for a while, since b594.
				Even it is adopted by ISO C11 as library extension and is clearer than plain 'int', the other problems remain.
				General C++ error handling (even with other error codes) is perferred.
				So the style is not supported any longer.
			For portability issues, 'errno' (and 'int' for this purpose) are still allowed, but they should be better not used, or only when extremely necessary.
Deduce of braced-init-list is limited.
	See http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3681.html and http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3912.html for background.
	See also https://isocpp.org/files/papers/n3852.html#FI3.
	WG21 N3922 changed the rule after ISO C++14. This is adopted, as per the working paper N4527. See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html.
	Clang++ 3.6 and 3.7 would issue an warning [-Wfuture-compat]. See http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20150209/123100.html.
	Note G++ 5.2 accepts currently invalid code even for '-std=c++11', deducing it as list-initialization rather than instance of 'std::initializer_list'.
		This would only be conforming after ISO C++14 rules are adopted.
Previously analysis of grammar of template default argument for non-type parameters turns to be wrongly.
	See $2013-10 report.impl.
	Note ISO C++11 [dcl.fct.default]/3 has already forbid non assignment-expression as template default argument for non-type parameters.
	It turned to be a G++ bug. See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57905.
Atomicity might be a real problem to file system APIs.
	This might cause TOCTTOU access and make inconsistent state in the resulted environment.
		There are no portable way to fix it.
		See https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use.
	Since there are few file systems support transactions, this is hard to achieve on this level.
	Users should be careful by themselves.
	File locks should be considered in future to make life ease.
Readonly attribute is considered in Win32 when removing a file.
	Win32 API 'DeleteFile' prevent deletion of a file.
	Low-level 'unlink' and 'remove' are based on 'DeleteFile' in MSVCRT (at least as in universal CRT source), so do the '_w' variants.
	Thus mearly calling these APIs are not able to remove a readonly file.
	To achieve consistent behavior with other platforms (mostly POSIX), YCLib 'FileIO' API now try removing the readonly attribute at first if it is not a directory.
		This would increase risk of TOCTTOU access.
Multilevel tree deletion actually works well, except for shared files are involved.
	For example, for multilevel tree deletion, if non root directory is opened at 'explorer' in Windows, the view would return to the parent directory of opened directory and the operation would fail (with the previously opened directory already removed).
	These potentional bugs should be further investigated in future.
There are many conditions concerned to copy file.
	'CopyFile' is proveded as a set of overloaded functions in module YSLib::Service.
		It relies on some APIs in YCLib.FileSystem to make the implmentation easy to use non platform neutral operations.
		The destination and source are basically specified by path strings or file descriptors.
			Other variants can be considered later.
	The API is carefully designed to meet different requirements, particularly:
		Users should be able to specify whether the operation would fail when the destination is already existed.
			At least a parameter should have functionality similar to 3rd 'bFailIfExists' parameter of Win32 API 'CopyFile'.
			For availability, 'CopyFile' actually provides a 'size_t' parameter to allow users specifying maximum allowed link numbers when the destination is already exists.
				Note the call would change the link number of the destination path only when destination is not existed yet, that is, from 0 to 1. The parameter is not used here.
		Link behavior should be considered.
			Users should be able to specify whether the modification of destination is visible through other paths.
				Note the problems only occur on overloads with the destination specified by a path.
				Thus, providing such functionality through other names is a surprise and bad.
			For hard links, if shared writing is allowed, there need to be no extra operations, otherwise the destination should be removed before the copy.
			For symbolic links, if shared writing is allowed, the link should be followed, otherwise the destination should be removed before the copy.
		To make it clear as the name of the function and to ease the use, several limitations are made by design.
			'CopyFile' creates only one regular file by one successful call, without reading the source file contents before the actual copy.
			'CopyFile' does not remove destination explicitly, except for the link behavior needed above.
		When the destination is not existed, 'CopyFile' can be called directory.
		When uncoditionally deletion of destination is needed, user can call always 'TryRemove' and then 'CopyFile'.
		When the destination is existed as regular file with link number equals to 1, the file are to be opened directly and write by 'CopyFile'.
			The node ID and creation time (if any) shall not be touched.
		New APIs should be designed for some specific operations (e.g. to increase performance) without direct calls of 'CopyFile':
			Batch operations are needed.
			Conditional links are needed.
			Conditional writing, e.g. comparing source of file (to minimize writing) before actual copy, is needed.
	Several preconditions shall be hold, or the operation would fail:
		The destination shall not be on a readonly file system.
		The destination shall be in a directory with write and search permission.
		The source shall be with read permission.
		The destination shall not specify a directory.
			Otherwise it violates the intention of "not removing destination" above.
			This should also fail when destination is a nonempty directory, since tree removing operation is complicated so it is not fit to implement on this level.

dep.merge:
libwibble(https://packages.debian.org/sid/libwibble-dev): tentatively rejected.
	This is a package about some general/low-level C++ utilities for developers.
	The interface is not up-to-date to modern C++ style.
	The functinoality should be covered by YBase and YFramework.YCLib intentionally, though most of them are not done yet.
folly(https://github.com/facebook/folly): tentatively rejected.
	Though used productively and is under actively development, this library is not fit for YSLib as a dependency.
		The API design is awful.
			Too many functionality overlapped with the standard library, with less obvious design principles.
			Too many direct use of strongly coupled specific types in function signatures (e.g. explicit 'std::string').
		The quality of impelementation is not competitive.
		It relies on a subset of boost.
			Boost is rejected basically because it is too large. This subset is still considered large engough to be rejected.
			Though some equivalent API of them are of parts of YBase (e.g. boost.operators), it is too tricky to maintain.

$2015-10:

report.impl:
There are something to be noted for feature-testing macro '__cpp_lib_tuple_element_t'.
	According to WG21 N4030 and WG21 N4440, the feature-testing macro is defined for <utility>.
	However, the definition shall be in <tuple> as per ISO C++14.
	Microsoft VC++ 2015 has supported 'tuple_element_t'
		See https://msdn.microsoft.com/en-us/library/Hh409293.aspx.
		Note that Microsofot Microsoft VC++ 2015 implemented the primary template also in <utility> rather than <tuple> as ISO C++14 requires.
			This is acceptable because 2-phase lookup is not implemented yet in Microsoft VC++. Once <tuple> is included, the specialization of 'tuple_element' for 'tuple' would work as expected. So does 'tuple_element_t'.
			Since <utility> is always included by YBase.YStandardEx headers, the conforming issue does not take effect.
Assertions can not necessarily be used in 'constexpr' functions.
	ISO C++11 'constexpr' is limited for only one statement (besides static assertions, etc) is allowed in function-body.
		This is relaxed by ISO C++14. However, ISO C++11 compatibility is still needed for YBase currently.
	For ISO C++11 '__func__' and other similar extension like '__PRETTY_FUNCTION__' of G++, the implementation inserts the declaration directly into the function body. So it does not meet to the requirement above.
		The standard macro 'assert' may or may not use these facility.
			This actually causes 'assert' even cannot be reliably used in 'constexpr' function template for devkitARM and Android, but not for MinGW-w64.
		This is a defect of C++. See LWG 2234.
	As a workaround, custom implementation should be used instead.
		For example, '_LIBCPP_ASSERT' in libc++ is used in <__debug>. It uses '_VSTD::fprintf' and '_VSTD::abort'.
		The macro 'yconstraint' in YBase use custom 'yassert' instead of 'assert'.
			As a result, it would display different diagnostics when triggered.
			It might also behaves differently for platforms like Android.
				Note '__android_log_assert' is not directly used.
		The macro 'yassume' is not touched.
Proper string types should be selected to design APIs.
	For owning string, classes like std::basic_string instances may be good enough.
		The default allocator is 'std::allocator' instance.
			Replacing it by type-erased allocator in future is recommended for general scenes, if possible.
				See namespace in [memory.resource.aliases] in WG21 N4480.
		The specialization of APIs are modified significantly since ISO C++11.
			Reference-counted implementation is not allowed any longer.
				Be careful to non-conforming implementations, e.g. libstdc++ shipped before G++ 5, or newer but with old ABI. See $2013-12 report.impl for details and replacement.
	For readonly view of non-owning string, some particular pass-by-value objects should be used instead.
		Non-owing refereces are quite common to use.
			Particularly for strings, the computational complexity is O(1) for length computation, instead of O(1) 'strlen' call for traditional C NTCTS(null-terminated character type strings).
		See 'string_view' of [string.view] in WG21 N4480.
			Prior art for strings has been used elsewhere, see WG21 N3921.
			For arrays there is 'array_view' similarly, see WG/P0122R0. To simplify the APIs, see WG21 P0123R0.
		YBase.YStandardEx.StringView provides 'ystdex::basic_string_view'.
		Furthermore, YBase.YStandardEx.TStringView provides 'ystdex::basic_tstring_view' for strings with termination character only occurs at the end of the string, particully for NTCTS.
			Only specializations of null character as terminators are implemented now.
			Use it carefully, since it is essentially confilict with 'string_view' stuff because of overloading rules.
			Only use it for APIs serve to legacy NTCTS underlying facilities when no ambiguity would be introduced.
Options for threads should be cautious for portable build.
	Option '-mthreads' should be used in MinGW GCC to be compatible with Microsoft VC++ multithreaded environment (with predefined macro '_MT').
	Currently MinGW GCC with POSIX thread model defaults to '-pthread' if not provided '-no-pthread'.
		Although '-pthread' is also available (no effect) for GCC, to be compatible for Win32 thread model in future, options for GCC in build script is not changed.
	For Clang++, there is no specs and '-dumpspecs' is unavailable.
	Currently all compilers without specs are treated as the same. The pthread support is assumed to be existed in the hosted implementations in all cases.
		This also eliminate hard-coded check for specific OS.

$2015-11:

report.impl:
Some metaprograming interface design is concerned.
	Higher-ranked polymorphism is distinct than prenex polymorphism. The difference is the rank, i.e. the number of universal quantifiers appered to the left of arrows in the type signature.
	Some programing languages has native support on this feature based on a monomorphic type system.
		In C++, a type refers to monomorphic type in type theory. Polymorphic types are class templates. Template type parameter is prenex, while template template parameter is higher-ranked. Function templates in class templates can also considered higher-ranked.
		In Haskell 98 (without extensions), types are prenex by default.
	There are some complexity and interface limitations dealing with higher-ranked polymorphic types in genereal.
		Type inference for rank-2 polymorphism is decidable, but reconstruction for rank-3 and above is not.
	Kinds can be a replacement to higher order metaprogramming.
		Though it is also often limited in languages. Until GHC 8, types and kinds are treated differently. See https://typesandkinds.wordpress.com/2015/08/19/planned-change-to-ghc-merging-types-and-kinds/.
		In C++, there are no native support. However class template partial specializations and custom members can be used to achieve similar effect.
			Most notably, member 'type' is used as intermediate implementation for higher-ranked alias templates. This is also fit where alias templates are not available, e.g. TR1 and boost.mpl.
			Function kind '* -> *' can be simulated as boost.mpl style, which expose an 'apply' metafunction to call the specialized class templates as metafunction.
				See http://www.boost.org/doc/libs/1_59_0/libs/mpl/doc/refmanual/apply.html.
			In meta library of range-v3, there are some differences.
				The nested member alias template 'apply' in metafunctions is directed to the result, rather than a type with nested member type 'type'.
				Some helpers like 'quote' are used to help creation of metafunction expressions.
					There are some subtle issues with C++, e.g. CWG 1430.
				See https://github.com/ericniebler/range-v3/blob/master/include/meta/meta.hpp.
		Higher-ordered kind is not supported by standard Haskell but GHC. This is not considered here to avoid extra complexity.
	To avoid complexity, in YBase, design is limited.
		Higher-ordered polymorphism are avoid in template parameters except for several exceptions.
			One is the implementation proposed detection API, see WG21 N4502.
			Another case is some underlying helpers like 'vseq::defer'.
The 'what()' in classes derived from 'std::exception' shall always returns a nonnull pointer value.
	Since ISO C++ [exception]/2 specifies explicitly that it should be a valid pointer suitable as an argument of 'std::strcmp'.
	Thus it is redundant to check nullary of value of 'what()'.
	And the 'what' overriders can be declaraed 'YB_ATTR(returns_nonnull)'.

$2015-12:

report.impl:
GCC now emits additional code for block scope static variable initialization to ensure conforming to the standard (e.g. ISO C++11).
	The thread-safe initialization is controlled by 'flag_threadsafe_statics' in static function 'expand_static_init' in source file 'gcc/gcc/cp/decl.c'.
	It is toggled by '-fthreadsafe-statics' of the driver, which is enabled by default.
	For implemntation with single thread model, this is redundant.
		To reduce the binary size especially for some embedded platforms, the code can be compiled with '-fno-threadsafe-statics'.
			This is also good for compilation performance.
			This is also fit for libstdc++.
				See also https://github.com/devkitPro/buildscripts/issues/6.
				Note that '--disable-libstdcxx-verbose' have been already used for devkitARM, see https://github.com/devkitPro/buildscripts/blob/master/dkarm-eabi/scripts/build-gcc.sh#L47.
			This does not reduce YSTest binary significantly since there are few static variables.
The new GCC toolchain bloats code.
	The new compiler and linker actually optimized for size better. However, libstdc++ bloats significantly.
	It bloats 'YSTest' binary size to 1030KiB(b662) from 1000KiB(b661).
	The mangled names for standard library entities like 'std::string' in libstdc++ with C++11 ABI bloated a lot.
		There have been another issue since G++ 4.9 though: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60936.

$2016-01:

report.impl:
Overloaded function templates for 'std::size' works as expected only with core issue resolutions.
	The overloaded version for array accept non-static member access of array type depends on the change in CWG 616 available in ISO C++14, which forbids it to be a prvalue.
	The deduction for 'std::initializer_list' instance for overloaded version for array depends on the resolution of CWG 1591.

$2016-02:

report.impl:
It is intended that YBase.YStandardEx.Operators classes used in base are publicly derived.
	If only friend functions are used, it does not requires 'public', 'private' can be OK.
		See https://en.wikipedia.org/wiki/Barton–Nackman_trick.
		This is the situation for Boost.Operators and several variants like The Art of C++ / Operators(https://github.com/taocpp/operators)(formally df.operators).
	However, some overloaded operators like 'operator->' and 'operator[]' are only available as member functions.
		Friend declaration is not helpful since they can be used out of the derived classes.
		They are general for iterator overloaded operators.
		Since YBase.YStandardEx.Operators provides such operators, they should be derived with 'public'.
	For simplicity, all classes are derived with 'public', rather than optional 'private' to force users remembering which overloaded operators are used, even it will expose public non-polymorphic bases which should not be used to cast-from.
The allocator '__gnu_cxx::debug_allocator' should not be used.
	Because it is not meet the allocation requirements on non-throwing 'deallocate' member.
	There are generally more powerful and flexible debug methods (e.g. valgrind and DrMemory).
		Even for freestanding implementations without them, memory debugging is still hard with the aid of such allocator rather than cutome ones with desired error handling.

$2016-03:

report.impl:
There are several changes in the library final fundamental TS final draft(WG21 N4480) since WG21 N4081.
	There are several changes for 'optional' requires minor update for return type of member functions.
	The implementation of class 'any' is not effected.
		Note that 'allocator_arg_t' for constructors of 'any' are no longer required, which was not implemented.
		Another change in the specification is explicitly 'is_nothrow_move_constructible_v' noted, which also requires no implementation change.
	The member function 'clear' is removed from class tmeplate 'basic_string_view'. Assignment of empty string view should be used instead.
		See WG21 N4288 (adopted 2014-11) for the modification.
Rules on access specifier for operator bases are amended, based on $2016-02 report.impl.
	Now classes with these bases use 'private' at first, to conform to the general language rules.
	For %iterator_operators_t it is still remained to be 'public' due to possible 'operator[]' and 'operator->' members.
	User code is still not restricted.
WG21 N4279 introduces 'try_emplace' and 'insert_or_assign' for map-like containers. There are some points to be noted.
	Only 'std::map' and 'std::unordered_map' have such interface. Set-like containers do not.
	If needed for set-like containers, it is better to be emulated directly by 'ystdex::try_emplace' and 'ystd::try_emplace_hint' directly because they avoid some significant shortcomings.
		They have less ambiguity (between iterator and key parameter) with generic key type support.
		For overloading with hint, the return value type is richer, i.e. with also 'bool' component to detect whether the insertion has been succeeded.
		They are more generic.
	As emulating 'std::set' rather than 'std::map', 'ystdex::mapped_set' now does not provide such extensions.
		It also avoid heavy dependency on header 'ystdex/container.h'.
	On the other hand, 'YSLib::ValueNode' still provides 'try_emplace', with generic key types support.
		Since it is emulating 'std::map' and non-generic key are too limited.
		To be compatible, overloading with hint is still named as 'try_emplace' and using single iterator return value, with SFINAE detection to avoid ambiguity.
		Some other extensions like typed insertion (for 'ValueNode::Value') are still provided in other names.

$2016-04:

report.impl:
The POSIX function '::close' may return error and set 'errno' to 'EINVAL' or 'EIO', and the state of file descriptor after the call is unspecified.
	See http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html.
	On some implementations, '::close' and some other function calls may always cause file descriptor to be closed even if returning 'EINTR'.
		See https://www.python.org/dev/peps/pep-0475/#modified-functions.
	Ignoring error handling of '::close' for portable code is a common bug.
		See https://stackoverflow.com/questions/19056309/not-checking-closes-return-value-how-serious-really.
	However, for purpose of resource release (e.g. in destructor), this is intended to be ignored.
		Resource release is designed to not propogate any error to provide no exception guarantee.
		There are no way to handle the errors reliably because these errors are not recoverable in general.
		There are also no way to handle the errors portably. It has been existed in pre-POSIX UNIX implemntations.
			See http://austingroupbugs.net/view.php?id=529.
		For implementation does not guarantee the file descriptor being closed, caller should work around.
			However, the mainstream platforms are all behave like this, or there is even no chance to raise 'EINTR' in call of '::close'.
			Thus YSLib currently does not implement the workaround.
	Further, the API is designed to release resource as the main purpose.
		It is different to others, so special handling of 'EINTR' is acceptable.
	To assume 'EINTR' leaving the file descriptor open and then retry to close it is particular dangerous at least in Linux.
		See http://lwn.net/Articles/576478/. In fact, Linux is hard to raise 'EINTR' here.
		If flush is required, the caller should do it before closing the file descriptor, and '::fsync' call may be needed.

$2016-05:

report.impl:
Android GUI architecture in YFramework has been reviewed in progress.
	Early stage is finished. The remained work is delayed to v0.7. Some conclusions remains vaild.
	It is intended to keep the android native "UI" thread as main thread without full inversion of control by design.
		That is, the original thread in call of '::ANativeActivity_onCreate' has a longer lifetime than main routine call on spawned thread.
		Since this thread partially plays a role like Win32 (GUI) subsystem of 'csrss.exe', it should be lived at any time when a GUI client is running in a system-provided GUI session.
	Current implementation only supports DS window emulation.
		This should be updated to a broader capability even if the native Android GUI does not have a window manager supporting multiple windows like a stacking window manager in general.
		It is implemented using direct binding to 'Desktop' instance as a non-hosted platform (i.e. DS).
		This should be changed using a middle layaer as 'WindowThread' under Win32, to get more flexibility for implementing features in future.
			It can still be 'WindowThread' but without requiring a real thread, since there is only one event loop active at any time in one process.
		Problems remained on design of event loop related APIs, for example:
			A class of loop is generally not needed, but since there is direct "looper" out of the box proveded by Android native API, is it reqired to be wrapped?
			The loop is now implemented in 'AndroidHost' of 'YCLib' Android extensions. Should it also be configurable in 'Helper'?
			It is not clear that which precise sets of functionality should be exposed in 'Helper' and 'YCLib' Android extensions.
		It is also not clear that if it necessary to emulate a window manager between 'YCLib' Android extension and 'Helper'.

$2016-06:

report.impl:
There is one change concerned with FreeType2 not clear yet. That is, loading same typefaces might trigger an error message depending on different version of FreeType.
	On platform 'DS', the error message would be explicitly shown and an extra input was needed to continue the program.
		The message is like 'error: Face request error: 00000090' for same fonts.
			According to "fterrdef.h", the error code 0x90 stands for 'Locations_Missing'.
			In normal cases, this indicates missing location table of specific TrueType typeface in the font file.
		This occurred since b357 due to call to 'platform::YSetDebugStatus'. The error should exist earlier, but not shown.
		This was eliminated since b420 due to update to (modified) FreeType 2.5.0.1 from FreeType 2.4.11.
	Further test shows that this was introduced in FreeType 2.5.0.
		The replaced files for YSLib used had no effect on this issue.
			For the issue worked around, see http://savannah.nongnu.org/bugs/index.php?39383.
		For newer toolchain, the YSLib source may need be patched to make it compile.
			Current version of 'string.h' of YBase.LibDefect should be used.
			For 'iterator.h' in YBase.YStandard, type of data member 'transformer' of class template 'transformed_iterator' need to be decayed.
		FreeType 2.4.12 would not prevent the error message.
		The effective change was introduced in Git commit '760d342d37ec9b26420956e3421075d410571b65' of official repository by Behdad Esfahbod.
			The brief commit message is 'Add support for color embedded bitmaps (eg. color emoji)'.
			Change to file 'src/sfnt/ttsbit.c' caused the behavior change.
		The above change was once (wrongly) suspected to be a side effect and filed as http://savannah.nongnu.org/bugs/index.php?48117.
	The reason is that font may contain CBDT and CBLT (for color emoji) tables which would only be recognized since FreeType 2.5.0. If it does not contain other table, the error trigged as expected.
Alias analysing matters.
	ISO C99 has strict aliasing rules. ISO C++ has more restrictions.
		Void types and character types are ruled out in ISO C. Only 'cv void', 'cv char' and 'cv unsigned char' in ISO C++, however.
			This is why 'ystdex::byte' mandated to be 'unsigned char' but not 'signed char'. (And though 'char' is available, its unspecified signedness may cause unnecessary problems.)
		For object within its lifetime, see [basic.lval]/10; otherwise, see [basic.life]/6, [basic.life]/7 and [basic.life]/8.
			[basic.life]/6 is stricter on 'static_cast'. Only cast sequence essentially to 'reinterpret_cast' to 'cv void', 'cv char' or 'cv unsigned char'.
		Also note 'wchar_t', 'char16_t' and 'char32_t' is distinct to the underlying types. In C, they are just type alias to some integer types.
			This diverges the alias analysis in C and C++.
			For example, on Win32, 'wchar_t' lvalue may be safely accessible through 'unsigned short' pointers. This is not true on C++.
			This may cause trouble in interoperations. Use carefully.
		It is utilized as TBAA(type-based alias analysis) in various implementations, to generate better code.
			GCC 4 enables '-fstrict-aliasing' for '-O2' or above, with `__attribute__((may_alias))` to revert it on types other than 'cv char', etc: https://gcc.gnu.org/onlinedocs/gcc-4.0.1/gcc/Type-Attributes.html.
			Clang has implemented TBAA: https://llvm.org/bugs/show_bug.cgi?id=2547, but is lack of 'may_alias' attribute: https://llvm.org/bugs/show_bug.cgi?id=11082.
			So bypassing the restrictions may be not portable anyway in a long time.
		The extra attribute to bypass strict analysing is also considered like type qualifers (as 'const').
			Such rules of the standard is a limitation with mandated 'may_alias' only on several character types, which may be improved in future version of languages or dialects.
		If no aliased value can be used due to the strict aliasing, copying of the stored value in the lvalue may be needed.
		In C++, objects can be dynamically allocated using placement '::new' expressions, though other rules still limit the access on the underlying storage.
			The underlying object does not need to be array of 'cv char'.
	ISO C99 has 'restrict' to ease alias analysis.
		This is not type-based. However, violation of it also causes undefined behavior.
		This imporves the performance of carefully written C programs, comparing with FORTRAN programs.
		C++ has no similar features except for similar extension in dialects, typically spelled as '__restrict'.

$2016-08:

report.impl:
The standard library class "std::nested_exception" only takes currently handled exception.
	So there is lack of efficient way to create a nested exception object to be thrown.
	Stick on try-block, throw, catch and then call "std::throw_with_nested" instead.
		Use proper macros to ease the work in YFramework.
Now external file accessed by YFramework (including the configuration 'yconf.txt') uses file locking in hosted environments.
	Combined with file opening atomicity improvement, this reduced some race conditions.
	However, TOCTTOU access can still not be totally fixed.
		See https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use#Preventing_TOCTTOU.
	See also $2015-09 report.impl.

$2016-09:

report.impl:
In YSLib, bare passive clause is preferred for exception message or other error handling messages, besides those in assertion strings, etc.
	See also $2014-08 report.impl.

$2016-12:

report.impl:
Note the standard does specify that 'std::allocator' may differ with new/delete.
	Avoid mix new/delete with allocator.
		Especially be cautious to default deleters in smart pointers.
	Current libc++ does it theoretically wrongly in the large handler in <experimental/any>.
		Although the behavior can still be expected when 'std::allocator' is provided by libc++, which should be normal.
There are some troubles with Windows 10 rs2_prerelease console output.
	Buffered MBCS-oriented stream cannot interact well within the console.
		However, wide-oriented console output works.
		It seems that the underlying implementation would assume wrong width (number of bytes) of a multibyte character.
	It can be worked around by disabling the CRT buffering on the stream.
		The 'stdout' is buffered by default.
		The standard 'std::setvbuf' with '_IONBF' works.
		The call of 'std::ios_base::sync_with_stdio({})' also works, but it has side effects on console color setting.
			Notably, the '::SetConsoleTextAttribute' call of setting foreground color would have effect on the whole line instead of the output text after the call.

$2017-01:

report.impl:
Call expression of 'invoke' and its derivations like 'ystdex::invoke_nonvoid' is concerned.
	The left operand (pm-expression) of '.*' operator requires lvalue for build-in forms.
		The original form would accept non-lvalue left operand well-formed constructs, being distinct to the built-in operator rule.
	It is now changed to be aligned with built-in rule in 'ystdex::invoke'.
		It may being more friendly to catch bugs of wrong use.
		Now it is also same to the original proposal WG21 N4169 and the working draft WG21 N4606, without additional specification modification.
			Except for addtional of 'reference_wrapper' support is not included now.
				This was in the resolution of LWG 2219.
				See also N4170, though it seemed not to be accepted.
				It is likely to be supported in future in 'ystdex::invoke'.
		Note the original proposal N4169 seemed to miss this point.
			It was fixed in the referential implementation as https://github.com/tomaszkam/proposals/commit/8e9150acd1635f6cd33cb7db3f52e0c217538cd2.

$2017-02:

report.impl:
The 'TokenValue' type was introduced to eliminate non-terminated loop for reduction of delayed terms in 'EvaluateLeafToken' in build 753.
	Since delayed term evaluation would request retrying, it would be trapped in 'EvaluateLeafToken' again and thus it would loop forever if the term being evaluated was not changed.
	It was proved that allowing only 'TokenValue' rather than 'string' to be evaluated as tokens was an effective way for the purpose.
		'TokenValue' was a form of explicit unevaluated operands.
	However, the root cause was lack of proper normalization (i.e. 'Value' cleanup) after a successful reduction.
		This was fixed in build 755.
	The 'TokenValue' is still necessarily for ontology purpose, since token is not a simple lexeme in the design.
		There can be opportunities to insert some more semantic actions in this intermediate layer.
Some points about unevaluated expressions are concerned with the current implementation.
	There are different mechanisms to implement unevaluated expressions.
		As unevaluated expressions, 'DelayedTerm' is for general purposes after lexical analysis.
		'TokenValue' is different.
			It is used in lexical analysis passes.
			It is only for symbols, i.e. tokens to be evaluated, rather than arbitrary expressions.
			It is better on performance since no new terms have to be constructed during the evaluation.
		Transformation like 'TokenizeTerm' would be still preserved within a preprocessing pass in REPL context for saparation of lexical phase from further evaluation.
	Unevaluated expressions can be explicitly evaluated in function 'A1::EvaluateIdentifier' in module NPL::NPLA1.
		Terms of 'TokenValue' and 'DelayedTerm' would be processed differently.
		For 'TokenValue', it is done here directly rather than by wrapping in a new delayed term and than calling 'A1::EvaluateLeafToken' for 2 reasons:
			Const-correctness is needed on parameter with type of reference to 'ContextNode' and in other cases the 'A1::EvaluateIdentifier' function has no need to modify the context node.
			Performance of direct handling is better because wrapping a term in 'DelayedTerm' is more expensive and there is no good reason to do that.
		The evaluation of unevaluated 'TokenValue' does not check the possible infinite loop.
			It is the responsibility of users of the API to configure the evaluation passes properly to provide strong normalization property on name expression evaluation required by the specification of NPLA.

$2017-03:

report.impl:
Style of the Kernel language can be compared with current NPL, esp. NPLA1.
	The current specification is Revised^-1 Report on the Kernel Programming Language, with some rationales in the text.
	There are many similarity on design consideration. Despite developed without reference to Kenerl, many features are occasionally the same.
		The Principle G1 and G5 of Kernel is informally or implicitly implied by NPL design.
		Both can have homoiconic representations and many shared conceptual models of modern Lisp dialects.
		The same key feature is first-class support of modern forms of fexpr with lexical scopes.
		The naming of identifier like '$lambda' are often the same, with slightly differences on meaning.
			The original of '$' in NPLA1 is to express reserved identifier as well as traditional C-like '__'.
			It later changes to be function with unevaluated operands, i.e. fexprs, which is same to Kernel.
	Not all design are same, in the root of the design philosophies.
		Fundamental principles not only for ordinary users but also are significant for users who derive the language in NPL, are lack in Kernel.
			They may have higher priority in general.
			A dedicated example is the zero overhead principle.
				For example, operand tree matching does not requires duplication check, see description below on parameter tree.
		The Principle G2 of Kernel is not used by NPL design, because NPL is not designed to be a direct replacement of a Lisp dialect.
			However, Kernel is largely derived from R5RS Scheme.
			See below for differences about supported features.
		The Principle G3 of Kernel is informally used NPL design, but there can be difference on judgement of exceptional cases.
			That is, what is the precise extension of "dangerous computation behaviors", and what is "by accident".
		The Principle G4 is not used directly since it is better to be specified by derived implementations.
		Since NPL is designed as a family of languages rather than single general-purposed language in the very beginning, it requires no principle of single set of disciplines on interface design.
			Particularily, there is no guarantee on ease of use or avoiding misuses in general, which is inconsist to Kernel.
			Such properties are designed to be specified in derived implementations, which is an issue of QoI (quality of implementation) rather than designing.
		NPL has more focus on composition of abstraction.
			In general, NPL would prefer lower-level implementation-dependent features to abstract.
				This is often to avoid to violate the philosophy of zero overhead principle.
					If such lower-level features are not provided, users may have to fight against low usability with portability of the code.
				The feasibility to introduce required functionalities should be kept. The usability should not be effected significantly.
			Some notable (global to the language design) examples as listed here.
				NPL prefers 'eqv?' than 'equal?', which is opposite to Kernel.
					The applicative 'equal?' is meant to be composited based on 'eqv?' or other API by design.
					The reason is that the difference of list and non-list terms are intrinsically and generally non-avoidable in the languages.
						To mandate 'equal?' while not 'eqv?' would be the nontrivial case of non-composable interface.
				NPL prefers acyclic representations and data structures by default.
					This choice implies acyclic ownership relationships in design.
						So garbage collection is essentially not needed specifically to break the cycles.
						Note NPLA renders undefined behavior for unexpected cyclic references.
					This choice simplifies overall design and its implementation a lot.
						NPLA does not support circular substructure in syntax.
							This simplifies the syntax. It is now more like reduced S-expression used in SXML, rather than in traditional Scheme dialects and Kernel.
						It eases some specification of acyclic constructs.
							So it is unnecessary to specify acyclic constructs like parameter tree for '$vau' in Kernel.
						It simplifies the implementation of many derived functions which have to guarantee the termination in traditional Scheme dialects even for circular-referenced data structures.
							For example, 'equal?'.
						It merges different representations of the operand.
							So it need no different treatment on operand as 'list' and 'list*' in Kernel.
						It also wipes out the vulnerability in some simple Kernel derivations.
							For example, 'list*' would be definitely terminated since the elements of a list is finite.
					This choice gives users the leeway to determine where to break the cycles and the chance to adjust the trade-offs in higher levels of abstraction.
						It plays better with zero overhead principle.
						If cyclic representations or data structures are necessary, use specific library derivation to solve the specific problems.
						Though facilities to operate on cyclic data structures are not provided directly now, they can be written by users.
							Mostly the base data structure would be a list with custom value type.
							The cost of operating and interacting on different value types depends on users.
					This have impacts on implementation of a few features, notably, first-class recursion by resolving defined names.
						This is different to traditional Scheme dialects and Kernel which hide recursive capability in the primitive "define". Note this may be underspecified in these languages.
							Their specifications do not state the recusion visibility of freshly defined symbol in "define" clause explicitly.
							Alghough it can be partially inferred by requirments on properly tail-recursive calls.
							Nonetheless, the capability for "letrec" family is explicitly specified.
						NPLA does not required it directly. All of the usability of it is up to the operatives for environment mutation being used.
							Since first-class environment is supported, it would be built on environment mutation, at least internally.
							The basic one may not support recusion at all.
							The advanced one can support recursion by nesting one more static environment internally.
							For "letrec" families, it can be composed by basic primitives, similar to Kernel.
						This also has impacts on resouce management in closures, notably, when mutual closures are incurred.
							The lexical mutual references are still allowed.
							However, acyclic ownership relationship are effectively required, otherwise the behavior may be undefined indetermintely.
							To reduce undefined behavior by accident, some mechanism for resource management is needed, optionally.
								For example, garbage collection or region inference.
								Not all of these are good to use.
									See discussion of basic feature adoption below.
								NPL/NPLA/NPLA1 all mandate yet nothing in this area.
	There are many differences on adopted basic features, which has obvious effect on functionality of primitives.
		NPL mandates resource semantics which implies ownership and object models in derived implementations, while Kernel as well as traditional Lisp relies on unlimited extents of objects.
			NPL allows undefined behavior on reference with different object models, while Kernel requires garbage collection.
			For general use on resource management, garbage collection is not acceptable as the center ownership holder.
				It also violates design of first-class object endorsed by Kernel.
		NPL mandates no external representation as traditonal Lisps and Kernel do.
			If necessary, they can be specified by derived implementations.
			If needed, they can be implemented by users.
		Lisp-like pairs (cons pairs) are not used as basic data structure of the internal program representation. So interface for pairs is deliberately omitted. Note pair mutation is also optional in Kernel.
			There is also no null cell of this sense in NPL.
				However, empty lists still exist. They can still be tested by 'null?' predicate.
			Dot notation is not supported in the syntax.
				This simplifies the syntax, having simliar effect as given by avoiding circular substructure.
				Althoug there needs additional treatment to variadic parameters.
			The syntatic element is either a list or an atom (a non-list), though the latter can have a list value.
				Others (non-list linked data structure including cyclic) are considered irregular.
			Combiners do not support irregular data structure.
			The 'apply' applicative accepts only list as in Lisp, not as it in Kenerl.
				This loses no exresiveness since underlying operative also does not support irregular data structure for simplicity.
		NPL mandates no encapsulation.
			This can be good extension for the language generally in future.
			If needed, they can be specified by derived implementations.
		NPL mandates no partitioning of types.
			First of all, mandatory type system is avoid by design. See discussions below.
				The minimized requirement on typing leads agains to partitioning as a whole base system of typing.
			To allow variaties on interoperability, the type system in NPL is essentially not encapsulated.
				If needed, they can be specified by derived implementations.
					This is at least not the case in NPLA for C++ interoperations.
			This transparency also provides more flexibility to extend the language.
			Type predicates are essentially unspecified to be primitives or not.
				A type predicate only exist when the type exists.
					So no predicate is for a nonexisted type.
					This can occur when a value is only designed to be a unevaluated tag, like '#ignore' in Kernel.
						Since NPL mandates no external representation as traditonal Lisps and Kernel do, the data type is not required in most cases.
						This leads to simpler design in specification both on semantics and API.
				Predicates like 'bool?' would be specified in the type operation library as derived forms.
				Primitive type predicates always take one argument for simplicity.
		NPL deliberately keeps cyclic representation out of the program directly.
			This is opposite to Kernel as well as traditional Lisp.
			It is necessary to avoid bloating the minimal specification of a general language.
				This largely simplified many lengthy implementation of derived forms.
				If needed, features for cyclic data structures can be provided by library.
		Proper tail recursion is not required in NPL as in tradition Scheme dialects and Kernel.
			Most requirements on tail recursion is an issue of QoI rather than design, so it is not mandated.
			Ideally the operation on raw activation record frames should be deterministically handled.
				This requires the failure of allocation of activation record frames is always predicatable.
				Undefined behavior of recusion call failure in hosted language should be avoided.
					In typical naive native language implementation (e.g. C or C++) without TCO (tail call optimization), call stack overflow are unavoidable and it could be essentially unpredicatable even in aspect of implementation.
					So the implementation of object language should provide some guarantees to avoid such cases.
						Proper tail recursion is one effective way to specify the needed property.
			NPL does not specify the requirement of the general deterministic requirement on activation record frames yet.
				NPLA might require it someday.
				The form about requirments on tail calls would only be applied after there is a foundation of implementable rumtime continuation implementation.
		Kernel provides predicates for some special placeholder values, while NPL is not, for several reasons.
			The placeholder value needs to have a type only when it is evaluated.
		The value '#inert' is not supported in NPL because it is more correct to leave unspecified values as precise as the specification about the language semantics.
			To avoid misuses as additonal features is an issue of QoI but not requirements on language expresiveness.
			Even NPLA1 always uses %ValueToken::Unspecified for the unspecified values in API level, it is not required by the core semantics of the object language.
			This also recovers traditional 3-term form 'if' which is wiped out in Kernel due to inconsistency caused by explicitly overspecified '#inert' requirement on the result.
			There is no type or predicate for '#inter'.
		Formal parameter tree and operand tree of Kernel are not adopted in the same way in NPL, since there is no cons pairs in the internal representation.
			The NPL formal parameter is always a tree of either of a non-list or a list.
			Because there are no cons pairs to splicing the parameter in NPL, other mechanism is used to express variadic elements of parameter.
				The notation '...' is used to capture a list in the end.
					Since it can only occur once, there is no need to name it with specific symbol specified by users.
					For simplicity, named parameter like context parameter in the '$vau' operative is not provided.
			Operand tree matching does not requires duplication check, even it is indeed bad when misused.
				Kernel specifies the check mandated.
					This has trouble since other unique symbols can be rebound, so there must be extra mechanism taking extra resources (i.e. memory) to handle it correctly.
						This is a direct violation of the principle, so it is not adopted in the design.
				If the check is needed, it can be implemented ahead of matching.
		Many of combiners can be derived as Kernel does. However, not all are recommended implementation in NPLA.
			NPLA and NPLA1 may provide builtins as hosted primitive combiners to implement them.
			Derivations in Kernel can be time-ineffieient. Only in extreme conditions that the binary image size is important, the derivation can be used instead of builtins.
			The derivations could also easily have more unnecessary dependencies of implmentation, lead to bad design of dependency constructs and QoI.
				For example, the applicative 'list' as one of the fundamental core features:
					It is derived from '$vau' and '$wrap' in Kernel.
						In NPLA1 it works similarly, with slightly different syntax since '$vau' NPLA1 support multiple expressions at the end.
					In NPL it can be implemented around 'NPL::ReduceToList'.
					Even no extra specific NPLA1 implementation is needed.
						This is different to '$vau' and most other combiners.
						The combiner '$vau' is OK as a primitive for language specification, as some kinds of "inversion of dependency" on interface design.
						But it cannot be primitive enough in most cases based on reduction systems in reality.
							Nevertheless, it is still to be implemented as a builtin.
		Syntax of composite (by juxtaposition) terms is different to traditional Lisp dialects, esp. application for functions when there is no operand.
			Since NPL uses different syntax of parenthese to indicate composite expressions, the parenthese never stand for "application" solely.
				Note '(foo)' would reduced to 'foo' in the main reduction function which used as the default evaluator in NPLA1.
			Evaluation of combined terms are indicated implictly by boundary of expressions.
				This is different with traditional Lisp or Kernel where '(' and ')' are used to indicates application or combining.
				This is mostly to refine the tokens '(' and ')' play uniform roles of the expression boundary.
				It decouples the combining rules with the problem of empty list evaluation.
					Whether empty list evaluation should be well-formed or not has nothing to do with combining.
					It is actually ill-formed in most contexts just because the empty list is not expected to occur.
				It makes expressions easier to type in.
					As an example of motivation, in an REPL or interactive command line shell, there is no need to type in '()' around to evaluate the application.
				Some operatives are designed with this in mind.
					For example, the '$vau' operative supports variadic expression directly.
						There is no derivation of '$vau' like Kernel to support multiple expressions.
						Note the evaulations are not sequenced.
							If needed, '$sequence' should be used explicitly.
			To support evaluation on combined terms without operand, there has to be extra syntax to handle.
				The old hack is to remove '()' when the term has to chilren and '()' is in the 2nd position.
					This works only on applicatives, otherwise '()' which cannot handled by the default evaluator would be wrongly removed if the term has 2 children occasionally.
					Even on applicatives it does not work reliably.
						The handler has to implement special case (of no argument) if empty list is needed to be recognized as an argument, e.g. in 'list?'.
							This makes the implementation complicated a lot.
							It is also wrong in the exception message when the arity is mismatched.
				The new syntax contains support of prefix '()' mark to indicate the application.
					Now '() foo' (with explicit enclosing '()' or implicit boundary) is same to '(foo)' in Lisp-style syntax when 'foo' is the name of the function.
					This is a breaking change.
					Now empty list only can be part of the operand.
Mandatory type system is avoid by design of NPL, for both philosiphical and engineering reasons.
	Typing is not the silver bullet.
		There are multiple different uses that are not equally intuitively recoginzed by users, which causes confusion.
			Typing is first invented to rescue the mathematics foundation from Russell's paradox.
			Type system to be modeling (like in traditional OOAD and OOP approach) tools are plausible, but not strictly required in general.
		Naive design easily cause problems in design and applications.
	Mandatory type system is simply out of scope of the design of an expressive language aiming to be general-purposed, since there is no one-size-fit-all option in type system design.
		To be most general-purposed, the disciplines of typing have to be weaken engough.
			The main reason is to avoid insonsistency and to keep feasibility serving as many as domains.
			It utterly leads to no typing at all, except those necessitied for composing other non-typing first-class features.
			For example, to describe some domains of required values, normatively discrete types are required.
				One motivating concrete instance of this example is boolean value used if first-class conditional controlling constructs.
					It requires the dinstinction of 'bool' vs. others.
				This still minimizes the requirement on typing.
			The weaken disciplines effectively reject static typing as a mandated builtin feature of the language.
				Static typing is essentially built through refinements by phases (discrete "static" and "dynamic" phases like "compile-time" vs. "runtime") of underlying reduction disciplines.
					These underlying disciplines are expressed in either formal languages (metalanguages) or natural languages directly in the specification of the language.
					When mandated, it indicates there are some domain-specific rules are encoded in the specification of the language.
						Since it is mandated, conforming implementations cannot skip them, which may easily harm generality if the domain requirements are not suited to the typing.
				So the engineering weakness of high cost of wrong choice on typing can be (hopefully) minimalized.
	Mandatory of type systems requires a lot of unavoiadable work in specification even it is known not fit for several domains, which is agianst to simplicity of design.
	Similarly, it requires a lot of work on conformance in implementations.
	Type systems, if any, should be pluggable.
		The idea and similar consideration are available at http://www.bracha.org/pluggable-types.pdf.
	A related notion with similar side effects is nominal typing, which is used by contempory languages widely.
		It can be useful, but wrong design with static typing can have more power to make things in a mess, and little effort can be done to recover the errors.
			For instance, see http://stackoverflow.com/questions/4488727/what-is-the-point-of-dbnull.
		The necessity of mandatory on nominal typing is particalarly a widely adopted misconception.
			It makes users being confused of the purpose of typing (logical limitation vs. modeling, see above).
			It makes users being ignorant to other typing schemes.

dep.merge:
libfat 1.1.0: reviewed, partially merged, partially shelved.
	Changes in libfat 1.1.0 (distributed by devkitPro r46) are reviewed.
		In summary, no changes except one minor are to be ported, and there is one extra change to be evaluated.
		All changes are not ported now.
	Change https://github.com/devkitPro/libfat/commit/abde1cb73b585ac5fc76b8d4d5d598ad6841597d is not applicable.
		There is no separated install script.
	Change https://github.com/devkitPro/libfat/commit/73ccaec8154e2a12fd8995514e10 is not applicable.
		Since 'NAME_MAX' was used instead of 'MAX_FILENAME_LENGTH' at beginning in the module YCLib::DSIO.
	No changes in https://github.com/devkitPro/libfat/pull/9 has to be ported.
		These changes were merged in https://github.com/devkitPro/libfat/commit/d4926573ac184656146f39749192372b3b7388b0.
		No change has to be ported as https://github.com/devkitPro/libfat/commit/d59c7c8b35fedc2b247afee56d91c2a44101253d.
			Since 'platform::LFN::ValidateName' had done it right since build 657, originated from 'DEntry::AddTo' since build 611.
		No change has to be ported as https://github.com/devkitPro/libfat/commit/3fde6ce161db5293a302ef5b839483065526c3b5.
			The change is questionable on POSIX conformance.
				See https://github.com/devkitPro/libfat/issues/10.
				The original is conforming.
			Member function 'platform_ex::FAT::Partition::Unlink' followed the original implementation.
		No change has to be ported as https://github.com/devkitPro/libfat/commit/b7c4d38b320b8da0c9e318dbbdc2cc0ad966a93b.
			The change is still conforming to POSIX, but unnecessary for conformance.
			The change reduced QoI since it made client code less probable to detect the error.
	Change https://github.com/devkitPro/libfat/commit/9e2f91dee6c27e797bb510320bb359cce11c1015 is deferred to be evaluated.
		The change on type of internal file descriptor may be required by new toolchain in devkitPro r46.
			However, it is not planned to be updated immediately.
	Change https://github.com/devkitPro/libfat/commit/78ca2bd297f59b617fb1d0241e9f32393aa9f1ca is not applicable.
		The '-ffunction-sections -fdata-sections' has been used on whole YFramework compliation for years.
	Change https://github.com/devkitPro/libfat/commit/b7450524b18118df693870f64242cabf5d62234b is to be ported.
		It may be better delayed, waiting for '::isDSiMode' brought by libnds 1.6.2.
		However, it is trivial, so the port is done directly using internal '::__dsimode' currently.

$2017-04:

report.impl:
Recursive captured vau abstraction names in variable binding constructs (e.g. definitios) in general need some special treatment including shared ownership.
	The evaluation order of vau abstraction expression implies the side effect of binding sequenced after the evaluation of the binding target.
		So without additional mechanism, resolution for recursive name used as definiends cannot be implemented in evaluation of binding target.
	For binding constructs like '$define!' in Kernel, multiple symbols can be bound at same time.
		The recursive binding constructs need to store data structure holding the mapping from bound symbol to reference during evaluation of the binding construct.
	For encapsulation reason, the vau handlers need to store captured symbols in its static environment.
		So they cannot be modified after the binding expression is evaluated.
			Thus shared values are mandated to modify them after the side effect of binding.
			This cannot be implemented using determinstic initialization only once.
			This can be implemented in a 2-phase manner for simplicitly.
				First, for each symbols to be bound, it need a thunk to hold the state (value of functions) temporarily, which is never intended to be called.
				Second, after evauation of binding constructs, the bound references are ready to be referenced.
					Thunks are assigned to the real bindings.
					There may be some housekeeping on the names being bound for ownership reason (see below).
	The lifetime of owning references should be longer than any external non-owning reference, otherwise it would not be first class or there would be traditional funarg problems.
	It is obvious that if none of the references to created functions are owning, resource introduced by bindings will leak.
		To prevent the leak, at least one reference should be owning.
		For each bound name, only one reference is special, if any. That is, the reference on name being bound.
	For the reasons above, and since GC is not allowed by the design, it needs shared ownership.
	However, if all references are based on (reference-counted) shared pointers, there would be cyclic references.
		Resources would leak eventually.
		The cycles are explicitly disallowed by the design for the very reason.
		So weak references are needed.
		To be deterministic and simple, the reference to entity denoted directly by the defined name is to be owner.
	There is one more problem to implement 'unwrap' like Kernel.
		The type of object bound on the name is actually not the same to a directly bound object if no trick is performed.
		Thus, the bound object has to be a proxy with same type referenced by a non owning reference and builtin shared ownership.
	The solution used in NPL implementation is hidden behind the native form implemantation of vau abstractions.
		It uses a thunk data type holdings the shared 2-phase initialization thunks to be initialized.
		In the 1st phase, the thunks are initialized to default value of context handler which will always throw when called.
		In the 2nd phase, after the evaluation of the binding target and side effects of bindings, the thunks are assigned to the newly initialized real bindings, and the bound references are replaced with the proxy.

$2017-05:

report.impl:
Symbol evaluation is reviewed.
	See $2017-02 report.impl for previous status.
	To make symbol term to be evaluated only once, the reduction now produces 'ReductionStatus::Clean' rather than 'Reduction::Retrying'.
		This make '$set!' implementable as in Kernel.
		This also makes it unnecessary to care about normalization besides infinite execution in leaf token passes.
Names as replacement of 'car' and 'cdr' are considered.
	For short, the anwser are 'first' and 'rest', currently.
		The name 'first' is consistent with SFRI-1, Racket, Clojure, etc.
		The name 'rest' is consistent with Racket, Clojure, etc.
		They may be not best names, though.
			Notably, 'first' should not imply the numeric value 1.
				Nothing is relying on the Peano axioms here.
				Exact numbers are also not required in gerenal.
					Though Kernel relies on it for some cases like derivation of 'map', they should be better avoid in the spirit of the principle rules of Kernel itself.
				It is still acceptable when noted.
	The old names are bad for several reasons.
		They are leak of implementation details historically.
			See https://en.wikipedia.org/wiki/CAR_and_CDR.
			This is not the case of 'cons', which is still accaptable here.
		They have no clear lexical meaning.
			This may be compromised because it seems that English has no specific words for the components of a pair.
		The name 'car' is misleading to English-centric speakers because of its meaning other than in Lisp world.
			It is even more misleading in sense of Chinese (with primary school education, probably), for obvious reasons in mind of native speakers of Chinese.
		It is sill not fully resolved that nested name like 'caddr' are not natually support in alternative naming schemes.
			Although things like 'ffirst' can be supported, they are not natural enough.
			For 'caddr' ones, it can be complemented by adding support of SRFI-1 ordinal names like 'second', 'third', etc.
			For others, it can be argued that those name should not be used to get the code more difficult to read, besides the probable ease of writing.
			And even mandated (by RnRS, etc), the nesting level is limited, which can be fatal to treat them as necessity.
				So things like 'list-ref' are still superior in general, besides it is relying on the exact integers so it may be limited by other way (e.g. by dependency management policies in base library).
			Currently NPL does not support them at all.
				They may be also better avoided in derivation of library functions.
		See also http://arclanguage.org/item?id=10546.
		Someone may think lack of such names would violate the principle of least astonishment "for people coming from Lisp".
			For instance, http://software-ninja-ninja.blogspot.com/2011/08/clojure-patterns-cons-car-and-cdr.html.
			But more importantly, those old names has already violated the principle for other people, which is still not a good reason to be kept.
			Moreover, the 'cons' form is still supported in such case.
				In fact, it requires 2nd argument as a list in all major derivation of Lisp.
				It is actually the right design choice to signal an error for 'cons 1 2' because '2' is not a list.
			And anyway, cons pairs are still virtually supported in NPLA1 as well as in Clojure.

$2017-07:

report.impl:
Code bloat of exception message is still not resolved in the devkitARM release 46 toolchain.
	See $2015-12 for previous status.
	See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60936.
		This is not backported for GCC 6.
	This may be better in upcoming devkitARM release 47 since it would update to GCC 7.
Use of direct evaluation is general preferred, even '$quote' has been now introduced.
	This is as the same style as in Kernel.
	In general, there are no need to '$quote' since 'eval' handles lists well.
		Lists are constructed by 'cons', 'list', 'list*' or other constructors.
	However, when necessary, '$quote' can improve some readability by avoiding excessive nested 'list' applicative in the 1st operand of 'eval'.
		This may also likely (but not guaranteed) provide some performance improvement if used properly.
	Passing a symbol to be evaluated without knowledge of enclosing environment can be potentionally dangerous becuase access of dangling references denoted by symbol after rebinding will cause undefined behavior.
		Direct 'eval' style has already prevent it largely.
			Symbols to be bound can be specified as operand as '$vau', or derived modifying operatives based on it (e.g. '$set!' and '$setrec!'), with no need to construct symbols reflectively (e.g. passing a 'string->symbol' result as an operand).
		The use of '$quote' also reduce necessity of reflective use of symbol further.

$2017-08:

report.impl:
Transformation of lvalue expressions support in NPLA1 implemented carefully.
	There are multiple purposes to add such support by an intermediate layer (i.e. 'TermReference') with massive update in implementation of evaluation routines.
		One is to add support of modifiable reference in specific operations like '$set-first!', without mandatory reference for each first-class objects.
		The second is to add support of list reference as well as other reference to terms.
		Another is to make it extensible for more metadata, esp. type tags like 'const' qualifiers or rvalue references, and new value categories like xvalue.
	Basically, well-formed code should need no modification to function well.
		The only exception is that varibles (implictly) captured by vau abstractions would now get reference semantics and this feature is explicitly documented.
	In general, to support lvalue reference with such backward compatibility kept, a universal conversion on the operand tree is needed.
		This is 'NPL::LiftToOther'.
	Every term of const lvalue that would be evaluated should be considered.
		Since the operand tree does not support lvalue references as binding source yet, each instance also needs to be handled properly.
			This is simplified as 'NPL::LiftToSelf' before other operations.
		The parameter tree is not so special.
			It still needs to be handled similarily since it might be evaluated as well, though not common when directly used (in vau abstractions).
	For terms that are not to be evaluated, direct 'LiftTerm' call is still OK.
	There are also other simpler operations provided by NPLA.
		For example, if no recursion is needed, 'NPL::LiftTermOrRef' can be used to replace 'NPL::LiftToOther' or 'NPL::LiftToSelf'.
			There is no real instance to use it currently.
		Direct access like 'NPL::ReferenceTerm' is more efficient for operations like equality test.
		Call of 'NPL::AccessTermPtr' can also be used to replace 'YSLib::AccessPtr'.
			This is not necessary after call of 'NPL::LiftTermOrRef' or similar functions.
	For operations only require immutable reference, new underline expression categories are to be introduced.
		They are not in schedule.
Update of devkitARM is carefully handled.
	The build system is modified a little to adapt to devkitARM r47.
		The command 'objcopy -O binary' would not work properly.
			It would produce a large binary with all sections and made it failed to link.
		This would actually not work since devkitARM r46 after update of linker script and crt0 objects.
	In FAT implementation in YFramework on platform DS, max lengths of name have been changed.
		This is caused by upstream change of value of 'NAME_MAX' macro in header <sys/syslimit.h>.
			The value previously in devkitARM r44 (as used by b611) is 768, and was changed to 255.
			See https://github.com/devkitPro/newlib/commit/770821c9e4745d69c2df69624f0e4b1f759ecfb6.
		The value of 'platform::FAT::LFN::MaxMBCSLength' is adapted in 'YCLib.FileSystem' for 2 reasons:
			To make the static assertion in 'YCLib_(DS).DSIO' happy, otherwise it does not compile.
			To make the actual limitation sane, otherwise the length error condition is wrong.
		The value of 'platform::FAT::LFN::MaxLength' (for UCS-2 sequence) is also changed to keep it not greater than length of converted MBCS.
		As a result, length of FAT long filename greater than 255 now does not work.
	The upstream newlib libsystem file descriptor change need 'YCLib_(DS).DSIO' to be updated now.
		See also the deferred change in $2017-03 dep.merge.
FAT initialization error has been tested and revisited.
	The error is the failure to initialization FAT partition and the FAT mounting is thus aborted.
	The error is caused by a wrong condition check after successful reading of master partition table entry.
		It returns 0 as error, so sector 0 is still to be verified (whether it contains the FAT signature).
			This would fail because sector 0 is checked to has no signature.
	This error does not occur on DeSmuME because the bootcode ensure the sector 0 has valid FAT signatures.
	It would occur on real DS with a typical real card. It could be shown clearly since some revision between b656 to b669.
		Before that revision, the error message is incomplete (for other minor bugs in message printing routines during initialization), but it was believed to be this error.

dep.merge:
libfat 1.1.0: reviewed, partially merged, partially shelved, tested but not merged into master branch for some issues (e.g. binary code bloating).
	Change https://github.com/devkitPro/libfat/commit/9e2f91dee6c27e797bb510320bb359cce11c1015 is ported.
		Actually it is adjusted manually independent to the commit.
	Change https://github.com/devkitPro/libfat/commit/b7450524b18118df693870f64242cabf5d62234b is ported.
		The function '::isDSiMode' is used instead of internal '::__dsimode'.

$2017-09:

report.impl:
Safety of 'eval' should be carefully maintained in NPL.
	The memory safety should be kept like local closure reduction like beta-reduction of vau abstractions, unless it is proved no local references would escape.
		The memory safe is broken when the result references a subexpression of the expression being evaluted.
	The reevaluation should be limited in one environment.
		Or simply be forbidden, if different evaluations are not guanteed to be in the same environment.
	These security wholes prsented since build 772 in function 'NPL::A1::Forms::Eval'.
		Both defects have been fixed in build 802 by using 'NPL::A1::ReduceCheckedClosure' with addtional call to 'NPL::CheckNorm'.
	The fix makes Kernel-style applicative 'get-module' can now work properly (though it is not provided in YFramework yet).
Tracing output for NPLA is reimplemented. Changes are dealt with cautions.
	It is now based on separated logger in the context object since build 803.
		This allows more precise control of single context logging.
		In each context object, there is a trace object based on logger object to support the feature.
			This allows user to override the default method of logging to provide variant traces, like 'SHBuild' does.
	The need of modification on 'Logger' class is done for mainly on copy and move constructors.
		There is a problems dealing with exception specification on 'std::function' object.
			This is resolved by the current standard draft. It would likely be in the next standard (ISO C++17).
			This is already available for some implementations before the standard guarantees.
			So this has been worked around by detection of standard library implementation before the next standard is available.
	For NPLA, only one case is the consumer. This is vau handler invocation in NPLA1, which is somewhat performance-sensitive because it would be called very frequently.
		So there need to be little overhead in release configurations.
		This was previously a non-issue because in release configurations no code for 'YTraceDe' would be actually generated.
			Instead of 'YTraceDe', the text is less verbose since build 803, without line number by default.
		However, this is now an issue since build 803, where logging is directly called via member function of trace object in the context.
			Since the default value of 'CXXFLAGS_OPT_UseAssert' has no 'NDEBUG' and logger filter level is default to 'Debug' instead of 'Informative' when 'NDEBUG' is not defined, it cause problems.
				The stage 1 'SHBuild' is the only program effected in default configurations. It would print many diagnostics usually not interested during stage 1 bootstrapping.
				There can be more in user code.
				Note the standard library macro 'assert' relies on 'NDEBUG' setting so it cannot be changed easily.
			And this is no longer effected by 'YB_Use_YTrace' macro.
		Since build 804, SHBuild is aware of issue and it set filter level explicitly to resolve the problem.
			If the tracing messages are needed again in future, it can read configurations to change the behavior.
		User programs are still need to make change when assertions are enabled through 'CXXFLAGS_OPT_UseAssert' or in debug configurations to get old behavior, since build 803.

$2017-10:

report.impl:
Proper tail calls are considered to be implemented.
	The main purpose is to guarantee no stack overflow would be caused by nested calls in the object language.
		There may be some other ways, but this is most intuitive.
		It also provide some benefits on computation complexity of function calls.
	Since the host language does not support proper tail calls, it needs to be implemented in the object language translator.
		Here it is in the reduction.
		This is implemented by using trampolines of CPS(continuation passing style) to make the implementation portable among host implementations.
			It is in general not efficient, but choosed for some other reasons.
				it can get rid of platform dependencies.
				And it is expected to be not too inefficient by having predictable additional overhead in normal cases compared to the non-CPS'd direct style.
			Conditional CPS has been considered.
				See https://news.ycombinator.com/item?id=3961466 for example.
				This is not planned because the host language does not support proper tail calls, so it is necessary anyway, unless some platform-dependent factors (like stack size) are also considered to provide information allowing it configuarable in API.
			The general way adopted is to setup a continuation of type that doing one-pass reduction in the NPLA context (called tail action) and then to translate direct style calls using the tail action object.
				Each sequence evaluation of combined evaluation with multiple passes is transformed into a sequence of CPS calls as the tail action, with at most one active pass to be called.
					Combination of reduction status is also rewritten and shared implementation with result combiner function object type 'PassesCombiner'.
				The evolution of code base should be from top to bottom, to remain compatibility of non-CPS'd code.
				It should be cautious that tail action is not to be overriden randomly.
					So when needed, guard is used to hold the old one and recover the state when necessary (e.g. on exception).
				Host exceptions in loops are not guaranteed being handled like them in direct style (esp. stack unwinding), except that basic exception guarantee is still held.
					Anyway, this is unspecified previously, and can be adjusted later.
	First-class continutation is still not supported, but it can be implemented based on current work.
	The top-level loop is adjusted to these changes.
		Now the loop is flat for all descendant reductions of subnodes previously introduced recursively.
		The loop now comes after setting of default tail action to make it more natural with CPS.
			It is necessary to avoid overriding tail action before entering the loop when the function is called again.
				Otherwise, redundant tail action left by previous call would clash with new one set before entering the loop.
		The return value is the last step of reduction in the loop.
			Any intermediate status handled by tail action is not cared by the returning value directly.
			It can now be in retrying status when there is no sufficient tail action to handle it.
				This indicates it should be probably handled in the caller which could handle the reduction of the parent term.

$2017-11:

report.impl:
To implement asynchronous CPS by trampolines, there are different ways to deal with tail action.
	The traditional way is to save the contination as the tail action and then to call the captured current action directly.
		This is general safe, though not very efficient.
		It is now delimited for the currently active frame to allow operating at the end of sequence of asynchronous operations for frame cleanup.
			The current action representing current continuation is detached from the context before being invoked.
			The next continuation is set (by current continuation dynamically, or setup before the invocation) as the tail action in the context, being the pending continuation.
		This allows reifying delimited continuations in future.
			This is like to introduce control effects as of static delimited continuation control operator like "shift" and "reset".
			Since the current action is always detached before invoked, it is not the same as of dynamic delimited continuation control operator like "control" and "prompt".
			Further reading for the general topic of delimited contuations: http://okmij.org/ftp/continuations/.
	A variant is to defer the call of setup tail action after (rather than before) the call of current action.
		This deferred way is slightly more effecient with less memory allocation and deallocation operations compared to traditional ones.
			The performance has been verified by profiling using Valgrind.
		This is the canonical way to switch current control (represented by current tail action) to out-of-bound action after current action is finished.
			However, since compatibility with synchronous calls is required, it can only assume the action contain no boundary in limited cases.
			The capture of out-of-bound action as continuations is still not implemented yet.
				This needs some extra data structures allocated in the context.
			Even when extra storage of continuations is implemented, the variant can be still useful for administrative continuations which are not intended to be first-class in object language.
		To replace normal TCO with it may misbehave in general if tail action interoperations are performed, so it should be used with cautious.
			Since the continuation is not set, any try to capture next actions by saving the tail action would not work.
				Even if 'ContextNode::Switch' is called, the return value would be empty, thus all next tail actions are effectively lost.
			It is safe only when no continuation is need to be captured and saved.
				There should not be nested calls, for example, because activation records delimited in the boundary are also maintained in tail actions asynchronously.
	In general, the apply of asynchrounous CPS with 2 consecutive actions reduced directly can be optimized to sequent direct-style calls instead, when CPS is not needed.
		The only remained difference is the call binds the term reference and context reference again, which is not cared here.
			The parameters here are only indicating the initial values of the synchrounous call (e.g. toplevel reduction).
			The actual reduced parameters for subterms should be bound previously.
		So the call is avoided for performance and simplicity of implementation for usual cases where no recursively called handlers occurs.
			The recursive calls rely on client code to guarantee proper tail calls, so it is not acceptable in general.
			The known depth of host activation records would almost always smaller enough.
			It is even more precise (and efficient) with the difference being taken into account.
				The parameters are not altered by rebinding of parameters of next actions here.
				So it would be correct parameters for next actions when it is a toplevel reduction.

$2017-12:

report.impl:
Implementation of delimited continuation supported has been considered.
	It is designed independently, but similar to the referenced abstract machine of Chapter 2.1 in http://www.brics.dk/RS/05/2/BRICS-RS-05-2.pdf.
		The context and meta-context in NPLA is mapped to function objects in form of current action and delimited actions.
	Delimited continuation is not supported previously, including the evaluation pass handlers.
		Asynchronous transformation of the handlers imposes no need of continuation capture currently.
			So it should be neutral to existence of delimited actions.
	The transition of last cont2 transition rule is now implemented by 'ContextNode::Transit', rather than 'ContextNode::Pop' directly.
		The transition is to be implictly called when no current exists in the rewriting loop.

$2018-02:

report.impl:
Term lifting at end of returning from closure is reconsidered.
	The no-op (instead of lifting) returning of term is the copy elision (unconditionally).
		It is equivalent to returning by reference, which can be dangerous.
		It is not always detectable reliably without tracing lifetime of all objects since the referenced term may be not hold by 'shared_ptr', etc.
	Term lifting is necessary to maintain the return value of lvalues sane without introducing dangling references.
		Removing lifting would change too much.
		This is a breaking change. The code would behave wrongly if no value copy is added.
		To remove lifting with well-behaved code, it needs to explicitly use value copy function to reintroduce the lifting again for returned value.
			Keeping same semantics by calling value copy may be verbose, so new combiner constructor variants which exactly retain the old behavior may be introduced in future for convenience.
	Term lifting needs some magic to work with tail call optimization.
		Becuase the inserted lifting operation is the tail context, direct switching to next continuation will change the semantics.
		Since it is idempotent operation, it need only occur before the next continuation only once.
			If it has already existed, it should be already in the tail context.
	The conbiners '$and?' and '$or?' can not be directly implemented without new conbiner constructor.
		Since lvalue reference is always be lifted (i.e. lvalue-to-rvalue conversion), the result would not be reference, even the reference here is safe.
			Here all retained reference can only be from the operand, which is safe for lvalues, so lifting would be overkill.
		Without lifting, it can be expressed by other primitives like in Kernel.
			Even the G1b guideline is not enforced in NPLA1, consistency is still important.
		This is to be changed in future by providing conbiner constructor other than '$vau'.

$2018-05:

$report.impl:
Several DS buidling problem concerned with compatibility issues in devkitPro has been addressed.
	The update of libnds 1.6.0 changes minor internal interfaces, which has been adapted in module YCLib::NativeAPI.
	The update of devkitARM r46 changes libgloss I/O interface in newlib, using 'void*' instead of 'int' as internal representation of file descriptor.
		Module 'YCLib_(DS).DSIO' is adapted to use 'void*' type file handle instead of raw file descriptor.
			This also reduces casts between pointers and 'int'.
	The ndstool distributed with devkitARM r46 and later versions has added DSi ROM generation, which would cause problems.
		This is not documented.
			See https://github.com/devkitPro/ndstool/commit/18d3c00df65a2b7a9c9f0312eaac518678869345 for the change.
		It would now generate DSi ROM when both ARM7 and ARM9 object files are ELF objects by default.
			It seems there is no option is supported to override the behavior directly except adding '-h' option to indicate the required header size.
			See also https://github.com/devkitPro/ndstool/issues/7.
		DSi ROM cannot be handled steadily on DeSmuME.
			In fact it is not supported currently, in version 0.9.11.
				See http://wiki.desmume.org/index.php?title=Faq#What_does_DeSmuME_emulate_and_on_what_systems.3F.
				Although there can be chances to work occasionally (with ELF objects packaged directly, see below), it does not function well.
					For instance, font loading would fail at 'FT_NewFace' with unknown format error, while the previous reading operations seem to be normal.
			Nevertheless, even the newest official stable release would support DSi, the version used to test in YSLib (without disabling homebrew capability) would still not support DSi.
				So DSi ROM generation need to be disabled.
		Removal 'objcopy -O binary' and using ELF object to be packaged directly instead of raw binary ARM7/ARM9 image may change the result.
			At least one removal in either ARM7 or ARM9 has to be existed, to enforce the new versions of ndstool generating DS ROM instead of DSi ROM (with "unitcode" value 0 instead 2 in the header).
			Note that since devkitARM r46, raw images generated by 'objcopy -O binary' do not work at all, so single removal is not enough.
				It would lead to white screen on DeSmuME, even it is a DS (not DSi) ROM.
				It would also bloat significantly (the arm7/arm9 file size, about ~100x of .nds file) in resulted ROM file.
		Note all devkitProm versions after r45 has same problem above (even with newer libnds).
			Thus, the only viable solution with updated devkitARM is to change the makefiles without 'objcopy -O binary' operations and using '-h 0x200' in the 'ndstool' command.
				Note that ELF objects can work with old ndstool, so using an old version of ndstool can also work.
			The good news is it would eventually make the binary size in resulted ROM file smaller.
				It would bloat ~35KiB by removal 'objcopy -O binary' (though much smaller than raw images with devkitARM r46).
				But with recompilation of FreeType2 with new toolchain, it would save ~80 KiB.

$2018-06:

$report.impl:
TCO (tail call optimization) algorithm in NPLA1 to support PTC (proper tail call) has been carefully revised and further enhanced.
	Since the host language (C++) as the source language does not support PTC, TCO is necessary anyway to the support of PTC.
		Although it is optionally enabled in the current source by conditional inclusion, the object language NPLA1 mandates it in conforming implementations.
			So this is the default configuration.
			Other configurations are not always tested and not guaranteed to work.
	The call here can be an ordinary function call (a β-reduction of λ/vau-abstraction) or an underlying evaluation in 'eval' form.
		As usual, calls do not interleave, to avoid introduce of parallelism in simplest cases of design.
			This also means in users' view there is only one call being active simultaneously.
			This also simplified the implementation to worry about concurrent access, although the design is actually able to be extended to support it.
			If needed, parallelism can be added by threading and other means in future.
		This design supports mixture of asynchronous and ordinary synchronous handlers of calls once the asynchronous calls are properly guarded by some synchronization mechanism.
			The abstraction of such handlers are called as actions.
			In a specific context for reduction, depending on the configuration, an action can be either synchronous, or asynchronous. 
				Sometimes there has to be different implementations for synchronous and asynchronous uses of an action.
			An action can be represented by various data structures.
				A notable example is the data structure used as the handler in TCO, see below.
		Within TCO, calls happen as a sequence implemented using an asynchronous style in the source language.
			This works like CPS (continuation passing style), except the continuation is stored in the context, rather than being passed by parameters in the source language.
				Note this does not imply a rewrite of CPS form which is used in various compilers of typical functional languages.
			A asynchronous handler stored in the context ('NPL::ContextNode') is a reducer (of the type 'NPL::Reducer').
				An action represented by the reducer implies an internal continuation being executed in the context.
					The continuation is used with some other states in the context, like 'SkipToNextEvaluation'.
					This is to be extended to implement first-class continuations in the object language (NPLA1) accepting parameters not in the 'Reducer' type.
		Other kinds of calls may be introduced by derived implementations.
			This design does not include them.
			Modification may be necessary.
	TCO operates on potentially active record frames.
		A record frame consists of an environment and optional other components.
		The active frame is the frame whose environment is introduced by the active call (i.e. the call still not returned).
			As parallelism is exluded in the discussion above, there is only one active call at any time.
			The environment component of the active frame is the environment object in the current context object.
			The optional components include the function prvalue (as the temporary object) and the additional environment holding the temporary operand object, which are saved in the TCO action.
				The function prvalue is based on the function object determined by the implementation of 'NPL::A1::ReduceCombined' and the guard object after the compression (see below).
					The function object here is the context handler representing the optional function prvalue of the combining form.
					If the prvalue does not exist (when the function is a lvalue stored elsewhere), the context handler is empty.
				Similarly, the operand has to be saved to avoid dangling references binding to it.
					The difference to the function prvalue is it would be added immediately after the frame switch and before the next action of actual function call.
					The operand is transferred in the form of environment object so it can be collected, see below.
		Other frames are owned by the TCO action, which represents a special kind of actions to handle the probably optimizable tail call specifically.
			They are inactive and basically introduced by other formerly active calls.
				Some of them are definitely inactive, and they are the targets to be safely removed during TCO.
			However, some frames can own objects referenced by the active frame so they cannot be definitely inactive.
				They have to be preserved to keep the memory safety.
		The representation of a frame is not necessarily always same.
			But for simplicity, all frames preserved in a TCO action are in two forms.
				The first form is like other non-TCO frames, called guarded frame, representing the continuation of the TCO action.
					It is stored in a guard object of type 'NPL::A1::EnvironmentGuard', providing strong exception safety.
				The other is the frame solely stores the resources.
					These resources make the frame having the correspondence to the active frame, which also has 3 components. But the storage form and the order of them are not required to be same.
					The components are the function prvalue, the frame environment and the additional environment holding the temporary operand object.
				There is most one valid guarded frame in one TCO action.
					There is exactly one valid guarded frame if the action initialized with a valid next action (in 'Context::Current') as well as a different environment (always true in case of TCO) for the next action.
				There are zero or more valid non-guarded frames when there is a valid guarded frame. They are stored in the frame record list.
				During the reduction performed in the TCO action (implemented in 'operator()' of the action), non-guarded frames would be removed in the reverse order of insertion. Guarded frame would be switched and destroyed after all non-guarded frames have been removed.
					This process resembles the LIFO stack frames built by environment switching during ordinary nested function calls (as well as evaluation of 'eval' with operands).
					Conventionally, the frame record list pops the front frame at first. Environment to be added into the list caused by environment switching is also insert in the front place if the guarded frame exists (otherwise it should be placed as the guarded frame).
						Thus old frames lives longer are place in back. Guarded frame is the last frame (living logest) and it is virtually the one-past-end element of the list in sense of lifetime (although it is actually held out of the list).
			No other frame representations for other cases are specified yet.
		During TCO, zero or more incative frames would be found and removed, with the permission of nondeterminism about lifetime of objects in the inactive frames granted by the semantic rules of the object language.
			During the removal of an inactive frame, if the environment is previously uniquely referenced, the environment in the frame is destroyed, so resources are reclaimed.
				The objects held in the binding within the environment of the frame shall be destroyed to enforce there is no resource leak.
					This is ensured implictly by the destruction of the environment.
				The parantage of remained object shall also be maintained to avoid behavior not allowed by the semantic rules of the object language.
					This needs additional explicit operations before the destruction.
				This indicates the environment is collected.
				Not all environments in inactive frames are to be collected, because they may have reachable objects, i.e. objects referenced by active frame.
			The candidate inactive frames to be removed are found by the check operation against inactive frames specifically.
				The check is performed each time when there is a new frame being activated.
					Zero or more old frames are to be removed as the result of the check.
					The resources of these frames are thus collected when needed, i.e. when there is no object not owned by the environment holding the reference of the environment.
			The removal of TCO frames shall keep the parentage of environments properly as per the language rules.
	Routine containing TCO is entered once during some operations at tail contexts with environment switching.
		Currently, function calls in vau handlers and 'eval' reductions are the direct audience.
			Other PTC can be composed with these cases.
		The input contains a guard object holding the environment of previous action in the context.
			The environment was switched before enter of the routine and the old one would be the one stored in the guard.
			This guarantees strong exception safety.
		The operation initiates TCO shall create a TCO action if it is not existed as the next action; otherwise it shall maintain the members of an existed TCO action properly, especially the frames stored in the action.
			Only when the next action is a TCO action and the input guard is valid (holding an environment), TCO can be performed.
			The operation shall make the guard object stored in the TCO action to be the input guard on creation of the TCO action, or add it in the frame record list of existed TCO action after TCO.
		If there has been already a valid guarded frame in the stored guard object, TCO check is needed; otherwise, the input guard is simply installed by assignment to the stored guard object.
		TCO check and recource removal are performed immediately before the insertion of the guard object for an existed TCO action.
			Each time it performs only one turn of check. It shall colloect more resources as possible, to prevent them leaked before tail contexts are met later again.
				The guard object would not be collected before the next turn of check, as it holds the newly deactivated frame.
				It can be collected only after the frame switch would not be rollback by an exception.
				The strong exception safety of the collection for it is difficult to achieve, so keep it as-is, and it can be collected in next turn if necessary.
			The frame record list holds all frames after previous turns of collection (if any).
			The new frame would held by the input guard be inserted at the beginning of the list.
		In order to check frames, TCO tests whether the frames saved in the frame record list can be safely removed when the provided guard object lives long enough until the TCO action is reduced via its 'operator()'.
			This is done by searching environments with no reference from others in active frames in the frame record list.
			The objects being seached is a set of environment, called candidate search set, defined by the following rules:
				The environment in the guard object is the root of search.
				All direct and indirect parents of the root which can be determined in finite time is also in the set.
					The determination dependes on module NPL::NPLA. In the current design, there is no nondeterminism in parantage, and all search operations shall terminate in finite time.
				No other object are in the set.
			Tracing is the operation to determine the candidate search set.
				After tracing, the objects to be collected in the candidate search set has been determined.
				Objects are then collected if necessary.
					See below for the judgement of the necessity.
			Both tracing and collection of environent objects not in the frame record list are handled by a record compressor.
				The record compressor maintains a common state, called trace record, upon the candidate search set.
					The trace record consists of three parts.
						The first is the reachable set indicating the known active objects not to be collected.
							It is represented as a set of refereces to environment objects, with initial value of single root environment, i.e. the reference to environment object as the active frame.
						The second is the universe standing for the candidate search set and the corresponding tracing reference count used by tracing for each candidate.
							It is represented as a map from reference to environment object to a count.
							It is initially empty and will be updated by the process of search.
							All other references to the searched environment objects are considered exteranl references of the environment.
						The last is a list holding the ownership of objects to be collected.
							The collection would be finished in the destruction of the compressor.
							It is represented as a vector of shared pointers to the environment object.
								If there is need to specify order of destruction in future, it can be a deque.
				Once an environment is finally searched, the tracing references held in the trace record and the reference counts provided by the references are used to be determined whether it is safe to be removed.
					There are two kinds of reference provided by the environment are considered.
						The strong reference is represented by the type 'shared_ptr<Environment>', or the reference sharing ownership with the weak pointer in an 'EnvironmentReference' object.
							It is allowed to be 0 because the environment object can keep alive to use 'shared_from_this' to get a new strong reference.
						The weak reference is the reference holding an anchor object of the environment object, in type 'NPL::EnvironmentReference'.
							The weak reference count is the reference count of the anchor object, which equals to the number of live weak references plus the one in environment object itself, so the minimum value is 1.
					The total reference count to an object is defined as the sum of strong and weak reference count minus 1, or the sum minus 2 when a temporary strong reference is retained (to get the strong reference count) via 'shared_from_this' call.
					All reference counts except 'use_count' result of 'shared_ptr<Environment>' are not exposed as public features of the object language.
						They are steady for the purpose here to illustrate the algorithms involved in the TCO implementation.
					During the search, the state stored in the trace record would be sufficient to determine whether a candidate in the candidate search set is an external reference or not.
					When the strong reference count reaches to zero, the object would be automatically destroyed.
						So simply avoid to keep redundant strong reference away would be sufficient to make objects collected.
						Otherwise, if the strong reference shows the object is not uniquely held by the frame record list, the environment reference is removed.
							As the environment reference is also held elsewhere, the environment is not collected. 
					Otherwise, if no external objects hold (weak) reference to the environment, the environment reference is needed to be removed.
						The environment is then collected at once.
						The trace is used to maintain the data determining whether objects being traced are held externally.
						The referent (the object being referenced) is to be collected in the following 2 cases:
							When the weak reference count is 1 and the strong reference count is 0 or 1, the environment is not shared. If it is not also reachable (i.e. referenced directly or indirectly by some external objects), it is an orphan.
							When the weak reference count is same to the weak count in the universe but not in the reachable set, there is no external references, i.e. no external objects are known to hold reference to the environment.
				Each basic operation of collection is concerned with 2 environment objects: the destination and the source.
					The destination is the environment object to be collected.
					Before the collection, the parent of environment should be settled so the parantage can be maintained.
					The source is the object to receive new parent. All other members of source are not touched.
					Sometimes, before setting the parent of source object, bindidngs lived both in source and destination are deduplicated.
						The deduplication is simply to remove all bindings in the destination with same names in source.
							The object lifetime would be altered. It shall be only used following the semantic rules of object language.
						Sometimes the source and destination can have same bindings when the destination is the only parent of the source. If deduplicated, destination can be empty and be then collected.
							This typically exists like frames created by recursive function calls, which is a majority source of need of TCO.
							It is necessary for elements in the frame record list because the referent cannot be removed otherwise.
								The result of emptiness is important because an nonempty environment cannot be removed.
								Also note moving destination bindings to merge to the source is not feasible in general.
									The only exception is the case that name resolution can be proved not effected (in search order, etc.) by it, which is too complicated and not worthy in general.
				The compressor provides methods to add references before further operations.
					The methods are to determine the universe.
					A count is set to each entry in the universe, initially indicating the total reference count to the object in the entry.
					The parameters are roots, as the entry of traverse described below.
						The first root is strong and other roots are weak.
						The first root shall be the reference to the environment of active frame.
						Only the strong root is considered reachable initially.
						Weak roots are specifically interested because they are held internally and additional reference count fixes are needed.
							See the description of the tracing algorithm below.
				The compressor provides a "compress" method to be called after adding all interested references.
					The interested references are references to the environments in the universe.
						All references to environments out of the universe are considered external, and the object referenced by an external reference is not to be collected.
					The method compresses frames by tracing and removal of orphaned environment objects defined below:
						An orphaned environment object is an environment object not referenced by any external references. It is safe to be collected.
						The orphaned environment object is determined by traverse of specified environment objects (called roots) and their parent environment objects directly and indirectly.
					The search is basically performed in depth-first manner, from the roots specified previously as the parameter of adding operations before the compression.
					Each step of the search enumerates a parent of current searched environment using the order same to name resolution and update the common state.
						As environment object and their parents are in a acyclic data structure, there is no cycle during the traverse.
						The traverse enumerates parents of environments by types as they provide different ownership of environment objects.
					The compression consists of 2 stages, tracing and moving.
					Following steps of tracing operations are performed as the 1st stage of compression:
						All objects in the universe are traversed once and the corresponding count is decremented.
							The values of counts before decrement operations shall be positive.
						For the roots specified in the previous adding operations, further decrement the corresponding count.
							The values of counts before decrement operations shall still be positive.
							The roots are intended as the uniquely held environment in the frame record list. The value shall precisely decremented by 1.
						All resulted counts of value 0 indicate the corresponding environment are orphaned (even with cycles across strong and weak references) and they are candidates to be collected unless they are otherwise reachable.
						For objects with count greater than 0, correspoinding references are then moved to the reachable set.
						All objects as direct or indirect parents of objects referenced in the reachable set are also considered reachable.
							The correspoinding refrences are moved to the reachable set.
							This process loops till there is no new references to reachable object found.
					Following steps of moving operations are performed as the 2nd stage of compression:
						Strong references in the remained references in the universe are added to the collected set.
							This is used to keep the ownership of objects to be collected tentatively.
						The strong root is finally traversed and all remained objects fix their parent properly to avoid the objects to be collected occurring in the parantage.
							During the operations of assignment parents, objects to be collected are still alive due to the collected set.
							After the traverse, objects in the collected set would have reference count value 1.
				During destruction of the compressor, the collected set would be destroyed eventually.
					The objects except weak roots (if any) are finally collected here.
			For each turn of check, an object of record comprocessor is created using the reference to environment object in the active frame as root.
			The adding operation is then entered at least once to add all collectable environment into the universe.
				For strong root, it is not added in the universe set directly as it is not collectable, only the direct and indirect parents are added into the universe.
				For weak roots, the root itself is added into the universe as well as its direct and indirect parents.
				The first call using the reference to the environment in the current context object (as the active frame) to specify the strong root, thus its direct and indirect parents can be added into universe.
				The reference to environment in the guard object as the parameter then added.
				The temporary environment holding the operand is also added.
				Additional weak roots handling can be enabled by conditionally inclusion. As they are not used by default, they are disabled.
				The successive calls traverse frame record list to provide weak roots.
			After the adding operations, there is a try in loop for further compression operations, which traverses the frame record list.
				The order is from front to back, so the recently inserted frame is first to try.
				Each try in loop targets the current iterated reference as the referenced to be processed and consists of several operations:
					If the strong refrence count is not equal to 1 (either 0 or more), it is held elsewhere.
						The frame in the list is removed and the referent should remain alive.
					Otherwise, if the referent is orphaned, the frame is removed and the referent is collected.
					Otherwise, compression is performed with the reference being processed as the parameter.
						After compression, if the weak reference count is 2, it can be the processed reference and its sole parent.
							Note the compressor does not process the element of frame record list.
								Although The compressor should know the object because it is the parameter, it is hold by strong reference, so it should be never collected by the compressor.
								This is also the reason of cleanup of orphaned referent referenced by element of frame record list should exist above.
								Moreover, if the environment is duplicate (e.g. from a function call), it cannot be removed by the compressor as it is designed without deduplication of bindings.
								So they are further compressed by taking the processed referent as destination and the referent held by guard object as source.
							All duplication of source environment bindings in the destination environment are removed.
							If the resulted parent environment is empty, it is to be collected.
								The parent of destination environment is moved to the source 
				The condition is based on size of frame record list.
					If the size changed, there is at least one object in frame record list is collected.
					The try would be continued as there can be new orphaned object not in the list due to the removal of object in the list.
			After the above first try of loop, components of the frame element are processed if necessary.
				The environment component holding temporary object is cleaned up if it is uniquely referenced. 
				The function prvalue component of front element of frame record list is then set to empty.
					This is a hack that avoiding improper tail calls caused by a false positive external reference to the static environment object held in the temporary function object which is or is similar to a vau handler.
					Ideally, multiple temporary objects are allowed coexisted.
						Otherwise, the first element of frame is also useless, which is the status quo.
					However, there is no simple way to implement this keeping the vau handler interface hidden under the type-erased context handler API, whose object can be wrapped more than once, to precisely know which object of vau handler appertains the frame.
					There shall be no undefined behavior if correctly implemented.
						The static environment is still accessible after destroying the function object if referenced when the object kept alive (by one ore more strong reference).
						Otherwise, it is a program error of ill-use of weak reference.
			Then the "compress" method is called.
			A new element is then inserted into the frame record list. The newly inserted frame element is the active frame components except the envrionment, and the environment stored in the guard object.
			Finally, during the destruction of compressor, remained objects are collected.
	The process of TCO tracing, check and collection is somewhat like tracing GC, but not the same.
		The design here is conservative but accurate in collection.
			It always collect in certain points of execution. All information used by the collection is depending only on the external program state. The timing of collection is determinstic.
			It always achieve space complexity of activation records no worse than conventional stack-based memory allocation stratigies in implementations of ALGOL-like languages, while tracing GC do not have such guarantees.
			It does not move objects in memory, while some kinds of tracing GC may move objects, so there is no special operations needed for interoperations as object pinning provided by some kinds of tracing GC.
			The design here is always local, against to global GC used by default in some language implementations.
			The design here is specifically for frames, not arbitrary objects to be collected.
			The algorithm used for tracing can be similar to GC based on reference counts, but collecting with multiple roots and counting down to 1 rather than 0 (as the anchor always holds an instance contributing to the weak count).
				For example, see http://arctrix.com/nas/python/gc/.
		The design here does not offer optimized throughput by default, which is often aimed by a tracing GC.
		The design here is deterministic like pure reference counting GC, rather than a traditonal tracing GC which would collect periodically or heuristically, typically introducing nondeterministic.
		The trace here is lightweight comparing to the traces used by traditional tracing GCs.
			It is necessary to determine the universe (the set of all the objects can be collected) and as well as the lived object set, not only the live object subset in a traditional tracing GC.
			It is used to locally determine the candidate search set, not the reachable set to determine the state of arbitrary set of objects to be avoiding from collection.
				It remains valid in one turn of collection, and can be generated frequently. This also requires it to be lightweight to avoid overhead of collection.
			There is no need to have granulated trace as it is already local to particular set of operations, and thus substantially efficient unless the control hardly terminate and already consume a lot of resources in some deep nested tail context.
				This worst sort of cases should be very rare (at least far rarer than cases need PTC for ALGOL-style programs) in reality, although there is room to optimize in future.
	By adding tracing, indirectly referenced frames can be collected, notably, for cases of recursively creation and call of vau abstraction would still leak leak slowly of the created function objects, like:
		Case 1:
			$defl! f (n) ($vau (x y) env eval (list $sequence x y) (lock-environment env)) n (f (- n 1)); f 1;
		Case 2:
			$defl! f (n) ($vau (x y) env eval (list $sequence x y) env) n (f (- n 1)); f 1;
		Case 3 (derivation of '$sequence'):
			$def! $sequence
				($lambda (&cenv)
					($lambda #ignore $vaue cenv &body env
						$if (null? body) inert (eval (cons $aux body) env))
					($set! cenv $aux $vaue (weaken-environment cenv) (&head .&tail)
						env $if (null? tail) (eval head env)
							(($vau (&t) e ($lambda #ignore (eval t e))
								(eval head env)) (eval (cons $aux tail) env))))
				(make-environment (() get-current-environment));
			$defl! f (n) $sequence n (f (- n 1)); f 1;
			Note that this would not work even with growing instance of environment objects, before the tracing and collecting of indirect referent is supported here by the design above.

$2018-07:

$report.impl:
Currently, 'ystdex::basic_string' is modeled on 'std::experimental::basic_string'.
	Moving towards ISO C++ need to rebase 'std::basic_string' to reflect the modification in WG21 P0254R2.
	There have to be a 'ystdex::basic_string' to provide the changes instead of 'std::basic_string' to keep no ISO C++17 fetures are unconditionally relied on.
Use of inherited constructors are rechecked to interact without resolution from WG21 P0136R1.
	This is searched using regular expression pattern 'using (.+)\:\:\1' in the editor in VS 2017.
	Currently, resolution of WG21 P0136R1 (esp. for CWG 1941) is not relied on.
		Some of the inherited constructors may be effected with dependent types from template parameters.
			Currently, these class names matching the pattern are 'derived_entity', 'default_init_allocator' and 'path' in namespace 'ystdex' provided by YBase module YStandardEx.
			The only use of 'derived_entity' in user code is 'NPL::TokenValue' in module NPL::NPLA.
				This is not considered relying on P0136R1 because it is based on interface like 'std::basic_string', where there no issue is related directly.
				This changes after adoption of C++17 whose 'std::basic_string' having conditionally enabled constructor targetting to 'std::basic_string_view' instances.
					This should ideally be resolved before adapting 'string_view' on the new 'ystdex::basic_string', but nothing is required to be done yet, since new constructors of 'std::basic_string' is still compatible in semantics with substitution failure.
			No use of 'default_init_allocator' in user code is found.
			Class name 'path' is safe because due to 'ystdex::sequence_container_adaptor'. 
		All other use are safe except 'using u16string::u16string;' in class 'String' in module YSLib::Core::YString.
			This should also be handled like 'ystdex::basic_string' and 'NPL::TokenValue'.

$2018-08:

$report.impl:
Type of feature testing macro values are adjusted as WG21 P0941R2.
	This is more consistent with '__cplusplus'.
		Now it also supports implementations where the range of 'int' is not large enough to represent the values with a steady type ('long') instead of unspecified one of 'int' and 'long'.
		Alhough currently no configuration of such implementation is known to  work with this project yet
	This is processed in definition sites using regular expression pattern 'define __cpp_([a-z_]+) (\d+)' replaced by 'define __cpp_$1 $2L' in the editor in VS 2017.
		There are 27 matched cases.
	This is then done in use sites using regular expression pattern '__cpp_([a-z_]+) ((<|>)\=?) (\d{6})(?!L)' replaced by '__cpp_$1 $2 $4L' in the editor in VS 2017.
		There are 27 matched cases.
UNC (universal name convention) paths support is reconsidered.
	It is considered necessary to be a part of complete file system path implementation for Windows based on the fact that symbolic links in Windows should be able to handle UNC paths.
	The lack of UNC path support also makes YFramework initialization failure if the executable module is in remote host in LAN.
	The ISO C++17 <filesystem> does not mention any sorts of UNC paths, but implemenation in Windows can support smoothly.
		As the difference is conforming, relying on UNC paths cannot be portable in the sense of ISO C++.
			However, YSLib paths does rely on more abstract 'ystdex::path' templates, rather than <filesystem> API. Thus there is no such portability problems.
		The <filesystem> implementation in Microsoft VC++ 2017 seems has most complete support in current mainstream implementations.
			From the comments, root path prefixes '\\server\', '\\?\', '\\.\' and '\??\' are all explicitly supported.
		In contrast, current libstdc++ only handle double slash prefixes, while libc++ seems to have no support of special handling of root prefixes at all.
	Some other implementation may have different strategy of support feature sets.
		For example, DMD standard library does not handle some cases like NT device namespace (prefix '\\.\') as per the installed documentation.
	YSLib follows the complete implementation like Microsoft VC++ 2017 <filesystem>.
		However, the abstract 'ystdex::path' does not distinguish root directory from root path, so there are several other caveats.
			The root directory are direcly attached following the root name. The root path consist of optional root name and root directory.
			As the separater, root directory is omitted in the internal representation. Paths I/O (parsing and printing) should handle it properly.
		With aid of 'YSLib::IO::PathTraits', 'YSLib::IO::Path' has overriding settings over the 'ystdex::path' with default traits.
			To keep backward compability, as the special case, 'YSLib::IO::Path' allows empty root name which indicates an implicit root directory.
		No tilde expansion is performed (like UNIX implementation in DMD).

$2018-09:

$report.impl:
Functions to introduce abstraction forms in NPLA1 have been revised.
	The variants of "with environment" (or "with static environment" where "static" is always inferrable) are renamed.
		The new '/e' postfix is clearer to the previously used 'e' due to more explicit boundary with the word it follows.
		This follows the design of the Kernel language, which inturns follows practice of "call/cc" as short for "call-with-currect-continuation" in the Scheme language.
			The Kernel language chooses the short form. It is more preferred here as '/e' occurs more frequently in the codebase in derivation of fundamental functions.
		The change actually does not break the code in the project besides the YSLib implementation itself, since these low-level function names are not directly used in known user code (i.e. SHBuild installation scripts).
PTC implementation in NPLA1 has been revisited.
	A bug of scanning the shared frame environment in the loop is fixed.
		The bug wrongly removed other components in the frame.
			This would cause undefined behavior with environment locking, e.g. in evaluation of expression '$let/e (() make-environment) () 42'.
		The resolution of the bug also relies on removing the hack of collecting function prvalues (see below).
	Now hack of prvalue function collection is also removed.
		It seems at current it does not effect PTC typically.
		See $2018-06 for descriptions of original design.

$2018-10:

$report.impl:
Last reduction status interaction has been simplified in thunked code of NPLA and NPLA1 implementation.
	The status shared in evalation passes of a single evaluation now is placed as the last status in the context.
		This avoid additional allocation with 'shared_ptr<ReductionStatus>'.
	Note rewriting last status is unavoidable for thunked code even the reducer does not always relies on the result.
		Because there is no simple way to know what is the last status when it is needed in an asynchronous action, the last status has to be always kept and updated in time.
		This is true even when it can be predicated statically about which of the asynchronous actions need to use the previous status.
Retionale of reductions in NPLA1 (esp. implementation of 'A1::ReduceOnce') is restated here for clarity.
	Reductions implements evaluations.
		Some are underlying reductions for evaluation in one-to-one mapping style, with a spicific term.
		Others are hidden from evaluations, namely so-called "admistrative", provided by actions, i.e. reducers in NPLA.
			Reducers can be formed by evaluation passes provided in NPLA1 and hidden terms.
			Reducers can be formed from handlers not related to any concrete evaluations in the sense of the object language.
		Since an evaluation reduction sticks on the same term so when retried, so it is safe to skip remained administrative reductions.
	If reducible, the current action should have been properly set or cleared.
	In general, the reduction status cannot be cleared immediately because no simple way to guarantee the current action is the last one for an evaluation rather of administrative merely by the status.
	'ContextNode::Current' needs to be exposed to allow capture of current continuation.
	The status as a returning value of an action would inform propably existed enclosing invoker to retry a new turn of evaluation reductions if the current action is cleared.
		Otherwise it is to be ignored as per the condition of enclosing rewriting loop.
			Typically the loop is provided by a trampoline of synchronous caller, or top-level enclosing loop in NPLA context.
		The invoker of the action is either synchronous or asynchronous, either in evaluation or of admistrative.
	The returning value cannot be handled just (as the enclosed operation) by unconditionally retrying some specific operation, thus it reflects the control of administrative reductions.
	The status 'ReductionStatus::Retrying' indicates a request to skip the all remained administrative reductions.
		The skip is treated as attempt to switch to a new action, which should be in turn already properly set or cleared as the current action.
		'ReductionStatus::Retrying' can be the result of the last reduction derived from a call of 'A1::ReduceAgain'.
	For thunked (asynchronous) calls, both evaluation and admistrative reductions need to support continuation capture.
		There are several differences.
			As mentioned, the continuation for evaluations are directly capturable via the current action (i.e. 'ContextNode::Current'), but administrative ones are not.
			The continuation of an administrative reduction does not always expose a parmeter to be passed to support first-class continuation invocation.
			The boundary of actions is implied differently.
				In the evaluation case, it is addressed by the separation of current action and delimited actions in the context.
			The implementation of 'A1::ReduceOnce' does not use deleimited actions.
				The purpose is to avoid need of unwinding which introduce the necessity of delimited frame marks and frame walking in delimieted actions.
					Even this may be faster when properly implemented.
			Delimited actions are reserved to control primitives the in object language.
				For instance, "shift" and "reset" operations. See http://hjemmesider.diku.dk/~andrzej/papers/AC.ps.gz.
				They are not implemented yet.
Options of "strip" operation for linking has been modified to be saner.
	The command line option "-s" is only effective in linking stage of both G++ and Clang++.
		See https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options.
		See also https://clang.llvm.org/docs/ClangCommandLineReference.html#linker-flags.
	When command line option "-c" exists, the compiler driver does not link.
		See https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options.
		See also https://clang.llvm.org/docs/ClangCommandLineReference.html.
		G++ silently accepts "-s" as a compiler option Clang++ complains with warning [-Wunused-command-line-argument] if '-s' is specified in this case.
		To eliminate the warning, "-s" is not used for compiler option now.
			This seems also better for logical reasons.
		The command line option "-Wl,-s" is also valid for linking stage.
		The command line option "-s" is suspected to suppress relocation tables and it would interfere ASLR, but this does not matter currently.
			See https://stackoverflow.com/questions/14175040/effects-of-removing-all-symbol-table-and-relocation-information-from-an-executab.
			Support of additional command line options for ASLR ("-fpie", "-pie", etc.) are not provided by the scripts yet and they would not be rely on existence of "-s".
		So now strip command line option for compiler (defaulted as "-s") is removed from the build scripts.
			The linker command line option is preserved.
Context type of NPLA has been modified.
	'ContextNode' is now a polymorphic base class.
		'A1::ContextState' derived from it is for NPLA1.
			Passes previously in 'ContextNode' are also moved to 'A1::ContextState'.
		The separation serves better in SoC(Separation of Concers), and with 'ystdex::polymorphic_downcast' this actually perform better.
	New current state of next to-be-called term reference is provided in 'A1::ContextState', to have better support of first-class continuations.
		'ContextState::SetNextTermRef' is required be called in one of following cases:
			It is before list or leaf passes (in 'A1::ReduceOnce').
			It is before some other evaluation of subexpressions changing the active term being evaluated and the evaluation is allowed to be captured as a continuation in the object language.
			It is immediately after all actions of a non-tail evaluation.
				When following a tail call immediately, it can omit the operation since the reference is always overwritten later, if used.
		Then the called 'A1::Continuation::operator()' can read saved active term reference by calling 'ContextState::GetNextTermRef'.
The MSVC-specific attribute '__declspec(novtable)' has been supported in 'ydef.h' as 'YB_ATTR_novtable'.
	See $2013-09 report.impl for previous analysis.
		The requirements has been loosed to be more accurate on behavior.
	This is also supported in Clang++ since version 3.7, see http://releases.llvm.org/3.7.0/tools/clang/docs/AttributeReference.html.
		Now this would be ignored if for non-Microsoft ABI, see http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20150720/133747.html.
	It is considered that there can be a better name to 'vtable' in 'YB_ATTR_novtable' as it has been exposed too much implementation details, but nothing clearer is found yet.
	Use of the attribute will be adopted in future in YSLib code, notably, for YBase base classes and YFramework interface types.

$2018-11:

$report.impl:
Pool allocation has been implemented.
	The base implementation now is in "ystdex/memory_resource.h", which replaces and extends ISO C++17's <memory_resource> interface in a compatible manner.
	There are a few out-of-box implementations for reference.
		Microsoft VC++ 15.8.2 has provided the full implementation of ISO C++17 <memory_resource> with some LWG DR resolutions while libstdc++ and libc++ not (only with library fundamental TS interface).
		Boost.Container has another implementation (probably targetting library fundundamental TS currently), with some extensions.
		Some post-C++17 LWG issues define further interface change, e.g. LWG 3038. They are also implemented in Microsoft's implementation.
	Supported LWG resolutions are documented in the header file.
	The pool has a separated type, in spite of there are "std::unsynchronized_pool_resource" and "std::synchrnoized_pool_resource".
		These pools do not guarantee to deallocate upstream resource unless totally released.
			This is bad for long-running programs since it would likely lead to definitely memory leaks because the pools never shrink.
				On systems having virtual memory, it would like waste swap space; otherwise it would waste RAM a lot.
			Microsoft's implementation does not suffers from this, but it is not guaranteed portable for this property.
			See also https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/MKBWu8yzTOA.
		The latter is inheriting the former publicly in Microsoft's implementation. This might be promatic.
		So anyway, a new type seems necessary. This is done separatedly even when Microsoft's implementation is available.
	Some implementation techniques not specified by the interface are used to improve performance for average cases.
		A stashed chunk pointer is used to avoid most cases of O(n) search of candidated chunks in allocation.
		An empty chunk pointer is used to cache the empty chunk, thus it avoids some unnecessary immediate reallocations when there is a chunk with all blocks deallcated recently.
		A heuristic strategy of growth is used in the pool chunks.
			The growth factor is 2 is choosed mainly for simplicity.
				Not same to 'std::vector', since the chunks are not inteneded to be reused (like reallocation in 'std::vector'), a factor of 2 does not suffer from cache missing issues.
				See https://www.reddit.com/r/cpp/comments/2ezwee/stdvector_optimization_by_facebook/ about issues of vector reallocation.
		All of the above implementation details are similar or same to Microsoft's current implementation but different to Boost.Container's.

$2018-12:

$report.impl:
Deleter types for allocators have been reviewed. The idea of deleters has been considered in different proposals.
	See https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/rx8k-q7qeyI for the discussion.
		At least two of them are proposed to WG21, namely WG21 P0211 and WG21 P0316.
		And there are also prior arts in existed libraries.
		There are subtle differences among interface designs.
			Partial specialization for reference allocator types is in WG21 P0316, but not in other designs.
			The 'const' qualification changes among revisions of WG21 P0211.
			There is allocator access support (by 'get_allocator') in various designs, but not in WG21 P0211.
	The interface provided as 'ystdex::allocate_delete' in "ystdex/memory.hpp" has done different to these proposals.
		It actually is in line with libc++'s internal 'std::__allocator_destructor', which deallocates but not destroys objects allocated previously.
			This is actually indirectly mentioned in WG21 P0316 as internal details.
		The equivalent functionality to the 'std::unique_ptr' combined with and the deleter are proveded by guard pointer template 'std::__allocated_ptr' in libstdc++.
			As it is too specific for internal use, it is not adopted in 'ystdex'.
	The interface in 'ystdex' is now changed, but still not same to the existed designs.
		The old interface is renamed to 'ystdex::allocator_guard_deleter'. The old name 'ystdex::allocator_delete' is then used by new a class template with object destroying.
			To be consistent with other uses, the changed name proposed in WG21 P0211 is not adopted yet.
				This might change later if it is adopted in the standard draft.
			As the internal count is not in the 'ystdex::allocator_delete', they are separatedly implemented (without inheritance).
		Qualification and internal 'mutable' is preserved.
		Referenced allocator support is added, but without a partial specialization.
		Allocator access is preserved. Additional 'count' access is added for 'ystdex::allocator_guard_deleter'.
	Remained interface in the proposals like 'allocate_unique' is to be added in future.
The ABI concerned with 'std::aligned_storage' may differs in libstdc++ and other implementations on the same underlying platform (ISA).
	See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61458.
	This is perhaps better being done as well in YBase for the same reason to '__aligned_buffer' used internally in libstdc++.
	Minimization may be implementable.
		See https://github.com/WG21-SG14/SG14/commit/98baf1aeab for example.
		However, this approach is not taken for various reasons.
			As the result of the GCC issue, the current libstdc++ is still conforming and change is ABI-breaking.
			Change of the default template argument 'ystdex::align_storage' is not allowed by the policy of YBase, so if needed, new traits should be introduced anyway.
				This is disallowed because it does need implementation-specific knowledge. So it is essentially not portable out of a standard library implementation.
				It is also not intended to make 'ystdex::aligned_storage_t' and 'std::aligned_storage_t' behave differently for a same platform configuration.
			Any critical use of the buffer could use explcit alignment like '__aligned_buffer'.
Special handling of reference wrappers in constructor template with 1 value parameter in 'ystdex::any' has been removed.
	The removal of extension prevents the construction relying on concrete wrapper types by default.
	It also makes 'ystdex::any' having more consistent behavior of general erased type wrappers like 'boost::any', 'std::any', 'std::function' and so on.
	The behavior in 'any_ops::ref_handler' on copying is same to 'any_ops::value_handle' directly passing value.
		The only difference is to keep the ownership in the object or not.
		If external ownership is needed, 'any_ops::ref_handler' should be better explicitly used.
	Since reference wrappers are first-class object simulation of raw reference types, it should not be implying value copying by default, which undermines generality of the constructor to handle first-class objects.
		This is also problematic for mixture of use for different ownership schemes in single constructor signature.
Several alternative designs and implementations of 'std::function' have been reviewed.
	There are feature improvements and issues oncerned in current 'std::function'.
		The main reason is that implemenations of 'std::function' are lacked of allocator support in general, so replacements are needed.
			Allocator is planned to be used in NPL with 'YSLib::GHEvent', whose implementation is currently based on 'std::function'.
			By altering the underlying implementation, issues can be resolved in a flexible way.
				The impact of compatibility should be minimal.
					Behavior relying on these features are planned but not yet used.
					Use of 'function' is always qualified with 'std::' prefix in YSLib currently.
		LEWG 34, including multiple issues on 'std::function', targets C++20.
			Currently it is in the "DESIGN_REVIEW" status.
			See https://issues.isocpp.org/show_bug.cgi?id=34.
			WG21 N4348 proposes synchronization in interface.
				This is not in favor of both LEWG 34 and YSLib for violation of principle of zero overhead abstraction (cf. ISO TR 18015).
				See also discussions in WG21 P0045R0.
		Multiple potential feature improvements on 'operator()' are considered.
			Different qualification on 'operator()' is needed.
				WG21 P0045 proposes change of 'const' and other qualifiers on 'operator()'.
					This can be difficult due to ABI compatibility. It is not approved yet.
				Here other qualifiers concerned are ref-qualifiers and the 'noexcept' specifier where ISO C++17 'noexcept' type is supported.
			Narrow contracts on 'operator()' is needed.
		Noncopying wrappers are needed.
			WG21 P0288 proposes a replacement 'std::unqiue_function'.
		WG21 P0770 restates the 'noexcept' requirement on move of 'std::function'.
		Translation-time enhanced safety is appreciated.
			WG21 P0932 proposes the additional constraint on 'std::function' return to capture specific danling referernce error during translation.
	The reviewed replacements are needed to work around deprecation of allocation support of 'std::allocator' in WG21 P0302.
		As stated in the paper, the feature have not been implemented at all in libstdc++ (with even no concerned signatures at all) and libc++, while Microsoft VC++ has only limited support.
			And the support of Microsoft VC++ is to be removed, see https://github.com/aws/aws-sdk-cpp/issues/652.
		Library fundamental TS v3 (WG21 N4758) has been drafted with a new 'std::experimental::function' interface with 'erased_type' allocator support.
			This is mostly the right design.
			However, this is does not planned to be compatible in source level in YBase.
			As new 'function' is needed, there are other candidates to be analyzed.
	There are several source of alternatives. They are listed here for reference.
		WG21 P0288 mentions some implementation of 'unique_function'.
		Document of 'fu2' (with 'unique_funtion') in turn mentions other implementations.
			See https://github.com/Naios/function2.
		Some multiple dispatched function wrappers are collectively benchmarked at https://github.com/FrankHB/nano-signal-slot/tree/master/benchmark.
			They are mostly for multiple dispatching implementations and have been analyzed by this project previously.
			However, the base implementations can still be referenced.
			The upstream has migrated the benchmark to a new project, see https://github.com/NoAvailableAlias/signal-slot-benchmarks.
		More candidates are collected in https://github.com/jamboree/CxxFunctionBenchmark.
	For purpose of being the baseline of interface design and performance benchmark, 'std::function' implementations as well as ("preferred syntax") 'boost::function' should be considered.
		See ISO C++17 and https://www.boost.org/doc/html/function.html.
		They are mostly the same in the interface design.
		As the baseline, the candidates should support most features in 'std::function'.
			As the exception, the deprecated and unimplemented by most implementations allocator support in 'std::function' is not required.
			As another exception, some WG21 P0288 'unique_function'-like interface may not support copying by design.
				When not provided separatedly, it needs 'std::function'-like interface as the complement for need of copyable wrappers.
	Several decisions are made to be noted.
		The type erasure wrapper should be based on 'ystdex::any' for simplicity.
			The size of 'ystdex::any_storage' should be carefully tuned for performance.
		The interface like 'unique_function' is not separated in 'ystdex' because 'ystdex::any' can support noncopyable types.
		Multiple overloads is not planned to be supported in 'ystdex' as the overhead is not ignorable.
			The typical implementations use an overload table to support multiple overloads in type-erased wrappers.
			Actually WG21 P0045R0 has the feature but WG21 P0045R1 drops it.
			Examples are 'cxx_function::function' and 'fu2::function' (see below).
		Throwing (like 'std::bad_any_cast' in 'std::function') is intentionally avoid.
			For user code like 'YSLib::GHEvent', the exception is already handled.
				This can be further optimized by removal of the whole exception handling code once all calls on empty wrapper have been avoided.
			If needed, it can be added in user code.
		The parameteric design like 'fu2::function_base' for 'fu2::function' (see below) is not supported.
			So 'ystdex::function' will be a template simpler as specification of 'std::function'.
			Since many features are filtered out, there have been no need to parameteric the configurations.
		Wrapper view as 'std::function_ref' proposed by WG21 P0792 is not planned in near future.
			Almost all function warppers used in the user code are owning, or they are not interested in external owners.
				The view is not required currently.
			If needed, it can be added later.
	Candidates as primary references are listed.
		1. 'cxx_function::function' and 'cxx_function::unique_funtion' from https://github.com/potswa/cxx_function as reference implementations in WG21 P0288.
			Design in WG21 P0042 is not used.
				In particular, 'ystdex::any' does not follow the scheme of 'ErasureClass' proposed by WG21 P0042.
					'ErasureClass' is admitted "completely differerence" to 'std::experimental::any' implementation in libc++ and libstdc++.
						The implementations in latters are in turn more like to the implementation of 'ystdex::any'.
			Some designs in WG21 P0043 is concerned.
				It proposes seperation of container as a new interface.
					While sometimes useful, providing both interface does incur complexity of use.
					As the container behavior is not used in YSLib (particularly, not in NPL), the design is not adopted currently.
						The capability of interoperations between 'function' and 'function_container' in the underlying implemantion should still be considered.
						This is also fit for 'ystdex::any' with upcoming allocator support to be the base of 'ystdex::function'.
				The interface requirement about need of allocator stored in the function wrapper is reconsidered.
			Deprecation is not needed in YSLib because no deprecated behavior is relied on.
		2. 'fu2::function' and 'fu2::unique_function' from https://github.com/Naios/function2.
			The design fits the needs in YSLib quite well.
			Differentiating "weak destroy" from "destroy" in the implementation seems redundant.
	Other mostly feature-complete candidates are also listed here.
		1. 'func::function' from http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/function.h.
			This implementation may have undefined behavior concerned with strict alising.
			This implementation does not support move-only targets.
			The implementation to wrap pointer to members using 'std::mem_fn'.
				While conforming, this is usually inefficient with indirect wrappers.
				It is unspecified the result type of 'std::mem_fn' call, so there is no guarantee to further enable the result with small object optimization.
			When allocation is required, it unnecessarily forces using a copy of 'const' allocator object in the constructor.
			The implementation allows opt-out of wide contract (throwing exception) in call of 'operator()'.
			Calls in this implementation outperformed a lot in CxxFunctionBenchmark for calls.
				The null state is inlined, so there is no need to check whether the underlying callable object is null.
				The call table is directly weaved as function pointers, so there is less indirection and dispatching overhead.
					However, the space efficiency is low. When used heavily, it might harm cache locality. This does not identified by the benchmark (note the size of the object does not show this problem).
				Pointer to members are not benchmarked in CxxFunctionBenchmark so it is unknown the cost from 'std::mem_fn'.
		2. 'bsl::function' from https://github.com/bloomberg/bde/blob/master/groups/bsl/bslstl/bslstl_function.h.
			This implementation does not support different overloads of 'operator()'.
			This implementation does not throw on 'operator()' only when exception is disabled.
			This implementation support pre-C++11 language implementations.
				It has optional rvalue reference support.
				It simulates variadic template when it is not available (up to 13 arguments).
			This implementation uses multiple pointer objects as representation. The memory footprint concerns are documented within the code.
	Candidates lacking of required allocator support are listed here.
		1. 'stdex::function'.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/stdex.hpp.
			This implementation does not support move-only targets.
			Implementation of allocator usage does not support stateful allocators in 'stdex::function'.
				The destruction uses allocator copy and the allocator object is not lived with the 'function' object in its lifetime.
		2. 'generic::delegate' and 'gnr::forwarder' from https://github.com/user1095108/generic.
			'generic::delegate', marked obsoleted, originates http://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11.
				See https://github.com/user1095108/generic/blob/cd20bf0105735dede2f4542b71a6716b257d72f4/obsolete/delegate.hpp.
				See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/delegate.hpp.
				This implementation has specialization of 'std::hash'.
				This implementation does not support target access.
			'gnr::forwarder' seems a recent replacement.
				See https://github.com/user1095108/generic/blob/cd20bf0105735dede2f4542b71a6716b257d72f4/forwarder.hpp.
				See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/forwarder.hpp.
				This implementation supports target access by 'target', but without 'target_type'.
			Both implementations do not support allocators, move-only targets and different overloads of 'operator()'.
		3. 'embxx::util::StaticFunction' from https://github.com/arobenko/embxx.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/embxx/StaticFunction.h.
			This implementation does not support allocators, move-only targets and different overloads of 'operator()'.
			This implementation does not support target access and totally misses exception specifications.
		4. 'Function' from https://github.com/rigtorp/Function.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/Function-rigtorp.h.
			This implementation does not support allocators, move-only targets and different overloads of 'operator()'.
			The 'operator()' is not qualified by 'const'.
	Candidates lacking of functionality of 'std::function' (other than exception of missing of copying) are listed here.
		1. 'hpx::unique_function' from https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/util/unique_function.hpp.
				The 'target_type' is not support since https://github.com/STEllAR-GROUP/hpx/commit/655bac8440b2315882395a65a8c1741ddaa8de0c.
					This does not fit for the need of 'YSLib::GHEvent', but other interface would still be useful to reference.
				It also provides other metadata in https://github.com/STEllAR-GROUP/hpx/blob/master/hpx/util/detail/basic_function.hpp, but there is no allocator support.
			The original link (in WG21 P0288) https://github.com/K-ballo/hpx/blob/master/hpx/util/detail/unique_function_template.hpp is dead.
		2. 'move_only_function' from the answer of https://stackoverflow.com/questions/28179817/how-can-i-store-generic-packaged-tasks-in-a-container.
			The implemantion includes common techniques used in implementing 'std::function' and other variants.
				It is simplified since SFINAE-friendly 'std::result_of' (proposed by WG21 N3462) is accepted in ISO C++14 and superseded by 'std::invoke_result_t' in ISO C++17.
			It also provides overloads of 'operator()' on 'const' and ref-qualifiers.
			However, as only a demonstration of 'unique_function'-like interface, it does not qualify to be used in industrial cases.
				It has no allocator support.
				Nor does it have target access.
				It does not support small object optimization and it also dispatches underlying operations inefficiently.
				It also totally misses exception specifications.
		3. 'fixed_size_function' from https://github.com/pmed/fixed_size_function.
			This implementation demonstrates the small object optimization already used in most other implementations.
			Otherwise, it does not qualify to be used in industrial cases.
				It provides no allocator support or move-only targets support, nor different 'operator()' overloads.
				Different to the 'std::function', its 'operator()' is not qualified at all.
				It also totally misses exception specifications.
		4. 'smallfun::SmallFun' from https://github.com/LoopPerfect/smallfunction.
			This implementation has similar issues of 'fixed_size_function'.
		5. 'fastdelegate::FastDelegate' from https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/clugston_styled/FastDelegate.h.
			As analyzed previously for 'YSLib::GHEvent' underlying implementation, this one relied on ABI-specific knowledge like internal components layout of pointer to members, which renders it not fit the use in YSLib.
				However, it should be considerably efficient for specifically targeted platforms.
				In fact, as shown in https://github.com/FrankHB/nano-signal-slot/tree/master/benchmark, the multiple dispatching wrapper based on it was the only one having more efficient calls in general compared to 'YSLib::GHEvent'.
					This would probably remain true for a long time.
			This does not pace up to ISO C++11 features like '&&' and it does not replace 'std::function'.
				CxxFunctionBenchmark does not include the test for it possibly for these reasons (as 'ssvu::FastFunc' below).
		6. 'ssvu::FastFunc'.
			See https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/QgvHF7YMi3o.
				It shows that the interface is not conforming as 'std::function' by missing well-formed constructions from target with convertible function signatures.
			See https://gist.github.com/SuperV1234/6462221.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/clugston_styled/FastFunc.hpp.
		7. 'folly::Function' from https://github.com/facebook/folly/blob/master/folly/docs/Function.md.
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/folly/Function.h.
			Like proposed 'unique_function' in WG21 P0288, it does supports copy interface. Copyable types need 'std::function'-like interface as the complement.
			This implementation has overloads of qualified 'operator()' with 'noexcept' when supported, but otherwise all of the overloads are qualified as 'const'.
			This implementation does not support allocators and target access.
		8. 'stdext::inplace_function' from https://github.com/WG21-SG14/SG14/blob/master/Docs/Proposals/NonAllocatingStandardFunction.pdf.
			This is a draft proposal, but never being released (as WG21 P0419).
			See https://github.com/jamboree/CxxFunctionBenchmark/blob/master/inplace_function.h.
			This design only support targets that do not need being allocated.
			This design does not support target access.
			The implementation has extra effort to minimize ABI difference caused by different implementation of 'std::aligned_storage_t'.
		9. 'multifunction' as an example of Boost.TypeErasue, from http://www.boost.org/doc/html/boost_typeerasure/examples.html#boost_typeerasure.examples.multifunction.
			This is promising about the way of conbination based on 'any', though it lacks most other interface from 'std::function' as well as specific resolutions of issues.
			The resulted interface is actually quite different to 'std::function'. It is placed here for exposition-only use.
Generic object type 'ystdex::any' has been optimized.
	The constructor now avoids unnecessary initializations of unused storage data member.
		The storage modifications are redundant when the constructors are correctly implemented.
		This improves performance a bit.
		Because 'constexpr' is needed for the default constructor, it has to be with explicitly initialized storage.
	The assignment operators are changed.
		They are specified in terms of 'swap' in ISO C++17 [any.assign], which is occasionally exactly the same (except the parameter name) to the old implementations.
		However, implementions (at least libstdc++ and Microsoft VC++, but not libc++) may use reset and move instead, granted by the valid but unspecified move-from state rules stated.
		Now assignment operators of 'ystdex::any' change similarly.
		These changes improve performance in heavy use (NPLA1 interpretation) of 'ystdex::any' as well as 'ystdex::function' instances based on it.
			Without the changes, use of 'ystdex::function' instead of 'std::function' in 'YSLib::GHEvent' is slow.
				This can be no less than 10% mesuared by intrcution fetch in release configuration of x86-64 Linux built by GCC 8.2.1, at least in NPLA1 case with mostly object language applicative calls.
					The used NPLA1 program is equivalent to '$defl! fib (&n) ($if (<=? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)))); iput (fib 17); exit'.
					The case is with 'int' arithmetic operations, applicatives 'iput' and 'exit' given by the implementation in the client code.
					The environment initialization has also a few minor initialization and bookkeeping in NPLA1 and native code.
				CxxFunctionBenchmark-derived tests (on 'function<int(int)>') does not find the differences.
			The performance is now comparable to 'std::function' previously.
	The underlying storage has been tuned.
		To reduce overhead of indirect calling in DLL/DSO, more member functions of 'ystdex::any' is put in the header instead of the "any.cpp".
			This is particular effective to be used as 'ystdex::function' base implementation.
			To the test case above, it can reduce 102% cost to 90%, with 'std::function' in 'YSLib::GHEvent' as the base line.
		The resulted storage is 2 words in typical implementations (e.g. 8 bytes in x86).
			This is larger than 'std::experiment::any' in libstdc++, but less than several others like Microsoft VC++'s.
			This is occasionally same to some other implementations, like https://github.com/emweb/wt/blob/master/src/Wt/cpp17/any/any.hpp.
		Note small object optimization may harm to overall throughput if not used properly.
			If the object is not small enough, it will have significant pressure on register files of the processor.
			This implies the size should be reasonably small.
			In fact, smaller size may perform better even it has addtional allocation cost.
				 Notably, the size of 'sizeof(ystdex::function<...>)' is 16, which equals the sum of size of 'ystdex::any' and the invoker.
				 As 'ystdex::any_storage' is 8 bytes, it is not engough to store a polymorphic holder with allocator pointer (which requires 12 bytes) in 'ystdex::any_storage'.
					The polymorphic holder has at least an overhead of 4 bytes of the virtual table pointer in both Microsoft and Itanium C++ ABI.
					The allocator pointer (an instance of 'std::unique_ptr') basically has 4 bytes for the pointer, and additional 4 bytes for the non-trivial allocator object (like a 'ystdex::polymorphic_allocator' instance used in 'YSLib::AllocatorHolder').
				 'YSLib::AllocatorHolder' requires 12 bytes as the polymorphic holder so it also cannot be stored locally.
				 However, even 'YSLib::YObject' has allocated more for 'YSLib::AllocatorHolder', it is still better because small 'ystdex::any_storage' benefits other cases.
	Allocator support has been added.
		The allocator design here also applies in implementing 'ystdex::function'.
		This is not same to the allocator type-erased model in library fundamental TS v3 (WG21 N4758) or WG21 P0987.
			It does not has 'allocator_type' nested type, and the member function 'swap' does not throw.
		It is considered that separately erased allocators like WG21 N4758 'std::experimental::function' is harmful.
			As 'ystdex::any' is used to implement 'ystdex::function', the concerns have been raised a while.
			The point is similar to WG21 P0043, as the container semantics have incur performance and other subtle ease of using issues.
			Some designs are different to WG21 P0043.
				The default constructor does not specify the behavior equivalent to the default allocator.
					It would be equivalent where the default allocator has same allocation behavior to 'new'.
						Note the allocation in the default allocator does not guarantee it has a single 'operator new' call, neither would it interact with class-scope 'operator new'.
				The copy of allocator object is required.
		The default cases (without explicit allocator specified in construction) can use 'pmr::default_memory_source'.
			It can actually be more efficient than raw 'new' in a sufficient long.
				Though no definite determinism, his can be related to cache efficiency.
			This is not applied because the cost in mandatory abstraction semantics is greater and this is not possible to optimized away because the memory resource can be set later.
				If memory resource is really needed, it should be constructed with a 'ystdex::pmr::polymorphic' instance.

$2019-01:

report.impl:
Unifying parameter type has been reviewd.
	This basically judges whether a forwarding reference parameter or a non-reference (object) parameter used in a specific context.
	The rationale is previously published as an answer at https://stackoverflow.com/questions/21035417/is-the-pass-by-value-and-then-move-construct-a-bad-idiom/53825424#53825424.
		A core notion of judgement for whether style used is "ignorable" of the cost, to ensure there is no unacceptable overhead while having the pros of non-reference parameters.
		If and only if the ignorable condition is true in the context, unifying (non-reference parameter) is preferred.
	The non-reference (object) types are applied to callable parameters in operations concerned with callable wrappers.
		This is consistent to 'std::function', 'ystdex::function' and similar types.
		Class templates like 'ystdex::expanded_caller', 'YSLib::GHEvent', 'YSLib::GEvent' and their helpers like 'ystdex::make_expanded' have been adjust consistent with this style.
			Previously, the constructors of the instantiated classes might have different styles used. The inconsistecy has now been fixed.
			It also saves several 'ystdex::decay_t' template instantation and it further reduces bloat of internal templated code using such types before decaying.
				For 'YSLib::GHEvent', this also makes internal operations for equality have more consistent types in different cases.
			For caller sites passing values to such operations, the forwarding calls have to been modified for efficiency and avoidance of unexpected copies of arguments being passed.
				This is mostly by changing 'yforward' to 'std::move'.
				Note 'ystdex::expanded_caller' is special in some cases, as it does not necessarily used as a holder-like wrapper.
					For caller site in NPLA1, this is better changed to 'ystdex::lref'. However, 'ystdex::expanded_caller' currently does not support qualifiers other than 'const'.
						So 'ref-qualifiers' are not respected in the calls.
						This is known and documented in the comments.
	Note constructors of 'ystdex::any' are not the same, as it does not assume the parameter object having ignorable cost during passing like the wrappers above.
WG21 P0541 has been implemented now, as it is approved in the current working paper of the standard.
	The major change is adding the pair initialization with uses-allocator construction recursively.
	Other change includes simplification on allocators.
		For 'pmr::polymorphic_allocator', it is simplified even when used with Microsoft VC++, which has no support yet.
		There is nothing to do with 'scoped_allocator_adaptor' because it is not introduced in 'ystdex'.
	The implementation is somewhat tricky.
		Since it needs to work without inferred trailing return type indroduced in ISO C++14, the declarations of implmentations are broken down in pieces when necessary.
		The implementation reveals some fixes on buggy 'ystdex::is_invocable' and related traits (while the 'std' implementations in libstdc++ is correct).
			The cv-qualified recursive instantiation will not work because of types mismatched in different declarations and function body in the implementation.
				The bug in the traits wronly used the functional declarator as the template arguments internally, which dropped qualifiers unexpectedly.
				For the similar reason, the already removed 'std::result_of' does not qualify to be used here.
			Another bug is that missing SFINAE in 'ystdex::is_invocable_r' and 'ystdex::is_nothrow_invocable_r'.
				The bug in 'ystdex::is_invocable_r' is caused by incomplete type handling.
					See also https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65760 for the similar bug.
				The bug 'ystdex::is_nothrow_invocable_r' has more concerns on 'noexcept' test.
				These bugs are not directly concerned here, but since the bug of 'ystdex::is_invocable_r' makes constructors of 'ystdex::function' not conforming as 'std::function', they are also fixed together.
		There are also multiple implementation issues.
			Mostly issues will not be problems without recursive pair support.
			At least for platform Android, libstdc++ is lack of the resolution of WG21 N4387, i.e. the conditionally EXPLICIT constructor of 'std::pair', so there needs additional workaround.
			For platform DS, G++ 8.1 complaints weirdly with an error on use of deleted defaulted function.
				The error is triggered when instantiating the event map lookup ('emplace_hint') in YFramework module YSLib::UI::YWidgetEvent after the feature here is implemented.
					See also LWG 2397, whose resolution is conditionally used here.
				The error is similar to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88368.
					However, because it is on instantiating 'YSLib::ValueHolder<std::_Tuple_impl<2, std::tuple<YSLib::ValueObject&&>&&>>' so there is no way to insert the proposed workaround.
				Clang++ 7.0 does not has the problem.
				It is unknown why this bug is not on platform MinGW (G++ 7.3), Android (G++ 5.3) (after other workarounds), and Linux (G++ 8.2), despite that the bugzilla issue also does not locate the root of the bug precisely.
					Note the header <tuple> is exactly same between platforms MinGW and DS.
				For interface used by 'YSLib::ValueObject' implementation, there is room to implement.
					The user code may be broken if 'ystdex::any' constructors are not SFINAE-friendly after the 'ystdex::any' initialization involving the allocator calling with 'ystdex::uninitialized_construct_using_allocator'.
						The template default arguments for SFINAE are tricky.
							They are carefully coded to avoid infinite recursion on deducing the template parameters.
							As there can be static assertions in value holders, non-holders are checked to ensure they are not the template argument of the holders.
					To use the SFINAE-friend 'ystdex::any' constructors, 'ystdex::any_ops::construct' and holders 'init' static member function templates are also tuned to be SFINAE-friendly.
					For use of 'ValueObject' with SFINAE-friendly constructions, 'ystdex::boxed_value' is also improved with SFINAE-friendly constructors.
					It can be still broken when 'std::tuple<const ValueObject&>' (rather than 'std::tuple<ValueObject&>') used with instantaiation of 'ystdex::uses_allocator_construction_args'.
						This is broken by SFINAE check in infinite recursion of 'std::tuple' constructor for multiple elements, which should fail in this case.
						This only breaks non-C++17 modes (with GNU extensions or not) in G++ and Clang++.
							It has nothing to do with 'std::invoke'.
							It should have nothing to do with CWG 1227, as C++14 modes also fail.
				As the workaround, the non-throwing check is intercepted for 'std::_Tuple_impl' instances used for 'ystdex::boxed_value'.
				Other workaround includes preventing nested (in template parameters) 'YSLib::ValueHolder' instances constructed in 'ValueObject'.
					This is not guarded by the compiler version condition checks because behavior of avoiding nested 'YSLib::ValueHolder' should be uniform for all implementations.

$2019-03:

report.impl:
Pointer holder in module YSLib::Core::YObject is reworked.
	Semantic properties on lifetime have changed.
		Based on clarification of allowing exception in holder 'get' function in module YStandardEx::Any, getting an object may throw an exception if the object is not existed.
		Since the getter may throw, some 'ystdex::any' API as well as 'GetObject' overloads for 'ValueObject' do not have noexcept-specifier any longer.
	For weak pointers ('NPL::weak_ptr' instances), the getter can throw on expired now.
	However, the 'type' function in the pointer holder still does not throw. But the behavior is also changed.
		Now it does not reilies on owner judgement.
		For weak pointers, it does not need to get strong pointers to get the type.
			An expired value might lead to 'void' type previously. This is changed to getting 'void' only when the pointer value is null despite the owner.
			User code should be careful in this case.
NPL objects involved with pointer holders are effected by the change of pointer holder in module YSLib::Core::YObject.
	Values of Weak references in the past would be more troblesome as the values without strong reference is recognized as 'void' rather than concrete type.
		So, there would be simply wrong value rather than the 'YSLib::bad_weak_ptr' exception thrown, if no other strong reference is kept.
		The only example is 'ContextHandler' used as the default object by the call of 'NPL::A1::Forms::DefineWithRecursion'.
	This is now changed to improve the interoperbility.
		See the discussions of pointer holder modification for weak pointers above for reasons.
	Keeping some strong references elsewhere is however difficult after the whole evaluation without special handling using centralized storage (e.g. in 'NPL::ContextNode').
Internal recursive thunk as the part of implementation of function 'NPL::A1::Forms::DefineWithRecursion' is reworked.
	To allow identifying the situation of cyclic references, default objects still use weak references, but the behavior is slightly changed. See the discussions concerned with pointer holders above.
	Now newly bound variables are stable, i.e. they do not be restored to another values in the call of 'NPL::Forms::DefineWithRecursion' after the evaluation of the expression as the binding source.
		This ensures references to these variables do not go out of their lifetime unexpectedly.
		After defining, the default objects are recovered as thunks which access the environment by name for the real caller when called.
			This allows check and exceptions can be thrown on failure.
	Expired 'weak_ptr<ContextNode>' value in a default object is a corruptied value.
		This is now handled generally by by improved implementation in modules NPL::NPLA and NPL::NPLA1 with API provided by module NPL::NPLA.
		If the default object is corruptied and called, it would throw a different exception ('bad_weak_ptr') from default ones.
			This is undefined behavior in the object language.
				The current behavior is for ease of debugging.
				Although it will not changed frequently, the behavior is not guaranteed stable.
	Implementation of operative '$defrec!' (by 'Forms::DefineWithRecursion') is revised.
		To avoid undefined behavior caused by recursive reference with ownership, the weak reference of target bindings is kept.
		The environment access to recursive binding is now delayed with symbol access to the locked-on-access environment, to allow more error checked (in case of already undefined behavior specified in the object language), e.g. by throwing 'bad_weak_ptr'.
		Since the environment enclosing the bound variables does not have strong reference to the object, it should be careful to save the environment in the binding with 'lock-current-environment', rather than 'get-current-environment', if necessary.
	The implementation difference is significant especailly when 'NPL::LiftToReturn' does not lift reference at first by 'NPL::LiftTermRefToSelf' (now removed).
		The lift makes it essentially deep copies the shared value (configured by pointer holders) of bound variables.
			See the values of shared variable '$aux' in the following cases.
		Case 1 (an alternative derivation of '$sequence'):
			$def! $sequence
				($lambda (&cenv) ($lambda #ignore $vau/e cenv body env
					$if (null? body) inert (eval (cons $aux body) env))
					($setrec! cenv $aux $vau/e (weaken-environment cenv)
						(&head .&tail) env
						$if (null? tail) (eval head env) (($lambda #ignore
							(eval (cons $aux tail) env)) (eval head env)))
				)
				(() make-standard-environment);
			$sequence "a" "b";
			The case above will not work without deep copy in 'NPL::LiftToReturn' of the shared values if '$aux' is not stable.
				Alternatively, lift specifically configured in implementation of 'cons' or wrapping '$aux' with a native deep copy identity function for both occurences is also OK.
		Case 2 (an invalid derivation of '$sequence'):
			$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (() copy-environment) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (() copy-environment) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))))
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));
			$sequence "a" "b";
			The derivation is invalid because of cyclic references, which implies undefined behavior in NPLA1.
				With the deep copy (likewise in Case 1), it will occasionally work as the '$aux' is unshared before calling.
					With modification of '$defrec!' with delayed environment access, it does not work.
				Without the deep copy and '$defrec!' modification, it also does not work.
					It will access invalid memory by TCO in the call using the shared value hold by '$aux'.
					It will access invalid memory or infinitely recursively reenters the host function (value of 'NPL::ContextHanlder') of '$aux'.
						Whether to reenter depends on the implementation details of 'NPL::Forms::DefineWithRecursion'.
				The applicative 'deshare' is provided to restore the deep copy locally. It is not needed in most cases.
			The workable derivation is:
				$def! $sequence
				(wrap
					($vau (&$seq2) #ignore $seq2
						($defrec! $aux $vau/e (make-environment (() lock-current-environment) (() copy-environment)) (&first .&rest) env
							($if (null? rest) (eval first env)
								($seq2 (eval first env)
									(eval (cons $aux rest) env))))
						($vau/e (make-environment (() lock-current-environment) (() copy-environment)) &body env
							($if (null? body) inert
								(eval (cons $aux body) env)))
					)
				)
				($vau (first second) env (wrap ($vau #ignore #ignore (eval second env))) (eval first env));
Memory safety of NPL environment is taken cared.
	Anchors in 'NPL::A1::Forms::BindParameter' are fixed.
		This fixes a bug that releasing TCO frames too eary.
		They were wrongly referred to TCO temporary, which is not the cases used in the referent implied by the reference values.
		To support the fix, 'NPL::A1::Forms::MatchParameter' now has more additional parameters to indicate the anchor pointer.
	Additional check for memory safety based on environment anchor reference counts in NPLA is added.
		The check is performed in the destructor of 'NPL::Environment'.
			The check get reference count of anchor and ensure it is expected. Otherwise, it issues an error message by logging (via 'YTraceDe', not the logger in 'NPL::ContextNode').
			Since there is no specific order of destruction of bindings in the environments, this is not reliable in general.
				It should be OK to leave the dead anchor pointers (in the destructor of the environment binding recored) since they are essentially the weak references without accesses.
				Removal of the order requirements would also increase performance.
				And it will cost too much to add a specified order for each bindings record in the environments.
				So, it is normally only useful to aid debugging.
			The anchor of temporary bound by the '&' sigil for reference operands in the TCO impmlementation of 'NPL::A1::BindParameter' will cause significantly lot of false positive check failures.
				Because the source environment of referent is not traceable in the function, the anchor in the references are not accurate.
					Without the fixes above, there can be many false positive results.
					With the fixes above, there can be still a few false positive results shown on the cases having references in the environment which is introduced as the local environment of some caller.
						These were exactly buggy without the fixes having nothing to do with the actual bug.
				However, this is still necessary for safety of TCO within nested function calls.
					At least 'NPL::A1::ReduceOrder' does require the parent frames not being released too early, which in turns relying on the count introduced here.
				Ideally the anchor should be passed from the real referent.
					However, this is not always possible unless that all objects have the anchors.
					The current design does not use anchors for tracing all objects.
						Only environments and reference values in the object language have anchors.
						Otherwise, it needs too many resources and it is not even a good choice for debug builds.
							If such capability is needed, a tracing GC would do better in general (except that the determinism of finalization should be cared additionally).
			For performance and the correctness reason above, this is not enabled by default.
				This can be enabled by change the definition of the new macro 'NPL_NPLA_CheckEnvironmentReferenceCount' in the header of the module NPL::NPLA to control the conditional inclusion.
					The macro is in the header to get less restrictions on the implementation and to prevent possible warnings of unused code as well.
		Since the dead environment references are allowed to be preserved elsewhere, direct check at destruction of environment have false positive results.
		More precise check is still at environemnt destruction, but it distinguishes anchor reference counts from environment references vs. term references.
			The basic idea is to store another reference count to indicate the different source, i.e. 'NPL::EnvironmentReference' vs. 'NPL::TermReference'.
				To minimize the change, the unused anchor value is now changed to store the secondary reference count, and 'NPL::EnvironmentReference' are modified to have explicit reference count maintenance code with friendship of the anchor value interface.
				This is not efficient, anyway.
			The check is then added to ensure all remained anchor references are from 'NPL::EnvironmentReference'.
		The check is then used to find bugs in the current implementation.
		For non-TCO implementations, everything is OK.
		There are several failure cases without tail rewriting being enabled:
			1. $let ();
			2. list*% ();
			3. ($lambda% (x) x) ();
			4. ($vau% (x) #ignore x)();
			5. ($lambda (x) forward x) ();
			6. ($lambda (x) ($lambda (y) idv y) x) ();
			7. for-each-ltr ($lambda .) (list ());
			8. map-reverse ($lambda .) (list ());
			9. $def! l list (); ($lambda ((&x .)) x) l;
		While some of the cases (3 and 4) are indeed undefined behavior, a few others are really interesting.
			The cases 1, 2 and 5 is the real bug, whose fix is to reorder the cleanup of TCO action records.
				The order is significant, but there is still uncertainty not properly handled before.
				This fixes many cases like case 1 and 2 above, and all errors shown in the loading stage of the module NPL::Dependency are cleanup.
			The case 6 is caused by order of components removal in the same frame.
				Note the name 'idv' is somewhat insignificant (as it can be any unary function compatible with the argument), for example the following are also problematic:
					6a. ($lambda (x) ($lambda (y) id y) x) ();
					6b. ($lambda (x) ($lambda (y) ++ y) x) "";
				And even with an empty body, it is still problematic:
					6c. ($lambda (x) ($lambda (y)) x) ();
					6d. ($lambda (x) ($lambda (.)) x) ();
				But the following variants are OK:
					6e. ($lambda (x) ($lambda (.) ()) x) ();
					6f. ($lambda (x) ($lambda (y) y) x) ();
					6g. ($lambda (x) ($lambda (y) (idv y)) x) ();
					6h. $def! foo $lambda% (z) z; ($lambda (x) ($lambda (y) foo y) x) ();
					6i. ($lambda (x) ($lambda (y) ($lambda% (z) z) y) x) ();
				This is fixed by explicitly clear of the components in the frame before the removal.
			The case 7, 8 and 9 are caused by the bug of '&' reference using wrong anchor from 'NPL::BindParameter'.

$2019-04:

report.impl:
Several designs of NPLA have been revised.
	The reference type ('NPL::TermReference') now supports xvalues.
		This is achieved by additional metadata as the internal data members of 'NPL::TermReference'.
		The metadata is organized as the tag type 'NPL::TermReference::Tags'.
			Member functions with 'bool' parameter are updated to use this type instead.
		The constructors with inference of the metadata is also updated.
			Now the arguments keep the tags using 'NPL::TermToTag'.
	Value category are identified by metadata only in references.
		Currently objects in environments are not general available in the object language except for a few operations like 'resolve-identifier' in NPLA1.
		The type of object 'x' is like 'decltype((x))' in the host language, in despite of 'decltype(x)' having possible different result.
		Now the reference type 'NPL::TermReference' has more tag.
		For temporary objects bound to references, the metadata is needed in 'NPL::TermNode' as well.
			The tag type is now lifted as the bitmask scoped enumeration 'NPL::TermTags'.
			An index enumeration 'NPL::TermTagIndices' is also provided to avoid magic values in the enumerators in 'NPL::TermTags'.
	'NPL::EvaluateIdentifier' is fixed to ensure results are lvalues.
		Other resolution are not directly subject to the value of variable.
		This is carefully designed to keep the applicative 'forward' work.
			There are two dependencies of the implementation as the prerequisitions of this change.
				First, the applicative 'first%' is needed to changeto prevent invalid 'forward' call in the old implementation.
				Second, operatives of the '$let' family are now split like '$lambda' and '$lambda%'.
					The old implementations would not work without the change because 'forward' call cannot correctly get the value category of the final return value when it contains the lvalues bound directly as objects in the parameter list.
					On the ohter hand, in old implementations with old rules, it would not treat such resolved parameters as lvalues.
			For performance, a native implementation is also added.
		The result of 'lvalue?' for the reference from environment are always '#t'.

$2019-05:

report.impl:
The simplified Chinese translation (in locale zh-CN) of terms has been reconsidered, but nothing has been decided to change yet.
	The translation of term 'complete' for types has been reconsidered to change to '完全' from '完整' ('完全类型' from '完整类型' for 'complete type', '不完全类型' from '不完整类型' for 'incomplete type').
		The current translation is consistent to some canonical sources, including the standard GB/T 15727-94.
			The documentation of Microsoft Visual Studio has the same use of 'incomplete type', e.g. https://docs.microsoft.com/zh-cn/cpp/c-language/incomplete-types?view=vs-2019.
			The diagnostic messages of Microsoft VC++ are also the same on 'incomplete type'.
			This is also used in some other notable online documents like https://zh.cppreference.com/w/cpp/language/type.
		However, the consisdered replacment is consistent with other sources.
			It is consistent with most mathematical concepts and the usual translations of phrases widely used in computer science like "NP-complete problem".
				A second mathematical replacement is '完备'. This is not considered here. 
			It is consistent with diagnostic messages in GCC.
				The characters '不完全' for 'incomplete' are also exactly same in locale zh-TW.
					However, some translations in locale zh-CN is considered somewhat in the zh-TW flavor, e.g. '提领' instead of '解引用' for 'dereference'. So, this is considered not quite precisely reflecting the actual popular use in zh-CN.
				The characters '不完全' for 'incomplete' are also exactly same in locale ja, e.g. '不完全型' for 'incomplete type'.
			There is an entry of '不完全类型' in Chinese Wikipedia, e.g. https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B.
				However, the content is mostly about partial classes in C#.
				As the time of writing, the only other entry of translation available is https://de.wikipedia.org/wiki/Partielle_Klasse, which has nothing about incomplete types of C/C++.
					The English tranlation is at https://en.wikipedia.org/wiki/Class_%28computer_programming%29#Partial. This is again has nothing to do with incomplete types.
		As concluded, the replacement use is not considered canonical in locale zh-CN. Nothing is changed.
	The translation of term 'full expression' in locale zh-CN is still '完全表达式'.
		The tranlsation of 'full' is originally kept distinct to 'complete'.
			As the latter is not changed, it is kept.
		There is also no good (intuitive and widely used) replacement other than '完全' or '完整' find.
		Further, the prase is hyphened in recent working draft of ISO C++.
			This change makes it quite contextually specific to limited C++ specification text.
				The use in YSLib documentation (notably, the glossory used in wiki pages and in NPL documents) is then not necessary to keep the use as exact as the C++-style.
			This is gramatically (in English) not necessary, though.
		Note that the current "full-expression" in ISO C++ draft has other problems, see https://github.com/cplusplus/draft/issues/2885.
Self assignment is supported in several applicatives in NPLA1.
	The old '<-%' did not handle this at all.
		It is now fixed in 'assign%!'.
	The old behavior of 'NPL::A1::Forms::SetFirstRef' actually did not allow self-assignment by documented '\warning' command in the Doxygen comments.
		It is too error-prone to involve undefined behavior, as there is no easy way to make sure the parameter is of an rvalue reference implying not aliasing like in C++, so it is subject to be changed.
		To be consistent with 'assign%!', the self-assignment is handled simlarly.
			Note arbitrary cyclic reference check is still not present.

$2019-06:

report.impl:
Several NPLA1 improvements are made, including some critical bug fixes related to the PTC guarantee.
	A bug of dynamic environment capture in vau abstraction causing PTC guarantees broken has been fixed.
		The bug causes '#ignore' not being ignored in the creation of the combiner.
		Instead, a dynamic environment named "#ignore" is bound in the newly created environment before evaluation of the vau abstraction body in the call of the combiner.
			This breaks PTC because currently named dynamic environments are not collected by the TCO frame compression algorithm.
				With the fact about the fundamental role of vairous vau abstractions, the bug also breaks almost all non-native derivations in NPLA1.
				Even despite the guarantee, asymptotic memory consumption behavior between native and non-native lambda abstractions differs, which should be unexpected.
			This is actually weaker than what Kernel guarantees in RnRK.
				However, klisp also leaks here, e.g. by '($sequence ($define! $f ($vau () #ignore (($f)))) (($f)))'.
			With the fix, at least the non-native derivation of lambda abstractions behave normally. For example:
				$defl! f () () f; () f;
				$defl! f () () (unwrap f); () f;
			The following cases are also fixed regardless of native derivations are used or not:
				$defv! $f () #ignore () $f; () $f;
				$defv! $f () #ignore () (wrap $f); () $f;
	NPLA1 now enforced clearer rules on temporary lifetime. Notably, the operative '$sequence' is clearified with intended behavior on temporary lifetime.
		This was underspecified at the first glance of the specifiation of the operative.
		However, there is a real bug of native implementation of '$sequence' and it is now fixed.
			The general temporary rules to assert full expressions on parameters were only effective for combiner "application", thus it should have make the parameters sequenced, which was not implemented in the native implementation.
			And anyway, native and non-native derivations should have the same observable behavior (e.g. with destructors of hosted objects called), whatever the expected behavior should be.
	NPLA1 TCO implementation is simplfiied in various aspects.
		The TCO implementation is simplified to avoid a bug on the collection operation of the orphan temporary object cleanup.
			The old implementation collect the temporary object unconditionally during the vau handler calls. This is illogical in general.
				It would break the following case:
					$defl! |> (&f &g) $lambda/e% ($bindings/p->environment ((() make-standard-environment)) (&f (forward f)) (&g (forward g))) (&x) (forward g) ((forward f) (forward x));
					$defl! double (n) * n 2;
					$defl! increment (n) + n 1;
					(|> (|> (|> double double) increment) double) 5;
				The compressor would access invalid parent environment collected previously by the orphan temporary object cleanup.
			The new scheme uses more less aggressive orphan temporary object cleanup, but a simpler temporary object store at first in the binding code in the vau handler calls.
				Since the temporary binding has been involved with 'TermTags::Temporary' on terms directly, no other temporary objects are need to be saved.
				Now there is no difference in TCO and non-TCO implementations to store the operands.
			The old implementation is still kept for exposition only.
				Note it is still problematic with following cases even when the orphan temporary object cleanup is disabled during the vau handler calls:
					$defl! f (n) ($vau (x) d eval x d) (f n); f ();
				While the following case is good to TCO:
					$defv! $f (x) d eval x d; $defl! f (n) $f (f n); f ();
			The orphan temporary object cleanup is also disabled in the reduction of by 'A1::ReduceAgain'.
				It might be replaced for a saner and simpler implementation in future.
		The TCO implementation is simplified with specialized inactive frame detection removed.
			The old implementation overlaps the execution of compressor lifetime and the record frame list traverse, which is not necessary and potentionally buggy.
				The frame detection in the record frame list traverse is now performed before the compressor.
			The specialized detection with variable deduplication between the active frame (saved in the guard) with its parents is now removed.
				On contrast, no variable deduplication is needed in the compressor.
			Currently both record compressor and inactive frame detection work for known cases to test PTC.
				No cases suitable only for compressor but not inactive frame detection, or vice versa.
			Moreover, actually no cases are tested for compressor itself.
				However, removal of environments not included in the activation records relies on the copressor or other means out of the scope of record frame list traverse.
			Since the compressor is more general, keep it instead of inactive frame detection in the traverse.
	NPLA1 TCO now collects function prvalue implemented as combiners as well as function lvalues.
		This is implemented by converting function temporary object to components saved in the vau handler before the evaluation of the function body.
		For example, the following cases now work conforming to PTC:
			$defl! f (n) ($lambda (x) f x) n; f 1;
			$defl! f (n) ($vau (x) d f (eval x d)) n; f 1;
		In contrast, the following correspoinding cases using lvalues work even without the change:
			$defl! g (x) f x; $defl! f (n) g n; f 1;
			$defv! $g (x) d f (eval x d); $defl! f (n) $g n; f 1;
		Note the following cases also work without the improvement because function prvalues are immediatedly called before recursively saved as temporary objects:
			$defl! f (n) ($vau (x) d eval (list f x) d) n; f 1;
			$defl! f (n) ($vau (x) d eval x d) (f n); f 1;

$2019-08:

report.impl:
Assertions in YBase have been revised.
	The assertion macros 'YAssert' and 'YAssertNonnull' should have be more like 'assume' by default.
		This is now guraranteed by using 'assert' instead of 'yassume' in when 'NDEBUG' is defined.
			Different to 'yconstraint' or 'yassume', with name "assert", use of 'yassume' may cause surprising result if the expression is evaluated in release configurations.
			It is also better for performance when the hint is not used for branch.
		Now there is also a note in the source to allow them being overriden.
	The pseudo keyword 'yconstraint' and 'yassume' are explicitly specified with unspecified behavior about whether the expression is evaluated.
		This ensures the allowance of using of 'yassume' as current.
		See also the caveats of 'YB_ASSUME' below.
	The macro 'YB_ASSUME' is also updated.
		It is also explicitly documented with unspecified behavior on the condition expression evaluation.
		Support of '__builtin_assume' is added. This is superior than the implementation with '__builtin_unreachable' in general.
		Not same to 'GSL_ASSUME' in https://github.com/Microsoft/GSL/blob/master/include/gsl/gsl_assert, the '!!' is not used in the fallback, since '_expr' is not assumed as an expression capable as the operand of '!'.
		Since it can still be implemented as fallbacks without guarantee of the unevaluated operand, it is suggested that this macro should be used locally for the best performance.
	The evaluation of condition expression may have effect on optimization.
	A new peseudo keyword 'yverify' has been added.
		The interface guarantees the condition expression is not evaluated when 'NDEBUG' is defined, which is like the macro 'assert' in the standard library.
		This can be treated as 'yconstraint' with 'assert' instead of 'yassume' in the implementation aspect.
	Uses of 'yconstraint', 'yassume', 'YAssert' and 'YAssertNonnull' are also revised.
		After the change of 'YAssert', most cases just work as expected.
		Some other evaluations of expressions in these macros may still be suboptimal, but not much.
			Most calls involved are like call on 'is_undereferenceable' which is assumed pure, though the implementation may be lack of the information (esp. in the cases of ADL).
				These assertions are replaced by 'yverify' expressions directly or indirectly.
			A few constarint checks in the operand of 'yconstraint' in YBase module YStandardEx::Any are now implemented separatedly using 'YAssert'.
				See also the notes about LTO below.
			The checks in 'ystdex::polymorphic_downcast', 'ystdex::erase_n' and a few more are now implemented using 'YAssert' instead of 'yassume'.
		For code where the hints are needed, additional explicit 'YB_ASSUME' is more appropriate.
		The function 'NPL::AssertBranch' in YFrameowrk has an issue of warning [-Wunused-parameter] on unused parameter if 'assume' is used. This has been fixed.
	See also https://stackoverflow.com/questions/25667901 and https://stackoverflow.com/questions/44054078.
Some exception specifications have been fixed.
	Mostly it is a wrong use between the choice of 'ynothrow' and 'ynothrow_spec'.
		Note in YSLib, currently only noexcept-specifier but not noexcept-expression is adapted to be a macro.
		The latter has an 'noexcept' operator in the noexcept-expression with an unevaluated operand. This is not suitable for a result from a type trait value.
	To simpler the fix, traits within 'ynothrow' (after the fix) as an exception speificier is replace by 'ynothrow_spec' with an unevaluated operand directly, when feasible.
		This is not feasible when the result is more complicated (e.g. requiring 'std::declval').
			Most 'is_nothrow_default_constructible' (but not things like 'is_nothrow_default_copy_constructible') used in YBase can thus be replaced.
				However, replacement of 'is_nothrow_default_constructible' can not work in G++ 7.1 due to a bug.
					The resulted code causes G++ 7.1 crash: internal compiler error: in tsubst, at cp/pt.c:13525.
					This seems a regression not reported, but fixed in later versions (at least in 9.2).
					A possibly related case with exact the same diagnostics in G++ 7.1: http://coliru.stacked-crooked.com/a/7f17cf55137efefa.
						However, this case seems never fixed. Tested in https://gcc.godbolt.org/ for other versions:
							G++ < 6 there is no '-fconcepts', so the case does not work.
							G++ 6.1 ICE cp/pt.c:13014.
							G++ 6.2 ICE cp/pt.c:13073.
							G++ 6.3 ICE cp/pt.c:13073.
							G++ 6.4 ICE cp/pt.c:13077.
							G++ 7.2 ICE cp/pt.c:13607.
							G++ 7.3 ICE cp/pt.c:13630.
							G++ 7.4 ICE cp/pt.c:13657.
							G++ 8.1 ICE cp/pt.c:14378.
							G++ 8.2 ICE cp/pt.c:14400.
							G++ 9.1 ICE cp/pt.c:14560.
							G++ 9.2 ICE cp/pt.c:14561.
							Search on bugzilla shows some candidates.
								https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78514 for 6.2 matches, but it is for invalid code.
						Similar with https://wandbox.org/. It is not fixed in trunk (10.0.0.20190 for now). With G++ 7.1 the backtrace shown:
							prog.cc:13:8: internal compiler error: in tsubst, at cp/pt.c:13525
							 void f(Swappable& x) {}
									^~~~~~~~~
							0x5daeeb tsubst(tree_node*, tree_node*, int, tree_node*)
								../../gcc-7.1.0/gcc/cp/pt.c:13525
							0x5e67bc coerce_template_parms
								../../gcc-7.1.0/gcc/cp/pt.c:8103
							0x6dc46a resolve_variable_concept_check(tree_node*)
								../../gcc-7.1.0/gcc/cp/constraint.cc:304
							0x6dc514 deduce_constrained_parameter(tree_node*, tree_node*&, tree_node*&)
								../../gcc-7.1.0/gcc/cp/constraint.cc:329
							0x61df5e cp_parser_maybe_constrained_type_specifier
								../../gcc-7.1.0/gcc/cp/parser.c:17084
							0x6212c1 cp_parser_nonclass_name
								../../gcc-7.1.0/gcc/cp/parser.c:17175
							0x63f478 cp_parser_type_name
								../../gcc-7.1.0/gcc/cp/parser.c:16981
							0x63f478 cp_parser_simple_type_specifier
								../../gcc-7.1.0/gcc/cp/parser.c:16853
							0x62828d cp_parser_type_specifier
								../../gcc-7.1.0/gcc/cp/parser.c:16499
							0x62917c cp_parser_decl_specifier_seq
								../../gcc-7.1.0/gcc/cp/parser.c:13330
							0x643375 cp_parser_parameter_declaration
								../../gcc-7.1.0/gcc/cp/parser.c:21183
							0x643b57 cp_parser_parameter_declaration_list
								../../gcc-7.1.0/gcc/cp/parser.c:20999
							0x643ebc cp_parser_parameter_declaration_clause
								../../gcc-7.1.0/gcc/cp/parser.c:20922
							0x634ac1 cp_parser_direct_declarator
								../../gcc-7.1.0/gcc/cp/parser.c:19645
							0x634ac1 cp_parser_declarator
								../../gcc-7.1.0/gcc/cp/parser.c:19521
							0x64990d cp_parser_init_declarator
								../../gcc-7.1.0/gcc/cp/parser.c:19046
							0x64a75d cp_parser_simple_declaration
								../../gcc-7.1.0/gcc/cp/parser.c:12777
							0x64b365 cp_parser_block_declaration
								../../gcc-7.1.0/gcc/cp/parser.c:12602
							0x629cb4 cp_parser_declaration
								../../gcc-7.1.0/gcc/cp/parser.c:12500
							0x64f8fb cp_parser_declaration_seq_opt
								../../gcc-7.1.0/gcc/cp/parser.c:12376
							Please submit a full bug report,
							with preprocessed source if appropriate.
							Please include the complete backtrace with any bug report.
							See <https://gcc.gnu.org/bugs/> for instructions.
					The minimal case reduced is with the following code:
						#define YB_DLL
						#define YF_BUILD_DLL
						#include <YSLib/Adaptor/Font.h>
						#include <YSLib/Service/File.h>
						#include <NPL/Configuration.h>
						#include <YSLib/Service/FileSystem.h>
						#include <Helper/GUIApplication.h>
						#include <YCLib/NLS.h>
						void aaaaabbbbbbbcccc();
						void ddddeeeeeeeeffff();
					The case only fails when '-g2' or higher debug level is used.
						The case is sensitive to header inclusion order.
						Macros 'YB_DLL' and 'YB_BUILD_DLL' are necessary.
						Actually it is not Win32-specific ('YCLib/NLS.h' is not necessary here; put it here just to be simple).
					The case above is not reproducible with preprocessed file (with 'gcc -E -xc++'). So, this is tested directly with cc1plus for the whole source.
					It only reproduced when there are enough long (unmangled) names of functions or objects, or even macro names after '#ifndef'.
						The length of such long names is not less than 16.
					As the result, GCC 6.3 and GCC 8.2 work but GCC 7.1 and GCC fail.
						It seems a GCC 7 regression.
						It is not known which bug is related in GCC Bugzilla.
						As now, only versions 7 before 7.4 are conservatively assumed broken for this case.
			For clearity, 'is_nothrow_destructible' is also not replaced.
Some issues met with LTO are reviewed.
	LTO may cause multiple definition with MinGW.
		This is an unresolved bug. See https://sourceware.org/bugzilla/show_bug.cgi?id=12762.
		This is now fixed in build scripts (both the shell script and NPLA1 script), as well as the generator for Code::Blocks projects in the tools.
	The modification in YBase module YStandardEx::Any in build 864 requires workaround of the bug above.
	The modification of 'ystdex::unchecked_any_cast' in YBase module YStandardEx::Any in build 864 (see notes about constraints above) would cause wrong code (illegal instruction) in release static build of YSTest with MinGW32 G++ (at least i686 7.1 and 7.3).
		This is worked around by using 'yconstraint(p); yconstraint(p->has_value());' instead of 'yconstraint(p && p->has_value());'.

$2019-09:

report.impl:
YBase now provides 'ystdex::list' class template.
	It is a drop-in dedicated replacement to 'std::list', with some C++20 features (e.g. [WG21 P0084R2]) enabled.
	Currently it it remains the layout ABI-compatible to (non-debugging version) ISO C++11 'std::list' (which has a node count for O(1) size) in libstdc++.
	There are several differences to the implementation of libstdc++.
		There is no effort to detect whether a pair of list iterators is a whole range of a list object in getting distance between them.
			The internal implemantation of list iterators have overloads of 'std::__distance' for a fast access when the range is the whole list.
			The perforance might be effected if user code does not optimize explicitly in this case, e.g. on call of 'std::lower_bound'.
			Consider using something already knows the size of the range instead when possible, e.g. 'ystdex::lower_bound_n' in YBase.StandardEx.Algorithm.
		The implementation of 'list::remove_if' and 'list::unique' respect to [LWG 526].
			See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91620.
				Both libstdc++ and Microsoft VC++ has the desired behavior.
			This is fixed for 'std::list::remove', see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17012.
		The 'list::sort' implementation has some optimal implementation without using a magic number for pre-allocated temporary lists in libstdc++.
		The 'list::resize' implementation is optimized to avoid unnecessary size update.
		The 'list::erase' implementation for range is optimized to the 'clear()' case check (like Microsoft VC++) and have less update to pointers otherwise.
	The necessity for the previous builds is from the fact that 'std::list' implementation in libstdc++ on the Android configurations (with CrystaX) are still not conforming to C++11, and it breaks 'NPL::TermNode' allocator-extended construction in YFramework.NPL.SContext.
		However, since it also needs to fix 'std::stack' (thus, including 'std::deque') if nothing is changed in the client code in YFramework.NPL.SContext, update to the official NDK r20 is planned instead.
			The update requires to implemented YCLib.FileIO support for libc++ and a few other fixes, but no need to replace the 'std' types. 
		YFramework still plans to change to 'ystdex::list' now as it is believed to have better performance (at least in x86_64-linux).
	Another bonus is it supports incomplete value types specified in [WG21 N4510], which is adopted as an ISO C++17 feature.
		This is considered to be used in 'ystdex::pmr::memory_resource' implementations when the pool type was not exposed. Is not the case now.
		This is now used to replace 'ystdex::map' as the chunks onwer in 'ystdex::pmr::resource_pool'.
	The class 'ystdex::pmr::pool_resource' now uses 'ystdex::list' despite there is no need for adapt to incomplete value type here.
		The pool finding is optimized with 'ystdex::lower_bound_n' instead of 'ystdex::lower_bound' (see above).
			This have few effects for 'std::list' in libstdc++ because it is already optimized.
			However, this is necessary to prevent performance degression for other implementations without such optimization.
		Strictly speaking, since 'ystdex::pmr::resouce_pool' now is not an incomplete type, and no allocator-extended constructors are relied on here, there is no necessary to change the list type.
			However, the optimization of using 'ystdex::lower_bound_n' can have slightly better performance with 'ystdex::list' instead of 'std::list'.
		A side effect is that the change removes the debug interface used for the list type of libstdc++ in several debug configuarations, which should be OK for now, as the implementation of 'ystdex::pmr::pool_resource' before the change is considered stable enough.
Android platform toolchain has been updated.
	Because CrystaX NDK does not release an updated version for years, YSLib switched back to the official Android NDK.
		The old release CrystaX sticks on GCC 5. This requires workaround for libstdc++ still not conforming to C++11.
		The newer test builds (e.g. https://dl.crystax.net/builds/1072/) are alive.
			It seems thatstill not having up-to-date compilers. https://tracker.crystax.net/issues shows GCC 6 is still not ready.
	Although GCC 6 is sufficiently to remove the workarounds, newer compilers should be better.
	The newest version of official NDK, i.e. r20, is used. The toolchain has some changes needing some additional work.
		Since it now only containers Clang++ and libc++, the makefiles of YSLib should be changed.
			Some changes have to be made because libc++ is yet not a part of Android platform.
				This is by design, see https://developer.android.com/ndk/guides/cpp-support#libc.
				The NativeActivity still only supports loading of one dynamic library, so libc++ should be statically linked.
				However, exception handling does not work when 'YB_PURE' is used.
					It throws via '__cxxabiv1::failed_throw' even with 'catch(...)'.
						This indicates there is something wrong in unwinding.
						See https://bugs.llvm.org/show_bug.cgi?id=43275.
					There are some non-bugs excluded.
						The bug of '__gnu_Unwind_Find_exidx' in libc (Boinic) is fixed at and fixed in the platform.
							See https://github.com/aosp-mirror/platform_bionic/commit/55ca56c27ca166a247b1e621a0a0e3f4d1907b4d.
							See also https://github.com/aosp-mirror/platform_bionic/commit/aeb5bc658feaa579b72560a7026374cbeb38ea56 for the 1st try.
						NDK bug for static libc++ has been fixed. See https://github.com/android-ndk/ndk/issues/593.
			Some bugs of C++ code are fixed to make Clang++ happy.
Rule of non-reference argument passing is revised for allocators.
	Although the standard using the form like 'const allocator_type&' as the parameter type, YSLib uses 'allocator_type' directly in constructors unless necessary (e.g. implementing standard-conforming container interface).
	Besides odr-uses issues (to allow allocators used in constant-expressions which is not relied on in YSLib), performance counts.
		One reason is to allow copy elision in the constructor calls. It may also count to other optimization as a result, though.
		It is verified that at least in GCC 9.2 on x86_64-linux, the former can make the compiler generate slightly bad code.
			This is tested with NPL client code. Uses of 'NPL::TermNode' constructors may have worse code generated with bloated 'strcmp' calls. It seems a side effect of failure of inlining.
		See WG21 P0889R1 for the detailed analysis on possible effects.

$2020-01:

report.impl:
Implementation of NPL in YFramework module NPL::NPLA1 has been cleanup for performance.
	Trampolined reductions in YFramework module NPL::NPLA1 has been cleaned up, as well as other improvements.
		'NPL::A1' API now are simplified and imporved in efficiency.
			A bug of inconsistency between synchronous and asynchronous implementations of 'A1::ReduceAgain' has been fixed.
				The guard call in 'A1::Reduce' is unnecessary in the synchronous reduction implementation.
				It should have been replaced by 'A1::ReduceOnce' once available, whether TCO is used or not.
			Various implementations now uses 'A1::ReduceOnce' instead of 'A1::ReduceChecked' equivalence.
				This eliminates the unnecessary overhead of tracking 'ReductionStatus::Retrying' results which has been handled by 'A1::ReduceOnce' and 'A1::ReduceAgain'.
		Function 'A1::ReduceChecked' has been removed.
			The function is now considered confusing because 'ReductionStatus::Retrying' handled by this function has been nothing necessary to do with trampoline in callers for a while.
			The asynchorous implementation relies on the external trampoline to do the right handling of 'ReductionsStatus::Retrying', which is not as safe as explicit call of 'A1::ReduceAgain'.
				There are risks to handle unnecessary 'A1::ReduceOnce' action in the asynchonous implementation if there are more action other than 'A1::ReduceOnce' inserted before the asynchronous call of the check.
				On the other hand, the call of 'A1::ReduceAgain' ensures the inserted next continuation not intercepted by action other than the intentional 'A1::ReduceOnce'.
			The inserted asynchrouns check relying on the last status 'ReductionStatus::Retrying' is also inefficient in particular where no other actions are intended to be inserted before the later 'A1::ReduceOnce'.
	The macro 'NPL_Impl_NPLA1_Enable_TailRewriting' is removed.
		It is considered outdated for a while.
			Since the temporary objects are now stored in the reduced terms rather than frames for calls, no special allocations are cared.
			The only instance of the remaining use is 'A1::ReduceOrdered'. This is however always expected enabled for TCO. 
	A new macro 'NPL_Impl_NPLA1_Enable_InlineDirect' is added to tweak implementations on asynchronous calls.
		The macro specifies the outermost asynchronous calls formally composed by function templates like 'NPL::RelayNext' or 'NPL::RelaySwitched' now split and being synchrnized sequentially.
			This also means the inner calls (if any) composed by these function templates now usually ignore the return value 'ReductionStatus::Partial' in asynchronous implementations.
		The macro shall be used carefully.
			Asynchronous native implementations expect the actions in the called functions always asynchronous, so they can be further captured to be actions in the context.
				This is not necessary if the resulted reduction action is not needed to be captured as a continuation.
			If the asynchronous calls have direct recursion paths (which can potentially overflow the host stack), it can render the thunks useless.
	Term check in 'A1::FormContextHandler' is removed.
		There is no real use in the NPLA1 implementation except a few cases now.
			In applicative 'regex-match?' in YFramework module NPL::Dependency, term check is used as the precondition check by 'A1::Forms::RetainN'.
				It is easily avoided by direct call of 'RetainN'.
			The remaining call is 'NPL::IsBranchedList'.
				It should succeed for correct implementations, therefore it is replaced by an assertion in the call initiated in 'A1::FormContextHandler'.
		Term check can be opt-in in the handler if needed.
Some issues met with LTO are reviewed again, as $2019-08.
	Default constructors of 'ystdex::function_base' with lambda-expressions are fixed.
	However, the fixes would cause in YBase.YStandardEx.Any in build 878 (see notes about constraints above) would cause wrong code (illegal instruction) in release static build of YSTest with MinGW32 G++ (at least i686 7.1).
		This is worked around by using 'YB_ATTR(noinline) YB_ATTR(optimize("O2"))' when 'YB_IMPL_GNUCPP && defined(NDEBUG) && !(defined(YB_DLL) || defined(YB_BUILD_DLL))'.
			The using of static library are assumed across YBase, YFramework and client programs.
			There may be other implicit options for options are effective besides inlining. It is yet unknown which presice set of options are effective.
			It would be still broken if either 'YB_ATTR(noinline)' or 'YB_ATTR(optimize("O2"))' (or more low optimization level) is not present.
Warnings to suggest attributes and other source-level micro optimizations are applied when using GCC.
	Note the unrecognized warning options are ignored by GCC.
		Compatibility may concens across different vesions of GCC being used. Some of options known incompatible to old supported versions of GCC.
		However, as the policy in general, there is usually no effort to make newer warning options work with older toolchain versions.
		Version check of the toolchain in the build tools is planned to be implemented in future.
	GCC releases from 5 support "-Wsuggest-final-types and -Wsuggest-final-methods".
		See https://www.gnu.org/software/gcc/gcc-5/changes.html.
	GCC releases from 6 seem accept "--warn-suggest-attribute=const" "--warn-suggest-attribute=pure" "--warn-suggest-attribute=noreturn".
		This style seems compatible in future releases.
		However, the following shorter "-W" options are used instead in the build scripts for simplicity.
			This is even true when the support for GCC 6 series are not dropped yet.
			See the policy mentioned above.
	GCC releases from 7 seem also accept "-Wsuggest-attribute=const" "-Wsuggest-attribute=pure" "-Wsuggest-attribute=noreturn".
	GCC releases from 8 seem accept "-Wsuggest-attribute=cold".
	Wrong ong suggestions by "-Wsuggest-attribute=const -Wsuggest-attribute=pure" on functions with 'void' return type (causing G++ 9.2 warning: "-Wattribute") are ignored.
NPLA1 lexical analysis can be lifted reasonably reasonably ahead-of-time now.
	This is done by adding support of tokenizer callbacks in YFramework module NPL::SContext.
		For compatibility issues (e.g. used by NPL::Configuration), old ones are preserved and implemented with a default callback.
	The REPL context now uses the callback by default.
		The callback is exposed as a data member named 'ConvertLeaf'.
			This allows the alternative optimal 'ConvertLeaf' to return 'string' values as self-reducing terms rather than lexemes.
			It is also significantly more efficient by default.
			Further, it avoids the nested call safety problem in the recursive call of 'TokenizeTerm'.
		Alternatively, 'ConvertLeaf' can use a slightly different strategy to the default in 'NPL::SContext' one by converting 'NPL::TokenValue' as the result directly, instead of a separated call to 'TokenizeTerm' later in 'REPLContext::Prepare'.
			This also has merits above.
			It is not used to avoid complexity of radically different call paths and the modification of interface on 'REPLContext'.

$2020-02:

report.impl:
NPLA1 separator handling in YFramework modules NPL::NPLA1 and NPL::Dependency is optimized.
	The separator handling API is now exposed as class with function templates instead of non-templated functions.
	The old handling is implemented based on list evaluation passes.
		As the first pass, it can convert lists being evaluated to prefix form.
		This is now superseded by syntactic transformation in 'REPLContext::Preprocess'.
		This is now stricter for non-evaluated expressions, because some terms previously not evaluated (like paramter trees) are now also transoformed.
			Since ';' and ',' are never expected used as names of variables directly (without quotes indicating the code literals), this is not a breaking change.
		This is also stricter in statements of <body> (e.g. in '$cond').
			If a <body> has ';' or ',', it must have been enclosed in parenthese.
				This is for the syntactic priority.
				Otherwise, ';' or ',' will separate the <body> into two different <expression> at first, rather than two subexpression in the <body>.
			This is also not a breaking change.
				Instead, it is actually a fix to a missing diagnostics bug.
				A bug in <body> of '$cond' of such use in YSLib tool script 'SHBuild-YSLib-common.txt' is fixed before this improvement to avoid break stage 1 library building.
	The old handling in module NPL::Dependency is now moved to NPL::NPLA1 in 'REPLContext::Preprocess'.
		The new handling scan the term recursively, instead one pass.
			Along with non-evaluated expressions, this has some performance overhead.
				The overall performance is still slighly better than ond one in general for less evaluation passes, though. 
		Supposing 'passes' as a modifiable reference to a passes object (either of 'A1::EvaluationPasses' or of 'A1::TermPasses') and 'a' as the allocator, the old one can still be implemented (in C++) by new API (more efficiently) as:
			passes += ystdex::bind1([](TermNode& term,
				const ValueObject& pfx, const TokenValue& val,
				const ValueObject& pfx2, const TokenValue& val2) YB_FLATTEN{
				SeparatorTransformer::ReplaceChildren(term, pfx,
					ystdex::bind1(HasValue<TokenValue>, std::ref(val)));
				SeparatorTransformer::ReplaceChildren(term, pfx2,
					ystdex::bind1(HasValue<TokenValue>, std::ref(val2)));
				return ReductionStatus::Clean;
			}, ValueObject(std::allocator_arg, a, ContextHandler(Forms::Sequence)),
				// XXX: Allocators are inefficient for short strings here.
				TokenValue(";"),
				ValueObject(std::allocator_arg, a, ContextHandler(FormContextHandler(
				ReduceBranchToList, 1))), TokenValue(","));
A bug of missing regularization of leaf term reduction in NPLA1 is fixed.
	The bug is effective because the literal handling in 'A1::EvaluateIdentifier' does not guarantee the result is regular, and 'A1::ReduceLeafToken' does not handle it properly.
	This has been existed since the very early design, when the leaf pass and 'A1::ReduceLeafToken' are not present.
		It has been introduced by 'A1::RewriteLiteral' since build 725, moved to 'A1::EvaluateIdentifier' in build 726.
	Since build 807, 'A1::ReduceLeafToken' can call 'A1::ReduceAgain'.
		For call delegated to list passes, the term can be regulized in 'A1::ReduceCombined' by default.
		This does not change the other cases.
	Since build 858, support of irregular representations has been added to the main reduction function 'A1::ReduceOnce'.
		As a result, the input to leaf pass now does not guarantee it would be regular as before.
		The regularzation is then always required when there is no knowledge about concrete value representations.
Comparison of 'std::type_info' objects has been optimized by tuning options for the compiler.
	The behavior is controlled by macro '__GXX_MERGED_TYPEINFO_NAMES' in libstdc++'s <typeinfo>.
	This also has effect on hash (not used).
		See https://cpptruths.blogspot.com/2018/11/non-colliding-efficient.html.
	For platform configurations like x86_64-pc-linux, this changes the behavior and it has additional restrictions.
		For example, 'dlopen' with 'RTLD_LOCAL' can behave differently.
		See documented assumptions: https://bitbucket.org/FrankHB/yslib/wiki/Development.zh-CN.md.
	This is implemented by options '-U__GXX_MERGED_TYPEINFO_NAMES -D__GXX_MERGED_TYPEINFO_NAMES=1' in the build scripts.
		The user source files are also assumed to use these options.
		For simplicity, no checks are added to detect libstdc++.
			It should have no effects on other implementations like libc++ (which has no such changes).
		The '-U' option is needed to avoid clashing with the predefined macro.
			For example, with i686-w64-mingw-g++ 7.2:
				<command-line>:0:0: error: "__GXX_MERGED_TYPEINFO_NAMES" redefined
				<built-in>: note: this is the location of the previous definition
NPLA name resolver is simplified.
	It is decided to include the 'Resolve' callback and its default implementation ('DefaultResolve') at 'NPL::ContextNode' instead of 'NPL::Environment'.
		The callback is needed in 'NPL::ContextNode' to allow overriding.
			As 'NPL::ResolveName' and other functions relying on the callback use non-default (other than 'DefaultResolve') implementations, it cannot be moved out of 'NPL::ContextNode'.
			It is not necessary configured per environment, as the context always perform the name lookup within the current environment which is known by the context.
		The change simplifies the initialization of 'Resolve', as now no environment argument need to be bound at that time.
		This also reduces the cost of maintaining the copy of the callback in the environments, hence less allocations.
	However, the change improves performance only after the optimization of 'std::type_info' above in x64 Linux.
		Otherwise, the underlying call of '__strcmp_avx2' will occasionally hit the bad branch of crossing memory boundary too many times, with severely bad (actually worse than before) performance, despite less allocations.

$2020-04:

report.impl:
Implementation of allocator value holder of 'ystdex::any' has been improved a bit.
	Nonnull type is used as the owner value instead of 'std::unique_ptr' instance.
		This improves performance a bit by omitting a bnch on destroying the object.
		Note that the owner is nonmovable which requires the change on 'ystdex::any_ops::is_in_place_storable' avoid the static assertion failure.
	The change on 'ystdex::any_ops::is_in_place_storable' effectively supports nonmovable type as the target.
		The move constructor of 'ystdex::any' has the gurarntee to avoid the call of the move constructor of the target object as the extension, so there is no additional change required here for nonmovable targets.
		This is not same to 'std::any' which requires noexcept-exception on the move.
	It is considered that the new thunk as the owned value for 'ystdex::any_ops::allocator_value_handler' in the 'ystdex::any_ops::allocator_holder_handler' can be simplified by reusing the allocator from the allocated object.
		To accomplish this, 'get_allocator' is required as a non-static 'noexcept' member function (accepting 0 arguments) of the type of the allocated value type, and this function shall return the allocator being used.
			The allocator returned shall be equal to the allocator used in the initialization to prevent potential problems (esp. undefined behavior caused by inequal allocators among container objects).
		A unary type trait 'ystdex::has_get_allocator' has been added to simplify the implementation.
			The type trait has a 'value' data member as 'ture' if and only if the type being allocated has a 'get_alocator' satisfying the requirements above.
		However, the code generated by x86_64-pc-linux G++ 9.3 shows this is actually a slightly worse.
			As the consequence, this stratagy is not enabled currently.		
Some 'YB_ATTR(always_inline)' has been removed to allow the generated code being actually more efficiently.
	This includes instance in YBase module YStandardEx::Any, for example.
	YBase module YStandardEx::Allocator also has no benefits from additional 'YB_ATTR(always_inline)'.
	YFramework module NPL still keeps the fine-tuned ones.
The client code (e.g. in YFramework module NPL::NPLA1) still keeps the allocator argument for 'TermNode::Value'.
	Actually 'YSLib::AlloctorHolder' (due to the underlying 'ystdex::any_ops::allocator_holder_handler') can allow the omission the traling allocator argument for 'ystdex::pmr::polymorphic_allocator' instances.
	However, omision of the trailing allocator agurments is generally a bit inefficient in the generated code.
The assertion in the destructor of application class 'YSLib::Application' has been relaxed.
	The cleanup of all shells cannot be reliably implemented in all cases, since the cleanup code can live in the different thread than the application object.
		In cases where the application object is a static object hidden in a library, the cleanup code may be ignored due to termination of the program.
		The handled shell is explicitly cleanup to make the resource before the call of exit guard callbacks.
	It is still better make sure all shells are destroyed before the destruction in general.
		There should usually be at most one shell handle used in the application object.

$2020-06:

report.impl:
Actions in NPLA context node ('NPL::ContextNode' in YFramework module NPL::NPLA1) has been redesigned.
	The actions now are composed based on a sequence basis, rather than composited object over a single reducer object.
		Since the sequence of the current action is now saved directly, it is possible to inspect the actions in the sequence by iteration, as per the dynamic target type of the reducer oejects.
		This allows backtrace based on the continuation (the action sequence) inspection.
		The corresponding composed actions API are adjusted.
			Actions for TCO and other previously composed actions now do not have to save the trailing sequence of the subsequent actions.
			The call to 'A1::RelaySwitched' now simply insert the action at the front of the current action sequence.
			The call to 'A1::RelayNext' is now removed and replaced by multiple other calls.
				This is safe because there has been also no strong exception safety previously.
		This is also more efficient in implementation.
			Although the direct transitions of calls like 'A1::RelaySwitched' are even more inefficient, it makes the possibility to cache the recently dropped (empty) actions in a stashed sequence, which boost the performance significantly.
			The stashed sequence uses 'YSLib::forward_list' for efficiency.
		The action sequence is exposed as a new class 'ReducerSequence' in 'ContextNode' based on 'YSLib::forward_list'.
			The cleanup is specicically handled to ensure the destruction order of the actions, since 'YSLib::forward_list' has no guarantee on the order in the destruction.
		Another action sequence is internally handled as the stacked action. 
	A guard type 'ReductionGuard' is also provided in class 'ContextNode' to be used in the derived code with 'A1::Guard'.
		The guard is basically dyanmic to incoperate with other guards more effeciently.
			The guard uses the stacked action to manage the protected actions in the outer continuations.
			The use of the stacked action avoids the need to create a new object per guard while preserving the necessarily ability of reentrancy.
		The dynamic guard is not responsive to cleanup the current action sequence in 'ContextState::RewriteGuarded'.
			If not cleanup, this would cause failure on exception when loading modules due to danling references used in the remained current actions.
			There remains the unwinder as the guard to cleanup at first.
	The current action object (being as the internal action sequence rather than the old 'ContextNode::Current') is now read-only out of 'ContextNode', except for a few cases.
		The current action sequence is allowed to be cached and guarded.
		The current action sequence is allowed to be cleanup in a whole.
			The cleanup order of the actions is specifcically handled, see above.

////

