/*
	© 2016 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file Workflow.Annual2016.txt
\ingroup Documentation
\brief 工作流汇总报告 - 2016 年度。
\version r126
\author FrankHB <frankhb1989@gmail.com>
\since build 663
\par 创建时间:
	2016-01-11 09:35:01 +0800
\par 修改时间:
	2016-05-12 11:26 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::Workflow::Annual2016
*/

// See "Meta.cpp" for meta descriptions.

$import $WORKFLOW;
$LINE-WIDTH-RESTRICT 0;

$WORKFLOW:
// Following lines are only for logging informal project information.
// See Meta.txt for formal project information.
// See ChangeLog.*.txt for accepted contents.

$2016-01:

report.impl:
Overloaded function templates for 'std::size' works as expected only with core issue resolutions.
	The overloaded version for array accept non-static member access of array type depends on the change in CWG 616 available in ISO C++14, which forbids it to be a prvalue.
	The deduction for 'std::initializer_list' instance for overloaded version for array depends on the resolution of CWG 1591.

$2016-02:

report.impl:
It is intended that YBase.YStandardEx.Operators classes used in base are publicly derived.
	If only friend functions are used, it does not requires 'public', 'private' can be OK.
		See https://en.wikipedia.org/wiki/Barton–Nackman_trick.
		This is the situation for Boost.Operators and several variants like The Art of C++ / Operators(https://github.com/taocpp/operators)(formally df.operators).
	However, some overloaded operators like 'operator->' and 'operator[]' are only available as member functions.
		Friend declaration is not helpful since they can be used out of the derived classes.
		They are general for iterator overloaded operators.
		Since YBase.YStandardEx.Operators provides such operators, they should be derived with 'public'.
	For simplicity, all classes are derived with 'public', rather than optional 'private' to force users remembering which overloaded operators are used, even it will expose public non-polymorphic bases which should not be used to cast-from.
The allocator '__gnu_cxx::debug_allocator' should not be used.
	Because it is not meet the allocation requirements on nothrow 'deallocate' member.
	There are generally more powerful and flexible debug methods (e.g. valgrind and DrMemory).
		Even for freestanding implementations without them, memory debugging is still hard with the aid of such allocator rather than cutome ones with desired error handling.

$2016-03:

report.impl:
There are several changes in the library final fundamental TS final draft(WG21 N4480) since WG21 N4081.
	There are several changes for 'optional' requires minor update for return type of member functions.
	The implementation of class 'any' is not effected.
		Note that 'allocator_arg_t' for constructors of 'any' are no longer required, which was not implemented.
		Another change in the specification is explicitly 'is_nothrow_move_constructible_v' noted, which also requires no implementation change.
	The member function 'clear' is removed from class tmeplate 'basic_string_view'. Assignment of empty string view should be used instead.
		See WG21 N4288 (adopted 2014-11) for the modification.
Rules on access specifier for operator bases are amended, based on $2016-02 report.impl.
	Now classes with these bases use 'private' at first, to conform to the general language rules.
	For %iterator_operators_t it is still remained to be 'public' due to possible 'operator[]' and 'operator->' members.
	User code is still not restricted.
WG21 N4279 introduces 'try_emplace' and 'insert_or_assign' for map-like containers. There are some points to be noted.
	Only 'std::map' and 'std::unordered_map' have such interface. Set-like containers do not.
	If needed for set-like containers, it is better to be emulated directly by 'ystdex::try_emplace' and 'ystd::try_emplace_hint' directly because they avoid some significant shortcomings.
		They have less ambiguity (between iterator and key parameter) with generic key type support.
		For overloading with hint, the return value type is richer, i.e. with also 'bool' component to detect whether the insertion has been succeeded.
		They are more generic.
	As emulating 'std::set' rather than 'std::map', 'ystdex::mapped_set' now does not provide such extensions.
		It also avoid heavy dependency on header 'ystdex/container.h'.
	On the other hand, 'YSLib::ValueNode' still provides 'try_emplace', with generic key types support.
		Since it is emulating 'std::map' and non-generic key are too limited.
		To be compatible, overloading with hint is still named as 'try_emplace' and using single iterator return value, with SFINAE detection to avoid ambiguity.
		Some other extensions like typed insertion (for 'ValueNode::Value') are still provided in other names.

$2016-04:

report.impl:
The POSIX function '::close' may return error and set 'errno' to 'EINVAL' or 'EIO', and the state of file descriptor after the call is unspecified.
	See http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html.
	On some implementations, '::close' and some other function calls may always cause file descriptor to be closed even if returning 'EINTR'.
		See https://www.python.org/dev/peps/pep-0475/#modified-functions.
	Ignoring error handling of '::close' for portable code is a common bug.
		See https://stackoverflow.com/questions/19056309/not-checking-closes-return-value-how-serious-really.
	However, for purpose of resource release (e.g. in destructor), this is intended to be ignored.
		Resource release is designed to not propogate any error to provide no exception guarantee.
		There are no way to handle the errors reliably because these errors are not recoverable in general.
		There are also no way to handle the errors portably. It has been existed in pre-POSIX UNIX implemntations.
			See http://austingroupbugs.net/view.php?id=529.
		For implementation does not guarantee the file descriptor being closed, caller should work around.
			However, the mainstream platforms are all behave like this, or there is even no chance to raise 'EINTR' in call of '::close'.
			Thus YSLib currently does not implement the workaround.
	Further, the API is designed to release resource as the main purpose.
		It is different to others, so special handling of 'EINTR' is acceptable.
	To assume 'EINTR' leaving the file descriptor open and then retry to close it is particular dangerous at least in Linux.
		See http://lwn.net/Articles/576478/. In fact, Linux is hard to raise 'EINTR' here.
		If flush is required, the caller should do it before closing the file descriptor, and '::fsync' call may be needed.

$2016-05:

report.impl:
Android GUI architecture in YFramework has been reviewed in progress.
	Early stage is finished. The remained work is delayed to v0.7. Some conclusions remains vaild.
	It is intended to keep the android native "UI" thread as main thread without full inversion of control by design.
		That is, the original thread in call of '::ANativeActivity_onCreate' has a longer lifetime than main routine call on spawned thread.
		Since this thread partially plays a role like Win32 (GUI) subsystem of 'csrss.exe', it should be lived at any time when a GUI client is running in a system-provided GUI session.
	Current implementation only supports DS window emulation.
		This should be updated to a broader capability even if the native Android GUI does not have a window manager supporting multiple windows like a stacking window manager in general.
		It is implemented using direct binding to 'Desktop' instance as a non-hosted platform (i.e. DS).
		This should be changed using a middle layaer as 'WindowThread' under Win32, to get more flexibility for implementing features in future.
			It can still be 'WindowThread' but without requiring a real thread, since there is only one event loop active at any time in one process.
		Problems remained on design of event loop related APIs, for example:
			A class of loop is generally not needed, but since there is direct "looper" out of the box proveded by Android native API, is it reqired to be wrapped?
			The loop is now implemented in 'AndroidHost' of 'YCLib' Android extensions. Should it also be configurable in 'Helper'?
			It is not clear that which precise sets of functionality should be exposed in 'Helper' and 'YCLib' Android extensions.
		It is also not clear that if it necessary to emulate a window manager between 'YCLib' Android extension and 'Helper'.

////

