/*
	© 2009-2021 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file LanguageConvention.txt
\ingroup Documentation
\brief 语言使用规约。
\version r2580
\author FrankHB <frankhb1989@gmail.com>
\since build 543
\par 创建时间:
	2012-10-08 05:13:05 +0800
\par 修改时间:
	2021-12-21 12:33 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::LanguageConvention
*/


/*

@0 前言(Preface) ：
本文档适用于一般开发，用于促进程序代码中可预期的良好性质。

@0.1 体例说明：
引用标记参见 [Documentation::CommonRules @@0.1] 。

@0.2 可读性(readability) ：
基本概念参照 [Documentation::CommonRules @@0.3] 。
本文档限定：可读性是能减少语法(syntax) 和语义(semantics) 噪音至可接受程度内的性质，是可预期的良好性质(@0) 之一。
语法和语义噪音是程序代码表现的对代码作者原始意图的偏离。

@1 绪论：

@1.1 正式引用：
@1.1.1 的简写引用的来源同 [Documentation::CommonRules @@1.1] 。
以下作为概念定义参考的文档的来源同 [Documentation::CommonRules @@1.1] ：
— ISO/IEC 2382 (all parts), Information technology — Vocabulary
— ISO/IEC 10646-1:1993, Information technology — Universal Multiple-Octet Coded Character Set (UCS)
	— Part 1: Architecture and Basic Multilingual Plane
以下文档的来源同 [Documentation::CommonRules @@1.1] ：
— The Unicode Standard — Version 6.0 – Core Specification
以下其它文档在本文中引用：
— ISO/IEC 9899:1999, Programming languages — C
— ISO/IEC 9899:1999/Cor.3:2007(E), Programming languages — C, Technical Corrigendum 3
— ISO/IEC 14882:1998, Information technology — Programming languages — C++
— ISO/IEC 14882:2017, Information technology — Programming languages — C++
— ISO/IEC TR 10815:2006, Information technology — Programming languages, their environments and system software interfaces — Technical Report on C++ Performance
— ISO/IEC TR 19769:2004, Information technology — Programming languages, their environments and system software interfaces — Extensions for the programming language C to support new character data types
— 1003.1-2004 - IEEE Standard for IEEE Information Technology - Portable Operating System Interface (POSIX(R))

@1.1.1 引用简写：
以下引用简写同 [Documentation::CommonRules @@1.1.1] 。
ISO C
ISO C11
ISO C++
ISO C++03
ISO C++11
ISO C++14
其它引用简写：
CWG ：WG21 Core Working Group (Issues) 。
ISO C90 ：ISO/IEC 9899:1990 。
ISO C99 ：ISO/IEC 9899:1999 。
ISO C++98 ：ISO/IEC 14882:1998 。
ISO C++17 ：ISO/IEC 14882:2017 。
LWG ：WG21 Library Working Group (Issues) 。
POSIX.1-2004 ：IEEE Std 1003.1-2004 。
SUS ：Single UNIX Specification 。
WG14 ：ISO/IEC JTC1/SC22/WG14 。
WG21 ：ISO/IEC JTC1/SC22/WG21 。

@1.2 术语：

@1.2.1 C++ 语言：

@1.2.1.1
以下列表中的概念参考 ISO C++ ：
翻译单元(translation unit) ：(2/1 [lex])；
字符集(character set) ：(2.2 [lex.charset])；
预处理记号(preprocessing token) ：(2.4 [lex.pptoken])；
记号(token) ：(2.6 [lex.token])；
注释(comment) ：(2.7 [lex.comment])；
头名(header name) ：(2.8 [lex.header])；
标识符(identifier) ：(2.10 [lex.name])；
关键字(keyword) ：(2.11 [lex.key])；
操作符(operator) ：(2.11 [lex.operators])；
标点符(punctuator) ：(2.11 [lex.operators])；
字面量(literal) ：(2.13 [lex.literals])；
转义[字符]序列(escape sequence) ：(2.13.2 [lex.ccon])；
实体(entity) ：(3/3 [basic])；
名称(name) ：(3/4 [basic])；
作用域(scope) ：(3.3/1 [basic.scope])；
链接(linkage) ：(3.5 [basic.link])；
存储期(storage duration) ：(3.7 [basic.stc])；
类型(type) ：(3.9 [basic.types])；
对象类型(object type) ：(3.9 [basic.types])；
不完整类型(incomplete type) ：(3.9.1 [basic.fundamental])；
命名空间(namespace) ：(7.3 [basic.namespace]) 。

@1.2.1.2
以下内容参考 ISO C++ 相关描述：
续行/断行连接(line continuation) ：(2.1/2 [lex.phases])，“splicing physical source lines to form logical source lines”。

@2 语言实现的兼容性和互操作性：
仅在特定必要情形下使用语言/方言实现之间的的互操作特性。
注意可以是相同语言（如 C++ ）之间进行互操作。
关于 C 和 C++ ，参见 @3 。
另见 [Documentation::CommonRules @@3.7.3] 。

@2.1 ABI（Application Binary Interface ，二进制应用接口）及其兼容性：
对保证 ABI 兼容性提供文档说明。
不假定没有文档约定的二进制兼容。

@2.2 ISA（Instruction Set Architecture ，指令集架构）：
仅在必要时使用汇编语言或机器指令，包括内联汇编或 shellcode 。
不假定相同 ISA 的不同实现具有完全一致的特性。不依赖这些实现的专有特性。

@3 C 和 C++ ：
ISO C++ 和 ISO C 的兼容性参见 ISO C++ Annex C 。
注意一般 C++ 实现同时是 C 实现。这些实现一般可通过扩展名默认区分翻译单元使用的语言。

@4 C 语言使用规约：
略。另见 @3 和 @5 。

@5 C++ 语言使用规约：
本节表述具体设计内容无关的源代码特性使用和编码风格。
除非另行指定， ISO C 指所有 ISO C90 及之后版本都兼容适用的规则， ISO C++ 指所有 ISO C++98 及之后版本都兼容适用的规则。
所有没有明确指定的规则基于 ISO C++03 。

@5.1 概述：
相关概念参见 ISO C++11 Clause 1 。
若实际代码与本章的规则不一致，则应以文档或代码附近的注释显式说明不遵守的充分理由。

@5.1.1 良定义(well-defined) 要求：
禁止程序引起语言标准指定的未定义行为(undefined behavior) ，除非为以下情形之一，且另有文档说明：
明确依赖定义了明确行为并作为扩展的兼容标准；
明确可使用的特定平台环境；
依赖特定平台环境的语言实现，保证可预期的行为，且不违反公开接口约束（如内部实现使用的 noexcept 保证不被违反时，可指定实现省略检查）。
注意使用未初始化对象具有未决定值(indeterminate value) 。读取未初始化对象的值引起未定义行为。
禁止接口行为依赖未决定值。

@5.1.2 未指定行为：
避免程序的结果依赖引起未指定行为(unspecified behavior) 的特性。
接口行为不应依赖特定的未指定行为。

@5.1.3 实现定义行为(implementation-defined behavior) ：
需要使用引起实现定义行为的特性时，适当注释。
接口行为不应依赖特定的由实现定义行为，除非存在显式的接口使用约束（同时给出注释）。
注意 ISO C++ 中，实现定义行为不是未指定行为的子集，这点和 ISO C 不同。

@5.1.3.1 例外：
可以有少数不显式注释即使用或依赖通用的实现特性的例外，在这里列出：
对预处理指令 #include " q-char-sequence" new-line ，假定从源文件的当前路径开始搜索包含项。

@5.1.4 区域(locale) ：
除非另行指定，程序不和实现环境提供的修改区域特定的行为(locale-specific behavior) 的特性交互。
在不修改区域特定的行为时，程序的行为可依赖程序执行环境的影响区域特定的行为的配置。
除非另有文档说明，区域特定的行为仅依赖上述配置。
**注释**
ISO C 、ISO C++ 、POSIX 以及特定操作系统可提供影响区域特定行为 API 。
POSIX 和特定操作系统可提供环境变量影响区域。
推论：在没有明确使用的区域时，程序的行为同使用默认区域（ "C" 区域）。

@5.1.4.1 例外：
总是假定执行字符集能表示在源字符集中使用的 Unicode 字符。
程序对其中的附加成员(additional member) 的使用引起的行为，不视为依赖区域特定的行为。

@5.1.5 有条件支持的特性：
注意有条件支持的(conditionally-supported) 特性不保证被所有实现支持。
慎重使用有条件支持的(conditionally-supported) 特性。
除非使用的实现可用的平台配置总是支持这些特性，使用这些特性应有文档说明。

@5.1.6 避免使用的特性：
不应使用 ISO C++03 Annex D 中的 deprecated 特性，除以下有说明外；
避免使用 ISO C++11 Annex D 中的 deprecated 特性。
注意以下在前者在前者中作为 deprecated 特性，在后者中被删除（重新支持）的特性，除非必要应避免使用：
ISO C++03 Annex D.2 static keyword [depr.static] 。
（参见 [WG21 N3296 #FI6] 。）
应特别注意不应使用在前者中作为 deprecated 特性，在后者中不支持的特性：
ISO C++03 Annex D.3 Access declarations [depr.access.dcl] ；
（参见 [WG21 N3296 #US56] 。）
ISO C++03 Annex D.4 Implicit conversion from const strings [depr.string] 。
有限使用动态异常规范，参见 @3.6.2.6 。

@5.1.7 语言规范的缺陷：
注意规避当前语言标准未解决的问题。例如：
[CWG 232] ，截至 ISO C++11 出版仍是草案状态，通过内建下标操作访问（但不使用值） one-past-end 指针不能确定引起未定义行为（但 ISO C99 中已明确不是）。
上述情况下应该使用指针加法代替下标操作。

@5.1.8 正确性：
合式的(well-formed) 程序遵照三个规则：语法规则、可诊断语义规则和 ODR（One Definition Rule ，唯一定义规则）。
形式非法的(ill-formed) 程序是非合式的程序。
注意一个合式的程序可以包含未定义行为。此时程序不是正确的可移植的程序。
特别注意一个实现虽然一般应拒绝并没有被限定形式非法的程序，但有“不要求诊断”(no diagnostic required) 的情况下除外。
ODR 对不同的实体(@5.2.1) 的特定使用（称为 odr-used ）具有不同的要求。参见 ISO C++ 3.2 。

@5.1.9 C++ 存储模型：
C++ 讨论的内存(memory) 明确排除不可按字节(@5.7.2.4) 寻址的存储。一般被实现为主内存。

@5.1.10 C++ 对象模型：
对象具有生存期(lifetime) 和存储期(storage duration) 。
对象具有类型(type) 。
非类类型对象或最终派生类(most derived class) 类型的对象是最终派生对象(most derived object) 。
除了位域(bit-field)，最终派生对象保证占用连续的非零存储单元。一般第一个单元对应的即表示对象存储的地址。
不同的对象占据不同的存储单元的完整对象具有不同的地址。

@5.1.11 程序执行：
ISO C++ 使用抽象机描述程序语义，但不要求实际实现与之完全一致。

@5.1.11.1 可观察行为：
至少遵循的语义包括对 volatile 对象的访问、程序终止状态和可被动态观察的输入和输出对应的行为，称为可观察行为 (observable behavior) 。

@5.1.11.2 as-if 规则和程序优化：
实现的语义遵循 as-if 规则：不影响可观察行为的程序行为可以被实现改变。这基本和 ISO C 一致。
这是可被允许的一般的优化的根本依据。
注意 ISO C++ 提供少数其它改变可观察行为的等价性规则可被作为优化依据：参见 @5.8.5 和 @5.13.4.3 。

@5.1.11.3 表达式的求值(evaluation) ：
表达式的求值一般意义上包括值的计算(value computation) 和产生副作用(effect) 。
副作用包含对 volatile 对象的访问、对对象的修改和使用 I/O 库函数，表示对环境的改变。
求值的顺序并不一定被确定。任意两个求值之间具有先序(sequenced before) 、未决定有序(indeterminatly sequenced) 或无序(unsequenced) 二元关系之一。
在同一个对象上的无序求值引起未定义行为。

@5.1.11.4 信号处理(signal handling) ：
ISO C11 明确信号处理函数中，除了 volatile std::sig_atomic_t 类型的对象或无锁操作的原子对象以外对象的值以及浮点环境状态未指定。
ISO C++11 要求信号处理函数只能修改 volatile std::sig_atomic_t 类型的对象或无锁操作的原子对象。
之后的修订取消了这个限制，指定通过 raise 函数引起的信号处理函数后于调用，先于返回 [WG21 N3910, WG21 N3936]。
当前只使用正式标准规定的定义。另见 @6.3.2 。
应注意信号处理的接口一般要求可重入性(reentrency) 。

@5.1.11.5 I/O 操作：
注意 I/O 操作是副作用。
另见 @6.15 。

@5.1.12 多线程执行(multi-thread execution) 环境和数据竞争(data race) ：
实现可能允许一个程序具有多个并发执行的执行线程(thread of execution) ，简称线程(thread) 。
ISO C++11 起已直接提供线程的支持。注意是否允许多个线程并发执行由实现定义。
线程对对象的访问之间可能具有不确定的关系。当无法确定值时产生数据竞争，程序具有未定义行为。使用恰当的同步(synchronization) 避免数据竞争。
注意免数据竞争，确保程序的线程安全(thread safety) 。具体接口可能不具有线程安全性，而通过另行添加同步代码保证。
一般地，线程安全不具有组合性。组合线程安全的代码仍需同步以确保组合代码的线程安全。
设计接口可选地提供线程安全保证。
用户代码可能无法提供更优的细粒度(fine-grained) 的同步，所以一些操作（例如同步原语）有必要提供线程安全。其它大部分操作应根据需要决定。若接口实现需进行同步操作保证线程安全，除非总是保证可移植的最优实现，应不仅提供线程安全的接口。
原理：线程安全可通过非线程安全但其它语义相同的接口和外部同步代码的组合实现。嵌套线程安全的接口调用通常有重复冗余同步代码开销而不适用于一般情形。

@5.2 基本概念及语义：
参见 ISO C++11 Clause 3 和 Clause 5 。注意与 ISO C++03 的区别。

@5.2.1 名称和实体：
区分名称和实体。
明确声明引入名称，定义和实体的存在直接相关。
明确定义是声明，但声明不一定是定义。参见 ISO C++ 3.1 。
名称使用限制参见 @6.1 。

@5.2.2 对象、变量和值：
对象和变量都是实体。
注意区分对象和变量：变量可由引用引入。
对象表示存储；另见 @5.1.10 。
明确变量是通过声明引入的对象。变量具有对象或对象引用类型。
注意对非 trivial 构造/析构的对象，生存期始于构造结束，终于析构开始。
注意静态对象的生存期。
注意 POD 对象（包括 ISO C++03 和 ISO C++11 的不同定义）、标准布局(standard layout) 类型对象和 trivially copyable 对象，以及它们之间的区别。
注意非 standard layout 或 trivially copyable 对象的使用限制（和 C 存储的交互性， std::memcpy 、offset 的适用性等）。
了解 scope guard 等和对象生存期相关的惯用法。
值(value) 是由实现定义，没有其它约定的实体。
一个对象的对象表示(object representation) ，以其存储被 N 个 unsigned char 对象连续表示体现，其中 N 等于对象的大小。
一个对象的值表示(value representation) 是特定位的集合，能决定特定的值。因此对象具有存储值(stored value) 。

@5.2.3 作用域：
注意名称隐藏(hiding) 。

@5.2.4 名称查找(name lookup) ：
注意查找顺序。
using 关键字的使用参见 @5.5.7 。

@5.2.4.1 参数依赖查找(argument dependent lookup, ADL) ：
当需要禁止 ADL 时可以使用限定名称或带小括号的名称代替非限定名称。
注意当非限定名查找类成员、非 using 声明的块作用域名称或非函数（模板）名称后 ADL 查找关联名称为空。
不使用冗余的限定名（如非模板类型参数相关且 ADL 和非限定名称查找结果一致时），但需要突出所在的作用域时除外（例如使用带有前缀 :: 的全局名称以便和其它命名空间的名称区分）。

@5.2.4.2 依赖名称：
类模板中，显式使用 this 启用依赖名称(dependent name) 的名称查找。
若不需要依赖名称，不使用 this-> 等形式引用名称，以避免可能的错误引用和编译性能下降。

@5.2.4.3 类作用域：
基本内容参见 ISO C++11 3.3.7 。
注意类作用域内声明的名称的作用域不仅仅从声明点到类定义结束，还包括所有函数体、默认参数、异常规范和初值符。
类定义内的名称必须指称相同的声明，且调整成员声明顺序不改变这些指称，否则程序形式非法但不要求诊断(@5.1.8) 。

@5.2.5 程序和链接(linkage) ：
注意链接是名称而非实体的属性，尽管也用于命名空间(@5.5.8) 。

@5.2.6 程序的启动和终止：
ISO C++ 规定程序必须包含全局 main 函数。在独立实现中，是否需要定义 main 函数由实现定义。
main 函数被作为程序的入口。 ISO C++ 规定 main 函数必须返回 int 。只有两种形式的 main 函数总是被实现支持。
在 main 函数中省略 return ，默认同 return 0 。
任何需要其它形式实现支持的入口需提供文档说明。
ISO C++ 规定 main 函数不能被使用：不能被递归调用。
程序在入口结束时或被特定的库函数(@6.3.4) 终止。
注意非正常终止程序不保证析构函数被调用，可能导致非预期的行为。
任何终止程序的行为需提供文档说明。

@5.2.7 存储期：
注意存储期类别适用于引用，但引用是否占据存储是未指定的。

@5.2.8 生存期：
生存期由存储或构造/析构决定。
注意在生存期外的对象使用受限。

@5.2.9 类型(type) ：
C++ 的类型包括 void 类型、对象类型、函数类型和引用类型。
注意类型可被限定符修饰，限定符可影响类型，参见 @5.6 。
类型关键字、静态类型推导（模板以及 C++11 关键字 auto 和 decltype ）参见 @5.7 。

@5.2.9.1 右值引用(rvalue reference) 和转移语义(move semantics) ：
右值引用是 ISO C++11 支持的新的引用类型。
关于右值引用和值类别的关系参见 @5.2.10 。
非 const 右值对象引用用于实现转移语义。
注意一般地，转移语义仅保证转移后目标的后置条件。
除非另行指定，函数参数类型的使用满足 ISO C++ [res.on.arguments] 的规则。
若用户定义的类类型提供转移操作，除非另行指定，满足 ISO C++11 17.6.5.15 [lib.types.movedfrom] 的规则，被转移的对象在操作后的状态有效但未指定(valid but unspecified) 。
注意大多数标准库定义的类型的对象被转移后为有效但未指定状态，如满足 MoveConstructible 的对象在未另行指定时被转移后的状态；
相反的例子，如标准库的 std::unique_ptr （通过所有权转移约定）和 std::shared_ptr （通过转移构造函数约定），保证被转移后的对象为空。
若用户定义的类类型无法通过其它显式的操作（如通过默认构造）取得与转移后状态等价的有效状态，除非另行指定转移后状态的有效性，不提供转移操作，以保证状态的有效性可被验证，并避免非预期的操作。
注意允许无法通过其它显式的操作取得转移后状态的转移操作可能是必要的。特别地，直接用于参数或返回类型（而不需要 unique_ptr 等包装）等需要复制初始化的场合，在 [WG21 P0135R1] 之前，当前语言特性无法支持不满足 MoveConstructible 的类型。
另见 @5.12.2.4.1 。

@5.2.9.2 引用折叠(reference collapsing) 和完美转发(perfect forwarding) ：
引用折叠是 ISO C++11 引入的特殊引用规则。对特定上下文（如 typedef 和 decltype 组合引用类型）中，被左值引用修饰的引用类型为左值引用，被右值引用修饰的右值引用类型为右值引用。
通用引用(universal reference) 是函数模板中形式为 T&& 的函数参数类型，其中 T 是所在函数模板的一个类型参数。
在函数模板类型推导时，对模板类型参数 T ，对通用引用特殊规则，能保证实例化的函数形式参数保持和实际参数相同的 cv-qualifier 和值类别，因此实现完美转发：无需对每个 const 或左值引用/右值引用提供单独的重载版本。

@5.2.9.3 限制使用：
在有更合适的替代时，限制使用不利于表达清晰语义的类型。

@5.2.9.3.1 内建指针：
一般地，内建指针仅在互操作以及语言或标准库要求使用时必要。
注意以下情形不适用指针而优先使用其它更清晰表达意图替代：
表示具有所有权的资源，使用智能指针(@6.9.2) ；
引用无所有权的参数，使用内建引用；
表示迭代操作或范围，使用迭代器为基础的类型；
尽可能使用 nullptr(@5.4.5) 表示空指针常量。
简化起见，非所有权的弱引用可以使用指针。

@5.2.10 值类别(value category) ：
注意值类别是表达式的属性。
注意区分 lvalue 、xvalue 和 prvalue 。
注意右值引用为 xvalue 的条件： xvalue 是右值对象引用。
注意函数表达式的值类别。

@5.2.10.1 左值访问限制：
注意 ISO C++11 [basic.lval]/10 规定了转换静态类型后的值的类型满足一定条件下才能访问原左值，否则引起未定义行为；即严格别名(strict aliasing) 限制。
这允许 TBAA(type-based alias analysis) 等机制下能依赖更少的假定（即可能存在别名）生成代码，便于优化，但对互操作有限制。
注意 char16_t 或 char32_t 左值和（由 ABI 保证）具有一致布局和对齐要求的 wchar_t 左值之间的互操作也是未定义行为，但作为 C 函数的参数或来自 C 函数的返回值时可以允许使用，因为 C 中这些类型为整数类型的 typedef 名称，并非不同的类型，因此按 ABI 要求不能随意假定不存在别名。
但在 C++ 代码中以不同静态类型访问左值没有以上的保证，应避免以保证优化代码引起无法预期的行为。
通过 reinterpret_cast 引用的左值仅和以非 C++ 源代码形式提供的库函数交互时是安全的，因为实现不涉及使用 C++ 语义决定访问左值。
需要相同存储位置的不同类型的左值时，使用 placement new 创建新的对象(@5.8.5) ，注意仍受到不同的限制(@5.2.8) ；或使用实现扩展保证特定左值上不使用严格别名分析并在相关接口文档中说明。

@5.2.11 对齐(alignment) ：
对象类型具有对齐要求(alignment requirement) 。
对齐(alignment) 是实现定义的整数值，表示相邻分配对象的最小地址间隔。

@5.2.12 表达式及其求值(evaluation) ：
基本概念参见(@5.1.11) 。
注意非求值操作数(unevaluated operands) ，其中不发生求值，没有副作用。
注意内建表达式和重载操作符约定的值类别(@5.2.10) 的差异。
注意函数类型等价性，尤其是讨论重载时；参见 @5.12.1 。
精确地使用括号：在必要时使用，且不使用冗余的括号，以免改变语义（例如 @5.2.4.1 ）。

@5.2.12.1 lambda 表达式 [ISO C++11] ：
注意 lambda 表达式中的捕获变量规则。
没有捕获的 lambda 表达式存在非 explicit (@5.12.1) 到函数指针的转换操作符。
lambda 表达式转换的函数指针具有 C++ 语言链接(@5.5.5.3) [CWG 1557, WG21 N3690] 。

@5.2.12.2 算术操作：
注意 ISO C++ [expr.add] 规定指针算术越界为未定义行为。

@5.2.12.3 比较操作：
内建比较操作对内建指针的结果只提供有限保证。
注意在 ISO C 中，非同一聚集或联合对象内的元素且非超过数组末尾一个元素(one-past-end) 的指针不能比较，否则行为未定义，参见 ISO C11 6.5.8 和 ISO C11 J.2 。另见 https://www.securecoding.cert.org/confluence/display/seccode/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array 。
在 ISO C++ 中，上述限制不适用，结果可能未指定但不引起未定义行为，参见 ISO C++11 5.9 。
作为限定符相关的指针比较操作问题 [CWG 73, CWG 1512] 的解决， ISO C++ 进一步保证对关系操作中蕴含的相等的比较，结果是确定的 [WG21 N3478, WG21 N3690]。

@5.3 词法、预处理和内容无关的上下文编码规则：
本节以外其它相关编码风格参见 @6 。

@5.3.1 源代码文件和字符：
必须保证源代码文件使用的字符集可被实现接受并正确处理（兼容基本源字符集和基本执行字符集）。
禁止源文件的注释以外部分使用 Unicode 控制字符。
不使用双联符(digraphs) 和三连符(trigraphs) 。
行末必须保留至少一个换行符以保证不引起未定义行为。
不过度依赖词法分析的贪婪性。对多个连续的操作符，必须以无误导性的方式使用空白符分隔。
例如，避免二元/和一元 * 连用导致错误的注释起始标志。

@5.3.2 标识符命名风格：
以下讨论内建特性相关的名称。其它参见 [Documentation::CommonRules @@4] 。

@5.3.2.1 range-based for ：
注意适当使用 begin 和 end 重载函数配合 range-based for 的使用。

@5.3.3 宏定义：
有源代码兼容性和可读性良好替代方案的情况下，尽可能不使用宏。
在不能确定特定宏未被定义时，为避免重复定义，在定义前应使用 #undef 或条件包含判断宏是否需要定义。
注意保留名称规则(@6.1.2) 也适用于宏。

@5.3.3.1 常量：
尽可能使用 constexpr 关键字而不是宏定义常量。
尽可能使用 const 关键字定义只读对象。
另见 @5.5.4.2 。

@5.3.3.2
某些宏影响实现特性的宏，如 __STRICT_ANSI__ 或 _POSIX_SOURCE 。注意应在标准库头前包含之前决定唯一定义。

@5.3.4 条件包含：
使用条件包含指令控制文件包含，而不是编译器相关的非标准预处理指令（例如 #pragma_once 和 #include_next ）。
除此之外，尽可能不使用条件编译。
注意区分 #if 和 #ifdef 。

@5.3.5
可以使用 #error 和 #line ，但没有确定环境支持时，仅使用基本字符集的字符，以免出现不符合的预期文本。
对 #error 提示用户的文本内容，一般尽可能使用字符串字面量而不是直接的记号序列，以完整地表达含义且便于搜索。
在确定环境支持时，可使用 #warning 。

@5.3.6 #include 指令：
使用 <头名> 或 <相对路径> 表示外部库依赖项（仅允许头）， "文件名" 或 "相对路径" 表示内部库依赖向（特殊情况下允许源文件，但需在文档中说明目的）。
关于搜索路径，另见 @5.1.3.1 。
在非正式测试等临时用途以外的情况下不使用绝对路径。
在翻译单元中一般应保持 #include 指令最前，除以下例外：
需要在特定位置（可能重复）包含；
需要定义影响后继 #include 的宏（如 @5.3.4.2 的情形）。
后者可能被工具链中的预定义宏选项替代。

@5.3.6.1 包含顺序：
注意 <cassert> 等可能被多次包含，且其作用依赖上下文（如宏定义 NDEBUG ）。部分系统头文件（如 <Windows.h> ）也可能依赖上下文。
其它标准库头和自定义的头文件一般应在源文件的顶端包含，且假定其顺序不影响作用。
避免直接使用 clang-format 等外部工具排序 #include 指令，以避免破坏上述可能影响作用的包含顺序且避免依赖特定的包含顺序隐藏实现问题。
一般地，#include 指令顺序应满足以下要求：
若使用预编译头，应在其它 #include 指令之前；
可能依赖上下文顺序的 #include 指令按需出现在合适的位置。
同时，建议依次满足以下规则：
在用于被其它源文件包含的头文件中，若约定了公开的接口依赖（如 ISO C++ 的 synopsis 节的形式），首先按公开约定的依赖（或顺序，以及通过依赖推断的顺序）包含；
源文件中靠前包含其它更多头文件的依赖（若这些依赖中 #include 的作用是可靠的），以使处理预处理翻译单元时嵌套的重复依赖的访问更集中，有利于翻译性能；
在一个用于实现的源文件中，若提供对应的头文件，此头文件应该放在其它文件之前（若存在预编译头，在这个头文件中间接包含），且此头文件里出现过的包含不在源文件中重复出现；
其余的 #include 指令顺序未指定，可按需要使用在具体翻译单元一致的顺序，例如和之后使用的名称顺序一致，或者根据来源分组等。
此外，未确认 #include 作用可靠的库的头文件按需使用单独的翻译单元隔离而避免冲突；在这个单独的翻译单元中，可通过优先靠后包含以排查潜在的问题。
注意标准库中的实现可能存在和包含顺序相关的质量问题，如 https://travisdowns.github.io/blog/2019/11/19/toupper.html 。

@5.3.7 #pragma 指令和 _Pragma 操作符：
允许使用 #pragma STDC 。
避免 #pragma 后的标识符被作为宏替换为非空记号，以免由实现定义的行为导致的差异。
其它使用 #pragma 的情形由具体项目定义。
可在宏定义替换的记号序列中使用 _Pragma 操作符代替 #pragma 。

@5.4 替代记号(alternative tokens) 、转义字符序列和字面量：

@5.4.1
一般不使用替代记号，以避免导致被替代的标点不够清晰。

@5.4.1.1 例外：
使用 and 和 or 代替内建操作符 && 和 || 以向读者强调对预期的程序逻辑，两个操作数的求值顺序可被交换（注意 C++ 语义仍然一致）。

@5.4.2 转义字符序列：
使用正确、无歧义的转义字符序列。
注意被转义的字符和基本源字符集之间的关系。
仅在必要时使用八进制或 Unicode 转义字符序列。

@5.4.3
关键字 true/false 和 bool 类型对应；宏 TRUE/FALSE 和 int 类型（例如自定义的 BOOL 类型）对应。
除非有必要，仅使用前者。
另见 @5.11.6 。

@5.4.4
非关键字字面量的表达必须保证符合语法，且兼顾可读性。

@5.4.5 零值：
除非没有语言特性支持，以下规则不优先于 @5.9.4 。
整数用 0，浮点数用 0.0 。有必要使用 float 时，用 0.F 。
空指针用 nullptr （考虑 C 兼容性可以在保证定义正确的前提下使用 NULL ）。
表示字符串结束的空字符用值初始化的非字面量（对字符类型 T 使用 T() ）或自定义宏 NUL 表示。其它具有零值的字符用对应类型的字面量如 '\0' 或 L'\0' 等表示。
bool 类型以外的整数类型零值和 false 可以互相转换。另见 @5.11.6 。

@5.4.6
合理使用字符串字面量前缀（'L' 、'u8' 、'u' 、'U' 、'R' 及其组合）。

@5.4.7
可以使用字符串字面量初始化 C 风格字符串。
被初始化的若为字符数组，元素（字符类型）必须是 const 类型修饰的，参见 @5.1.6 。

@5.5 声明和命名空间：
注意区分涉及声明的语法歧义，参见 ISO C++11 6.8 。
注意函数声明和函数定义的区别。
除了头文件中的函数声明以及其它特别注明外，尽可能使用定义代替非定义的声明（如类定义代替类名声明，函数定义代替非函数定义的函数声明）。
不在同一个文件且同一个作用域内使用超过一个等价的声明。

@5.5.1 auto 关键字：
不使用表示存储类的关键字 auto ，使用隐式的自动存储类实现。
注意 ISO C++11 起无法使用关键字 auto 表示存储类。
显式使用会使和 ISO C++11 及之后的代码的共用出现问题。

@5.5.2 register 关键字：
不使用存储类关键字 register ，参见 @5.1.5 。
注意 ISO C++17 起无法使用关键字 auto 表示存储类。
除了平台相关的上下文以外，不使用 register 。
注意 register 仅是建议，而不是命令。

@5.5.3 静态存储期：
尽可能避免使用静态和线程局部存储期对象。
如有必要，在接口明确这些对象如何被使用。

@5.5.4 static 和 thread_local ：

@5.5.4.1 命名空间作用域 static ：
注意命名空间作用域的 static 修饰的声明的名称具有内部链接。
避免使用 static 在命名空间作用域声明对象，参见 @5.1.6 以及以下讨论；除非明确需要内部链接且使名称满足特定于实现的需求。
使用翻译单元内的适当的若干未命名命名空间代替，以便自由选择使用内部链接或外部链接，且允许使链接作用于类类型或 typedef 名称等的声明；参见 @5.5.8.1 。
注意 ISO C++03 要求模板非类型实际参数要求名称具有外部链接，参见 ISO C++03 14.3.2/1 ；此时 static 不再适用。但是， ISO C++11 明确命名空间具有的链接(@5.5.8) ，同时也取消了这个限制，参见 ISO C++11 14.3.2/1 。
因此在 ISO C++11 实现中， static 仍然可用，但可能造成混乱，所以避免使用。
为了一致性，一般同时使用未命名命名空间代替命名空间作用域内的 static 函数。
若需要命名空间中声明的名称具有内部链接，可以使用嵌套未命名命名空间(@5.5.8.1) 。但是，现代的实现一般使用 as-if 规则对二进制代码进行优化，它不改变用户程序的可观察行为，所以这种用法并非必要。

@5.5.4.2 类作用域 static ：
注意类作用域 static 用于修饰成员声明，指定其为静态成员，决定其不依赖具体对象。
除非必要，否则不依赖 this(@5.7.5) 的成员应该为静态成员。
对成员函数，在类的定义中直接使用 static ，不在类的成员函数定义中重写。
const 或 constexpr 静态数据成员可直接在类定义内初始化。在没有被 odr-used(@5.1.8) 时不需要定义。这是除 ISO C++17 起引入的内联变量外，初始化且不引入定义的唯一特例（关于声明和定义，参见 ISO C++ [basic.def.odr] ）。
注意 ISO C++17 修改类定义中的 constexpr static 数据成员的链接，详见 [WG21 P0386] 。应避免依赖非 odr-used 的变量定义，改用 constexpr 函数代替。
不使用在 ISO C++17 前模式中实现提供的类似 ISO C++17 的语言扩展。
注意 static constexpr 函数在类定义内的常量表达式内使用的限制，详见 [CWG 1255] 和 [CWG 1266] 。

@5.5.4.3 块作用域 static ：
注意块作用域 static 用于修饰声明的对象，决定其具有静态存储期。
除非有明确目的，使用 static 保证块作用域 const 对象不占据多余的存储，参见 ISO C++11 [intro.object]/6 和 [CWG 734] ；另见 https://llvm.org/bugs/show_bug.cgi?id=27443 。

@5.5.4.4 thread_local ：
在可以且有必要使用 thread_local 时，不使用 static 代替。
注意可能和 static 同时使用。
注意 thread_local 允许动态初始化，而实现提供的类似扩展特性可能不允许。
注意对应 ISO C11 的标识符 thread_local 不是关键字，而以宏形式在标准库头 <threads.h> 引入，对应关键字是 _Thread_local 。

@5.5.4.5 和其它关键字连用：
注意 ISO C 中的存储类关键字并不在最前的函数声明被 future language directions 标注为过时。使用如 inline static 的声明，可能引起某些编译器的警告。
在 C++ 代码中一般习惯保持相同的使用顺序。

@5.5.5 extern ：

@5.5.5.1 extern 声明：
正确地使用 extern ，并检查语义的合理性。
注意对之前已有的对象声明， extern 不能直接决定其链接，必须参照之前的声明。
不使用冗余的 extern 。
仅在命名空间作用域中使用显式 extern 声明。

@5.5.5.2 类型：
在多个翻译单元中，extern 声明的类型应保持一致。

@5.5.5.3 语言链接(language linkage) ：
ISO C++ 指定实现需要支持 extern "C" （ C 语言链接）和 extern "C++" （ C++ 语言链接），默认隐式为后者。
特定的 C++ 语言构造要求使用 C 语言链接（如 @6.3.2.3 ）。除此之外，使用 C 语言链接以兼容 C 实现，并在 C++ 实现之间的互操作时取得一般较好的兼容性。

@5.5.6 指示符(specifier) 和属性(attribute) ：
按需使用属性。
必要且确保实现支持时，可以使用扩展，如 GNU C++ 的 __attribute__ 和 Microsoft VC++ 的 __declspec ，并考虑用宏统一包装。
注意 ISO C++ 标准属性被设计为尽可能减少语义的改变，参见 http://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/ 。
属性可以修饰声明或声明符。若两者效果等价（如 [[noreturn]](@5.5.11.1) 修饰函数声明），当声明中只有一个声明符时，直接使用声明的属性而不是声明符的属性。
注意 ISO C++ 标准属性和扩展属性不一定通用，参见 @5.5.6.6 。
关于 inline 和 constexpr ，参见 @5.5.6.1 和 @5.5.6.5 。
关于 inline 对 namespace 的使用，参见 @5.5.8.3 。

@5.5.6.1 一般语法：
在必要时使用 inline 关键字。
类定义内不使用冗余的 inline （类模板的成员不适用）。
注意属性应在指示符之前出现。
使用 static inline 而不是 inline static ，使用 thread_local inline 而不是 inline thread_local ；原因参见 @5.5.4.5 。
保持和 static inline 风格一致性，使用 explicit inline ，而不是 inline explicit 。
具体顺序规则参见 @5.5.6.7 。

@5.5.6.2 内联语义：
注意 ISO C++ 规定一个 inline 函数总是应被声明为 inline ，这和 ISO C 不同。
inline 对 ODR(@5.1.8) 发生影响。
注意 inline 的内联语义对实现只是建议而非强制。
若能保证不降低源代码的可移植性，在必要时可以使用与编译环境相关的内联语法，但不直接使用非标准的内联关键字，而使用特定的宏定义代替。

@5.5.6.3 禁止内联：
需要保证函数定义在确定的翻译单元时，应避免内联。
需要避免内联时，首先不在公用头文件中使用 inline 修饰函数声明，并避免在类定义内定义成员函数。
对模板实例，使用显式实例化和 extern 声明保证。
必要时可使用实现的扩展（如 GNU 扩展的 noinline 属性）指示不内联。
以下情形应考虑避免内联：
典型实现的虚析构函数的符号位置可能影响 ABI 规范定义的虚表(vtable) 的位置（若所有虚函数定义通过 #include 指令引入，则在每个翻译单元生成虚表： Clang++ 警告 [-Wweak-vtables] ）。需要确保符号唯一时，至少一个虚函数（通常是虚析构函数）应仅在类中声明，而定义在确定的翻译单元中（通常非头文件），即使使用显式默认的析构函数。
作为公开接口的回调函数在库中应保留明确的定义以便确定唯一实体。对动态库，应避免实现自动导入或其它修饰。

@5.5.6.4 链接：
注意函数上的 inline 和链接是正交的。注意具有外部函数的 inline 函数需要避免引用函数外定义的同名的不同实体，除非仅限非 odr-used 其值，以避免违反 ODR 造成未定义行为。
在此基础上，不连用 static inline ，以在未命名命名空间中的 inline 代替，即不直接使用 static 声明内部链接(@5.5.4) 的 inline 函数。
为避免未定义行为，同时禁止 ord-used 外部具有内部链接的变量（例如非 extern 的 const 或 constexpr 声明的对象）。
注意调用函数参数对此的 odr-used ，避免初始化引用类型的形式参数（包括使用 && 推导类型，参见 @5.14.4 ）。另见 @5.12.2.2 。
注意 ISO C 和 ISO C++ 对 inline 函数的链接的差异。 ISO C 的 inline 函数默认具有内部链接，而 ISO C++ 的内联函数默认具有外部链接。
按 ISO C++03 7.1.2 Function specifiers [dcl.fct.spec] 规定可知，非外部链接的内联函数内的局部静态对象不是同一对象。
按 ISO C++03 3.5 Program and linkage [basic.link] 规定可知，非外部链接的嵌套类名的成员函数不具有外部链接。
因此需要注意当使用内联成员函数且在其中定义静态对象时类名具有的链接。

@5.5.6.5 省略：
在类定义中的成员函数声明中省略 inline 关键字，参见 ISO C++03 7.1.2/3 ；另见 @5.9.1.1 。
注意修饰的函数或从 ISO C++17 起修饰类的静态变量的 constexpr(@5.5.6.1) 隐含 inline 。
使用 constexpr 时，不应使用冗余的 inline 。
不依赖 constexpr 中隐含的 const ，以避免影响声明类型的可读性。
若类的成员函数声明和定义分离，在完整定义而不是声明处使用 inline 。
函数模板在 ODR 上隐含和 inline 类似的效果，但一般不论是否需要被内联都使用相同的定义方式（参见 @5.9.1.2 ），不省略 inline 以明示目的。

@5.5.6.6 标准属性限制：
注意实现对标准和扩展属性的支持并不完全一致。
标准属性相对扩展属性可能受限。在 ISO C++ 不支持的上下文，应避免标准属性和替换标准属性的宏，而在可能时使用实现提供的扩展。
这可能和实现相关，如：
[[noreturn]] 不支持修饰 lambda 表达式（尽管 G++ 错误地接受，但 Clang++ 拒绝），而 __attribute__((noreturn)) 可用。
一般地，对 lambda 表达式内的函数体使用 YB_ATTR(noreturn) 而不是可能替换为标准属性的 YB_NORETURN 。
关于 G++ 对 lambda 属性的支持问题，另见：
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60503
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89640
标准属性不能指定非定义的友元(@5.5.9) 声明（ Clang++ 拒绝但 G++ 错误地接受），详见：
https://stackoverflow.com/questions/52332203
当前标准属性不能在显式实例化声明中出现（ Clang++ 拒绝但 G++ 接受），详见：
https://groups.google.com/a/isocpp.org/g/std-discussion/c/dbxwk5yeCv8
https://bugs.llvm.org/show_bug.cgi?id=29094
因为当前和特定实例或类型相关的属性都是扩展属性，所以在此直接避免使用标准属性。
此外，某些上下文中，一些实现如 G++ 允许 [[nodiscard]] 等标准属性和 __attribute__ 形式的扩展属性交换顺序；
另一些实现如 Clang++ 不保证接受任意顺序。
通过对多个指示符和属性的使用约定顺序避免这些问题，详见 @5.5.6.7 。

@5.5.6.7 顺序约定：
满足 ISO C++ 和以上各节的规则下，出现在完整声明的指示符（以及替换为它们的宏名）的顺序通过基于以下分组定义的规则确定：
修饰整个声明且不能修饰类型的标准属性（如 [[nodiscard]] ，考虑 @5.5.6.6 的顺序限制）；
修饰声明符号可见性的属性；
修饰整个声明的其它属性（如 [[noreturn]] ）；
标准存储类指示符(storage-class-specifier) （如 static ）、函数指示符(function-specifier)（即 explicit(@5.5.6.1) 和 virtual ）或 friend(@5.5.9) ；
未归类的标准声明指示符（直属于 decl-specifier 的记号，包括 constexpr 和 inline ）；
构成声明的类型指示符(type specifier) 的声明指示符组成部分（对函数，典型地以函数返回类型起始）。
以上组之间出现的顺序固定。最后一组外的每一组的记号序列中，内部各自以字典序（兼容以 [ 、_ 和其它标识符字符的顺序）排列。
若以一个宏替换多个不同组的指示符，或需要符合语言规则（如 Clang++ 不支持 [[noreturn]] 在 __attribute__((visibility("default"))) 后出现）时，允许有限地调整相邻顺序变通。
声明符位置出现的指示符，排除修饰整个声明的指示符，视为一个整体，内部顺序为字典序。
注意和 https://github.com/cplusplus/draft/issues/119 不同。
另见 https://github.com/cplusplus/draft/issues/2371 。

@5.5.6.8 修饰函数/函数模板的 constexpr ：
注意使用 constexpr 的语法和语义限制。
模板使用时，应保证至少有一个实例允许合式的 constexpr 以避免违反正确性(@5.1.8) 。
和 static 、explicit 配合使用时类同 inline ，参见 @5.5.6.1 。

@5.5.6.9 修饰函数/函数模板的属性：
应注意具体属性的要求和提供的假定，避免改变程序中 C++ 语言指定的语义。
使用表示纯函数(pure function) 和无状态函数(stateless function) 的属性时，应保证符合前提（排除违反 narrow contract([WG21 N3248]) ）时，副作用可被忽略以具有预期的行为假定。
模板使用表示纯函数和无状态函数的属性时，应保证每个模板实例都具有预期的行为假定。

@5.5.6.9.1 [[noreturn]] ：
注意一个翻译单元中 [[noreturn]] 如在函数声明中出现，则每一个函数声明中都必须出现，否则程序形式非法但不要求诊断(@5.1.7) 。
注意若从 [[noreturn]] 返回则行为未定义。
作为程序出口的函数可以直接捕获所有异常以改变运行时行为。

@5.5.7 typedef 和 using ：
不使用 typedef ，使用 using 别名声明代替。
注意 using 声明优先于 using 指令。
在 using 指令引入同名声明指称不同实体而造成歧义时，可使用适当的 using 声明消除歧义。
注意只使用 using 声明可能歧义的名称之一，否则仍然会造成歧义。具体选择应考虑语义、可转换性和用户代码的适配难度。

@5.5.7.1 using 声明：
不使用冗余的 using 声明。
尽可能避免在命名空间作用域内，尤其是头文件中使用 using 声明，以防名称污染。
在类作用域内合理使用 using 声明使被隐藏成员可见，或避免声明同名重载函数隐藏基类的同名函数成员。此时需要注意访问权限控制(@5.13.5) 。
注意类作用域内使用的 using 声明和构造函数/模板继承语法相似但语义不同。
类作用域内使用 using 声明应直接使用被声明的成员所在的直接或间接基类以便找到原始成员声明，除非至少存在以下情况之一：
需要避免多个基类声明路径不唯一造成歧义；
需要强调作为公开接口的 using 声明不依赖引入这个成员的所在的类而是其派生类。

@5.5.7.2 using 指令：
除非特别指定（例如文档说明），应避免在命名空间作用域内，尤其是头文件中使用 using 指令，以防名称污染。

@5.5.7.3 模板类型参数别名：
适当使用别名代替模板类型参数。
已有别名作为模板类型参数公开接口时，通常其它接口尽量使用别名。这使多个 template-parameter-list 模板参数之间（如类模板和函数模板的模板参数）较不易被混淆。
以上惯例和标准库风格不同，但和主流标准库实现一致。
若符合接口文档，且不使用别名能确保减少别名声明时，不使用别名代替模板类型参数。
这样的典型情形如实现 ISO C++ 标准库的兼容的或符合标准库要求的类似风格的类模板，使用 public 基类等实现方式，已提供了用户代码可使用的直接替代模板类型参数，而可在其它接口声明中避免的情形，例如：
allocator_type 、value_type 、key_compare 等容器相关的类型成员；
size_type 、difference_type 等迭代器相关的类型成员。

@5.5.8 命名空间：
注意命名空间是实体，但具有链接。
注意命名空间具有作用域。
注意 ISO C++11 3.5/3 明确，命名空间具有的链接对其中声明的、名称未被指定为内部链接的特定实体（变量、函数、命名类、具有 typedef-name 的未命名类、命名枚举、具有 typedef-name 的未命名枚举、具有链接的枚举中的枚举项和模板）具有传递性。
注意全局命名空间。

@5.5.8.1 未命名命名空间(unnamed namespace) ：
注意 ISO C++03 中未命名命名空间具有外部链接，但可能被实现优化，如 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=21581 。
注意 ISO C++11 3.5/4 明确，未命名命名空间及其中直接或间接的命名空间具有内部链接。
根据 @5.5.8 讨论的规则，未命名命名空间中的名称具有内部链接。

@5.5.8.2 命名空间别名：
尽可能避免命名空间别名造成的名称歧义。

@5.5.8.3 内联命名空间(inline namespace) ：
在 ISO C++11 实现及启用某些扩展的实现（如 Clang++ ）中，可在命名空间定义(namespace-definition) 中使用 inline ，可用于区分版本等。
和函数不同，对命名空间声明，可以只在原始命名空间定义（ original-namespace-definition ，之前未存在其它定义）中使用，而不需要所有声明都指定 inline 。
只要能确定命名空间定义在翻译单元中是原始命名空间定义，其它同一命名空间的定义（ extension-namespace-definition ，扩展命名空间定义）中的 inline 冗余使用并非语言规则强制必要；但一般仍应使用 inline 清楚地表示 inline 命名空间。（已知 Clang++ 3.4 (trunk186265) 默认会对不使用 inline 的情况产生警告。）
注意 ISO C++ 要求若在定义中使用 inline ，则必须是原始命名空间定义。实现可能不严格检查（如 G++ 和 libstdc++ 的 bug ： http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53402 ）。

@5.5.9 友元：
禁止在类定义中定义友元类。
注意声明在类的友元在命名空间中不自动可见。
注意友元函数非成员函数。
注意 friend 和属性的语法限制（参见 @5.5.6.6 ）。
除了以下提及的用法，避免使用友元。

@5.5.9.1 突破封装性的访问权限限制(@5.13.5) ：
友元无视访问权限控制的限制。

@5.5.9.2 名称查找：
友元被允许 ADL(@5.2.4.1) 查找。
参见 http://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick 。

@5.6 const 和 volatile 限定符(cv-qulifier) ：

@5.6.1 const ：
注意无 extern 时命名空间作用域声明的 const 对象名称具有内部链接，这点和 ISO C 不同。
尽可能使用 const 关键字，除了以下给出的例外(@5.6.3) 。

@5.6.2 volatile ：
仅在必要时使用 volatile 关键字。

@5.6.3 例外：
在函数参数列表中，省略不直接修饰参数的 const 。
在异常捕获块和异常规范(@5.10.5.6) 中，省略形式参数顶层的 const 和 volatile 修饰符。
函数参数类型在语义上必要时，考虑不使用 const ，参见 @5.12.2 。

@5.7 类型关键字：

@5.7.1 标量类型：
除非有必要，用非整数类型代替浮点数类型。

@5.7.2 整数类型：

@5.7.2.1 大小：
当需要时使用确定大小的整数类型。优先使用 <cstdint> 中支持的类型。

@5.7.2.2 符号和存储表示：
在位运算时尽可能使用无符号整数。其它情况按需选取有符号数。
注意 ISO C/C++ 支持原码、反码或补码的有符号数表示的实现。多数实现使用补码。

@5.7.2.3 整数与指针类型：
注意指针类型和整数类型的大小不保证相等。
需要使用和对象指针占用空间大小相同的整数类型时，若实现支持（可选支持，参见 ISO C++11 18.4.1 ），使用 std::intptr_t 或 std::uintptr_t 。
除了 char 以外的内建字符类型关键字在位域外不需要被 signed 或 unsigned 修饰。

@5.7.2.4 字符类型：
ISO C++98/03 支持 char 和 wchar_t 作为内建支持的字符类型。 ISO C++11 新增 char16_t 和 char32_t 类型，一般用于表示 Unicode 字符。
ISO C/C++ 中， char 类型实际定义了字节的大小，即 sizeof(char) == 1 ，且具有 CHAR_BIT （注意 CHAR_BIT 不小于 8 ）二进制位。
注意 ISO C/C++ 中，和其它能被 signed 或 unsigned 修饰的整数类型不同 signed char 、unsigned char 和 char 具有相同的大小和对齐要求，但是三种不同的类型。
注意 sizeof(wchar_t) 平台相关。而 char16_t 和 char32_t 分别表示至少能存储 16 位和 32 位二进制整数，并不表示确切的大小。

@5.7.3 枚举类型：
注意带作用域枚举(scoped enumeration) 在声明时不能省略作为枚举名称的标识符（参见 ISO C++11 7.2/2 ）。
enum class 和 enum struct 语义等价（参见 ISO C++11 7.2/2 ），统一风格起见应尽可能使用 enum class 。

@5.7.4 class-key ：
关于带作用域枚举，参见 @5.7.3 。
根据基类和成员的可访问性(@5.13.5) 的需要适当选择 struct 或 class 。
对同一个非 union 实体，在声明中总是一致地使用 struct 或 class 之一，以免某些非标准实现（如某些版本的 Microsoft C++ ）产生诊断消息。在某些实现启用诊断消息检查（如 Clang++ 使用 -Wmismatched-tags 警告）。

@5.7.5 this ：
注意 this 是实体（参见 ISO/IEC 14882 Clause 3 ）。
注意 this 的类型。
关于类模板中的使用，参见 @5.14.3 。

@5.7.6 auto 和 decltype ：
auto 使用模板推导规则。另见 @5.5.1 。
一般应尽可能使用 auto （以及 auto& 或 auto&& ）合理缩减声明类型的复杂性，但当类型关键字能够被确定且不超过 4 个字符（即不长于 auto ）时直接使用类型名称而不是 auto 。
注意 decltype 结果与操作数是否为 id-expression 和是否带括号相关。
注意 ISO C++14 的 decltype(auto) 和 C++11 auto 的差异。

@5.8 操作符、内建操作和常量表达式(constant-expression) ：

@5.8.1 sizeof 操作数：
尽可能用对象名称代替类型名称作为 sizeof 的操作数，以在重编码时保持一致性。

@5.8.2 操作符重载：
参见 @5.12.3 。
注意内建操作和重载操作符在操作数要求值类别和求值顺序等限制不同。

@5.8.3 自增和自减：
注意前置自增/自减和赋值的等价性。
注意后置自增/自减的副作用。

@5.8.4 sizeof 、alignof 和 alignas ：
注意 ISO C++ 的 sizeof 、alignof 和 alignas 的表达式是静态求值的常量表达式(@5.8.11)，它们的操作数是非求值操作数(@5.2.12) 。
注意 ISO C99 引入的 VLA 的数组类型 sizeof 在运行时求值，但 ISO C++ Array TS 引入的运行时确定的数组类型禁止使用 sizeof ，因此 sizeof 可确定是静态求值的常量表达式。

@5.8.5 new/delete 表达式：
注意 new/delete 对存储安全性的影响；使用时应充分考虑替代，详见 @6.9.2.3 。
注意 new 和 delete 匹配， new[] 和 delete[] 匹配，否则行为未定义。
注意 placement new 和（类类型的）析构函数匹配。
注意对类类型的非全局的 new/delete 可能通过 operator new/delete 重载。
注意 new/new[] 失败时可能由 operator new 或构造函数抛出异常。
全局 placement new 表达式（注意不是 operator new ）可用于创建新的对象避免一部分别名问题引起的未定义行为(@5.2.10.1) 。
除非是对内置类型非静态数据成员的明确默认初始化（即不初始化）， new 必须初始化（即对类类型也使用“ () ”而非省略）。
注意不同 new 表达式之间没有特殊规则保证副作用发生的顺序(@5.1.11.3) ，参见 [CWG 130] 。
优先使用智能指针(@6.9.2) 代替直接使用 new/delete 表达式分配和释放资源。后者仅用于特定实现（如智能指针或分配器）或当无法在所有条件编译场合下能简洁一致地使用前者时。可以在所有权明确转移时使用 new 表达式，如 @6.9.2.2 。
注意 ISO C++14 起允许合并特定的 new ；不应依赖其副作用差异。

@5.8.6 显式类型转换：
参见 @5.11.4 。

@5.8.7 typeid ：
注意 typeid 的操作数是非求值操作数(@5.2.12) 。
注意 typeid 对非多态类参数静态求值，而对多态类参数在运行时确定动态类型，有一定运行时开销，且根据 ISO TR 18015 可能较 dynamic_cast 更难被实现优化。
另见 @5.11.4 。

@5.8.8 算术操作、逻辑操作和位操作：

@5.8.8.1 算术转换：
注意算术转换，特别是算术操作数被提升为 int 类型。

@5.8.8.2 溢出：
注意有符号数溢出是未定义行为。
四则运算、取余和向左移位均可能导致溢出。
除数为 -1 可导致溢出，如 http://kqueue.org/blog/2012/12/31/idiv-dos/ 。
注意 n 位无符号数的内建二元 + 、二元 - 、* 、++ 、-- 、<< 及对应复合赋值和一元 - 操作遵循模算术(modular arithmetic) ，保证不溢出而保证结果回绕为 2 ^ n 的余数。
应特别注意避免无符号数减法导致非预期的结果。参考： https://www.securecoding.cert.org/confluence/display/seccode/INT30-C.+Ensure+that+unsigned+integer+operations+do+not+wrap 。

@5.8.8.3 浮点数：
注意浮点数的舍入误差、非数值（如 NaN 和 Inf 等）和浮点环境。

@5.8.8.4 逻辑操作：
注意内建 && 和 || 的短路求值：在第一操作数满足条件时不对第二操作数求值。注意重载的 && 和 || 没有这个性质(@5.12.3) 。
另见 @5.4.1.1 。

@5.8.8.5 移位操作：
注意右移位时从高位填充 0 或 1 （实现为算术右移或逻辑右移）由实现定义。
另见 @5.8.3.2 。

@5.8.8.6 其它二元逻辑操作：
注意 & 、| 和 ^ 的优先级。
注意 & 和 | 没有类似 && 和 || 的短路求值(@5.8.8.4) 。

@5.8.9 赋值表达式：
包括简单赋值表达式和复合赋值表达式，后者通过前者明确定义。
赋值操作的副作用在 ISO C11/ISO C++11 被更严格地限定顺序。
注意存在一些表达式在 ISO C90/99 和 ISO C++98/03 中存在未定义行为，但在 ISO C11 和 ISO C++11 正确的表达式如 i = ++i （另见 @5.8.3 ）。

@5.8.10 条件表达式：
注意条件表达式对值类别(@5.2.10) 的要求和影响。
注意 ISO C 和 ISO C++ 的条件表达式的语法差异。

@5.8.11 常量表达式：
特定的表达式可以在翻译时静态求值。
注意一些字面量、const 修饰类型的特定表达式，以及 constexpr 决定的表达式是常量表达式。
注意超过实现限制的表达式不是常量表达式。
注意未指定行为，如浮点计算精度导致某些表达式不能作为可移植的常量表达式。

@5.9 声明符和初始化：
注意区分涉及声明符的语法歧义，参见 ISO C++11 8.2 。

@5.9.1 声明符：
注意声明符的递归形式。
除非必要，避免使用复杂的声明符。

@5.9.1.1 默认(defaulted) 和删除(deleted) 函数：
默认函数是特殊成员函数(@5.12.3.2.1) 。
注意删除的声明对重载(@5.12.1) 的影响。

@5.9.1.2 函数定义：
注意省略函数体的函数声明不是函数定义。
除非接口设计或实现依赖的必要，不分离定义函数模板和 constexpr 函数，直接提供包含函数体的唯一的定义作为声明。

@5.9.2 直接初始化(direct initialization) 和复制(copy initialization) 初始化。
注意引起初始化特定的语法形式，区分直接初始化和复制初始化。
特定的上下文的初始化，如传递参数，总是复制初始化。
其它上下文中，用户声明变量或 new 语句中可以不同形式的语法指定不同的初始化。
复制初始化要求对象类型可被复制构造。注意对非 trivally copyable 类型直接初始化和复制初始化的行为可能不同。在这些情况下不使用复制初始化。
其它语法使用规则参见 @5.9.2.2 。

@5.9.2.1 歧义：
注意“ () ”形式的直接初始化受限。
声明对象时的初始化列表必须非空且其参数不能是类型名的函数风格转换，否则会被解析为函数声明符的组成部分而不是初值符，参见 ISO C++ 8.2 。另见 @5.10 。

@5.9.2.2 语法使用：
按是否允许“ () ”形式的直接初始化规则分为两类。

@5.9.2.2.1 直接初始化优先：
除规则 @5.9.2.1 和 @5.9.4 更优先外，以下上下文中尽可能使用“ () ”形式进行直接初始化。
适用于允许进行“ () ”形式的直接初始化的上下文，包括：
compound-statement 和 for-init-statement 中声明变量时的 initializer ；
new-expression 中的 new-initializer ；
lambda-expression 内的 lambda-introducer 内 lambda-init 中的 initializer （ ISO C++14 起）。

@5.9.2.2.2 复制初始化优先：
对类类型以及不能排除是类类型的（如带有模板参数的）依赖类型的对象，尽可能使用直接初始化以避免可能的复制开销；否则使用复制初始化。
注意在此 ISO C++11 也支持列表形式的直接初始化（“ {} ”）。
适用于“ = ”起始的复制初始化，但不支持“ () ”形式的直接初始化的上下文，包括：
selection-statement 的 condition 内的初始化，包括 if 和 switch 语句的条件；
iteration-statement 的 condition 内的初始化，包括 while 和 do-while 的条件以及 for 语句的可选条件；
member-declarator 的可选 brace-or-equal-initializer ，即类定义内的成员初始化（ ISO C++11 起）。

@5.9.3 零初始化(zero-initialization)  、默认初始化(default-initialization) 和值初始化(value-initialization) ：
注意静态或线程存储期的对象被零初始化。
注意 ISO C++11 明确默认初始化允许不进行初始化。此行为和 ISO C 兼容。
注意 ISO C++14 由于 [CWG 1301] 的解决，明确显式默认的默认构造函数(= default) 和显式删除的默认构造函数 (= delete) 或用户提供(user-provided) 的构造函数不同。

@5.9.4 初值符(initializer) 、聚集(aggregates) 、列表初始化(list-initialization) 和初始化列表(initializer-list) ：
合理使用类似语法。聚集类型需要和 C 兼容（如原子类型）时，使用复制初始化，否则适用以下规则。
不引起含义改变时，使用 {} 代替较长的默认值，如 nullptr 或 false ，而不代替 0U 等。
不引起含义改变时，使用 {} 代替较长的初值符（ *-initializer ），如 nullptr 或 false ，而不代替 (0) 等。另见 @5.9.2.1 。
不引起含义改变时，使用 {} 代替表示空字符串的字符串字面量如 "" 。

@5.9.4.1 列表初始化：
注意初值符的表达式有特定规则确定求值顺序(@5.1.11.3) ，参见 [CWG 1030] 。
注意 ISO C++14 由于 [CWG 1301] 的解决优先对聚集进行初始化，和 ISO C++11 的顺序不同。
注意类类型对象的列表初始化可能直接匹配构造函数的参数，或构造 std::initializer_list 实例类型的对象。
注意因为历史原因（先于转移语义，参见 [WG21 P0065R2] ）使用 std::initializer_list 的实例初始化复制初值符列表的元素，不兼容不能复制构造的元素类型，并可能引起性能问题；此时，应避免使用这种形式的列表初始化。

@5.10 语句和控制流：
编码时应注意避免干扰实现的分支预测优化。必要时可使用经过包装的特定实现的扩展。
语句中允许声明变量并初始化。初始化相关的语法使用规则参见 @5.9.2 。

@5.10.1 条件判断：
合理使用 if 语句代替 if-else 语句。

@5.10.2 无条件跳转：
尽可能不使用 goto ：仅在退出多层循环等少数具有明确语义且没有高效结构化控制流替代方式时使用。

@5.10.3 迭代和多分支：
合理减少 switch 块中的 break 的个数。
合理减少 break 和 continue 的个数。

@5.10.4 for 语句：

@5.10.4.1 for-init-statement 和 condition 子句：
注意 for-init-statement 必须存在，而 condition 是可选的。
使用的初始化语法规则不同，参见 @5.9.2.2 。

@5.10.4.2 expression 子句：
注意 expression 是可选的。
关于迭代条件的使用要点，参见 @5.8.3 和 @5.12.3.3 。

@5.10.4.3 range-based for ：
参见 @5.3.2.1 。

@5.10.5 异常使用规则：
理解 C++ 语言提供的异常是同步异常，此外存在体系结构和其它非同步异常，可能表示程序的设计和实现错误或非预期的运行环境，不由 C++ 异常处理机制解决。
理解 C++ 语言提供的异常机制及实现的限制，参见 @5.14 。
在必要时使用异常，而不是错误码或其它替代手段。
对通用的接口，可以同时保留使用异常和错误码表示错误的版本。
用于表示正常流程结果不使用异常，使用返回值等其它手段。
在大的循环内部或立即需要处理错误时不使用异常以保持代码清晰及减少不必要的性能开销。
除非必要，不使用嵌套 try 块。

@5.10.5.1 抛出异常和异常对象：
注意 throw 语句复制而非转移异常对象， throw 表达式中的对象需要满足可复制构造。
注意使用无参数的 throw 应保证存在当前处理的异常对象，否则程序终止。
除非文档说明的特殊情形，抛出的异常对象应具有类类型，即异常类(@5.10.5.5) 。

@5.10.5.2 捕获和重新抛出异常：
注意捕获派生类。除非文档说明，调用方不应依赖具体的异常类型。
注意处理 ctor-initializer 抛出的异常需使用 function-try-block 。
注意对构造函数或析构函数的 function-try-block 捕获的当前异常对象处理后遇到块的结束会自动被重新抛出，在此前可以抛出其它异常，如抛出嵌套异常(@5.10.5.7) 。
除以下例外，禁止使用 catch(...) 捕获所有异常而不重新抛出（除非保证程序控制流不到达或另行指定，此情况需要记录运行时日志），以免未预期地捕获非 C++ 异常(@5.14.2.2) ：
预期程序退出（包括记录致命错误的日志程序、@5.5.11.1 以及 @6.3.3 的情形）但最终抛出异常时；
在析构函数边界根据语义要求捕获异常，参见 @5.13.4.4 ；
特定运行时程序边界抛出其它异常，且明确约定允许捕获非 C++ 异常时；
全局 main 或线程启动函数需要无异常退出以保证程序继续运行时；
使用 std::make_exception_ptr 或特定实现的异常传播机制保存异常；
存在抛出异常的接口时，补充使用 std::nothrow 或其它形式的对应的非抛出异常的接口，且之间除异常情形的返回值外没有其它语义差异；
由文档说明补充解释语义而另行指定的情形。

@5.10.5.3 异常安全(exception safety) 约定：
基本内容参见 http://www.boost.org/community/exception_safety.html 。
可能在以上模型中插入其它层次，如 http://www.reddit.com/r/haskell/comments/2mfxka/handling_async_exceptions_in_haskell_the_right_way 。但为简化问题和特定语言上的解，在通用需求上只考虑此模型。
外部代码和非外部代码的约定不完全相同。此处的外部代码指当前程序组件的外部实现([Documentation::ProjectRuls @@3]) 代码。

@5.10.5.3.1 基本异常安全(basic exception safety) 保证：
除非另行指定，总是需要保证的最低安全性：避免异常处理造成资源泄露。
原理：因为不保证允许确定具体插入使之具有异常安全的保护操作的实现位置，一般地，一个不具有基本异常安全的接口无法通过用户代码组合为异常安全的接口。
注意这和可以通过用户外部添加同步代码的线程安全(@5.1.12) 情形不同。

@5.10.5.3.2 强异常安全(strong exception safety) 保证：
保持异常抛出后，程序的状态和引起异常的操作之前的某个状态等价。
必要时实现抛出异常后的状态回滚。
强异常安全是建议保持的默认接口异常安全保证策略。
注意这和线程安全接口设计的情形不同：一般情形下，通过选取合适的强异常安全的基本操作进行组合，实现的接口是强异常安全的，用户代码也不需要负担嵌套调用的冗余开销；而线程安全一般不具有组合性。

@5.10.5.3.3 无异常抛出(no-throw) 保证：
必要时使用，禁止异常导致控制流中断。

@5.10.5.3.4 资源生存期、资源类和资源对象：
优先使用 RAII 和确定性析构的 RRID[Documentation::CommonRules @@2.3.2.3] 实现异常安全的设计，封装资源为资源类：使用构造函数获取资源，使用具有无异常抛出保证(@5.10.5.3.3) 的析构函数释放资源。
资源类的对象是资源对象。资源对象的析构函数不应包含清理和释放资源以外的逻辑。
资源类的析构函数具有释放语义，需提供无异常抛出保证(@5.10.5.3.3) ，或在失败时终止程序(@5.2.6) 。
任何可能允许异常抛出的清理操作需要另行公开，在析构函数中调用并处理（忽略或进行无异常抛出保证的日志记录操作等）。
另见 @5.13.4.4 。

@5.10.5.3.5 提交(commit) 操作：
提交操作保存状态。除非能立即处理异常，保证异常中立(@5.10.5.4) ，允许异常传播。
析构函数可能进行提交操作，此时不需要提供无异常抛出保证(@5.10.5.3.3) ，参见 @5.13.4.4 。

@5.10.5.3.6 基本例外：
用于实现保证异常安全的资源管理的分配([Documentation::CommonRules @@2.3.2.3]) 相关例程（如 ISO C++ 约定的存储分配函数），处理的资源本身不保证异常安全，包括：
分配例程的直接调用；
对应的实现例程（如 std::malloc 可用于实现 ::operator new ）的调用；
包装分配例程的直接调用（如分配器的分配方法）。
这些例程的实现本身仍应保证基本异常安全，即保证不泄漏正在分配以外的资源。
除 ISO C++ 分配例程（重载或替换 operator new 和 operator new[]），使用基本例外的例程仍应在文档说明。

@5.10.5.3.7 外部代码约定：
若声称提供异常安全保证的代码允许控制流转移到外部实现（如回调），则实际的异常安全受到外部实现的代码限制，为其中较弱的一个。
除非另行指定，总是要求外部代码（至少）满足基本异常安全保证(@5.10.5.3.1) 。

@5.10.5.4 异常中立：
除非属于内部实现或异常能够被合适地完全处理，或应当保证异常不被传播(@5.10.5.3.3) ，总是不显式处理异常或向调用者重新抛出捕获的异常。
异常中立对上层调用透明，另见 @5.10.5.2 。

@5.10.5.5 异常类：
避免抛出非类类型异常以便捕获抛出的异常对象。

@5.10.5.5.1 异常类特性：
异常类是空类或多态类。
除非必要（如考虑性能），一般以 std::exception 作为基类。
异常类可使用多重继承。
异常类可使用虚继承。

@5.10.5.5.2 异常类成员：
考虑避免可能在构造函数时抛出异常的成员，这可能会直接导致无法捕获预期类型的异常对象。
必要时，利用覆盖基类的 what() 或其它成员的提供输出异常消息的接口。其中的内容需考虑显示效果清晰易于阅读。
异常消息保存抛出异常时的上下文状态。除非另行指定，异常消息仅影响用户交互，其具体的值一般是所在接口未指定的而不应被依赖。
除异常消息，程序也可能保存错误条件和所在的上下文信息为具有确定值的非用户交互状态。
捕获的异常在必要时被重新被抛出，一般应和提供原始的异常不同的上下文的信息，以避免相同信息在不同异常中重复出现的冗余：
	一般地，异常消息通常仅提供依赖当前上下文状态确定的局部信息。
	特别地，若一个表达式求值时可推断操作数是引发在操作内部（而非子表达式的求值）抛出的异常的直接理由，则这些操作数提供的信息通常不在操作内部中引发的异常时保存的信息中出现。
	这是因为：
		有时，操作内部不可能取得外部的上下文信息。例如，new 表达式分配调用的 operator new 抛出异常时不能引发失败的 new 的正在构造对象的类型（ operator new 也可能并非通过 new 表达式引发错误）。
		有时，操作内部可能取得外部的上下文信息，但外部不总是需要这些信息且在必要时总能完整地确定这些信息。例如，一个表示文件名的操作数可能在多个嵌套的调用中完全一致，仅在首先确定这个操作数的值时需要关心保存这些信息。
	在求值可能引发异常的表达式外部捕获并重新抛出操作内部引发的异常（可以是嵌套异常(@5.10.5.7) ），并在抛出前指定确定参数的值时明确的附加信息，能使操作内部不需要具有和这些信息一致的冗余。
	避免取得外部的上下文信息同时减少了捕获和重新抛出异常的需要而有利于以更简单的方式实现异常中立(@5.10.5.4) 。
异常类可使用基于构造时使用的参数指定异常消息。
其中对已知可能使用部分原始消息的异常类，应假定构造的消息不是消息的末尾以按需指定正确的标点，包括：
std::system_error （如 libstdc++ 追加冒号分隔的字符串，后者来自异常类别而非参数）。

@5.10.5.6 异常规范：
除了本节指出的例外，在无异常抛出保证[Documentation::CommonRules @@3.6.2.1.3] 的场合，应使用异常规范。
在非显式使用的异常规范上下文中，使用自定义的异常规范宏代替 throw 关键字。
注意动态异常规范是 ISO C++11 中的 deprecated 特性(@5.1.6) ，应限制使用（如仅用于调试）。
除异常类设计和本节提到的其它例外，不显式地使用异常规范，而用异常规范宏代替。
注意 ISO C++11 规定的继承构造函数/模板和特殊成员函数(@5.12.3.2.1) 的隐式异常规范。除析构函数外，只在必要时使用推断的隐式异常规范，否则应显式在声明中指出。
注意覆盖虚函数的异常规范至少和被覆盖的虚函数一样严格。除非确定不覆盖（如作为 final 类或至少不使用 public 继承），析构函数一般不显式使用异常规范。
注意按 WG21 N3279 ， ISO C++ 标准库实践中析构函数不使用异常规范，如 WG21 N3508 ；但按 ISO C++ 15.4/14 析构函数上隐式的异常规范同隐式声明的特殊成员函数而不是无条件地默认 noexcept （如 [WG21 N3166] 的提议）。此外，允许有覆盖规则提供例外情况，如 [LWG 2337] 。
注意隐式推导同特殊成员函数。当定义中有 throw 表达式时不自动推导为隐式异常，允许抛出异常时需要显式指定异常规范。
注意不同配置下的不同表达式调用对析构函数隐式异常规范推导的影响，如断言(@6.3.3) 在析构函数中使用时应始终保证无异常抛出。

@5.10.5.6.1 noexcept 使用准则：
使用 noexcept 代替 noexcept(true) 。
注意违反 noexcept 可能导致程序非正常退出。
注意 WG21 N3248 明确了标准库使用 noexcept 的准则。
为了便于程序验证（可测试机性等），不直接在所有无异常抛出保证的函数上使用 noexcept ，仅当函数具有 wide contract([WG21 N3248]) ，即保证不（因为参数或状态违反前置条件）引起未定义行为时使用 noexcept 。
WG21 N3263 在此基础上明确了标准库容器(@6.12) 成员的 noexcept 使用。 WG21 N3279 明确了标准库中的一般使用。
转移构造函数、转移赋值函数和 swap 需要使用 noexcept ，除非依赖仅由模板参数引入的对应操作非 noexcept 的基类或成员子对象。
除以下指定的规则外，一般库的设计应遵循标准库上述对异常规范的使用准则。
资源对象(@5.10.5.3.4) 的析构函数需要保证无异常抛出时不使用允许抛出异常的异常规范。注意隐式推导时调用的函数需要保证具有无异常抛出保证的异常规范。
仅在隐式异常规范不符合接口目的时使用 noexcept 指定不同行为。
以下情形的任意其它析构函数允许显式指定 noexcept 异常规范，但需要在文档中标注并明确理由：
禁止抛出异常：保证不抛出异常，但隐式异常规范不保证无异常抛出；
允许抛出异常：明确保证不在栈展开(@5.14.1) 时使用，明确允许抛出异常，但隐式异常规范保证无异常抛出；
允许可能抛出异常：使用 noexcept 的操作数指定可能抛出异常，一般用于模板代码。

@5.10.5.7 嵌套异常：
使用嵌套异常组合有明确顺序依赖的异常。一般这些异常应在不同位置上引发。
注意嵌套异常的复制开销。
使用标准库 std::throw_with_nested 等抛出嵌套异常。
包装底层来源不同（例如和平台实现相关）的外部(alien) 异常时，应使用嵌套异常或其它机制提供统一的抽象，明确调用方可统一捕获异常的范围（必要时使用文档说明）。
可使用递归例程处理嵌套异常。应注意保持适当的上下文信息以便必要时区分递归调用和显式调用处理嵌套异常例程的位置的差异，避免混淆异常的来源。

@5.10.6
除非必要，不使用 <csetjmp> 。

@5.11 标准转换、显式转换和类型使用限制：

@5.11.1 左值变换(lvalue transformation) ：
讨论重载(@5.12.1) 时，标准转换 lvalue-to-rvalue conversion 、array-to-pointer conversion 和 function-to-pointer conversion 统称为左值变换。
注意函数参数和返回类型的退化(decaying) ：数组到指针，函数到函数指针。
可以使用 std::decay 显式实现。

@5.11.2 非确定长度的数组：
除非兼容性需要，不使用非确定长度的数组（包括扩展的变长数组）。

@5.11.3 显式类型转换：
使用 C++ 风格而不是 C 风格的显式类型转换。
足够清晰时使用 C++ 类构造函数语法代替 reinterpret_cast 和 static_cast 而不使用显式转换，以避免过于冗长。
优先使用函数模板包装转换以明确更特定的语用。

@5.11.4 显式类型转换：
注意 dynamic_cast 依赖运行时类型识别(RTTI) ，需要多态类(@5.13.3) 操作数；而其它三个关键字表示的转换在编译时确定，无此限制。
尽可能使用 dynamic_cast 代替 typeid ；
尽可能使用 static_cast 代替 dynamic_cast ；
尽可能使用 static_cast 代替 reinterpret_cast 。
接口类型([Documentation::CommonRules @@2.4.1]) 转换可选 dynamic_cast ，但能保证类型安全且不被虚继承时首选 static_cast ，以提升性能。
如果可能（对 simple-type-specfier 和 typename-specifier ），一般应使用函数调用形式代替 static_cast ，以保持简洁。
注意 const_cast 禁止用于转换 const 动态类型的对象，以免引起未定义行为。
注意在函数指针和对象指针之间的 reinterpret_cast 是有条件支持的(@5.1.5) 。

@5.11.5 成员指针转换限制：
除非显式约定布局，派生类的成员指针不应转换为基类成员指针的 static_cast ，以避免成员指针实现相关的错误。

@5.11.6 转换为 bool ：
注意 if 的条件表达式等上下文遵循 ISO C++11 的 contextually converted to bool ，此时无需转换。尽可能使用此规则保证相关上下文中的无歧义和简洁。
注意 ISO C 的对应上下文中不使用此转换。
例如对指针类型 p ，在 C++ 中使用 if(p) ，在 C 中使用 if(p) 或 if(p == NULL) （而 if((int)p) 不保证等价）。
注意浮点数等允许通过标准布尔转换隐式转换为 bool 类型。
另见 @5.12.1 。

@5.12 函数/模板参数和重载：
注意函数重载和默认参数的使用的清晰性和易读性。

@5.12.1 函数重载：
避免不必要的重载和歧义。
重载使用复杂的规则。注意 explicit 关键字对重载的影响。
对不期望隐式转换的类类型，使用 ISO C++11 引入的 explicit 转换操作符避免不必要的转换；在 ISO C++98/03 中使用转换为非公开成员指针类型代替。
注意函数和返回类型的限定符(@5.6) 和退化(@5.11.1) 不影响函数类型等价性。

@5.12.2 参数和返回：
参数和返回统称传递(passing) 。
不涉及引用时，只使用按值传递(pass by value) 可避免引用访问超出生存期的对象(@5.2.8) 导致的未定义行为，保证所有权意义下的内存安全(memory safety) 。
使用按引用传递(pass by reference) 确定被引用值的同一性，可用于共享状态或显式地避免复制。
参数传递和返回值初始化是复制初始化，可能调用复制构造或转移构造函数，可能有复制省略(@5.13.4.3) 。
参数和返回类型应符合接口需要的语义要求。参数类型应符合 @5.12.2.2 的选择策略。
参数类型和返回类型使用单一的 void ，但不能被限定符(@5.6) 修饰。
在需要完全的值类型语义且复制开销较小（例如传递一个内建整数类型的对象、内建指针、典型的迭代器、常见的函数对象）或预期是否被复制传递显式未指定（如 ISO C++17 [algorithms.general]/10 ）时，使用非引用类型形式参数或返回类型。
对直接按值复制传递的函数参数，当需要按引用传递时，使用 std::ref 或 std::cref 包装。
（经验表明特定布局的非空类类型的小对象使用 const 左值引用可提供比直接使用对象更多的优化机会，例如包装整数类型的 union 在 G++ 4.7 上的表现。）

@5.12.2.1 参数列表：
注意只有没有参数的函数允许使用 void 参数类型，在 C++ 中一般省略。
注意非定义的函数声明中 C 和 C++ 对空参数列表的不同： C 的“ () ”相当于 C++ 的“ (...) ”，而 C 的“ (void) ”相当于 C++ 的“ () ”。
函数定义中 C 的“ () ”和 C++ 相同，但一般和原型声明保持一致以保持清晰。
注意使用 std::va_list 的实际参数时的所在的活动调用。改变活动调用的操作如 RAII(@5.10.5.3.4) 不总是可用。

@5.12.2.2 参数类型：
非引用类型的参数传递方式为按值调用(call by value) ；引用类型参数传递为按引用调用(call by reference) 。
以非引用类型直接作为参数类型是按值传递(@5.12.2) 的实例；使用引用类型的函数参数是按引用传递(@5.12.2) 的实例。
在需要转移语义(@5.2.9.1) 时，使用非 const 右值引用类型参数，同时使用 std::move 或等价的显式类型转换包装参数传递。否则，参数被复制。
当使用类的静态对象作为默认参数时，引用类型的形式参数造成此静态对象的 odr-used (@5.1.8) 因此需要额外的类外定义（参见 @5.5.4.2 ），即便是 const 或 constexpr 决定的常量表达式(@5.8.11) 。
对函数类型参数应注意 function-to-pointer conversion 退化(@5.11.1) 。
因为退化后适合以下按值调用的情形，对可能涉及函数类型的泛型接口，不需要考虑函数类型传递造成的开销，所以选取参数时只考虑非函数类型参数的传递。
复制开销可预测地足够小且不需要修改参数时，以下情形直接使用按值调用：
在一般体系结构不会具有较大复制开销的类型，包括内建的整数类型和指针；
不显式指定布局的类类型（注意 ABI 仍然可能导致额外开销但一般需要忽略，如 @6.9.2 ）；
保证一致语义、简化接口设计约定的惯用方式（参见 @6.9.2 、@6.10.3 和 @6.13 ）；
合一操作(@5.13.4.3.2) ，包括合一赋值(@5.12.3.2.3) 和语义与之类似的同时需要支持 const 左值引用和右值引用的参数的情形；
仅需要常量表达式的值，保证使用 lvalue-to-rvalue conversion 退化(@5.11.1) 的结果，为了省略前述的静态数据成员定义时（参见 @5.5.6.3 ）。
否则，一般使用 const 左值对象引用类型作为参数类型。
注意部分对象副本的复制开销在当前语言规则下无法通过复制省略被避免，参见 [CWG 6][CWG 1049][WG21 P0889R1] 。这可能引起以上判定和某些约定的惯用方式冲突。使用明确约定的规则（如 @6.9.1.1 ）以避免冲突，否则仍使用惯用方式以避免可能的语义的不一致。
注意传递参数只作用于参数类型；对参数类型关联的类型可使用特定的非引用类型间接地启用不同的语义，如 @6.10.1 。

@5.12.2.3 返回类型和返回值：
注意避免返回引用类型引用自动对象引起未定义行为。
除了 @5.12.2 的约定外，当返回对象可转移构造时，返回类型也可使用直接使用对象类型。
另见 @5.13.4.3 。

@5.12.2.4 参数转发(parameter forwarding) ：
仅向内部实现中的调用传递参数，外层参数使用非 const 右值引用类型时，同时使用 std::forward 或等价的显式类型转换包装参数传递。
注意右值对象引用类型的参数不保证实际参数在函数调用后被转移(@5.2.9.1) 。
对可转移构造但不能复制构造的对象类型非模板函数参数，仅当可预期和可接受转移构造开销并且总是需要转移操作时直接使用对象类型，否则使用右值引用参数。参见 http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html 的讨论。
另见 @5.2.9.1 和 @6.9.2 。

@5.12.2.4.1 可共享右值引用例外：
可另行指定特定对象类型对应的右值引用类型参数可不被认为引用唯一对象且不保证被转移。
这表示这些函数的实现不能假定实际上引用的一个对象类型右值而不是经过显式转换为 xvalue 的左值，因此不能随意进行别名优化；同时，转移后的对象保证具有确定的状态。
实用意义上，这里使用右值引用主要原因为允许直接构造临时对象作为函数的实际参数，而不是为了启用使用转移语义(@5.2.9.1) 的优化。

@5.12.3 操作符重载：
对一元操作符重载，使用成员重载。
对参数形式对称的二元操作符重载，使用非成员重载并合理利用转换。
注意重载的操作符如 = 、&& 、|| 和 , ，没有和内建操作符相同的操作数值类别限制和求值顺序保证。

@5.12.3.1 限制特定的重载：
除非必要，不重载一元 operator& 和 一元 operator* 。若重载，需要和内建操作符的对应语义相关。
一般不重载 operator->* 和 operator, 。若重载，需要特别注意优先级。
二元操作符一般重载为非类成员，其它操作符一般使用重载为类成员。

@5.12.3.2 重载 operator= ：
注意 operator= 被派生类隐藏。
除非另行制定，operator= 的实现应保证强异常安全(@5.10.5.3.2) 。

@5.12.3.2.1 特殊成员函数：
除非另行指定，重载 operator= 作为特殊成员函数或替代特殊成员函数时，只要存在对应的操作，实现的行为应对应满足标准库的 CopyAssignable 、MoveAssignable 和 Swappable 要求。
注意复制赋值函数和转移赋值函数是非模板的特殊成员函数，实现提供隐式的声明和定义，可以声明为 = default 显式使用（当不满足特定条件时同 = delete ）。
若没有 trivial 复制赋值，没有转移赋值会导致以此类对象作为成员的类无法使用默认生成转移赋值（隐式地，或声明为 = default ，都相当于 = delete ）。
除非另行指定，不应依赖转移赋值不引起实际参数状态的改变。
若转移赋值是必要的，一般应确保存在可访问的转移构造函数。
为避免混淆，一般仅使用特殊成员函数定义的赋值操作。
另见 @5.10.5.6 。

@5.12.3.2.2 自赋值(self-assignment) ：
对参数指定的对象和 *this 相同的情形称为自赋值。
为避免混淆，简化接口语义，禁止特殊成员函数以外的自赋值。
根据 @5.2.9.1 指定右值引用参数遵循标准库的约定，除非另行指定，不考虑自赋值。
对递归类型（如支持自身类型作为元素类型的容器）的转移赋值，和自赋值类似，可涉及被转移的对象被转移的目标对象所有。
基于不允许转移赋值中上述的自赋值类似的理由，此类转移赋值不需要考虑检查这种情形，即便违反可能导致循环引用或其它不被预期的行为。接口的使用者应避免引起此类行为的操作。

@5.12.3.2.3 异常安全实现：
经典复制赋值实现使用 copy-and-swap idiom 和 const 左值引用参数，能避免自赋值副作用且至少具有强异常安全保证(@5.10.5.3.2) 。
转移赋值一般应保证无异常抛出(@5.10.5.3.3) 。特定的容器(@6.12) 的转移赋值可不满足无异常抛出要求，如被容器所有的交换函数对象不满足无异常抛出，或使用预分配节点的实现。
转移赋值可以使用 copy-and-swap idiom 的变体，用转移构造代替复制构造创建新对象后交换。
由于异常规范仅适用于块，不涉及参数复制的异常，因此当函数体内保证无异常抛出时，可以直接使用无异常抛出保证的异常规范。这允许在参数上创建对象统一异常安全的复制和转移操作(@5.12.3.2.4) 。
另一种转移赋值的实现方式是直接组合基类和数据成员的无异常抛出保证的转移操作提供无异常抛出保证。这也是默认生成的 = default 转移赋值的实现方式。
若 swap 操作开销总是较大（如较大的数组类型），则应考虑其它方式（包括直接转移成员）代替以优化性能。
注意使用 copy-and-swap 实现赋值可能隐含不必要的 wide contract([WG21 N3248]) ，如允许自赋值(@5.12.3.2.2) 。应明确接口不依赖这些非预期的假设。
对转移赋值，若使用 copy-and-swap ，需要多一次转移构造创建对象，当没有被消除时(@5.13.4.3) 可能有不期望的开销。

@5.12.3.2.4 合一赋值(unifying assignment) ：
对复制赋值和转移赋值使用合一操作(@5.13.4.3.2) ，结果为合一赋值，可以获得对象复制的优化，但具有以下缺点：
重载右值引用参数的 operator= 会引起重载歧义，即无法通过单独重载优化的转移赋值；
因为参数类型的原因，无法使用 = default ，即便默认生成的赋值符合要求（如只有一个成员，或各个基类和成员的转移赋值都有无异常抛出保证的情形）；
无条件构造对象，无法根据复制或转移的目标对象及被转移的对象的状态进行优化，可能构造冗余的对象及引起不必要的性能开销（详见 @5.13.4.3.3 ）；
因此，一般不重载非引用参数的 operator= ，而分别重载 const 左值引用参数和非 const 右值引用参数的版本（也可能不需要转移赋值，仅重载前者），除非满足 @5.13.4.3.3 的条件。
注意 @5.13.4.3.3 的条件是 @5.12.2.2 中约定以值传递的真子集。对一般的迭代器和函数对象，若需要显式提供复制赋值和转移赋值，则通常仍应分别提供，而非合一赋值。
若使用合一赋值，通常使用在参数替代临时对象的 copy-and-swap(@5.12.3.2.3) （实际也包含 move-and-swap ）。

@5.12.3.2.5 非完全赋值：
赋值不一定保证子对象的值被赋值或被复制。
典型例子是容器的分配器，参见 @6.9.1.2 。

@5.12.3.2.6 复制赋值操作符：
复制赋值可使用合一赋值或复制赋值操作符之一实现。
异常安全的复制赋值的实现可使用保证无异常抛出的不复制完整对象（避免循环依赖）的其它赋值操作符，包括转移赋值和非完全赋值操作符。
对被复制的类类型 T ，赋值参数 args ，典型实现如：
*this = T(std::forward<decltype(args)>(args)...);
其中的 = 使用现有的不复制完整 T 对象的其它赋值操作符。
若复制赋值操作符是必要的（蕴含不使用合一赋值），在确定上述其它赋值操作符的基础上，确定其实现：
若具体数据成员的复制赋值不能直接组合为符合要求的复制赋值，或存在优化实现性能等必要，使用特定于具体对象语义的非典型实现；
否则，若可行，优先使用可实现复制复制操作符的其它赋值操作符，以避免不必要地依赖交换等实现细节，同时有利于利用非典型的实现；
否则（不存在满足要求的操作符，如转移赋值操作符不存在或不在接口意义上保证无异常抛出），使用显式的复制和交换。
注意对支持分配器的容器的交换，通常复制分配器以确保分配器相等。若分配器不相等，存在未定义行为。详见 @6.9.1.2 。

@5.12.3.2.7 一般实现策略：
对保存存储状态的不完全值语义对象（例如容器），使用最小赋值：在 operator= 的实现中判断状态，以避免分配不必要的存储空间。
对其它不完全值语义对象，若转移赋值是必要的，使用以下实现：
考虑是否允许使用合一赋值；
若具体数据成员的转移赋值不能直接组合为符合要求的转移赋值，或存在优化实现性能等必要，使用特定于具体对象语义的非典型实现；
具有明确的 clear 等操作回复值的状态时，使用断言（禁止）自赋值或判断自赋值的 clear-and-swap 实现，可以期望比 copy-and-swap 具有更好的性能（因为通常不需要大量 clear 操作）；
当不需要 clear 等操作回复状态（例如约定调用方保证参数是临时对象）时，可直接使用交换；
其它情况使用默认简单实现，即对每个子对象进行转移赋值（可以显式使用 = default ）。
之后，在确定复制赋值操作符必要时，按 @5.12.3.2.6 的策略实现。

@5.12.3.3 重载自增和自减：
在相同作用域内，前置和后置自增/减被同时定义时，尽可能保证它们的语义一致性，并通过前置自增/减来实现后置版本。若有必要改变，必须给出注释说明。
能使用前置自增/减实现相同效果时，不用后置自增/减。

@5.12.3.4 重载 operator() ：
允许多个重载 operator() 。应特别注意成员 operator() 的 cv-qualifier 。
当存在多个重载候选时，通过 std::enable_if 或其它 SFNIAE 进行选择。若无法选择，调用其它成员（模板）。

@5.12.3.5 重载转换操作符：
允许重载操作符模板。应特别注意成员 operator() 的 cv-qualifier 。
当存在多个重载候选时，通过非模板优先于模板匹配进行有限选择。若无法选择，调用其它成员。

@5.12.3.6 重载 operator new 、operator new[] 、operator delete 和 opertor delete[] ：
不依赖重载成员 operator new 、operator new[] 、operator delete 和 opertor delete[] 声明的隐式 static ，显式使用 static 关键字以明示不隐含 this 。

@5.12.4 默认参数：
合理地使用函数默认参数。需要注意参数顺序。

@5.12.4.1
在虚函数中应避免使用默认参数。
若需要使用默认参数，应在基类中使用具有默认参数的非虚成员函数调用没有默认参数的非 public 虚函数。

@5.13 类：
类是类型。
类类型包含 class 和 union 。
作为公开接口的类一般不在类定义中使用 final ，以避免对继承(@5.13.3) 的不必要的限制，即使继承 public 成员几乎总是不被期望的（如 @5.13.4.4 ）。

@5.13.1 类名：
类名声明不是定义。
类名声明引入的类在类定义前是不完整类型。

@5.13.2 类的成员：
静态成员函数同非成员函数，除了受到访问权限控制(@5.13.5) 的作用。
非静态成员函数操作受限。

@5.13.2.1 成员初始化：
注意成员初始化顺序。
除非是对内置类型非静态数据成员的明确默认初始化（即不初始化），每个成员必须初始化（另见 @5.8.5 ）。
注意 ISO C++ 支持成员直接在类定义内初始化。可使用列表初始化或复制初始化，使用的语法和策略同 if 条件中的使用，参见 @5.10.1 。
除了类定义内的初始化外，在构造函数内初始化非静态成员。除非必要，尽可能使用直接初始化而不是列表初始化或以赋值代替初始化。

@5.13.3 派生类：
注意空基类优化：基类子对象可能占用零存储。
继承和访问权限控制(@5.13.5) 相关。注意 C++ 中，类的成员是否被继承不受权限控制的影响。
具有虚函数或虚基类的类是多态类。虚基类无法静态转换为派生类。适当平衡运行时开销。
虚基类的初始化顺序和非虚基类不同。

@5.13.4 特殊成员函数：
注意排除模板。
区分隐式声明和定义。
注意若用户显式声明的即为非 trivial 的。
注意 ISO C++ 构造函数和析构函数中调用虚函数行为同非虚函数，参见 @5.13.7.1 。这和 Java 、C# 、C++/CLI 和早期的非标准 C++ 的类似特性不同。

@5.13.4.1 默认构造函数：
注意默认构造函数可能有默认参数。
默认构造函数被显式默认定义(= default) 时行为和显式删除(= delete) 的直接省略 ctor-initializer 的用户提供的定义不同，后两者可能导致默认初始化不初始化成员，参见 @5.9.3 。

@5.13.4.2 隐式声明：
注意隐式声明的特殊成员函数具有的异常规范。

@5.13.4.3 复制和转移：
注意 ISO C++11 12.8/31 指定的允许复制省略(copy elision) 而消除对象副本的特殊规则，不应依赖其副作用的存在性。
注意 ISO C++11 关于隐式声明复制构造函数和复制赋值操作符的 deprecated 特性。
注意 ISO C++17 （自 [WG21 P0135R1] ）要求复制省略的作用必须被实现，但这仍不允许省略对象类型函数参数的构造。
注意常量表达式中的复制省略的限制（参见 [LWG 2278] 覆盖 [LWG 2022] ）。
关于复制赋值/转移赋值，参见 @5.12.3.2 。

@5.13.4.3.1 重载解析：
注意 ISO C++ 11 12.8/32 的两阶段重载解析（优先转移，失败时复制）规则，条件为：
考虑被复制的对象为函数参数名指定后，满足复制省略(@5.13.4.3) 的条件（但不论是否进行），且对象为左值。
注意 ISO C++14 12.8/32 对此进行两点修正：
排除 exception-declaration([CWG 1493]) ；
明确 return 语句后的（可以是 id-expression ）被复制的源对象为需要自动存储的对象或函数及 lambda 表达式的形式参数，允许返回类型和 return 的对象类型不一致([CWG 1579]) 。
因此，对 return 作用的以名称出现的非 volatile 类类型自动对象（除函数和 catch 的参数外），不需要 std::move 即可优先转移，仅当无法转移时复制。
注意源对象不是声明为引用的变量。

@5.13.4.3.2 合一操作(unifying operation) ：
多个函数若满足以下条件，则可进行复制和转移操作的合一(unifying) ：
除相同位置的至少一个形式参数（及考虑 ref-qualifier 后隐含的 *this ）不同；
不同形式参数及可能存在的异常规范差异（详见以下条件）以外的函数签名相同；
不同的形式参数只有相同对象类型的 const 左值引用和非 const 右值引用，且存在全是 const 左值引用和全是非 const 右值引用的两个函数；
全是非 const 右值引用的操作不抛出异常且具有无异常抛出的异常规范(@5.10.5.6) ；
其中任意一个调用被调用其中的任意一个其它函数的一次调用替换，除创建临时对象的数量和生存期不同，不影响程序的预期行为。
可使用语义和这些函数的公共操作等价的一个合一操作函数定义替代这些函数的定义，即合一。和被合一的任意两个函数的差异类似，不同的只有参数和异常规范：
合一操作参数都是去除 cv 限定符的上述不同参数引用的对象类型；
合一操作具有无异常抛出的异常规范，当且仅当上述所有操作都有相同的无异常抛出的异常规范。
被合一的操作中， const 左值引用参数的实际参数被复制，非 const 右值引用参数的实际参数被转移。
因为合一条件中抛出异常仅可能在复制操作中，而合一的操作的复制操作发生在参数，不受异常规范限制，所以合一操作可以添加异常规范。
满足以上条件时，是否应使用合一操作替代非合一操作和具体操作相关，参见 @5.13.4.3.3 的讨论。
注意合一操作不能直接替代复制和转移构造函数，否则复制初始化引起无限递归，和预期行为不一致而不满足以上条件。

@5.13.4.3.3 对象数量不变量和实现开销：
一般地， C++ 对象模型预期进入生存期(@5.2.8) 的对象在程序终止前被销毁。
根据相同类型对象的数量对程序中的操作进行以下分类：
创建操作：某个类型的对象的数量增加 1 ；
销毁操作：某个类型的对象的数量减少 1 ；
创建和销毁外的平凡操作：某个类型的对象的数量不变。
即平凡操作中，对象数量构成不变量(invariant) 。
平凡操作包含相等数量的创建和销毁操作。实现相同的行为的操作平凡，具体的创建对象的数量可以不同，开销可以有差别。复制省略(@5.13.4.3) 可用于减少创建和销毁对象操作数量。
除此之外，其它一些操作的不同实现也可具有不同数量的创建。
典型地，为了异常安全(@5.10.5.3) 的对象引入临时对象并销毁对象副本实现赋值(@5.12.3.2.3) 是一种这里的平凡操作。
若已知对象中部分子对象的复制已满足强异常安全要求，用这些对象的复制和其它对象（若存在）的复制分别组合（类似 = default 的构造）而不是先整体复制后销毁，通过部分子对象的创建和销毁数量的增加减少（临时）对象整体的创建和销毁，通常具有更小的开销，是复制省略以外的优化。
这类替代优化是否可行和子对象的性质以及复制时需要满足的不变量相关，不被语言直接支持而需要单独实现。
基于参数传递的复制初始化的参数无条件（除异常控制流外，下同）复制或转移构造新的对象而无法排除对象的整体构造，不支持此类优化；同时， ISO C++17 要求的复制省略(@5.13.4.3) 在参数上也不可用。
作为实例，合一操作(@5.13.4.3.2) 在此受到影响：
在合一赋值(@5.12.3.2.3) 等操作中，通过参数初始化创建的对象引起对象的增加，最终需要附加 1 个销毁操作。基于语言规则，这个对象的销毁操作无法通过修改合一操作内部的实现避免；
反之，若合一操作初始化的参数对象总是用于创建操作（如实现构造函数时初始化整个对象或其中的某个数据成员），则不需要附加销毁操作。
注意，附加 1 个销毁操作导致 1 个此前的创建操作被撤销，相对非合一操作的开销增量是 1 个创建和 1 个销毁操作。
即便只考虑最小开销的构造函数和析构函数的组合，也并非每个类型的对象都能忽略（足够低和可预测而可接受）这种代价。
因此，在满足合一操作要求的前提(@5.13.4.3.2) 下，除非所有作为合一参数的对象类型都至少满足以下条件之一，不使用合一操作替代非合一操作：
对所有被合一的操作，复制初始化后的参数作为对象副本总是预期被需要的；
复制和转移构造都足够低和可预测而可接受的开销：能被平凡复制(trivially copyable) 和平凡析构(trivially destructible) ，或者只具有其它可接受的代价；
对所有被合一的操作，总是创建操作，且被通过参数转移到被创建的对象的代价总是可忽略。
（以上规则另见 https://stackoverflow.com/a/53825424/2307646 。）
对不适用的类型使用非创建操作的合一操作可能引入难以优化的冗余创建和销毁，作为接口对可用性提供了错误的暗示，应被避免。
不适用的非创建操作而不适合被合一的例子一般有：
赋值及对数据成员对象赋值；
典型的向容器插入值的操作（因为可能已存在对象或分配失败而不保证成功）；
有条件地创建对象或赋值对象的操作（如类似 ISO C++ std::map 的 insert_or_assign ，即便忽略可能的插入失败）。
不适用对象类型限制引起冗余开销的例子主要有：
转移构造函数可能包含不可忽略开销的非平凡（如分配动态存储或请求系统资源）的初始化（可能所有构造函数都需要这样的初始化）。
不能都保证总是适用的参数化类型（特别地，考虑递归复制的情形，如泛型容器，并非对所有类型的值的复制都适用；allocator-aware 的容器对分配器也有类似问题）。

@5.13.4.4 析构函数：
作为公开接口的多态类应该保证具有虚析构函数以避免通过基类销毁对象时的未定义行为。
除以下情形，作为接口的具有 public 非虚析构函数的类使用文档警告：
使用 final （另见 @5.13 ）；
作为特征(@6.8) 的实例；
作为删除器(@6.9.2.2) ；
其它库接口设计约定的情形。
析构函数应具有释放语义或提交语义，对应的异常保证满足 @5.10.5.3.4 和 @5.10.5.3.5 之一；除非另行指定，一般类的析构函数的行为同资源类。另见 @5.10.5.6.1 。
一般用例参见 http://stackoverflow.com/questions/130117/throwing-exceptions-out-of-a-destructor 。另见 WG21 N3614 。
在需要无异常抛出保证时，在不明确何种异常时可以使用 catch(...) 捕获所有异常，否则在 catch(...) 中断言控制流不可达。
关于析构函数的异常规范，参见 @5.10.5.6 和 @5.10.5.6.1 。

@5.13.5 访问权限控制：
访问权限控制决定可访问性。
注意访问权限控制和可见性相互独立。
注意对一般实现，访问权限控制仅在编译时检查。
关于友元，参见 @5.5.9 。

@5.13.5.1 隐式访问权限：
注意隐式访问权限： class 默认具有 private ； struct 默认具有 public 。
访问权限控制对大多数成员声明能体现实际语义，因此不依赖隐式访问权限，除了以下例外：
省略成员访问权限：友元声明和 static_assert 声明，对此无论何种访问权限都不显式改变语义，因此这些声明应出现在类定义中的第一个 access-specifier 前；
省略基类访问权限：明确的基类继承，如 struct 元函数([Documentation::CommonRules @@3.10]) 继承或混入操作符模板类继承。

@5.13.5.2 访问权限选择策略：
本节的语义包括领域逻辑语义和语言限定的其它语义。
对语义要求公开的接口，特别是体现 LSP（Liskov Substitution Principle ，里氏替换原则）的公开接口继承，使用 public 。
对语义要求非公开的接口，尽可能使用 private ，其次使用 protected ，若存在实现限制则使用友元。
注意数据成员同时体现直接读写访问的接口。若需要不同层次的读写访问权限，应该使用 private 保护数据成员，同时使用访问器(accessor) ，即 getter 和/或 setter 满足不同的需要。
对其它成员，若没有明确限制接口非公开，在能保证访问清晰明确时首先使用 protected 代替 private ，以避免实现可能不必要的间接适配（调用）层次的负担。最小接口([Documentation::CommonRules @@3.1.3]) 在之后的重构时体现。
对实现混入(mixin) 但需要由派生类定制的基类继承，使用 protected 。
对其它体现实现的继承，使用 private 。

@5.13.5.3 非静态数据成员访问权限：
注意显式指定非静态数据成员的访问权限可能影响布局和分配顺序。
ISO C++03 9.2/12 规定不同 asscess-specifier 声明的非静态数据成员所在的地址相对顺序和之间的分配顺序是未指定的，这包括相同的访问权限。
ISO C++11 放宽了语言规则的限制但限制了实现： ISO C++11 9.2/13 规定不同访问权限的非静态数据成员所在的地址相对顺序和之间的分配顺序是未指定的。
此外， ISO C++11 9/7 规定含有不同访问权限的非静态数据成员的类不是标准布局类，因此也不是标准布局类型(@5.2.2) 。

@5.13.6 继承：
尽可能使用组合代替 private 继承，除非需要使用作为基类的特性：
派生类覆盖 private 基类的（纯）虚函数；
using 声明基类的成员；
启用空基类优化。

@5.13.7 虚函数：

@5.13.7.1 覆盖(overriding)：
虚函数可以使用显式的 qualified-id 进行调用以取消动态多态，否则除非在构造函数和析构函数内，虚函数调用最终覆盖版本(final overrider) 。
注意避免函数签名的修饰符差异导致遗漏覆盖。
注意虚函数的覆盖不影响访问权限。
派生类覆盖的虚函数省略 virtual ，同时显式使用 override ，而不依赖基类被覆盖函数提供的 virtual 的隐式覆盖语义。

@5.13.7.2 纯虚函数：
纯虚函数是特殊的虚函数。
没有非虚覆盖版本的纯虚函数导致所在的类是抽象的，无法构造对象。具有虚析构函数，非静态成员函数都是纯虚函数的抽象类，可作为接口类型([Documentation::CommonRules @@2.4.1]) 使用。
注意 C++ 的纯虚函数的定义可选，一般用于提供默认实现。

@5.13.7.3 NVI（Non-Virtual Interface ，非虚接口）模式：
虚函数不一定需要作为公开接口。此时，用 private 或 protected 保护虚函数不被外部访问。
具体选择 private 或 protected 虚函数取决于是否确定需要显式 qualified-id 调用(@5.13.7.1) 影响。其它选择策略参见 @5.13.5.2 。
以调用虚函数的基类的成员函数提供访问时，实现模板方法(template method) 模式。
以友元调用虚函数时，实现虚友元(virtual friend) 模式。

@5.14 模板：
使用类模板和别名模板实现参数多态(parametric polymorphism) 和依赖类型(dependent type) 。
使用其它模板生成泛型代码。

@5.14.1 模板名称：
注意除了成员函数模板外的模板名称具有外部链接。
关于依赖名称，参见 @5.2.4.2 。

@5.14.2 模板的实例化和特化：
注意特化的结果包含实例。
适当使用 ISO C++11 引入的显式实例化声明(extern template declaration) 以节约编译时开销。
注意模板的特化的链接。
注意模板显式实例化、实例化点(point of instantiation) 、显式特化等顺序可能影响程序的语义。另见 ISO C++17 [temp.expl.spec/7].

@5.14.3 模板声明中的关键字使用：
在定义模板类型（非模板）参数时 class 和 typename 等价，但应根据语义适当选择，以提升可读性：
若能确定模板类型参数仅适用于 class 类型（例如内部对此模板参数使用 std::is_class 等的静态断言），使用关键字 class ；否则使用关键字 typename 。
注意模板模板参数时的语法要求，适当使用 template class 。
不使用 export 。此特性在 ISO C++11 中被删除，但 export 关键字仍被保留。由于实现的限制，多数实现无法支持这一 ISO C++03 标准特性。
关于依赖名称的 this 使用，参见 @5.2.4.2 。
关于函数模板，另见 @5.5.6.5 、@5.5.6.8 和 @5.5.6.9 。

@5.14.4 模板参数：
注意 && 模板参数的特殊性。模板实例可能对应左值或右值类型。
另见 @5.2.9.2 。

@5.14.4.1 模板参数替换(substitution) ：
注意模板偏特化使用和函数模板一致的偏序匹配规则。
注意 SFINAE(substitution failure is not an error) 仅对替换的直接上下文(immediate context) 有效。

@5.15 异常：
对异常的基本使用参见 @5.10.5 。

@5.15.1 异常机制和处理器函数(@6.6) ：
抛出异常时引起栈展开(stack unwinding) 按声明逆序销毁自动对象，若存在析构函数则被执行。
栈展开时若重复抛出异常，则调用 std::terminate 。除非必要（通过文档指定行为），应予以避免。

@5.15.2 实现：
注意 C++ 和底层无 C++ 异常机制实现支持的回调代码的隔离。
注意不同实现的运行时之间不保证兼容。
注意特定平台异常机制和 C++ 异常在语言实现层次上的交互。应保证行为可预期。

@5.15.2.1 Windows 结构化异常：
注意扩展关键字和标准关键字的差异。
注意非 C++ 异常捕获的错误可以引起 Windows 结构化异常。

@5.15.2.2 其它非 C++ 异常。
避免捕获非 C++ 语言异常，以保证实现行为可预测且易调试。

@6 标准库：
本章“实现”指 C++ 核心语言和标准库实现。
本章限定适用于标准库用户，但不适用于实现。
基本规则参见 ISO C++ [constraints] 。

@6.1 名称使用：
除非另行指定，本节中引用的标号分别表示 ISO C++03 和 ISO C++11 同时对应且内容一致的章节（若标号相同则只使用一个）。

@6.1.1 命名空间使用：

@6.1.1.1 namespace std ：
按 ISO C++03 17.4.3.1 Reserved names [lib.reserved.names] 和 ISO C++11 17.6.4.2.1 Namespace std [namespace.std] 规定，对全局命名空间 std 的使用受限，仅允许在满足其它条款要求时添加模板的特化。

@6.1.1.2 namespace posix ：
按 ISO C++11 17.6.4.2.2 Namespace posix [namespace.posix] 规定，全局命名空间 posix 及其中的名称保留给实现使用。

@6.1.2 ISO C++ 指定的保留名称：

@6.1.2.1
按 17.4.3.1.1/17.6.4.3.1 Marco Names [lib.extern.names] 规定，可能使用标准库头的用户程序翻译单元不得使用词法上等价于关键字的名称作为宏名。

@6.1.2.2
按 17.4.3.1.2/17.6.4.3.2 Global Names [lib.global.names] 规定，以下名称保留给（核心语言和标准库）实现使用：
包含连续双下划线 "__" 或以下划线 "_" 紧接大写字母起始的名称；
在全局命名空间和 ::std 命名空间内以下划线 "_" 起始的名称。

@6.1.2.3
按 17.4.3.1.3/17.6.4.3.3 External linkage [lib.extern.names] 规定，以下名称保留给（核心语言和标准库）实现使用：
声明在头中，在 std 命名空间或在全局命名空间的具有外部链接的对象名称，例如 <cerrno> 中定义的 errno ；
声明在头中，具有外部链接的全局函数签名；
外部链接的全局命名空间的对象和函数以及 std 命名空间的对象；
具有 extern "C" 或 extern "C++" 链接的包含连续双下划线 "__" 的名称；
C 标准库(Standard C library) 使用的具有 extern "C" 链接，在 std 命名空间或在全局命名空间的名称；
C 标准库(Standard C library) 声明的具有 extern "C" 或 extern "C++" 链接，在全局命名空间的函数签名。

@6.1.2.4
按 17.4.3.1.4/17.6.4.3.4 Types [lib.extern.types] 规定，对 C 标准库的每一个类型名称 T ， ::T 和 std::T 保留给实现使用。

@6.1.2.5
禁止定义宏 override 、final 、carries_dependency 和 noreturn ，参见 ISO C++11 C.2.7 Clause 17: library introduction [diff.cpp03.library] 。

@6.1.3 ISO C 指定的保留名称：

@6.1.3.1 核心语言和兼容性：
ISO C11 6.11 指定的记号不应被声明或作为宏定义。

@6.1.3.2 ISO C 标准库：
ISO C11 7.1.3/1 指定的保留名称被 ISO C++11 覆盖。
按 ISO C11 7.1.3/3 ，不应使用 #undef 保留名称。

@6.1.4 其它保留名称：

@6.1.4.1 C 标准库名称：
除非对应的 C 标准库头未被包含，出现在 ISO C++ Annex C.4 中的 C 标准库名称不应被声明或作为宏定义。
另见 @6.3 。

@6.1.4.2 POSIX 保留符号：
关于 POSIX.1-2004 指定保留的符号对应的名称参见 http://pubs.opengroup.org/onlinepubs/007904975/functions/xsh_chap02_02.html 。
对其中依赖头的保留符号，除非对应的头未被包含，对应的名称不应被声明或作为宏定义。

@6.1.4.3 宏名：
保留标识符不应作为宏名被 #define 指令定义。
不应该使用依赖保留操作符作为宏名被替换的结果（如直接出现在 #if 后）。
在预处理指令中检查宏是否被定义不引入保留名称，所以允许引用保留标识符作为 defined 的操作数。

@6.1.5 成员名称要求：
声明成员名称应注意符合要求(@6.4) 。
若名称源于基类，可通过 public 继承作为公开接口的基类，否则需要显式在派生类中声明类型名以免失效。
若此基类为类模板的实例，而依赖名称(@5.2.4.2) 作为此类模板的参数，注意需重新声明。

@6.2 标准库头：
注意 ISO C 和 ISO C++ 的标准库头不保证一定是文件。
注意标准库头受到 ISO C++ [using.headers] 的约束。
本节“包含”的含义参见 ISO C++11 17.6.5.2/1 ，即被指示为包含的头中的标准库接口的声明和定义保证和包含此头等效。

@6.2.1 由 Synopsis 节显式指定的依赖项：
<algorithm> 、<array> 、<deque> 、<forward_list> 、<list> 、<map> 、<queue> 、<set> 、<stack> 、<random> 、<regex> 、<string> 、<unordered_map> 、<unordered_set> 、<valarray> 、<vector> 、<utility> 包含 <initializer_list> ；
<ios> 包含 <iosfwd> ；
<bitset> 包含 <string> 和 <iosfwd> ；
<iotream> 包含 <ios> 、<streambuf> 、<istream> 、<ostream> 。

@6.2.2 补充指定的依赖项：
ISO C++11 24.6.5/1 指定，除 <iterator> 外，以下标准库头被包含时 24.6.5 的函数模板（即 std::begin 和 std::end ）也可用：
<array> 、<deque> 、<forward_list> 、<list> 、<map> 、<regex> 、<set> 、<string> 、<unordered_map> 、<unordered_set> 和 <vector> 。

@6.3 C 标准库：
注意使用 ISO C 标准库头被 deprecated 。
注意当前标准草案引用 ISO C11 ，包含以下改动：
有意不包括 <stdatomic.h> 、<stdnoreturn.h> 和 <threads.h> ，即不这些头不保证由实现提供；
使用 ISO C++ 标准库头 <ccomplex> 、<cstdalign> 、<cstdbool> 或 <ctgmath> 被 deprecated ，参见 [WG21 N4606] （提案参见 [WG21 P0063R3] ）。
由 @5.1.6 ，不应这些标准库头。对存在对应 ISO C++ 标准库头替代的，可以使用这些头。注意对应的 ISO C++ 标准库头被指定为等效于包含 ISO C 标准库头，但实现不一定需要以包含实际实现。
注意命名空间。

@6.3.1 资源管理：
除非必要，不使用 realloc 。
注意 ISO C 标准库关于内存分配的设计遵循无隐式动态分配（如使用 malloc ）规则(no-implicit-malloc rule) ，而 POSIX 和其它实现忽略，参见 [WG14 N1066] 。

@6.3.2 信号处理：
核心语言特性相关的基本限制参见 @5.1.11.4 。

@6.3.2.1 信号：
ISO C 仅要求实现有限的信号，即 SIGABRT 、SIGFPE 、SIGILL 、SIGINT 、SIGSEGV 和 SIGTERM 。
ISO C++ 没有扩充要求实现支持的信号。除非必要，只使用这些信号。 POSIX 和 SUS 提供若干扩展，优先于具体平台扩展选用。
注意存在无法被捕获或忽略的信号。

@6.3.2.2 signal 函数：
ISO C11 规定多线程环境下调用 signal 函数具有未定义行为， ISO C++ 无此限制。 POSIX.1-2004 规定多线程的进程中使用 signal 函数未指定。
signal 函数的行为很大程度依赖实现，可能在同一个系统的不同版本（如 Linux ）中具有不同行为。若需可移植性应避免使用。对符合 POSIX 的平台可以使用 sigaction 代替。

@6.3.2.3 C++ 互操作性：
ISO C++ 要求信号处理器(signal handler) 具有 C 语言链接。注意 lambda 表达式转换的函数指针不符合此要求(@5.2.12.1) ，禁止在此使用。
ISO C++ 指定和 C 特性兼容的 POF 以及可以用于信号处理器，此外由实现定义。此处实现定义可能不明确，通过调用不需要具有 C 语言链接或仅使用兼容 C 特性的函数变通。
ISO C++11 显式允许信号处理器使用原子操作。 WG21 N3910 进一步明确这些操作的外延。
禁止在信号处理器中抛出异常。 ISO C++ 特别指出在信号处理器中抛出异常很可能有问题。实际实现支持不同，如 Microsoft Windows 上的 Microsoft VC++ 可以支持而 Linux 上的 G++ 未能完全支持此特性。

@6.3.3 断言(assertion) ：
注意断言失败时非正常终止程序(@5.2.6) 。断言失败时可以捕获所有异常以避免对运行时行为的干扰。
注意标准库头 <assert.h> 和 <cassert> 可多次被重复包含，使用 NDEBUG 宏控制启用或禁用断言，参见 ISO C++11 17.6.2.2/2 。
跨翻译单元实例化的模板中使用断言时必须确保不同翻译单元同时启用或禁用断言，以避免违反 ODR(@5.1.8) 。
和静态断言不同，断言不保证翻译时。尽可能使用静态断言代替断言。

@6.3.4 终止程序的函数：
注意 std::exit 、std::quick_exit 和 std::_Exit 的参数的含义。特别地，这些值在不同平台中实现定义的值可能不同。
注意 std::abort 非正常终止程序(@5.2.6) 。
注意 std::atexit 和 std::at_quick_exit 的最小实现限制，除非必要避免使用。
注意 std::quick_exit 执行时不得引发信号，否则行为未定义。
在无法保证异步安全([Documentation::CommonRules @@3.11.2])的多线程环境中一般无法直接使用 std::atexit 和 std::at_quick_exit 可靠地执行任意清理。
注意 atexit 可能被实现（如 libgcc ）用于清理，如调用析构函数。因此，在无法保证异步安全([Documentation::CommonRules @@3.11.2])的多线程环境中应避免直接使用 std::exit 。
同理，需要避免 std::at_quick_exit 注册的回调引起不适当的状态才可在这些环境使用 std::quick_exit 。

@6.4 要求(requirements) ：
基本内容参见 ISO C++11 [requirements] 。
除非另行指定，使用 ISO C++11 [utility.requirements] 中的约定指定对类型的要求。

@6.5 可替换实现的接口：
全局函数 operator new 、operator new[] 、operator delete 和 operator delete[] 可替换定义。
注意这些函数不能以 inline 修饰，实现可不给出违反此规则的诊断(@5.1.8) 。
注意 ISO C++11 起基本的抛出异常形式的全局 operator new 和全局 operator delete 提供了其它可替换函数的基本功能实现。若替换其中的函数，其它函数的行为也可被影响。
注意 ISO C++11 起允许全局 operator new 抛出 std::bad_alloc 以外的异常。

@6.6 处理器函数(handler fucntion) ：
处理器函数是 std 命名空间中以 set_* 和 get_* 为名的函数，提供基本一些例程，和整个标准库的状态相关。
ISO C++11 规定调用这些函数不引起数据竞争。

@6.7 共享对象和线程安全性：
注意在不同线程间使用可引入数据竞争的标准库函数的程序行为未定义。
标准库定义的类类型的对象的构造函数调用完成应发生在任何成员函数调用之前。

@6.8 类型特征(type traits) ：
类型特征于 ISO C++ TR1 和 ISO C++11 中引入，属于元编程设施。
合理使用类型特征进行关系判断，如 is_same 判断类型相同。
合理使用类型特征进行类型操作，如 std::add_lvalue_reference 可避免泛型代码中出现非法的 void& 。

@6.9 存储管理：

@6.9.1 分配器(allocator) ：
使用分配器替换需要适配不同分配策略的接口。
除非必要且可确保符合设计要求，不使用 std::allocator 代替 new 表达式。

@6.9.1.1 使用分配器的构造(uses-allocator construction) ：
涉及特定的分配器的操作需构造值时，构造类类型的值可使用分配器：在初始化时提供分配器参数。
被提供分配器的构造应提供支持分配器参数的 public 构造函数或函数模版，以避免构造不合式。
使用分配器的构造应明确区分两类情形：类类型启用（在这个类中只有明确的一个类型的）固定类型的分配器和不保证支持固定类型的分配器。
若为前者，应在被构造的类中声明 public 的成员类型名 allocator_type 指称在构造器中的分配器类型；
否则，对被构造的类中特化 std::uses_allocator 类模板使其 public 继承 std::true_type 。
前者可在支持时自动启用分配器，适合配合 allocator-aware 的容器类型(@6.12) 嵌套初始化；而擦除类型（无固定类型分配器）只能使用后者。
尽管标准支持特化 std::uses_allocator 时同时指定 allocator_type ，为避免混乱，保证两种情形不相交。
注意以 std::uses_allocator 确定使用分配器需要支持的重载具有顺序：优先使用 std::allocator_arg_t 指定的重载。
若使用带分配器参数的重载：
对前者，和标准库容器类似，仅在无法在参数列表附加末尾分配器参数时使用 std::allocator_arg_t ，并保证无分配器参数的重载版本都有对应带分配器的重载版本；
否则，若需要使用带分配器参数的重载，统一使用 std::allocator_arg_t 指定，且不提供可确保不需要分配器的重载版本的对应的带分配器参数的重载。
除非必要（如符合 ISO C++ 标准库接口的设计），使用固定类型分配器的构造函数中，直接使用分配器类型以避免无法复制省略(@5.13.4.3) 的开销。（实际也还可能会有影响其它优化的冗余开销。）

@6.9.1.2 分配器的传播(popagation) ：
分配器在复制、赋值和交换操作中可能受到限制。
特别地，作为 allocator-aware 容器(@6.12) 的分配器，可在这些操作中创建和使用不用的分配器对象：
分配器的成员函数 select_on_container_copy_construction 可在复制使用不同的分配器对象；
std::allocator_traits 特征的成员决定是否在复制和转移时传播的分配器。
分配器对象之间的相等性决定分配器可兼容其它分配器对象分配的资源。
使用不相等的分配器，在复制和转移容器对象时可复制其中的元素，引起非预期开销。
注意交换操作要求分配器相等，否则行为未定义。

@6.9.2 智能指针(smart pointer) ：
智能指针于 ISO C++ TR1 和 ISO C++11 中引入，用于管理资源，易于保证异常安全性(@5.10.5.3) 。
在转移语义(@5.2.9.1) 的支持下， C++11 引入 std::unique_ptr 取代 C++98/03 的 std::auto_ptr ，避免后者无法直接区分复制和转移操作、无法作为要求复制的模板参数（如某些容器元素）等局限。
仅当需要共享资源时使用 shared_ptr ，否则尽可能使用 unique_ptr 。
使用智能指针作为参数时的一般规则参见 http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ ，但 unique_ptr 除外，另见 @5.12.2.4 。
注意 std::unique_ptr 是类类型，在一些二进制规范如 Itanium ABI 中因不能直接使用寄存器传递参数，在没有被优化的的公开接口中可能会导致相对内建指针的额外的开销，但除互操作外应忽略此差异。

@6.9.2.1 元素类型：
注意 std::unique_ptr 的析构要求元素是完整的对象类型，而 std::shared_ptr 允许直接使用不完整类型（包括 void ）。

@6.9.2.2 删除器(deleter) ：
自定义删除器可声明 pointer 嵌套类型成员指定删除的指针类型。
可使用和分配器(@6.9.1) 配对的删除器，配合智能指针使用。
注意默认删除器直接 delete ，不应混合 std::allocator 使用。

@6.9.2.3 助手函数模板：
特定情形使用 make_* 或用户自定义的类似助手模板创建智能指针：
	使用 std::make_shared 减少分离的内存分配。：
		注意使用 std::weak_ptr 指向共享对象时同时分配的对象内存可能无法及时释放。
		注意涉及动态删除器可能会因为 RTTI 使二进制文件体积增大。
	使用 std::make_shared 和 ISO C++14 引入的 std::make_unique 或其它类似的用户自定义接口而不是直接使用可能抛出异常的无序的(@5.8.5) 的 new 保证异常安全(@5.10.5.3) 。
		若没有 std::make_unique ，自行实现。参见 http://herbsutter.com/gotw/_102/ 。
	注意 std::make_shared 和 std::make_unique 值初始化被指向的对象。若需要其它形式的初始化（如默认初始化或列表初始化），可使用自定义的类似接口。
	若创建 std::unique_ptr 需要自定义删除器（如使用分配器(@6.9.2.2) ），无法使用 std::make_unique ，使用其它用户定义的类似接口或显式初始化 std::unique_ptr 代替。
仅当初始化智能指针不引起分配（如直接使用现有具有所有权的指针值初始化智能指针），或引起的单一分配副作用的顺序确定时，允许直接使用来修改智能指针对象（包括但不限于作为赋值的操作数以及 reset 成员函数的参数）。
创建对象满足上述条件的时，以下情形优先直接使用 new 表达式作为操作数而不是助手函数模板，以在保证代码不冗余时减少额外的对象创建和函数返回，便于调试：
	不需要类似 std::make_shared 的分配行为，用于直接初始化指向非数组类型的智能指针对象，但 ctor-initializer 以外初始化指向数组类型的智能指针，能避免重复指定类型名时除外；
	不需要分配器扩展性时（使用 new 表达式而不是 std::allocator 的删除器配合智能指针，另见 @6.9.1 ）；
	赋值至智能指针时，优先使用被赋值的智能指针的 reset 成员（使用 new 表达式作为参数）代替。

@6.10 可调用类型、调用包装和函数对象：
注意可调用类型(callable type) 的外延。另见 [WG21 N1673] 。
注意调用包装类型(call wrapper type) 和调用包装(call wrapper) 的作用。
除非必要，不访问调用包装的目标对象(target object) 。
传递调用包装(forwarding call wrapper) 使用引用传递参数且需要保证值类别，一般使用通用引用(@5.2.9.2) 传递参数。
简单调用包装(simple call wrapper) 应满足 CopyConstructible 和 CopyAssignable 要求且复制、转移和赋值不抛出异常。

@6.10.1 引用包装(reference wrapper) ：
使用引用包装类型以要求按值调用(@5.12.2.2) 的接口上使用按引用调用(@5.12.2.2) 的语义。

@6.10.2 成员指针调用：
在泛型代码中使用 ystdex::invoke 模板代替直接函数调用以支持成员指针，减少不必要的 std::mem_fn 、std::bind 或仅用于转发成员访问的 lambda 表达式的使用。另见 @6.14 。
传递可调用类型的参数时，若不需要直接修改可调用包装自身的状态或避免复制开销，直接按值传递(@5.12.2) 以满足左值可调用(Lvalue-callable) 性质，减少冗余重复代码。

@6.10.3 标准库中的可调用包装类型：
注意 std::bind 结果类型未指定。
注意 std::bind 和 boost::bind 等对嵌套 bind 表达式的语义不同。
作为通用的实现方式，尽可能使用 ystdex::invoke 及依赖其语义的 ystdex::invode_or_value 等替代使用 std::bind 和 std::mem_fn 的表达式。
其它情况下，作为较高层次的抽象，尽可能使用 std::bind 代替 std::mem_fn 和 lambda 表达式的使用。
注意 std::function 不保证目标对象的开销，但传递参数时若不需依赖内部状态，仍按复制语义直接传递值；用户代码应使用合适的方式（如引用包装类型(6.10.1) ）避免不可预料的复制开销。

@6.11 文本和字符串：
明确作为 C 风格字符串的 NTCTS （空字符结尾的字符串）的含义，注意和 C 标准库接口的兼容性。
另见 @5.1.4 。

@6.11.1 类模板 std::char_traits ：
注意 char_traits 对模板参数的要求。
对字符串批量操作，除非有更具体的成员函数，优先使用 char_traits 的操作。

@6.11.2 类模板 std::basic_string ：
注意 ISO C++11 起禁止使用引用计数实现。
一些实现因为 ABI 兼容问题可能保留旧实现，此时需要变通。如 libstdc++ 5 之前的版本，必要时适当使用 __gnu_cxx::__versa_string 代替，但注意不适用于 std::stringstream 等接口。
注意 ISO C++03 之前 c_str 和 data 的语义差异，在 ISO C++11 中两者等价；注意两者和 operator[] 语义的不同。
当前需要访问 std::basic_string 实例对象 s 中的元素时，仍然依序保持以下兼容性较好、更明确的使用规则：
直接访问元素时，用 s[0] 的形式；
访问需要修改的或非临时的存储，或在模板中和 std::basic_string 以外（不一定是字符串的一般序列）类型兼容时，用 &s[0] 或成员/非成员 begin/end 取迭代器的形式；
对需要另行提供长度的，用 s.data() 的形式；
对不需要另行提供长度的，用 s.c_str() 的形式。

@6.11.3 类型 std::string ：
注意 std::basic_string 可以有不同的分配器。
std::string 使用默认模板参数，被异常类等显式依赖，应明确和其它类似类型区分。

@6.12 容器：
注意容器对元素（值类型 value_type ）的要求。
对 allocator-aware 容器，注意分配器要求，如：
元素和分配器分配的值类型一致，是不具有 cv 修饰符的对象类型；
提供非静态成员函数 get_allocator 取分配器。
注意异常安全。保证无异常抛出的成员函数不一定显式使用 noexcept ，参见 @5.10.5.6.1 。
注意容器转移后为有效但未指定状态(@5.2.9.1) 而不保证为空。若需要空容器，先调用 clear() 清空。
替换容器优先使用赋值操作。
注意若不保证转移的值得类型具有无异常抛出的异常规范(@5.10.5.6) ，可能无法转移值（参见 std::move_if_noexcept ）。
注意转移容器的值时若不保证无异常抛出，或操作先清空容器后添加值，应注意可能不保证强异常安全(@5.10.5.3.2) 。
若可能，使用 empty 代替 size 。
若可能，对容器值类型外的参数，使用 emplace 或 emplace_back 等代替 insert 或 push_back 等。
关于迭代器使用参见 @6.13 。
注意容器适配器不要求有迭代器。
另见 @6.1.5 。

@6.13 迭代器：
注意迭代器类别(iterator category) 。
注意 std::iterator 已被现行草案 WG21 N4606 标记为 deprecated 。
除非依赖内部状态，迭代器一般按值传递(@5.12.2.2) 。
另见 @6.1.5 。

@6.13.1 迭代器要求：
注意迭代器要求。
注意 ISO C++ 未完全定义所有相关概念，如 [LWG 2035, LWG 2038] ，应在文档中避免这些概念以及不清晰的表述。
注意 ISO C++ 放宽了原始 SGI 迭代器的部分要求，如随机访问迭代器的 + 和 += 操作的范围检查。
考虑 @5.2.12.2 ，如果泛型算法接口中未明确避免指针（以及类似具有检查要求的迭代器）作为实例，应假定这些附加要求存在。

@6.13.2 范围：
迭代器对表示范围，可能来自满足特定要求的具体的类，如容器(@6.12) 。另见 5.3.2.1 。
若可使用常量迭代器成员，则优先使用（即 cbegin 、cend 、crbegin 和 crend 分别优先于 begin 、end 、rbegin 和 rend ）。
注意和范围匹配的迭代器对的元素类型可能相同或不同，其中当前标准库容器和算法支持的 API 中总是相同，但未来可能会改变。

@6.13.2.1 类型表示：
当符合其它要求时，尽可能使用 auto 等类型占位符或类型推断规则(@5.7.6) ，而不是直接使用类型名，以避免不必要的调整硬编码的类型名的需要。
若（因为特性限制等原因）不使用参数化类型表示容器解引用的值的类型且不适用其它理由分辨（类型都符合其它要求），优先使用序列起始迭代器。
对容器类非成员或成员访问，如以下优先顺序：
decltype(*cbegin(c)) 或 decltype(*crbegin(c)) ；
decltype(*cend(c)) 或 decltype(*crend(c)) 。
对容器类成员访问，如以下优先顺序：
decltype(*c.begin()) 或 decltype(*c.rbegin()) ；
decltype(*c.end()) 或 decltype(*c.rend()) 。
对算法，若类型相同，一般名称 first 表示的迭代器优先于 last 。
这些规则使修改范围起始和结束迭代器使之类型不同时，较不易出现误用；同时，也容易使指定不完整范围（使用的起始迭代器较结束迭代器多的情形）的算法风格保持一致。

@6.14 算法：
注意部分的算法复杂度和类型满足的要求相关。
关于迭代器使用参见 @6.13 。
注意当前标准库算法不支持 invoke 调用，对成员指针需要使用进一步的函数对象包装，参见 @6.10 。

@6.15 C++ 标准 I/O
选择 C++ 标准流或 C 标准流的操作或标准库对象由具体的程序按需决定；除非有充足的理由，库不对此进行假设。
可以同时使用 C++ 标准流和 C 标准流（ printf/scanf 函数族）进行格式化输入/输出处理。但在考虑目标文件大小及其附加性能开销时，一般避免使用 C++ 标准流。
在同一个程序中，仅在能保证同步的前提下，允许混用 C++ 标准流对象（ std::cout 等）和 C 标准流对象（由 stdout 等指定）的 I/O 操作。
应注意实现 C++ 标准库流对象惯用的 nifty counter idiom(http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Nifty_Counter) 对多翻译单元程序大小的影响。
应注意正确使用 printf/scanf 函数族格式化输入输出的控制字符，避免格式不匹配造成未定义行为（如 %p 应严格对应 void* ）。

*/
////

