/*
	© 2012-2023 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file NPL.txt
\ingroup Documentation
\brief NPL 规范和实现规格说明。
\version r34398
\author FrankHB <frankhb1989@gmail.com>
\since build 304
\par 创建时间:
	2012-04-25 10:34:20 +0800
\par 修改时间:
	2023-03-21 01:00 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::NPL
*/


/*

@0 前言(Foreword) ：
本文档适用于 NPL(@1.3) 及实现 。

@0.1 体例说明：
引用和标签标记参见 [Documentation::CommonRules @@0.1] 。
项目范围参见 [Documentation::ProjectRules @@1] 。
编码细节和其它规范参见 [Documentation::Designation] 。
本文档指定的语言规则(language rule) 中的形式文法(formal grammar) 包括形式语法(formal syntax) 和特定操作的形式，不提供附加的形式语义(formal semantic) 。
形式语法的语法类别(syntax category) 以 BNF(https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F) 推导规则表示。
C++ API 中仅列出在命名空间作用域需被归类的及其它和其它设计直接关联而被引用的部分。这些 API 的具体描述和其它 API 详见接口文档（可通过 Doxygen 源代码注释生成）。
对象语言接口的补充体例说明参见接口文法约定(@9.2) 和库接口约定(@10.3) 。

@1 绪论(Introduction) ：

@1.1 正式引用(Normative references) ：
以下 @1.1.1 的简写引用的来源同 [Documentation::CommonRules @@1.1] 。
以下作为概念定义参考的文档的来源同 [Documentation::CommonRules @@1.1] ：
— ISO/IEC 2382 (all parts), Information technology — Vocabulary
以下其它文档或在线来源也在本文中引用：
— Revised Report on the Algorithmic Language Scheme ([RnRS])
	http://www.scheme-reports.org/
	当前 [RnRS] 已出版多个版本。
	Revised^5 Report on the Algorithmic Language Scheme ([R5RS])
		https://schemers.org/Documents/Standards/R5RS/r5rs.pdf
	Revised^6 Report on the Algorithmic Language Scheme ([R6RS])
		http://www.r6rs.org/final/r6rs.pdf ([R6RS])
	Revised^6 Report on the Algorithmic Language Scheme -Rationale- ([R6RS-Rationale])
		http://www.r6rs.org/final/r6rs-rationale.pdf
	Revised^7 Report on the Algorithmic Language Scheme ([R7RS])
		https://small.r7rs.org/attachment/r7rs.pdf
— Fexprs as the basis of Lisp function application; or, $vau : the ultimate abstraction ([Shu10])
	https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf
— Revised Report on the Kernel Programming Language ([RnRK])
	https://web.cs.wpi.edu/~jshutt/kernel.html
	Revised^-1 Report on the Kernel Programming Language ([Shu09])
		ftp://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf
	当前 [RnRK] 只有 n = -1 的版本。引用确切版本时，同 [Shu10] 中的用法，使用 [Shu09] 标记；但引用时一般同样不涉及其版本差异。
— Racket Documentation ([Racket])
	https://docs.racket-lang.org/
	不定期更新。
— Scheme Requests for Implementation
	https://srfi.schemers.org/
	汇总多个对 [RnRS] 的修订提案。
— Representing Control in the Presence of First-Class Continuation ([Hi90])
	https://legacy.cs.indiana.edu/~dyb/pubs/stack.pdf
— Representing Control in the Presence of One-Shot Continuations ([Br96])
	https://legacy.cs.indiana.edu/~dyb/pubs/call1cc.pdf
— IEC 60559, Standard for floating-point arithmetic
— ECMA-262 ([ECMAScript])
	https://262.ecma-international.org/
	已出版多个版本。
以上已出版多个版本或不定期更新的文献在引用时不涉及不同版本的具体差异。
其它文中局部使用的文献暂不在此列出。

@1.1.1 引用简写：
以下引用简写同 [Documentation::CommonRules @@1.1.1] 。
ISO C
ISO C++
ISO C++11
ISO C++14
以下简写使用上述正式引用：
SRFI ：Scheme Requests for Implementation 。

@1.2 术语：
本文档中没有另行指定定义的基本概念使用参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html 。
描述中可能涉及上下文相关的略称参见 @1.2.5 。

@1.2.1 通用领域：
关于“语言”补充的基本概念和约定，使用元语言语法 <相关范畴/上下文> 。
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E9%80%9A%E7%94%A8%E9%A2%86%E5%9F%9F 。

@1.2.1.1 [<自指><名词>] ：
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E8%87%AA%E6%8C%87 。

@1.2.1.2 [<非自指>] ：
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E9%9D%9E%E8%87%AA%E6%8C%87 。

@1.2.2 [<计算机科学>] ：
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6 。

@1.2.3 [<规范>] ：
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E8%A7%84%E8%8C%83 。

@1.2.4 [<程序设计语言>] ：
包含 <NPL> 。
参见 https://frankhb.github.io/YSLib-book/Terminology.zh-CN.html#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80 。

@1.2.5 略称：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%95%A5%E7%A7%B0 。

@1.3 需求概述：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0 。

@1.4 其它设计和实现参考：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83 。

@1.5 领域设计原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99 。

@1.5.1 本体论：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%AC%E4%BD%93%E8%AE%BA 。

@1.5.1.1 正规性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%AD%A3%E8%A7%84%E6%80%A7 。

@1.5.1.2 存在性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%98%E5%9C%A8%E6%80%A7 。

@1.5.1.3 名实问题：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%8D%E5%AE%9E%E9%97%AE%E9%A2%98 。

@1.5.2 价值观：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BB%B7%E5%80%BC%E8%A7%82 。

@1.5.2.1 变化的自由：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%98%E5%8C%96%E7%9A%84%E8%87%AA%E7%94%B1 。

@1.5.2.2 避免不必要付出的代价：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E4%BB%98%E5%87%BA%E7%9A%84%E4%BB%A3%E4%BB%B7 。

@1.5.2.3 最小接口原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99 。
另见 [Documentation::CommonRules @@3.1.3] 。

@1.5.2.4 关注点分离原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99 。

@1.5.3 形而上学：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6 。

@1.5.3.1 正确性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7 。

@1.5.3.1.1 完整性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%8C%E6%95%B4%E6%80%A7 。

@1.5.3.1.2 一致性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E8%87%B4%E6%80%A7 。

@1.5.3.2 简单性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%80%A7 。

@1.5.3.3 可修改性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%80%A7 。

@1.5.3.4 避免抽象泄漏：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E6%8A%BD%E8%B1%A1%E6%B3%84%E6%BC%8F 。

@1.5.3.5 关注资源限制：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B3%E6%B3%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6 。

@1.5.3.6 开放性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%80%E6%94%BE%E6%80%A7 。

@1.5.4 结构和依赖原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%93%E6%9E%84%E5%92%8C%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99 。

@1.5.4.1 接口设计和实现分离：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB 。

@1.5.4.2 最小特权原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E7%89%B9%E6%9D%83%E5%8E%9F%E5%88%99 。

@1.5.4.3 最小依赖原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99 。

@1.5.4.3.1 单一模块依赖倒置原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8D%95%E4%B8%80%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99 。

@1.5.4.4 可复用性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7 。

@1.5.4.5 可组合性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7 。

@1.5.5 接口设计性质和原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%80%A7%E8%B4%A8%E5%92%8C%E5%8E%9F%E5%88%99 。

@1.5.5.1 统一性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%9F%E4%B8%80%E6%80%A7 。

@1.5.5.2 适用性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E6%80%A7 。

@1.5.5.2.1 易预测性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%98%93%E9%A2%84%E6%B5%8B%E6%80%A7 。

@1.5.5.2.2 可用性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E7%94%A8%E6%80%A7 。

@1.5.5.3 最小惊奇原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%80%E5%B0%8F%E6%83%8A%E5%A5%87%E5%8E%9F%E5%88%99 。

@1.5.5.4 正交性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%AD%A3%E4%BA%A4%E6%80%A7 。

@1.5.6 方法论：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%96%B9%E6%B3%95%E8%AE%BA 。

@1.5.6.1 避免不成熟的优化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%81%BF%E5%85%8D%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E4%BC%98%E5%8C%96 。

@1.5.6.2 封装：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B0%81%E8%A3%85 。

@1.5.6.3 信息隐藏：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8Finformation-hiding- 。

@1.5.6.4 模块化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E5%8C%96 。

@1.5.7 其它推论和比较：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%8E%A8%E8%AE%BA%E5%92%8C%E6%AF%94%E8%BE%83 。

@2 整体设计：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1 。

@2.1 基本原理、表达形式和抽象：

@2.1.1 模型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A8%A1%E5%9E%8B 。

@2.1.1.1 资源可用性基本约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%8F%AF%E7%94%A8%E6%80%A7%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A 。

@2.1.2 适用领域：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%80%82%E7%94%A8%E9%A2%86%E5%9F%9F 。

@2.2 理论背景、工具和依据：
基本内容参见 [Documentation::CommonRules @@2.1] 。

@2.2.1 组织概念模型：
略。

@2.2.2 设计意义：
参见 [Documentation::Designation @@2.2] 。

@2.2.3 形式语义方法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E6%96%B9%E6%B3%95 。

@2.2.4 程序实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0 。

@2.2.5 构建原则：
基本内容参见 [Documentation::CommonRules @@2.2] 。
其它参见 [Documentation::Designation @@1.2] 。

@2.3 NPL 规范模型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B 。

@2.3.1 实现的执行阶段：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5 。

@2.3.2 并发实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0 。

@2.3.3 阶段不变量约束：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%8F%98%E9%87%8F%E7%BA%A6%E6%9D%9F 。

@2.4 正确性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%AD%A3%E7%A1%AE%E6%80%A7 。

@2.4.1 翻译时正确性规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BF%BB%E8%AF%91%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%A7%84%E5%88%99 。

@2.4.2 错误：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF 。

@2.5 实现行为：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E8%A1%8C%E4%B8%BA 。

@2.6 简单实现模型约定：

@2.6.1 嵌入宿主语言实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B5%8C%E5%85%A5%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0 。

@3 基本文法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95 。

@3.1 基本文法概念：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E6%96%87%E6%B3%95%E6%A6%82%E5%BF%B5 。

@3.2 字符集和字符串：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2 。

@3.3 词法规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99 。

@3.3.1 基本词法构造：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%8D%E6%B3%95%E6%9E%84%E9%80%A0 。

@3.3.2 转义序列和字符序列：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%E5%92%8C%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97 。

@3.3.3 字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%97%E9%9D%A2%E9%87%8F 。

@3.3.4 分隔符：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%88%86%E9%9A%94%E7%AC%A6 。

@3.3.5 词法分析：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90 。

@3.4 语法 ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95 。

@3.4.1 基本语法构造：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%9E%84%E9%80%A0 。

@3.4.2 表达式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F 。

@3.4.2.1 原子表达式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F 。

@3.4.2.2 复合表达式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F 。

@3.4.2.3 列表表达式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%88%97%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F 。

@3.4.3 语法形式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F 。

@3.4.4 语句：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%AD%E5%8F%A5 。

@3.4.5 简单文法约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A 。

@4 NPL 公共语义：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npl-%E5%85%AC%E5%85%B1%E8%AF%AD%E4%B9%89 。

@4.1 基本语义概念：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E4%B9%89%E6%A6%82%E5%BF%B5 。

@4.1.1 表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A1%A8%E7%A4%BA 。

@4.1.2 演绎规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%BC%94%E7%BB%8E%E8%A7%84%E5%88%99 。

@4.1.3 状态和行为：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA 。

@4.1.4 作用使用原则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99 。

@4.2 实体语义：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E8%AF%AD%E4%B9%89 。

@4.2.1 实体的等价性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AD%89%E4%BB%B7%E8%B0%93%E8%AF%8D 。

@4.2.1.1 实体的同一性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7 。

@4.2.1.2 实体的不可变性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7 。

@4.2.2 实体数据结构：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84 。

@4.2.3 续延：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6 。

@4.2.4 一等实体和一等对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AE%9E%E4%BD%93%E5%92%8C%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1 。

@4.2.4.1 一等对象的同一性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E4%B8%80%E6%80%A7 。

@4.2.4.2 可变状态和普遍性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E5%92%8C%E6%99%AE%E9%81%8D%E6%80%A7 。
**原理**
普遍的一等实体支持使一等实体的访问不依赖非一等的实体而避免一些问题(@4.2.6.5) 。

@4.2.4.3 Kernel 中的一等对象：
**原理**
尽管没有显式指出一等实体和一等对象的区别，在 [RnRK] 中的一等对象和此处的一等实体在目的上一致。因为 Kernel 不直接支持区分对象同一性，一等实体退化为一等对象。
并不需要修改一等对象的判定准则(@4.1) 限定为后者并使前者依赖后者的定义，因为作为抽象，前者通常并非是后者的操作上进行限制得到（正相反，一般是通过补充约定假设得到，如 @4.1 的定义）。
类似的一个例子是不可修改对象(nonmodifiable object) 可以但不必要是对应的可修改对象(modifiable object) 的子类型(@4.7.7) 。
作为 @1.5.5.1 的实例，一等实体避免特殊规则，和 [RnRK] 设计原则 G1a 一致。

@4.2.5 同一性关联扩展性质：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%8C%E4%B8%80%E6%80%A7%E5%85%B3%E8%81%94%E6%89%A9%E5%B1%95%E6%80%A7%E8%B4%A8 。

@4.2.5.1 一等状态：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E7%8A%B6%E6%80%81 。

@4.2.5.2 一等作用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E4%BD%9C%E7%94%A8 。

@4.2.5.3 所有权抽象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%89%80%E6%9C%89%E6%9D%83%E6%8A%BD%E8%B1%A1 。
基本规则参见 [Documentaion::CommonRules @@1.2.4] 。

@4.2.6 一等引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E7%AD%89%E5%BC%95%E7%94%A8 。

@4.2.6.1 设计复杂性问题：
要求一等对象都是引用的设计无法回避几个基本的设计问题：
同时引入引用和被引入对象与仅要求（可能被引用的）对象相比，仅作为某个基本语言子集的设计上即显然更复杂，违反简单性原则(@1.5.3.2) ；
在形式模型(@2.1.1) 意义上，这种设计不支持不提供引用但仍能表达上述足够有意义的计算的子集，这违反最小接口原则(@1.5.2.3) 。

@4.2.6.2 可扩展问题：
在形式模型(@2.1.1) 以外，使用以基本语言子集扩展特性得到派生语言的方式，也无法避免不在对象语言中使用非引用的设计满足通用可编程需求，而产生其它复杂性及可行性问题。
特别地，这导致难以在基础语言的基础上复用和扩充语义规则派生其它语言。
考虑设计和实现整体，要求一等对象都是引用，在简单性(@1.5.3.2) 上是一个过早的优化(@1.5.6.1) ，它限制了一些整体较简单的实用的试图把和同一性(@4.1) 关联的性质附加到对象上的设计。
使用这种关联性质的扩展参见同一性关联扩展性质(@4.2.5) 的讨论。另见可变对象问题(@4.2.6.5) 中的例子。

@4.2.6.3 对象语义问题：
单一类型(@4.7) 的普遍引用存在替代被引用的一等对象，容易和一等对象设计的语义冲突。
和不要求仅通过引用而直接提供一等对象的设计相比，消除这些冲突的设计普遍更复杂且难以裁剪，违反简单性原则(@1.5.3.2) 和最小接口原则(@1.5.2.3) 。
而除了放弃要求一等对象都是引用以外的减小设计复杂性的方式，即便只作为核心语言（待扩充特性的基本语言子集），也会显著减小实现普遍需求的抽象（如资源所有权语义(@4.2.5.3) ）的表达能力。
仅对设计被扩充的核心语言而言，放弃一等对象都是引用，允许被引用对象作为一等对象（即便不普遍）而非作为扩充规则的修补仍然更合适。

@4.2.6.3.1 一般的对象属性(@4.2.1.1) ：
非一等的对象抽象实质上利用的仅仅是对“对象”的普遍预期操作的一个较小的子集，显著削弱了一等对象描述（不一定和对象的值直接关联的）附加状态的抽象能力：
仅通过引用访问的一等对象无法被预期是否具有存储以及基于存储的属性如大小(size) ；对生存期和所有权的确定也直接在形式上（而不只是实现上）依赖附加在对象以外的元数据(metadata) ，而无法利用蕴含在被访问的对象内部的状态。
这意味一旦需要这些附加属性时，提供的额外的操作依赖附加的定义。
这同时要求设计中假定普遍存在的作为间接抽象的引用和这些附加定义（直至扩充到被引用对象满足一等对象具有的操作），使语言的设计更复杂。
即使总是使用对象的引用间接访问这些属性，也需要依赖对象自身。
因此若设计不提供这些接口，实现仍然需要负担开销。尽管不提供接口可能容易优化实现，激进的优化和扩展语言特性很大程度上是矛盾的。

@4.2.6.3.2 对一等状态(@4.2.5.1) 的支持：
在具有引用的情况下，区分不同的副作用的实质由被引用对象引起，而并非引用的性质；要求一等对象都是引用并不简化派生实现添加不同一等状态的支持，反而引入了无法回避的复杂性。
单一类型的引用和以上最简单的值类别(@4.2.5.1) 的设计兼容，只要把引用关联到左值，非引用关联到右值即可；但这种设计和要求一等对象都是引用矛盾，因为后者使这里的右值不再是一等对象。
若特定的对象访问操作都通过引用进行，这些操作中需要的状态可直接使用引用提供；这是一种保守的设计优化，不保证可替代任意的对象属性(@4.2.1.1) 及基于这些性质的其它操作。

@4.2.6.3.3 对所有权的支持：
实体的所有权(@4.2.5.3) 无法通过单一类型的引用直接被区分。
引入非全局的所有权不依赖一等对象都是引用的设计。
与直接使用带有所有权的对象的设计比较，通过引用保持对象的所有权引入不必要的复杂性。若保证引用确定所有者，则：
需要单一的全局所有者(@4.2.5.3) ，或；
引用总是需要带有指示所有者的元数据（例如，在对象的引用的内部实现总是隐含对对象的所有者的引用），一般情形这无法由实现或者用户总是保证等效地移除，违反 @1.5.2.2 。
因为存在以上的已知问题，一般的引用不保证对象的所有权。
需保证所有权以实现资源管理等目的的特定的引用可在实现内部提供及由派生实现定义的特定数据结构引入，以支持 @1.5.2.1 。

@4.2.6.4 共享引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8 。
**注释**
关于程序无法可靠地避免共享状态导致的可观察行为的影响，一个例子是 @4.2.6.5 中的操作。
关于共享改变，参见 @4.2.6.5.3 。

@4.2.6.4.1 对象语言语义问题：
在未证明共享引用一定节约开销时，隐式的共享对象语言程序违反 @1.5.2.2 ，或者在实现需要明确对资源使用的约束时，对进一步的程序变换带来开销（如需要别名分析保证安全），进而鼓励用户代码违反 @1.5.2.3 。
隐式的共享添加伪依赖(pseudo dependency) 减小可程序中操作共享对象的可并行部分，也会由于对共享同步操作的要求而限制并发程序的设计。

@4.2.6.4.2 对象别名：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D 。
关于共享改变，参见 @4.2.6.5.3 。

@4.2.6.4.4 普遍的实现限制：
隐式的共享会隐藏一些语言不可访问的全局属性，使实现在提供语言特性之前先行受到限制，而影响可移植性。
隐式的共享要求运行时具有维护共享资源的机制。由于物理上资源并不能自然地共享，无法避免维护共享状态的运行时机制，如全局 GC(@4.2.5.3) 。
按 @4.2.5.3 ，这样的机制不被公开为 NPL 的设计。
若派生实现提供这样的机制的公开接口，则削弱实现对隐式的共享对实现带来的可用性，且用户利用这样的设计合理地消除开销仍然是普遍困难的。
维护共享状态的运行时机制依赖隐式的资源分配，以维护被引用对象和引用以外的全局状态。这样的分配机制难以具有可移植性，或者公用的可移植机制并不能满足隐式共享的引用的语义而必须有附加的开销，在一定程度上违反 @1.5.2.2 。
依赖全局状态的实现通常无法简单地通过程序逻辑的推理消除运行时的状态依赖或把运行时拆分为不同的系统。这使实现通常无法直接部署在分布式系统上而阻碍 @1.5.2.1 。
特别地，指令集架构(ISA, instruction-set architecture) 以地址空间(address space) 这样典型的形式提供的存储空间资源的元素之间通常是不可共享的；ISA 的实现共享的资源（如 cache ）并不为解决共享问题而设计，也不在 ISA 显式提供而基本不可能被利用加速隐式共享引用的实现。
现实的语言实现通常也符合这里的判断。典型地，允许普遍地通过引用提供隐式的共享行为的语言（如 Scheme ）使用不支持隐式的共享引用的语言（如 C ）实现，因为前者需要后者实现运行时；反之则几乎不存在实例，因为去除运行时的共享而模拟总是不共享的（可变的）对象是不必要和低效的。
使资源到修改(@4.1) 操作之后延迟分配使系统的失败风险被集中，但同时引入更多不确定性。添加不同的使用范型(paradigm) 和场景往往使对系统性能和可靠性的评估都更困难。
现有的如 COW（ copy-on-write ，写时复制）启用隐式资源共享的策略，都会要求运行时机制的更大的计算开销并增加系统复杂性。在硬件支持机制（如地址翻译）的辅助下，加速特定被指定总是进行的任务可使系统整体性能提升，但这不保证能适合作为通用的计算策略。
考虑到脱离硬件支持的情况下，一般的引用访问总是需被实现为额外的（间接）操作，这种缺陷也不能被实现直接避免。
即便在设计以下引入等价引用的兼容层可能提升实现被复用的可能性，不需要通过引用表达的属性仍然存在，减小复杂性需要保留冗余的间接操作而损害性能等实现质量。
此外，即便不涉及副作用，消除别名(@4.2.6.4.2) 的开销一般需要完整的别名分析，在实现中经常也是困难的。
原则上，即便是某种静态视图就能确定别名的存在性，也要求全程序优化的方式才可能可靠地消除别名。
为了使消除别名的分析算法在复杂度上有界，一般需要附加的元数据（如 ISO C 的 restrict 类型修饰符）进行标记。这种标记虽然在接口设计上可能是有效和有益的，但经常欠缺普遍必要性，而因此引入的语义复杂性相当显著，以至于大部分语言至今都没有采纳这种设计。

@4.2.6.4.5 语言的演化问题：
允许实现按需引入特定而非普遍的引用是更符合一般需求的决策。
在已具有隐式的共享作为普遍的默认特性的设计的语言中，引入保证不共享的机制（如所谓的值类型(value type) ）难以复用现有的特性，而需要大量并行的冗余设计。
**注释**
如 Java 添加值类型要求大量改动 JVM 添加无法被先前的语言实现机制表达的 inline class ：
http://cr.openjdk.java.net/~dlsmith/lw2/latest/

@4.2.6.5 可变对象问题：
仅使用引用操作一等对象在涉及对象修改(@4.1) 的存在一些问题。
一般地，和对象改变操作(@4.2.1.2) 对应的作用(@1.2.4) 及其类似的副作用(@4.1) 也和修改对象有类似的问题。

@4.2.6.5.1 可变对象操作限制：
在使用普遍引用的设计中，实体的可修改性(@4.2.1.2) 可能以被引用对象的可变性提供：通过允许改变对象中包含的引用指定对象可变，而体现可修改性。
因为引用不能替代被引用对象，即不能避免不包含引用的实体，这样的设计并不涵盖这些的一等对象可修改性。
Scheme 通过 SRFI-17 在受限的上下文引入可分辨同一性的一等对象(@4.2.4) 。相对一般的一等对象，这种设计违反简单性(@1.5.3.2) 和统一性(@1.5.5.1) 原则。
使用这样的操作要求可变对象是已知环境绑定的变量，而事实上无法脱离求值环境(@4.6.1) 。因依赖引入变量绑定的具体的环境，若需进行可变对象的互操作(@2.3.1) ，需要隐含环境作为操作数。在没有依赖变量绑定（而仅要求可变对象自身）时，这种不必要的依赖违反了 @1.5.2.2 。
实际使用时，这表示无法简便有效地表达“在多个已知不同的一等对象中选择值满足特定属性的对象进行改变”这样的操作，如在 C++ 中可实现的如下操作：
bool f(int);
int x = 1, y = 2;
++(f(x) ? x : y);
这样的操作中，若不同对象具有不同的值，无法共享被选择的不同对象；反之，表达这样的操作反而需要复制对象。引入附加的绑定来变通时，这种局部操作的意图是明确的，并不因此更易预测(@1.5.5.2) 。这样的抽象性上的损失并不能保证换取相应的其它优势。
依赖这种可变操作的限制可能简化语义模型，如 CEKS 抽象机（参见 https://legacy.cs.indiana.edu/ftp/techreports/TR202.pdf ）。
但是这类模型中依赖的全局存储引入了其它的问题，参见 @4.2.5.3 。

@4.2.6.5.2 对象分类的复杂性：
限制一部分只包含引用的实体具有可变性，即便是只在基本的数据结构上应用，也容易导致对象分类的复杂化而使设计违反简单性。因为区分可变和不可变对象而需要更多的特设的操作，也一定程度上违反统一性。
例如，Racket 区分可变和不可变的基本数据结构（从 https://blog.racket-lang.org/2007/11/getting-rid-of-set-car-and-set-cdr.html ），修改操作不能通用。除非用户明确需要，这样要求选取的类型是否不变（特别是没有引入区分同一性的一等实体支持时）是过早的优化(@1.5.6.1) ，同时违反 @1.5.2.1 和 @1.5.2.3 。
改变操作的冲突可以是未定义的(@1.2.4) 。避免冲突不是语言设计选取不变数据结构的合理理由（相对地，选择避免冲突的数据结构是用户的合理理由）。提前放弃未定义的选项，要求任意无法具有实际意义的操作冲突具有一致的行为(@2.5) 也是设计上的过早优化。

@4.2.6.5.3 共享改变：
仅允许这样的可变性也不允许被引用的对象通过不同引用可共享改变。
共享改变通常需要使用可变的包含引用的容器对象（称为箱(box) ）以至实质上的装箱(boxing) 和拆箱(unboxing) 操作，如 SRFI-111 。
这有以下问题：
这同样违反了简单性；
这使基于等价关系定义不同的修改(@4.2.1.2) 更困难且难以实现统一性(@1.5.5.1)（例如，需要更多的特设的基本修改操作(@4.2.1.2) ，或者如 SRFI-17 这样的为修改操作特设的上下文），乃至缺乏实际意义；
若支持 SRFI-111 的自动装箱(autoboxing) （实际包含自动拆箱(autounboxing) 和幂等(@4.1) 的拆箱操作），则进一步违反简单性，也更难以实现统一性。
基于 [RnRK] 的封装类型(encapsulation type) 可实现装箱，但装箱实际上依赖的是共享的引用，并非封装类型自身的名义类型(@4.7.2) 特性，不符合 @1.5.2.4 。并且，在扩展针对个别对象的属性（如不可变性(@4.2.1.2) ）时它仍存在一些不容易扩展的较复杂的问题，如：
https://groups.google.com/forum/?fromgroups#!topic/klisp/pLz-uqJ0WfE 。
使用 [RnRK] 的设计而在此之后引入一等引用（而不仅是一等被引用的对象）可能是对语言特性的实现的复杂的改动，但直接消除隐式的共享(@4.2.6.4) 而使用一等引用的设计并不需要这样的复杂性。
封装类型作为装箱以外仍有意义。
封装类型仍可用于实现箱，但这只是实现细节，更一般的情形两者是无关的——这也符合最小接口原则(@1.5.2.3) 和关注点分离原则(@1.5.2.4) 的要求。

@4.2.6.5.4 退化的间接改变：
退化的箱(@4.2.6.5.3) 可能不共享改变。这样的箱和一等引用没有实质区别。
**注释** 例如，表达为 Box<T> 、Reference<T> 或 Array<T> 这样的被装箱类型 T 的参数化类型，在这个意义上等价。
但是，依赖共享改变的特性在这样的设计中仍然是奇异的和非必要的，尽管这样的类型在某些过程调用(@4.5.3.1) 缺乏引用的语言中被作为替代引用传递(@4.4.6.5) 参数的变通（如 Java ）。
直接支持一等引用而不是其它类型使用户可自行扩展其它类型，在不依赖隐式共享的引用和封装类型(@4.2.6.5.3) 时仍符合可扩展性(@1.5.5.1) 。
一等引用外的其它类型在这个意义上仅因为共享的引用而具有可变性，这是实现细节而不应被依赖。它们应具有其它的特定的含义，以避免违反 @1.5.2.3 、@1.5.2.4 和 @1.5.3.2 ，并允许实现支持 @1.5.2.2 。
**注释** 例如，[RnRK] 中的 pair 因为 set-car! 等操作相当于这里的可改变的箱类型。在不保证共享改变的引用也不引入一等引用时，改变不会被扩散。

@4.2.6.5.5 非必要的实现依赖：
尽管箱(@4.2.8.2.3) 的主要目的是允许对共享敏感的副作用(@4.1) 以符合用户预期的方式可见，也有一些非典型的其它使用。
**注释** 特别地，这种方式关注副作用和其它计算作用(@1.2.4) 的顺序(@4.4.3) 。
一个代表是 Haskell 使用箱实现惰性的中间值(lazy thunk) 。
这种实现引入了一些性能问题。
在此，Haskell 提供未装箱的值以变通这些缺陷，乃至在类型系统上单独区分不同的种类(@4.7.9) 并提供新的种类多态(@4.7.9) ，称为多变(levity) 多态：
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/levity-pldi17.pdf
这本质上是关于对象表示的抽象泄露。
若需要解决性能问题，原则上完全避免惰性的中间值是更适合表达一般含义的做法，但这和 Haskell 的基本设计（求值算法不显含非纯求值，默认依赖惰性求值而提供普遍的等式理论(equational theory) ）矛盾。
这也暗示默认纯函数式的限制并不仅仅是关于计算作用的种类(@4.1.4) 上的，也会影响计算作用的渐进性质——尽管这些包括 Haskell 在内的绝大多数语言都不支持抽象这类性质而允许在对象语言中表达。
引入多变多态解决泛型实现在代码生成（编译）上的结论仍然有意义，但如文献中提及的其它替代做法中，问题最少的是 .NET 的运行时单态化(monomorphization) ，后者也不需要类似的对象表示的抽象泄露。
本质上，这里的问题不仅仅是关于一等对象的设计，还有静态类型(@4.7.1) 系统的滥用。类似的设计包含以下原则性问题：
违反变化的自由(@1.5.2.1) ；
使避免不必要付出的代价(@1.5.2.2) 难以实现；
通过种类的分类对一等对象进行划分，而不允许表达静态不确定种类的对象，事实上取消了一等对象。

@4.2.6.6 非必要性和其它限制：
对语言设计中的一些关键规则，要求使用引用同时保留非引用的形式访问对象并非必要，因为满足以上准则实际上仅关心对象（类似作为表达式）直接关联的值，而非其它属性。
这也体现是否仅允许通过引用访问对象应是实现细节，而不影响一等对象的判定。
依赖一等对象都是引用保证普遍的间接抽象能提供一部分实现的便利（如 TCO(@5.10.4) 可以直接移除活动记录帧(@4.5.3.4) ），但并非没有可忽略的代价（如要求全局 GC(@4.2.5.3) 引入非确定性）和替代实现方法。
另见规约实现(@7.4) 中关于 TCO 实现方式的讨论。

@4.2.6.7 替代设计：
不依赖普遍引用的设计仍允许特定一等对象以引用形式在对象语言中直接访问。
对象语言仍可引入普遍的、独立于被引用对象的引用实体，供用户使用。
这些引用不需要具有隐含的普遍引用的限制。对象作为实体，其不可变性(@4.2.1.2) 的描述不依赖关联的引用是否存在，尽管实现仍可能通过判断只使用限定为不可变（如 const 限定符）的这些引用进行访问的情形以假定或证明对象是否可变。
**注释**
这种引用可能是非一等的，例如 ISO C++ 的引用类型；也可能是一等对象，如 ISO C 的指针（不需要使用指针算术）。

@4.2.6.7.1 隐式引入对象：
在一些上下文中（如按值传递(@4.4.6.5) ），作为普遍的引用的替代，不同一等对象常被隐式引入。
创建新对象通常是对象的逻辑上的副本，而可忽略和其它对象之间共享的状态。
对使用这种假定的程序，用户应当自行确保共享状态的副作用，如把这些状态实现为管理状态(@4.1.3) 。
这类对象副本的创建可能基于语言提供的普遍机制，其实现可能是用户定义（可编程）的。
**原理**
这类对象副本的创建允许用户定义的不确定性。这可能破坏一些仅使用普遍的引用访问对象的程序中的隐含的可预测的属性，但是至少相对完整的别名分析(@4.2.6.4.4) ，这至少可确定不破坏一些局域性假设。
更重要的是，这里的设计决策影响的不只是语言的机器实现。排除不是不可见而不可能的情形，对人类读者，别名分析是困难的。而约定对象的复制(@5.8.2.3) 具有何种受限的情形则相对可行和容易得多（尽管绝对意义上仍然可能较困难）。
为简化设计，约定对象副本创建的行为通常和具体的对象分类相关，一般即对象的类型(@4.7) 。这在一定意义上（至少在按值传递等涉及接口约定的上下文中）加强了对象的类型的本体论意义。而相应地，不当设计引起的后果也更显著。但这类错误设计和实现一般在使用时是容易验证的（虽然潜在类型(@4.7.3) 并不原生通过类型检查(@4.7.4) 支持简化这类工作）。
另一方面，正因为直接避免依赖一些属性可预测，而避免了一些可扩展问题(@4.2.6.2) 。
**注释**
仅使用普遍的引用访问对象的程序中，这些上下文中隐含的属性的一个例子是引用自身的复制可通过全函数(@4.8.2) 描述（总是在有限步骤中完成），且开销足够小。这个假设是如此平凡，乃至许多这样的语言的语义中没有显式地提供这种保证，而实际程序却几乎无时不刻地依赖这种性质。
创建这类对象副本的一个例子是 ISO C++ 的复制初始化可能调用类类型的构造函数，其中对资源的副本创建可被用户定义。
C++ 可以相当典型地体现出在这类上下文中，对是否接受直接复制对象的选型的绝对复杂度的高昂，如：https://stackoverflow.com/a/53825424 。
即便如此，在清楚具体的对象类型时，这仍然是原则上可预测的（而没有别名分析那样的绝对不可行的状况）。
在最差的情形（C++ 模板中，被传递的对象类型是任意无限定的模板类型参数，且创建对象副本而没有发生复制消除），仍可通过接口的设计约定预期的使用方式；若完全没有约定而存在不合理的开销，则证明接口设计的失败。而无论接口设计是否合理，若不存在不恰当的使用，至少对 C++ 程序的运行而言，应当可以通过实现确保没有附加的运行时开销。

@4.2.7 自引用数据结构和循环引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8 。
**原理**
关于通过任意对象支持循环引用的问题，参见 @4.2.7.2 。

@4.2.7.1 循环引用和所有权：
循环引用支持和一等对象引用(@4.2.6) 的一些性质密切相关，特别地，隐含所有权(@4.2.5.3) 的假定。
数据结构的实现蕴含对资源（如存储空间）的使用，其中必然存在不被外部所有的资源，表示为内部的资源对象。
这包含对象对其它对象具有所有权的对象的情形，如一些语言（包括宿主语言）的对象可指定具有被包含所有权的子对象(@5.6.7) 。后者统称为内部对象(internal object) 。
为维护数据结构的边界，满足最小依赖原则(@1.5.4.3) ，数据结构作为宿主语言对象，其中的内部对象应具有以下性质：
数据结构对内部对象具有整体所有权。
推论：仅考虑具有所有权的引用时，数据结构不引用自身。
以上性质是逻辑上的普遍要求。具体的一些语言中，可能因为通过只通过外部所有者代理的方式的访问而无法在实现上保证，但这种逻辑关系仍应存在。
不具有所有权的对象不是内部对象。

@4.2.7.2 通过任意对象支持循环引用的问题：
若直接通过对象之间的引用支持循环引用，且不附加不由用户程序控制的数据结构外部的所有者，有以下问题：
首先，在设计上，这和资源释放算法([Documentation::CommonRules @@1.2.6.5.1]) ）要求所有权正规化([Documentation::CommonRules @@1.2.6.5.1]) ）矛盾。
由于没有外部所有者，必须存在明确的所有权的下界。这要求内部对象的引用至少需要区分两种引用（典型情况即区分是否可确定存在对其它对象具有所有权的引用）。
因此，除所有内部对象之间不具有所有权而直接被表示数据结构接口的单一对象所有外，内部引用对象链中的对象不能都对其它内部对象具有平等的（单一种类的）所有权。
否则，这种对内部实现的限制是一种资源管理机制的抽象泄漏。
其次，在实现上，相对不具有循环引用的情形，有更大的且难以避免的时间和空间开销。
此外，无论是否附加外部所有者，都需要引入更多的处理循环的专用(ad-hoc) 规则。
以上问题体现在不使用循环引用的场合下，一般对象上的循环引用同时违反避免不必要付出的代价(@1.5.2.2) 、最小接口原则(@1.5.2.3) 和关注点分离原则(@1.5.2.4) ，也不利简单性(@1.5.3.2) 。
这些问题的根本原因是所有权没有被足够早地显式区分。更进一步地，不附加外部所有者的普遍的循环引用要求不能直接区分，否则可通过定义某种规则从中判断出不循环的(acyclic) 的引用链的子集而不构成循环引用（实际上若能保证复杂度(@1.2.4) 上限，这也是消除循环引用的主要方式）。
因此，除非允许语言隐含不由用户程序指定的所有者，保留循环引用无法解决这些问题；甚至即便允许这样的所有者，也无法彻底解决实现开销的问题（而需要更多地依赖语言实现系统外部的假定减缓这些开销），仍然一定程度上不符合以上提及的所有原则的要求。

@4.2.7.3 一般引用数据结构的一般实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0 。

@4.2.7.4 无限数据结构：
具有潜在的无限构造的数据结构不一定需要自引用数据结构表示。
并且，即使使用自引用数据结构，也只适合直接表示其中的具有周期性的无限结构。
使用生成序列替代无限数据结构的直接表示则没有周期性要求和限制。
**注释**
数学中出现一些常见的无限构造，如实数和循环的连分数，在实际实现具有的计算资源可承载计算复杂度（主要是空间复杂度）的限制下，不能被直接地完整表示。
相对地，这种构造通常使用一种元语言的构造方式，即潜无限(potential infinity) ，而避免直接的实无限(actual infinity) 表示的资源限制问题。
数学使用的表示在语法上可能提供一些约定以利用这些构造。
使用潜无限是分析学的标准方法。其它方法，如非标准分析，对实无限的实体直接建模，其表示也是有限的。
这些通过有限的表示代替无限构造的实体的方式在通用语言中应当仍适用。

@4.2.8 其它一等实体普遍性质：
更一般地，基于和 [RnRK] 中讨论类似的其它实用性理由，定义一等对象的准则和设计决策还应满足以下几点：
第一，应使一等对象的定义和基于状态存储的对象的概念定义一致，即一等对象是对象。
第二，应允许类型(@4.7) 在语言中被抽象为一等对象。
一等对象准则内不依赖类型的概念（而可依赖值域(value domain) ）以避免概念定义的循环依赖。

@4.2.9 非一等实体的例子：
存在一些判定准则不符合这些要求，如 [RnRK] 中引用的 [Gu91] ：
“类型”未经定义直接出现在规则中，不满足 @4.2.8 最后一点；
显式地放弃了生存期的抽象，不满足上述 @4.2.6 第一点要求的对象一般属性的抽象能力。

@4.2.10 实体类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9E%8B 。

@4.3 名称规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%84%E5%88%99 。

@4.3.1 声明区域约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A3%B0%E6%98%8E%E5%8C%BA%E5%9F%9F%E7%BA%A6%E5%AE%9A 。

@4.3.2 可见名称：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E8%A7%81%E5%90%8D%E7%A7%B0 。

@4.3.3 名称解析
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90 。
另见作用域(@4.6.1.2) 。

@4.3.4 命名空间：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4 。

@4.3.4.1 命名空间指称：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8C%87%E7%A7%B0 。

@4.3.4.2 命名空间成员：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98 。

@4.3.4.3 简单名称和限定名称：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AE%80%E5%8D%95%E5%90%8D%E7%A7%B0%E5%92%8C%E9%99%90%E5%AE%9A%E5%90%8D%E7%A7%B0 。

@4.4 规约规则和求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E8%A7%84%E5%88%99%E5%92%8C%E6%B1%82%E5%80%BC 。

@4.4.1 求值规约：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E8%A7%84%E7%BA%A6 。

@4.4.2 管理规约：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AE%A1%E7%90%86%E8%A7%84%E7%BA%A6 。

@4.4.3 规约顺序：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A7%84%E7%BA%A6%E9%A1%BA%E5%BA%8F 。

@4.4.4 求值性质：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E6%80%A7%E8%B4%A8 。

@4.4.5 范式：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%8C%83%E5%BC%8F 。

@4.4.5.1 规范化中间表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA 。

@4.4.6 组合求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%84%E5%90%88%E6%B1%82%E5%80%BC 。

@4.4.6.1 递归蕴含规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E8%95%B4%E5%90%AB%E8%A7%84%E5%88%99 。

@4.4.6.2 严格性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%A5%E6%A0%BC%E6%80%A7 。

@4.4.6.3 顺序求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%80%BC 。

@4.4.6.4 替换策略：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5 。

@4.4.6.5 求值策略：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5 。

@4.4.7 可选求值规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%AF%E9%80%89%E6%B1%82%E5%80%BC%E8%A7%84%E5%88%99 。

@4.4.8 上下文相关求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E6%B1%82%E5%80%BC 。

@4.5 λ 完备语义和对应语法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%CE%BB-%E5%AE%8C%E5%A4%87%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AF%B9%E5%BA%94%E8%AF%AD%E6%B3%95 。

@4.5.1 名称表达式 ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%8D%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F 。

@4.5.2 函数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0 。

@4.5.2.1 函数内部的变量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F 。

@4.5.2.2 过程：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B 。

@4.5.2.3 过程调用的计算顺序：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F 。

@4.5.2.4 λ 抽象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%CE%BB-%E6%8A%BD%E8%B1%A1 。

@4.5.2.5 vau 抽象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#vau-%E6%8A%BD%E8%B1%A1 。

@4.5.3 函数合并：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6 。

@4.5.3.1 函数调用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8 。

@4.5.3.2 合并子：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%90%88%E5%B9%B6%E5%AD%90 。

@4.5.3.3 续延的捕获和调用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%AD%E5%BB%B6%E7%9A%84%E6%8D%95%E8%8E%B7%E5%92%8C%E8%B0%83%E7%94%A8 。

@4.5.3.4 活动记录：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95 。

@4.5.4 λ 求值策略：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%CE%BB-%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5 。

@4.6 上下文：
参见 https://frankhb.github.io/YSLib-book/docs/Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87 。

@4.6.1 求值环境：
参见 https://frankhb.github.io/YSLib-book/docs/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83 。

@4.6.1.1 实现环境提供的求值环境：
https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83 。

@4.6.1.2 函数和函数应用的求值环境：
https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E7%9A%84%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83 。

@4.6.2 互操作上下文：
参见 https://frankhb.github.io/YSLib-book/docs/Features/NPL.zh-CN.html#%E4%B8%8A%E4%B8%8B%E6%96%87 。

@4.7 类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B 。

@4.7.1 类型系统和类型机制：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6 。

@4.7.2 类型等价性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7%E6%80%A7 。

@4.7.3 类型标注：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8 。

@4.7.4 类型检查：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5 。

@4.7.5 类型全集：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%85%A8%E9%9B%86 。

@4.7.6 类型谓词：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D 。

@4.7.7 类型序：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%BA%8F 。
**原理**
相同类型涵盖不相等的子类型允许使不同的子类型实现公共严格超类型公开的接口行为，而有效地实现封装性(@1.5.6.2) 。

@4.7.7.1 边界元素：
一个类型系统可指定唯一的底类型(bottom type) 作为其它任何不同类型的严格子类型，记作⊥。若类型全集包含空类型，则底类型是空类型。
一个类型系统可指定唯一的顶类型(top type) 作为其它任何不同类型的严格超类型，记作⊤。这种类型即通用类型(universal type) 。
NPL 支持空类型作为底类型，但不要求在对象语言中支持其表示。
NPL 避免要求唯一的顶类型的存在以符合开放世界假设(@1.5.3.6) 。
派生语言可指定不同的规则。
**原理**
以空类型作为子类型在类型序的推理上是自然的。
就非特定的类型全集，通用类型的的构造和表示不唯一，因此不能直接断言其存在。
否则，假定存在这种类型，则断言不存在其超类型，这可能和其它语义规则冲突。
即使在名义上定义具体的超类型（如 Java 的 java.lang.Object 类型），也面临不能向上扩展（得到比 Object 更基本的类型）的问题，违反最小接口原则(@1.5.2.3) 和通用性(@1.5.7) 。
具体的顶类型在断言当前类型系统不存在公共超类型可能仍然有实用意义；此时，顶类型即一等实体(@4.1) 构成的类型，而不需要定义具体名义类型(@4.7.2) 。

@4.7.8 多态类型：
特定的类型系统支持类型签名(@4.7.3) 能对应多种不同的兼容(@4.7.3) 类型。这样的类型是多态的(polymorphic) 。
一般地，类型上的多态(polymorphism) 有：
	特设(ad-hoc) 多态：仅对项上局部的项上的类型作用使之满足上下文兼容要求的多态：
		函数(@4.5.3) 重载(overload) ：同一个名称(@1.2.4) 对应的不同的函数实体，允许按实际参数(@4.5.3) 的类型选择调用不同的函数。
		强制(coercion)：求值时使值向某个上下文要求的类型的隐式转换。
	参数(parameteric) 多态：接口签名指定以具体类型作为值的变量，组合为函数或者其它接口对应实体的类型。
	子类型(@4.7.7) 多态：接口签名编码接受子类型关系作为兼容类型。
	行(row) 多态：对组成具有名称和实体对构成的元素作为成员(member) 的实体，兼容限定部分成员的类型。
多型(polytipic) 的接口在同一个接口签名上以结构化类型的隐式类型(@4.7.3) 构造支持不同的类型而支持多态。
**注释**
重载在一些语言中自动地对函数对应的具体可调用实体(@4.5.2.2) 适用。
行多态以结构化类型(@4.7.2) 约束取代通常通过名义类型(@4.7.3) 指定的子类型关系。

@4.7.9 种类(kind) ：
种类是静态类型系统(@4.7.1) 的语法表示中具有特定类型模式(pattern) 的分类。
一定意义上，种类是类型系统的元语言中一种元静态类型。
一般地，实体类型的种类记作 * 。
除非另行指定，作为项的函数应具有函数类型，即符合类型种类为 * → * 的结果的类型(@4.7) ，如为简单类型 λ 演算(STLC, simply-typed lambda calculus) 兼容的函数类型实例。
其中，→ 是函数类型的类型构造器。
种类作为元语言中的类型多态(@4.7.8) ，实现种类多态：接口签名接受类型的编码中对应位置具有不同种类的类型。
**注释**
在实现中，种类也被作为互操作(@2.3.1) 的归类，如调用约定(@4.5.3.1) ：https://www.microsoft.com/en-us/research/uploads/prod/2020/03/kacc.pdf 。
但这不足以涵盖一般的形式定义；特别地，调用(@4.5.2.2) 是仅仅关于过程这类实体的互操作，而种类适合一般实体的静态类型。例如，在不考虑进一步地实现时，多变多态(@4.2.6.5.5) 的类型不需要限定过程（函数）。
种类也可扩展到特定的计算作用的作用系统(effect system) 上，此处从略。

@4.7.10 一等类型：
一等对象(@4.2) 的类型是一等类型(first-class type) 。
非一等类型的居留(@4.7.6) 不在乎对象语言中可表达，即对象语言中无法构造这些类型的值。
非一等类型仅用于构造其它类型（可能是一等类型）和类型检查等依赖类型的推理。
**注释**
一个典型的非一等类型的例子是 ISO C 、ISO C++ 和 .NET 等支持的类型 void 。
在语义的角度上，void 可视为依赖翻译阶段(@2.3.1) 把求值时得到 void 居留的表示替换为语义错误的单元类型，但这种居留在对象语言中始终不可取得。
若不限制翻译阶段，可通过在传递(@4.4.6.5) 时始终限制正常控制(@4.8) 的值实现类似的效果，例如不考虑类型消除时 ISO C++ 中在复制或转移构造函数始终抛出异常的类类型。

@4.8 程序的控制执行条件：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%9D%A1%E4%BB%B6 。

@4.8.1 异常：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%82%E5%B8%B8 。

@4.8.2 终止保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%88%E6%AD%A2%E4%BF%9D%E8%AF%81 。

@5 派生语言设计：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla 。
实现环境和抽象的对象语言约定以下附加规则。
其部分具体设计(@6) 和实现(@7) 以 C++ API 提供。
另见 NPLA1 解释实现(@7) 和作为具体对象语言的规格说明(@9) 。

@5.1 领域语义支持：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%A2%86%E5%9F%9F%E8%AF%AD%E4%B9%89%E6%94%AF%E6%8C%81 。

@5.2 NPLA 整体约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%95%B4%E4%BD%93%E7%BA%A6%E5%AE%9A 。

@5.2.1 NPLA 实现环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83 。

@5.2.2 附加功能：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83 。
关于 NPLA 数学功能，参见 @6.14 。

@5.2.3 NPLA 词法和语法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E8%AF%8D%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95 。

@5.2.3.1 NPLA 标识符：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%A0%87%E8%AF%86%E7%AC%A6 。

@5.2.3.2 NPLA 扩展字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F 。

@5.2.4 NPLA 名称和字面量求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E6%B1%82%E5%80%BC 。
**注释**
名称的内部表示参见记号值(@6.8.1) 。

@5.2.5 NPLA 求值的表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%B1%82%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA 。
派生实现使用的项不满足特定的表示(@6.3.7) 。

@5.2.6 NPLA 类型系统：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F 。

@5.3 NPLA 互操作支持：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E4%BA%92%E6%93%8D%E4%BD%9C%E6%94%AF%E6%8C%81 。

@5.3.1 类型映射：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84 。
**注释**
关于中间值，参见 @6.8 。
关于 string 类型，参见 @6.1.5 。
关于 NPLA 数学功能，参见 @6.14 。
关于由实现定义的宿主类型（及其所在的命名空间），参见 @6.1.7 。

@5.4 NPLA 未定义行为(@1.2.4) ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA 。

@5.4.1 常规宿主资源分配要求：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A6%81%E6%B1%82 。

@5.4.2 嵌套调用安全：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%AE%89%E5%85%A8 。
关于宿主 TCO ，参见 @5.10.4.2 。

@5.4.3 并发访问：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE 。

@5.5 NPLA 一等对象类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E4%B8%80%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B 。

@5.5.1 有序对：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9 。

@5.5.2 广义列表：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8 。

@5.5.3 符号：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%AC%A6%E5%8F%B7 。
**注释**
符号的实现(@6.8.1) 中和字符串的对应关系可简化互操作(@5.3) 。

@5.6 存储和对象模型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B 。

@5.6.1 NPLA 基础存储模型和对象模型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B 。

@5.6.2 间接值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC 。

@5.6.2.1 间接值使用约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A 。
其中，实现定义的情形详见 @6.4.3.2 中的约定。
**注释**
引用值(@5.8.3) 作为间接值可被消除(@5.8.3.5) ，是消除间接值的主要实例。
返回值转换蕴含的项提升(@5.6.7.1) 一般使用 NPL::LiftToReturn(@6.9.4.3) 实现。

@5.6.2.2 环境间接值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E9%97%B4%E6%8E%A5%E5%80%BC 。

@5.6.2.3 引用间接值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E5%80%BC 。

@5.6.3 求值和对象所有权：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83 。

@5.6.3.1 项对象和关联对象所有权：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A2%AB%E8%A7%84%E7%BA%A6%E9%A1%B9%E6%89%80%E6%9C%89%E6%9D%83 。
关于实现中项的宿主类型，参见 @6.2 。
关于实现中项的构成，参见 @6.3 。
纯右值可被环境所有，如绑定映射中的名称；此时，仅复制记号值(@6.4.3.2) 而不依赖其同一性。

@5.6.4 内存安全：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8 。

@5.6.4.1 非内存安全操作：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%9D%9E%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C 。
当前未被实现检查(@5.4) 的操作包括：
未关联环境引用计数(@6.8.3.1) 的 NPL::TermReference(@6.8.3) 初始化；
非内存安全提升操作(@6.9.4.5) 。

@5.6.4.2 NPLA 对象语言内存安全保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81 。
对象语言的内存安全(@5.6.3) 保证及违反内存安全的（不完全）检查（参见 NPLA1 非内存安全项(@7.1.3.2) ）的基本机制基于 NPLA1 关于被规约项、生存期、所有权和间接值的约定(@7.1) 。
关于引入不保证内存安全的间接值的 NPLA API ，参见 @6.9.4.5 。

@5.6.4.3 NPLA 内存安全保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81 。

@5.6.4.4 运行时内存安全检查：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5 。

@5.6.4.5 局部间接值安全保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B1%80%E9%83%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81 。
**注释**
用于按值传递参数时，一般使用 NPL::LiftTerm(@6.9.4.2) 和确保创建值副本的 NPL::SetContentWith(@6.2.3) 实现；前者取非引用类型的右值(@5.8.1) ，后者提升间接值确保结果不是中间值。
用于按值传递返回值时(@4.5.3.1) ，除显式分别对是否为引用值的情形进行处理，可使用 NPL::LiftToReturn(@6.9.4.3)（其中也使用以上方式实现），实现临时对象实质化转换(@5.8.4) ，详见返回值转换(@5.8.4.2) 。

@5.6.5 资源泄漏：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F 。

@5.6.5.1 资源回收策略：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5 。
关于不放弃确定性，另见 @4.2.6.6 。
关于循环引用避免，另见 @4.2.7.2 。

@5.6.5.2 资源回收安全性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E5%AE%89%E5%85%A8%E6%80%A7 。

@5.6.6 自动存储管理：
和 C++ 的自动变量类似，函数调用结束、控制退出函数体(@4.5.2) 的作用域（对应 C++ 的函数体最外层块作用域）后，被变量独占所有权(@4.2.5.3) 的资源被释放。
资源回收策略(@5.6.5.1) 允许存储资源和宿主语言对象之间的明确对应，且允许以环境持有所有作用域内的所有资源。
使用自动变量释放的机制，自动存储管理的基本设计可不依赖 GC(@5.6.5) ，也不需显式对资源进行释放。
**注释**
把右值(@5.8.1) 的值传递视为传递独占的引用，这类似 newLISP 的 ORO(One Reference Only) ：http://www.newlisp.org/MemoryManagement.html 。

@5.6.7 子对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1 。
**原理**
关于具体表示，参见 @6.3 。

@5.6.7.1 项的子对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1 。

@5.6.8 对象属性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E5%85%83%E6%95%B0%E6%8D%AE 。
关于实现定义的互操作的假设，参见 @6.2.2 。

@5.7 NPLA 环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E7%8E%AF%E5%A2%83 。

@5.7.1 环境对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1 。
**注释**
被绑定对象除具有和一等对象相同的表示外，可能还具有附加的非一等对象表示(@6.3.2) 的状态，参见临时对象标签(@6.2.2) 。
关于环境的内部表示，参见环境数据结构(@6.11.1) 。

@5.7.2 环境引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8 。

@5.7.3 当前环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83 。

@5.8 NPLA 表达式语义：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E4%B9%89 。
被求值的表达式使用被规约项(@6.2) 作为内部表示。

@5.8.1 值类别：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB 。
**注释**
可通过间接的引用(@4.2.6.3.1) 附加其它元数据。
另见引用(@4.2.6) 对一等状态(@4.2.5.1)的支持(@4.2.6.3.2) 。

@5.8.1.1 类型系统和值类别：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%80%BC%E7%B1%BB%E5%88%AB 。
内部表示允许存在附加的相关性(@6.3.1) 。

@5.8.1.2 值类别相关求值性质：
按已有的规则，NPLA 约定求值至少需要支持以下的重要的性质：
第一，允许表达式直接表示一等实体而不论它是否是一等对象(@4.1)（即便按 @4.2.4 ，默认不会出现这种情形，派生实现仍然可能改变）；
第二，使用支持按引用传递的策略(@4.4.6.5) ，允许通过表达式构造引用不同对象的引用类型(@5.8.1.1) 的值且被作为一等对象(@4.2) 传递（详见项引用(@5.8.3.8) ）。
一般地，这表示引入值类别的差异是必要的。因为，若假设平凡(trivial) 情形下，值类别可退化到都是泛左值或都是纯右值的情形。
若只存在泛左值，则任意的求值都决定一个对象；由于存在和一等对象无关的实体，无法满足第一条性质。
若只存在纯右值，则无法区分不同的对象，形式上无法构造出可用的引用类型的值满足第二条性质。
此外，NPLA 同时约定：
第三，求值满足递归蕴含规则(@4.4.6.1) ；
第四，允许对象的操作保持资源局域性，满足一等对象不依赖引用的抽象(@4.2.6) 同时允许按需区分是否依赖引用的两类一等对象；
第五，避免需要假设存在外部具有被引用对象(@4.2.6) 的所有权的所有者(@5.6.5) 。
第三条性质保证求值表达式的作用(@1.2.4) 是可组合的，并允许求值表达为树规约(@6.2) ，还保证能总是通过子表达式的特定的性质判定表达式的对应性质而不需求值。
因为被求值的表达式是有限的，判定过程是总是能终止，即便求值不满足强规范化性质(@4.4.5) 。
第四条性质要求提供泛左值总是能作为纯右值使用的机制和通过纯右值引入对象的机制，详见值类别转换(@5.8.4) 。
第五条性质要求在表达式之外不存在地位相同的对象的存储资源(@5.6) 的所有者，限定了被决定同一性的对象的外延；存储由环境提供(@5.6) ，其中不需要保存对象的引用。
不像 ISO C++ 一样仅限于静态类型系统范畴，NPLA 值类别的作用机制和 ISO C++ 存在一些明确的不同：
	对 C++ ，表达式求值规约的重写（如 ISO C++ 的左值到右值转换）是静态的文法构造确定的；
	但对 NPLA ，这种重写的存在性可依赖程序运行时的状态。
基于求值结果约定可能被求值的表达式的值类别是自然的，因为：
	值类别通常影响值的使用，若一个表达式预期被求值，对应求值结果以外的值类别通常不被关心。
		尽管允许取得构造关联的表达式副本时，值类别可能因其被用于其它求值而在求值前被关心。
	这也和 ISO C++ 更加一致，尽管后者因为上下文被静态地确定（排除 ISO C++ 未求值操作数(unevaluated operand) ）而可以直接只讨论被求值的情形，而不需要这种约定。
	注意此时表达式的值可能是左值，因此表达式的“值”与“右值”不等价，这与 ISO C 的一般约定不同。

@5.8.2 初始化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%88%9D%E5%A7%8B%E5%8C%96 。

@5.8.2.1 复制初始化和直接初始化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96 。

@5.8.2.2 函数参数和函数值传递：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92 。
**注释** 元数据以项引用的元数据(@6.8.3.1) 实现。

@5.8.2.3 对象的复制和转移：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E7%A7%BB 。
不要求可复制的子对象(@5.6.7) 包括是项的值数据成员(@6.2) 保存的宿主对象(@6.3.3) 。
**注释**
当前实现中宿主对象复制失败时抛出 `ystdex::invalid_construction` 异常。

@5.8.2.4 项的转移：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%A1%B9%E7%9A%84%E8%BD%AC%E7%A7%BB 。

@5.8.3 引用值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC 。

@5.8.3.1 子对象引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8 。

@5.8.3.2 引用值的有效性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7 。

@5.8.3.3 多重引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8 。

@5.8.3.4 引用值的属性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7 。
**注释**
关于跟随一等对象传递的元数据，参见 @5.8.5.5 。

@5.8.3.5 引用值的消除：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%B6%88%E9%99%A4 。
**原理**
不涉及引用值的消除时，NPLA 对象的子对象的不可修改性一般也直接依赖具体元素（如不可修改引用作为列表的元素(@6.2.1) ）。除不可修改引用蕴含的对直接引用的被引用对象不可修改外，是否满足需要传播不可修改性依赖具体操作的语义。

@5.8.3.6 引用折叠：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0 。
**原理**
使用被引用对象的临时对象标签(@6.2.2) 单独决定折叠结果更容易直接保留被引用对象的状态。

@5.8.3.7 对象的可转移条件：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%AF%E8%BD%AC%E7%A7%BB%E6%9D%A1%E4%BB%B6 。
**注释**
关于具体表示，参见项的可转移条件(@6.8.3.2) 。

@5.8.3.8 引用值的表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA 。
关于引用项的构成，参见 @6.3 。
另见项引用的元数据(@6.8.3.1) 。

@5.8.3.9 引用值的子类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B 。
另见项引用的元数据(@6.8.3.1) 。

@5.8.4 值类别转换：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2 。
**注释**
基于引用的左值到右值转换可通过 NPL::ReferenceTerm(@6.9.3) 实现。

@5.8.4.1 默认值类别转换约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%B1%BB%E5%88%AB%E8%BD%AC%E6%8D%A2%E7%BA%A6%E5%AE%9A 。
关于箱和自动装箱，参见 @4.2.6.5.3 。

@5.8.4.2 返回值转换：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2 。

@5.8.5 临时对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1 。
关于一等对象的表示，参见 @6.3.2 。

@5.8.5.1 实质化转换上下文：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E8%B4%A8%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87 。

@5.8.5.2 返回值转换上下文：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8A%E4%B8%8B%E6%96%87 。

@5.8.5.3 复制消除：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4 。

@5.8.5.4 生存期扩展：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E6%89%A9%E5%B1%95 。

@5.8.5.5 绑定临时对象标签：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%A0%87%E7%AD%BE 。

@5.8.5.6 临时对象的表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%A8%E7%A4%BA 。
**原理**
关于实现上项的宿主类型，参见 @6.2 。
简化实现的操作的例子如提升(@6.9.4.5) 转换临时对象到对应的非一等对象。

@5.8.6 表达式的类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B 。
**注释**
和宿主语言不同，语言机制不限制值类别和其它类型的判断操作和结果(@4.1) 被作为一等对象(@4.2.8) ，尽管不一定直接提供。
关于语法分析的实现，参见 @6.1.6 。
关于其中处理的类型，参见项节点结构分类(@6.2.1) 和记号值(@6.8.1) 。

@5.9 生存期附加约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%84%E5%8A%A0%E7%BA%A6%E5%AE%9A 。

@5.10 尾上下文约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B0%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BA%A6%E5%AE%9A 。

@5.10.1 真尾规约：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%9C%9F%E5%B0%BE%E8%A7%84%E7%BA%A6 。

@5.10.2 尾调用和 PTC ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C-ptc 。

@5.10.3 PTR ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#ptr 。

@5.10.4 TCO ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#tco 。

@5.10.4.1 宿主语言中立：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%BF%E4%B8%BB%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AB%8B 。

@5.10.4.2 TCO 实现策略概述：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#tco-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0 。
**注释**
TCM 一般只减小尾调用(@5.10) 需要占用的活动记录，而 TCE 可能直接替换控制结构，同时减小运行操作需要的时间开销。但 TCE 变换自身可能需要额外开销且实现较复杂。因此，当前 NPLA 只支持 TCM 方式的 TCO 。
因为只使用 TCM ，相对没有 TCO 的基线版本，无法保证具有可预期的时间性能提升；相反，引入 TCM 可因为增加运行时存储分配和缓存局域性等原因降低性能（但一般实现应不影响复杂度类而只降低可接受的常数）。
TCM 引入的构造通常基于对象语言的内部变换。静态 TCO 使用的对宿主语言的自动变换和这种内部变换可基于相同的策略，如通过对程序全局变换得到的 CPS(@6.11.3) 或 ANF(Adminstrative Norm Form) ）的中间表示(@2.3.1) 。
当尾上下文规约涉及的存储（主要是活动记录(@4.5.3.4) ）被一并消除时，调用消耗的空间复杂度有静态上界，满足 PTC(@5.10.2) 。

@6 NPLA 实现：
本章描述 NPLA(@5) 约定下的对象语言(@1.2.4) 的具体实现和宿主语言可访问的互操作接口。

@6.1 实现方案概述：
NPLA 实现支持可扩展的 C++ API ，作为解释器(interpreter) 的实现基础。
本方案中，除非另行指定（如总体架构(@6.1.3) 中的描述），API 在模块 NPLA 提供。
NPLA 以外的附加功能(@5.2.2) 模块主要包括 NPLAMath(@6.14) 。
作为可选特性，没有被模块 NPLA 依赖的附加功能模块不是 NPLA 设计(@5) 的直接实现，而为派生实现提供和 NPLA 公共实现的并列的基础功能。
**注释**
派生实现中可能要求支持特定的 NPLA 附加功能而非可选项。

@6.1.1 实现支持策略：
解释器的程序执以对语法分析(@6.1.6) 结果的规约实现，可对应语言或（适合改进执行性能的）某种等价变体的小步语义(@2.2.3) 。
在此基础上，可允许派生实现优化性能，如嵌入编译。
因为语法分析和规约的实现都在项(@4.1) 上进行变换，形式上，语法分析和规约实现整体实现了项重写系统(@4.1) 。
NPLA API 公开解释器的状态，可支持和宿主语言的互操作(@5.3) 。
虽然 NPLA 的设计(@5) 没有给出形式语义(@2.2.3) ，但 NPLA 实现中包含的 API 部分地提供和形式语义方法对应的支持：
通过回调对应依赖宿主语言(@5.2) 实现作为描述的指称语义；
在回调内对项和上下文进行操作，对应小步语义；
在回调内复用其它接口，对应大步语义。
NPLA 可支持非固定的规约规则集合，以 API 的形式体现，详见规约 API(@6.10) ；另见表达式的求值(@6.3) 。
部分实现的功能由公共 API 的形式提供，以便派生实现复用。本章约定这些 NPLA 公共语言实现接口。
用于 NPLA1 应用实例(@6.15.1) 和 NPLA 其它实现应用实例(@6.15.2) 等部分不直接用于 NPLA 解释实现的 API 可能在本章中被略过。
具体实现的编码风格导引参见 [Documentation::CommonRules @@6] 。
基于 NPLA API 的派生语言的设计详见 NPLA1(@7) 。

@6.1.2 实现选项：
NPLA 实现中提供构建时确定的实现选项，以宿主语言的宏定义在构建时启用，以宿主语言条件包含的 #if 指令判断。
除非另行指定，以宏定义提供的实现选项一般仅用于开发者测试，不提供使用不同选项的配置兼容性的保证。
一些实现选项仅影响实现且不影响正确性。这些选项对应的宏名带有前缀 NPL_Impl 。
部分选项是内部的，总是直接在源代码中提供固定的定义，而不在外部可配置。
其它选项可能通过外部指定定义。除非另行指定，在实现中不会覆盖外部配置提供的实现选项对应的宏定义。
特定实现选项可能影响实现的符合性(@2.3) ；这些选项总是内部的。
除非另行指定，实现选项的宏若被定义，则应被替换为：
若指定为数值，则为求值为无符号整数的常量表达式；
否则，能求值为 true 或者 false 的表达式。

@6.1.2.1 运行时检查：
当前实现选项用于指定启用检查（可蕴含可选的实现提供的内存安全检查(@5.6.4.4) ）：
NPL_NPLA_CheckEnvironmentReferenceCount 环境对象销毁时检查环境引用计数。
NPL_NPLA_CheckParentEnvironment 默认访问父环境(@5.7) 时，检查环境引用是否存在。
NPL_NPLA_CheckTermReferenceIndirection 项引用(@5.8.3.8) 的间接操作(@6.9.3) 时检查关联环境(@5.8.3.6) 。
若关联环境，要求关联环境的锚对象指针(@6.7.2) 和环境弱引用锁定的强引用指针非空。无法确保没有关联环境的非内存安全操作(@5.6.4.1) 中的引用有效性。
启用以上检查可避免引起不满足检查条件时的一些宿主语言的未定义行为(@5.4) ，即便已引起 NPLA 和对象语言的未定义行为(@5.6.4.1) 。

@6.1.2.2 外部实现依赖配置：
宏定义 NPL_Impl_NPLAMath_Has_UInt128 和 NPL_Impl_NPLAMath_UseQuadMath 配置 NPLAMath(@6.14) 的实现，详见外部表示 API 的优化实现(@6.16.6.1)

@6.1.3 总体架构：
NPLA 核心实现为对数据结构的管道-过滤器(pipe-filter) 架构模式的处理框架。每个处理节点实现一个或若干个阶段(@2.3.1) 。
这里的数据结构是语言实现的 IR(@2.3.1) 或通过代码生成(@2.3.1) 得到的代码。在 NPLA 实现中后者是可选的。
本节下文首先指定翻译单元经过词法分析(@6.1.5) 和语法分析(@6.1.6) 这两个前端(frontend) ，之后的处理见本章中的其余节。
除非另行指定，本节中的 API 都位于模块 NPLA ，详见 NPLA 公共语言实现接口(@6.1.1) 。
本章(@6) 下文中，C++ 名称使用限定名称（带有 :: 的前缀）以避免混淆，除以下例外：
	本章在引入的非限定的类型名称，视为在 C++ 命名空间 NPL 中引入。
		**注释** 这些名称包含指定为类等具体声明等形式，以及类型别名。
	以下名称视为在 C++ 命名空间 YSLib 中引入 NPL ：
		shared_ptr
		observer_ptr
		weak_ptr
		**注释** 实现可直接通过 using 声明引入这些名称。
	**注释** 满足本文档的要求时，实现也可在相关命名空间引入不在本文档中要求的 YSLib 名称。
本章下文中，项目的模块命名空间([ProjectRules @@3.2]) 名称若为 NPL 模块，省略 NPL 前缀；其它 YSLib 模块需使用限定名称；非 YSLib 模块还需指定库的来源。
本章下文中，使用 namespace 关键字指定 C++ 命名空间。
明确为类或枚举等（而非以“类型”描述）的具体类型实体直接定义在所在的作用域中（不带有内联命名空间，也不被定义为类型别名）。除此之外，类型声明是否为某个类模板的特化的别名是未指定的。
**注释**
明确类型定义保证能明确限制特定的 ADL 函数调用。
例如，在命名空间 NPL 中，因为 TermNode(@6.2) 明确为非模板特化的类类型，实际参数中仅有 TermNode 值的调用可不需要 NPL:: 前缀限定。
对本文档中未明确引入的名称，调用时是否使用 ADL ，按实现提供的声明和注释约定确定。

@6.1.4 安全保证：
NPLA API 和实现提供特定的整体安全保证以满足对象语言的要求，并提升实现行为的可预测性。

@6.1.4.1 嵌套调用安全：
除以下例外，NPLA 实现及对应可能由用户提供的替换的实现应支持嵌套调用安全(@5.4.2) ：
	没有启用 NPL_Impl_NPLA1_Enable_Thunked(@7.1) 的实现。
	TermNode(@6.2) 上的部分遍历节点的操作。
		直接遍历参数节点的操作。
			**注释** 包括通过 ValueNode 构造及比较相等或不等的操作。
		访问 TermNode::Value 引起嵌套重入的操作。
			**注释** 例如对任意目标类型(@6.2) 的值数据成员的比较。
		**注释** 析构保证嵌套调用安全，除非其中的值数据成员的析构非嵌套安全。
	直接递归遍历可具有任意嵌套深度子节点的节点的操作。
		**注释** 当前包括 NPL::SetContentWith(@6.2.3) 和 NPL::TokenizeTerm(@6.9.2) 。
	因为直接或间接调用上述遍历节点实现的操作而无法提供安全的操作。
		**注释** 详见不支持嵌套调用安全的提升操作(@6.9.4.6) 。
	在规约合并求值(@7.6.4.2) 调用外的宿主语言中的回调函数调用。
	派生实现定义的情形。
对 TermNode 的复制构造实现的嵌套调用安全依赖内部实现选项(@6.1.2) NPL_Impl_SContext_Enable_ThunkedActions 。
嵌套调用可能影响性能。在复制支持嵌套调用安全时，宏 NPL_Impl_SContext_Enable_ThunkedThreshold 指定使用允许直接嵌套调用（但在一定范围内不保证安全）的最大宿主函数调用层数。
**原理**
规约合并求值调用在启用 NPL_Impl_NPLA1_Enable_Thunked 时首先创建用于异步调用的对象(@7.6.4.2) ，在此用直接调用代替会使创建对象没有普遍意义。
其它回调（如本机实现(@5.3) ）可能足够简单而可证明不需要通过外部调用者的嵌套调用安全，以减小开销。

@6.1.4.2 异常安全：
基本内容参见 [Documentation::LanguageConvention @@5.10.5.3] 和 [Documentation::YFramework @@3.2] 。
在此基础上，NPLA 对表示对象语言一等对象的基本操作上提供有限的强异常安全保证([Documentation::LanguageConvention @@5.10.5.3.2]) ：
	修改最小的不可分割的一等对象表示(@6.3.2) 的操作若失败，则回滚到修改这个对象之前的状态。
	除非另行指定，本机实现(@5.3) 中可能通过用户程序引入的非平凡析构的对象表示的资源对象，满足强异常安全保证。
**原理**
TermNode(@6.2) 可表示用户程序引入的对象可包括对象语言程序引入的对象。
这些对象一般是用户定义的，不能保证宿主语言异常抛出时的状态，因此实现提供更强的运行时状态的可预测性可能减少互操作和本机实现(@5.3) 的复杂性。
但是，保证多个对象复制的强异常安全的事务(transaction) 维护复制的状态而需要冗余开销。
为平衡性能和可预测性，除 TermNode 直接支持的操作，在一等对象的边界以外部分不提供事务性保证。
**注释**
关于本机实现对异常的使用的其它情形仍然遵守一般约定([Documentation::YFramework @@3.2]) 。

@6.1.5 词法分析：
词法分析以源代码为输入(@5.2.3) ，遵循词法分析规则(@3.3.5) 输出分析的记号序列(@2.3.1) 。
本设计提供为参照实现模块 Lexical 。
词法分析实现可隐含确定关于每个名称的声明区域(@4.1) 有效的代码片段的最大位置范围；但 NPLA 设计(@5.1) 没有要求这种行为在对象语言中可见，因此简化起见，Lexical 不包含对应实现。
Lexical 模块在 namespace NPL 通过别名声明引入 YSLib::string 类型和 YSLib::string_view 类型。
Lexical 模块的词法分析器支持分析表示 S 表达式的文本流，但源语言中不包含点(dot) 记号，且支持同宿主语言相同的断行连接和转义字符。和宿主语言不同，不支持的转义前的 \ 不需要被重复，且不支持字符串字面量的直接并置连接。
词法分析使用二进制模式处理文本，字符序列被逐字节输入。CR(carriage return) 和 LF(line feed) 预期以单字节编码。
词法分析忽略 CR(carriage return) ，而 LF(line feed) 被视为换行。
词法分析的结果是记号的序列，以记号列表类型 TokenList 表示。
Lexical 模块提供类型别名和以下类型：
LexemeList ：词素(@3.3.1) 列表。
词素列表中的元素是在词法分析阶段中表示记号(@3.3.1) 的短字符串。虽然逻辑上并不依赖，但为便于实现，提供分配器(@6.4.1) 支持。
SourceLocation ：源代码位置。
词法分析提供以下元函数访问词法解析器中的类型：
MemberParseResult
ParserClassOf
ParseResultOf
GParserResult
词法分析提供以下类实现或作为词法解析器：
BufferedByteParserBase
ByteParser
DelimitedByteParser
其中，DelimitedByteParser 保留更多的中间结果。

@6.1.6 语法分析：
参照实现模块 SContext ，提供源代码的文本流或其词法分析结果(@6.1.5) 转换到分析结果的转换接口。
分析结果是结构化的递归数据结构，称为分析树(parse tree) 。除非派生实现另行指定，分析树中的节点应同构 NPL 语法(@3.4) 的非终结符(non-terminal) 文法元素。
语法分析通过调用词法分析转换源代码为 TokenList 类型(@6.1.5) 表示的记号列表结果，并在此之上递归解析取得记号序列对应的语法对象(syntax object) ，然后从语法对象构造分析树。
除包含构造分析树的必要信息，语法对象还可能包含来自源代码的附加元数据，如分析结果对应的源代码位置信息。当前 SContext 的语法对象不包含这些附加的元数据，因此和分析树同构。
分析树包含源代码中语法规则（包括 @3.4 和派生实现定义的其它扩展）关注的所有语法信息，也被称为具体语法树(concrete syntax tree) 。
与之相对，以 AST（Abstract Syntax Tree ，抽象语法树）作为保存分析结果的 IR 排除了之后的阶段中不需要的信息。
因为 SContext 输入的形式是和 Lexical 模块(@6.1.5) 兼容的 S 表达式，分析树和 AST 同构，不需要保持冗余信息。因此 SContext 只一种提供同时表示分析树和 AST 的数据结构。派生实现可根据扩展语法规则的需要定义不同的分析树。
对语法分析的递归操作应在分配资源失败应满足常规宿主资源分配要求(@5.4.1) 。
使用 AST 作为 FOAS（First-Order Abstract Syntax）不需要保留优先级等冗余信息。
派生实现可能检查更多语法规则。
SContext 模块在 namespace NPL 通过别名声明引入若干 YSLib 类型名称，包括（但不限于）：
ValueObject 、ValueNode 、observer_ptr 和 LoggedEvent 。
关于这些类型，另见 [Documentation::YSLib @@3.16] 和 [Documentation::YSLib @@3.2] 。
语法分析提供 TermNode 类类型(@6.2) 作为表示分析树（根据以上讨论，同时也是语法对象和后续使用的 AST ）的处理结果类型，及其相关操作。
以下类型和 TermNode 关联：
TNCIter
TNIter
TermByteAllocator
SContext 模块的其它 API 详见以下小节和项节点访问(@6.2.3) 。

@6.1.6.1 词素(@3.3.1) 处理：
以下命名空间 NPL 中的 API 提供词素相关的转换：
函数模板和函数 ToLexeme
仿函数 LexemeTokenizer

@6.1.6.2 读取器(reader) 状态：
类 ReaderState 保存辅助读取列表表达式边界标点的状态。

@6.1.6.3 NPL 源代码分析会话(session) ：
语法分析提供类 Session 表示分析处理一个翻译单元(@3.1) 的 NPL 源代码的会话。
会话利用词法分析器提取源代码中可被分析的信息，并提供使用指定词法解析器(@6.1.5) 取解析结果的 API 。
若不指定词法解析器，默认使用的词法解析器是 ByteParser(@6.1.5) 。
会话的输出应满足可被 @6.1.7 表达的形式。这限制了可识别的外部表示(@1.2.4) 。
由 @4.1.1 ，这限定了翻译单元(@3.1) 的组成。例如，翻译单元中的源代码(@4.1.1) 一般应能对应语法上完整的表达式(@3.4.2) 。

@6.1.6.4 命名空间 NPL::SContext ：
命名空间 NPL::SContext 提供转换节点相关数据和遍历节点的 API 。
以下命名空间 NPL::SContext 中的 API 递归遍历参数指定的记号范围以转换其中的结构化数据为表示的语法树：
函数模板 Validate
函数模板 Reduce
函数和函数模板 Analyze

@6.1.7 类型映射实现：
类型映射(@5.3.1) 使用的 C++ 类型在 namespace NPL 中声明，从 namespace YSLib 引入。
一些类型如 string 、ValueNode 和 ValueObject 在词法分析(@6.1.5) 和语法分析(@6.1.6) API 中引入，被以下章节的实现使用，成为实际的映射目标。
以下章节中，IR 节点数据结构(@6.2) 和 NPLA 中间值(@6.8) 提供的节点或中间值(@4.4.6.2) 类型(thunk type) 是类型映射的目标(@6.1.7) 。

@6.2 IR 节点数据结构：
NPLA 实现使用节点(node) 数据结构表示实现使用的 IR 中间表示递归的构造，如 SContext 产生的 AST 的节点和语义分析使用的项。
这样的节点类型为 NPL 中定义的类 TermNode ，也用于表示单一的树（如整个 AST(@6.1.6) ）。
NPLA 实现语义规则时对 TermNode 进行处理，包括节点上的规约(@4.1) ，即树规约(tree reduction) 。
TermNode 对象可作为规约的输入，并在树规约中作为中间表示，即被规约项(@4.4.1) 。
树规约的输入和各个规约步骤的结果中，变量不需要直接被表示，规约允许和输入 AST 中一致的未求值的名称，参见 @6.8.1 ；同时，允许在同一个树中包含经不同过程转换的结果，不需要显式区分阶段(@2.3.1) 。
**原理** 因为绑定(@4.1) 的表示方法不在 IR 内特设指定，树规约不需要使用 HOAS（Higher-Order Abstract Syntax ，高阶抽象语法）。
接受表达式到表达式的映射附加处理可通过派生实现约定对象语言中特定类型的对象实现，不要求被编码在规约的结果中。
通过求值环境(@5.7) 维护的名称和作用域保存在环境数据结构(@6.11.1) 中。
TermNode 中保存子节点的容器。作为被规约项时，TermNode 的子节点对象是子项(@4.1) 的表示(@1.2.4) 。
TermNode 的 Value 数据成员称为值数据成员(value data member) ，是 ValueObject 类型的对象。用于表示对象语言（ NPLA 实现）中表达式或对象储存的值，或者包装的中间值(@4.4.6.2) 。
ValueObject 可保存具有不同的动态类型的目标对象(target object) ，可在对象语言程序运行时确定宿主语言对应的对象类型，结合类型映射(@5.3.1) 实现潜在类型(@5.8.6) 。
其中目标对象的动态类型是目标类型(target type) 。
其它的宿主对象(@5.3.1) 也可能实现 ValueObject 类似的动态类型机制，保存相应的目标类型的目标对象，但不一定支持其它对象。
**注释** ValueObject::GetObject 是无检查访问目标对象的基本接口。其它通常使用类型擦除(@4.7.3) 实现的类型，如 std::function 的实例，也有类似的目标对象的概念。
目标对象是目标函数(target function) ，当且仅当是宿主语言的函数对象。
子节点和值数据成员是节点的子对象(@5.6.7) 。节点对子节点和值数据成员具有直接的独占所有权。
每个节点中：
子节点（若存在）的初始化先序(@4.4.3) 值数据成员的初始化；
子节点（若存在）的销毁后序(@4.4.3) 值数据成员的销毁；
不同子节点（若存在）之间的初始化和销毁顺序未指定。
作为子节点的容器，子节点的迭代器、指针和引用保持稳定，即移除子节点时保持其它项的迭代器、指针和引用有效而不被无效化(invalidated) 使访问引起宿主语言的未定义行为(@5.4) 。
子节点的稳定性也支持项被转移时（如维护临时对象的内部存储(@5.6.3) ）不需要附加操作维护已在其它位置被引用的子项有效性。
针对 TermNode 的一些操作如移除第一个子节点的 RemoveHead 一般使用 ADL 方式调用。
树规约可按需添加或删除 TermNode 的子节点。具体添加或删除的时机未指定，取决于具体的规约算法。
除非派生实现另行指定，删除值数据成员和删除子节点的作用非决定性有序(@4.4.3) 。
除最后的代码生成（若需要），规约时每个子表达式的树的结构总是在此表达式的根节点保持不变（被删除前保证表达式总是对应一颗树），且源于语法分析的节点名称不会被修改。
TermNode 中存储的值可引用其它节点共享部分数据形成 DAG(@4.2.7) 。当前节点不直接被共享，值数据成员可能共享数据。
因为节点可能被共享，在被引用节点的意义上的规约为图规约(tree reduction) ，但这不属于一般的规约规则。
注意实现应避免形成非 DAG 的共享，以保证不出现资源的所有权(@4.2.5.3) 的冲突。
使用 TermNode 进行处理时，若子节点的分配器(@6.4.1) 和所在的项的分配器不相等，则涉及子节点容器的交换操作（包括 swap 及 TermNode::SwapContent ）的行为未定义，参见关于分配器相等性的前置条件(@6.4.1.1) 。

@6.2.1 项节点结构分类：
节点容器的内容被视为子节点按迭代顺序确定的有限的序列。
当这些序列中的每个节点表示一等对象时，即构成无环列表(acyclic list) 的表示。每个节点表示(@6.3) 列表的元素(element) 。
推论：列表对其元素具有所有权。
无环列表不包含环(cycle) 。
若节点的值数据成员同时为空值（即 ValueObject() ），则节点表示真列表(@5.5.2) 。
真列表是列表(@5.5.2) 。节点可表示同属列表的非真列表(@5.5.2) 。
列表的元素有限，同一个列表的不同元素之间不具有相互的所有权，生存期不相交。
按内容的结构，项节点具有如下互斥的基本分类（使用 TermNode 的 empty() 判断）：
枝节点(branch node) 或非叶节点，即具有子节点的节点，表示非空列表或同时具有子节点和叶节点的非正规(@6.2.1) 的非列表；
叶节点(leaf node) ，即不具有子节点的节点，表示空列表或不具有子节点的正规的(@6.2.1) 非列表。
按表示的内容，项节点可进一步使用其它谓词判断其分类：
列表节点(list node) 是值数据成员为空的节点；
空节点(empty node) 同时是叶节点和列表节点；
分支列表节点(branched list node) 同时是枝节点和列表节点；
扩展列表节点(extended list node) 是枝节点或列表节点。
正规节点(regular node) 是叶节点或列表节点。
注意扩展的列表节点可能同时具有子节点和非空的值数据成员。
进一步地，节点可按子节点数（使用 TermNode 的 size() 结果判断）按需进行扩展分类。
列表节点对应对象语言的列表类型。作为列表节点的 TermNode 是对象语言中列表类型的宿主类型(@5.3.1) 。
考虑 TermNode 的值数据成员是否为空及其实际持有对象的动态类型等，具体实现 API 可约定使用不同的具体结构分类。
因为次级分类不一定是互斥的，所以可能需要约定对节点的操作顺序以确保结果一致，作为被规约项时典型地可能有以下几种情形：
先判断是否为枝节点，再判断是否为符合预期类型的非空叶节点，分派不同的操作；
根据项表示的值(@4.1) 考虑子节点及值数据成员。
**注释**
真列表以外的其它形式的一般列表数据结构及其表示参见真列表以外的其它列表(@6.3.7.1) 。
如 Scheme 和 Kernel 中可能有环的非真列表不被支持。原理参见循环引用(@4.2.7) 。
关于规约后的一般表示，参见正规表示(@6.10.6) 。

@6.2.2 项的标签：
枚举 TermTagIndices 和枚举 TermTags 作为索引和对应的掩码提供项使用的标签作为特定的对象表示。
TermTags 是表示对象属性的标签(@5.6.8) 和其它实现内部使用的值的集合。
每个项中包含一个 TermTags 对象作为标签数据供用户程序使用。
标签符合 ISO C++ [bitmask.types] 定义的位掩码(bitmask) 类型。TermTagIndices 是位掩码的索引。
没有没有设置任何掩码位的默认值是 Unqualified ：非限定对象。
TermTags 中的枚举项对应取值不相等的索引，表示的标签主要有：
	Unique ：唯一引用(@5.8.3.4) 。
	Nonmodifying ：不可修改(@5.8.3.4) 。
	Temporary ：临时对象(@5.8.5) 。
	Sticky ：粘滞位，不构成单独的一等对象表示(@6.3.2) ，用于特定的对象的表示的一部分(@6.3.7.1) 。
为互操作目的，实现假定引用值以外的对象不具有指定唯一引用或不可修改属性的标签。
在 TermTagIndices 中的枚举项带有 Index 后缀，和这些枚举项一一对应。
当前标签值都和引用值(@5.8.3) 的对象访问对应的含义相关，参见引用值的属性(@5.8.3.4) 。
**注释**
关于标签的假定允许实现在不同上下文（引用值或非引用值）复用相同二进制表示的标签以压缩占用的存储空间。这可能以对扩展对象属性规则的派生实现的兼容性为代价。

@6.2.2.1 标签值使用范围约定：
除非另行指定，标签值被初始化为默认值（非限定对象）。
模块 SContext 不修改项中的标签，保持为默认值。
默认值以外的标签仅用于：
NPLA 项引用(@5.8.3.8) 及其元数据(@6.8.3.1) ；
对临时对象标签，被绑定对象(@5.7.1) 中表示临时对象(@5.8.5) 的项；
派生实现指定的不表示对象语言的值(@4.1) 的项或者其它宿主对象(@6.3.3) 中具有的标签。
**注释**
当前设计中：
对象语言的表示值的项的标签总是默认值(@6.3) ；
临时对象标签仅在特定的值和项引用(@5.8.3.8) 标签中存在；
不表示对象语言的值的求值的中间表示(@6.3) 可能引入标签，参见 A1::ReduceCombined(@7.6.4.2) 。
关于被绑定对象的标签，参见绑定临时对象标签(@5.8.5.5) 和临时对象的表示(5.8.5.6) 。
**注释**
另见绑定操作(@7.7.3) 关于临时对象标签的描述(@7.7.3.2) 。

@6.2.3 项节点访问：
TermNode 中，值数据成员可直接访问。
修改值数据成员可直接赋值，但也可能使用其它辅助的成员（如 SetValue ）简化访问（如需要使用分配器(@6.4.1) 时）。
模块 SContext 在类 TermNode 外还提供其它访问项节点的 API 。
命名空间 NPL 中，TermNode 在类定义外提供关于节点内容的辅助 API 简化操作，以 Doxygen 命令标识为 \relates TermNode 。
其中，判断项节点分类(@6.2.1) 的谓词以 Is 前缀起始。
根据是否存在子项和非空的值数据成员的分类谓词包括：
IsBranch
IsBranchedList
IsEmpty
IsExtendedList
IsLeaf
IsList
按以上基本分类和第一个子项（若存在）的粘滞位(@6.2.2) ，提供以下扩展分类谓词：
IsAtom
IsPair
判断特定结构的列表可使用以下谓词：
IsSingleElementList
判断值数据成员(@6.2) 具有的类型或值的模板以 Is 或 Has 起始：
IsTyped
IsTypedRegular
HasValue
一些 API 专用于查找或判断标签包含粘滞位的项：
函数模板 FindSticky
函数 FindStickySubterm
函数 HasStickySubterm
函数模板 NPL::Access 和 NPL::AccessPtr 访问值数据成员中持有对象的引用或指针。重载兼容 TermNode 和 ValueNode 。
其余 API 包括：
函数模板 NPL::TraverseSubnodes
以上操作通常仅在不涉及语义（仅涉及语法，或更基本的底层操作实现）时使用其访问项中非列表类型(@6.2.1) 的值。
涉及更具体的语义时，使用项访问操作(@6.9.2) 、项引用和项引用访问操作(@6.9.3) 的 NPLA API 代替。这些接口提供了确切的项结构检查以符合正规化表示的相关假设(@6.10.6.1) 。
**原理**
原子节点定义为不能表示为一等对象有序对(@6.3.7.1) 的节点表示。其命名来自传统 Lisp 的原子谓词。在这个定义下，原子谓词判断的原子数据类型和有序对类型互补。
这和多数 Lisp 方言中对原子节点谓词的定义一致。仅有少数方言如 InterLisp 存在不是原子也不是有序对的数据类型。
**注释**
修改值数据成员为环境引用的宿主类型(@6.8.2) 和项引用(@5.8.3.8) 的值通常使用成员 SetValue ，且在合适时使用 in_place_type 实例参数。
另见典型分配器使用(@6.4.1.4) 。
关于原子谓词在 Lisp 方言中的兼容性的注释，另见 https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node73.html 。

@6.3 表达式和对象的表示(@1.2.4) ：
NPLA 表达式及其求值过程中得到的值以 TermNode(@6.2) 表示。
其中，TermNode 中的子项和值数据成员(@6.2) 可构成表示的一部分。
用于表示表达式的 TermNode(@6.2) 对象称为表达式项(expression term) 。
TermNode 的子项(@6.2) 在表达式项中作为子表达式(@3.4.2) 的实现。
派生实现应满足这些本节约定的作为不变量。若互操作(@5.3) 违反此不变量，程序的行为未定义(@5.4) 。
另见引用值的表示(@5.8.3.8) 和临时对象的表示(@5.8.5.6) 。
其中，引用项是值数据成员为项引用(@6.8.3) 对象的项。
关于子对象引用项的具体构成，另见 @6.3.7.2 。
对实现作为一等对象(@4.1) 的列表(@6.2.1) 的引用(@4.2.6) ，支持引用整个项的中间值是必要的；但项引用也支持引用非列表项。
**原理**
NPLA-GA(@3.4.5) 允许使用表达式作为 IR 的基本元素。
其它一些不符合类似性质的高级语言的实现可能在内部采用类似的结构。
例如，GCC 在前端后不从表达式区分语句。参见：https://gcc.gnu.org/pub/gcc/summit/2003/Tree%20SSA%20-%20A%20New%20optimization%20infrastructure.pdf 。

@6.3.1 值类别：
表达式项(@6.3) 及在表达式求值规约中得到的项具有表达式的值类别(@5.8.1) 。
作为名称表达式(@4.5.1) 明确引用直接存储在环境中的对象及其包含的（数据成员）子对象(@5.6.7) 的项都是左值。
右值一般存储在环境以外的项上；必要时，实现可能存储右值在特定的环境中。
在类型的值的内部表示上，值类别和特定的类型相关：
NPLA 支持的左值都是项引用(@5.8.3.8) ，这同时表示引用值(@5.8.3) 。
NPLA 一等对象的值的类型和它作为表达式项的值类别存在以下一一对应关系：
若类型是引用，则对应的值类别是泛左值；否则，对应的值类别是右值。
引用值的不同类型指定更精确的具体对应关系(@5.8.3.9) 。
**原理**
使用类型是否具有特定的引用值确定表达式的值类别简化许多设计，至少包括：
避免要求针对表达式是否具有引用类型时添加转发到非引用类型上的特殊规则，使引用类型实质上不能作为一等的类型；
避免作为类型系统的值类别和其它的类型的共存的概念定义和一般理论的不一致(@5.8.1.1) 。
早期 [WG21 N0130] 曾提案合并 C++ 的左值性（值类别的前身）和表达式的引用类型，但没有被 ISO C++ 接受。
ISO C++ 至今仍不把引用类型作为一等的类型，在一般表达式的类型上调整(adjust) 非引用类型，除非特定的上下文要求引用类型。
从 ISO C 上添加引用类型的历史过程看，这个设计是自然的，并且通过排除上下文添加例外的方式和 ISO C 的左值转换(lvalue conversion) 的方式一致。但类型系统上的冗余问题一直没有解决，即便 ISO C++ 现在完全独立 ISO C 描述这些规则。
作为不需要适应其它不完善的历史设计的语言，不应采取这种设计。
另一方面，表达式和变量的类型仍然被区分，后者原则上仅对清单类型有意义(@4.7.3) 。NPLA 和 NPLA1 不要求在语言的全局设计中引入变量类型。

@6.3.1.1 值的标签：
因为 NPLA 使用潜在类型(@5.2.6) ，表达式不保证提供静态类型(@4.7) 能编码值类别和类型信息；作为替代，这些信息通过规约范式中的项的标签保存。其中：
TermTags::Unique 指定特定的值类别（消亡值(@5.8.1) ）；
TermTags::Nonmodifying 指定特定的限定类型；
TermTags::Temporary 指定具有特定的值类别（纯右值）的引用值，或引用这些临时对象的项引用。
表示一等对象的值的项(@6.3) 中的标签可跟随一等对象传递。
可表示一等对象的值的标签值是表示一等对象的值的项的标签中可能具有的标签值。

@6.3.2 一等对象的表示：
一部分项可以作为对象语言中的一等对象或值的表示(@1.2.4) ，即一等对象表示。
一等对象的内部表示(@1.2.2) 应具有一等对象表示。
由标签的使用范围(@6.2.2.1) 的推论，表示一等对象的值的项不具有默认值外的标签(@6.2.2) 。
**注释** 一等对象也包括对象语言中可访问的列表的元素。因此，这些列表项的子节点也不具有默认值外的标签。
TermNode 还可能表示求值的中间结果（即求值规约中取得对象语言表达式的值之前出现的值），如表示某些中间值(@6.8) 的情形。
除非也作为一等对象的表示，NPLA 的规约范式(@6.10.3) 不使用中间值表示。
NPLA 允许（但不要求对象语言支持）以一等对象作为表达式的表示并被求值。

@6.3.3 宿主表示：
宿主语言中，具有宿主类型的值不一定表示对象语言的值，而不一定是宿主值(@5.3.1) 。
宿主值可对应 TermNode 的值数据成员和子节点中的各个值数据成员中所有被擦除类型存储的对象，即宿主对象(@5.3.1)。
典型情况下，TermNode 的值数据成员对应单一的宿主值。
除非另行指定，类型映射(@5.3.1) 的值是单一的宿主值。
本机实现的支持互操作(@5.3) 的接口约束（前置条件）应能明确接受的宿主值的值域。
没有对应对象语言表示的（在宿主语言可见而对象语言中不可见的）宿主值不符合约束，可能被检查。这种检查可指定为断言或异常。

@6.3.4 项的整体转移：
规约可引起项的转移(@5.8.2.4) ：包含宿主对象(@6.3.3) 的被规约项(@6.2) 被整体转移，而避免其中包含的对象的初始化在对象语言中具有可见的作用。
这包括：
以 TermNode 对象的形式使其子项和值数据成员被转移（转移后的项具有有效但未指定的状态(@5.6.3) 但不可在对象语言中被访问）；
以未指定的其它实现相关的方式使 TermNode 成为其它节点的子项（不存在转移后的项）。
和对象的转移(@5.8.2.3) 不同，因为被转移的对象的生存期结束，项的转移不保证被转移后的项中的对象的类型不改变。
除了不初始化新的对象和使被转移项中对象的类型改变，项的转移在对象语言中效果可能类似宿主对象的转移。
项的转移保证不无效化(@6.2) 子项，也不转移或复制值数据成员(@6.2) 所有的宿主对象。
被转移对象后的项具有有效但未指定的状态(@5.6.3) ，允许实现为项的转移(@6.3.4) 。

@6.3.4.1 宿主对象转移消除：
项的转移也类似 ValueObject 自身的转移，其实现（当前通过 ValueObject 内部的 ystdex::any 的转移构造函数）保证直接转移对象而不保证转移构造所有的值。

@6.3.5 求值关联实体的表示：
待求值项(@4.4.1) 用 TermNode 对象表示。
其它被规约项(@4.4.1) 和求值结果(@4.1) 也用 TermNode 对象表示，以支持树规约(@6.2) 中直接基于项的替换操作实现求值。
求值结果可以是具有 TermNode 子节点的列表(@6.2.1) 数据结构，是对象语言的值(@4.1) 的表示。
其中，列表项的子节点表示列表的元素，是这个列表项表示的列表对象的子对象(@5.6.7) 。
**注释**
另见正规性(@6.3.6) 。

@6.3.6 规约表示：
表达式、表达式在求值过程中的中间表示（如中间值(@4.4.6.2) ）和求值结果的表示统称规约表示。
在规约时，上下文(@4.6) 蕴含当前待求值项(@6.3.5) ，在逻辑上确定当前被规约的 TermNode 对象。
规约表示按以下规则确定其正规性(regularity) ：
	若一个规约表示仅由（一个 TermNode 对象的）其中的子项或值数据成员之一确定，而其它部分是（初始化 TermNode 决定的）默认值，则这个规约表示是正规(regular) 的。
	其它规约表示是非正规(irregular) 的。
表达式的表示(@6.3.5) 是正规的。
推论：忽略列表(@6.2.1) 和非正规表示，对象语言的值的表示(@6.3.2) 仅由值数据成员决定。
空求值(@4.4.4) 的被求值表达式和求值结果的正规性相同。
平凡(trivial) 非正规表示保证可被（此次规约中剩余的步骤）安全忽略而不改变规约的语义。其它非正规表示是非平凡(non-trivial) 的。
作为正规表示的表达式项的值数据成员(@6.2) 称为正规值(regular value) 。
不论是否正规表示，项应可复制和转移，且不影响其中值的有效性。
推论：非正规表示中不能依赖特定对象的同一性（如值数据成员直接引用子项）。
**注释** 具体实现可使用等价的其它数据结构代替逻辑上确定的当前被规约的 TermNode 对象。
除少数例外(@6.3.7) ，NPLA 表达式求值取得的范式(@4.4.5) 总是其表示（一个 TermNode 对象）中的子项或值数据成员之一，详见正规化(regularization) 操作(@6.10.6.1) 。
作为 NPL 语义(@4) 的扩展，作用于非表达式项上的规约规则不是求值规则。

@6.3.7 非平凡(@6.3.6) 非正规表示：
NPLA 非正规表示应符合以下约定，否则行为未定义：
带有粘滞位(@6.2.2) 的标签仅在非平凡非正规表示中的子项中出现；
规约中，只存在受支持的非平凡非正规的规约表示。
NPLA 仅支持本节中的以下非平凡非正规的规约表示。
派生实现可另行指定支持不和以上规则冲突的其它非平凡非正规表示。
除非另行指定，本文档以下的非正规表示指非平凡非正规表示。
**原理**
NPLA 实现可假定不符合要求的规约表示不存在，以确保较高效的实现。
对粘滞位标签的限制确保可使用值数据成员非空判断不是真列表。同时，IsList(@6.2.3) 的实现不需要访问标签。
非平凡非正规表示相对正规表示一般需要较大的构造和其它处理开销。使用非平凡非正规表示的对象一般相对正规表示较少出现，而具体表示也允许简化正规表示的情形，因此开销可以接受。
具体的非正规表示参见以下各节的讨论。
**注释**
带有粘滞位的标签不在表示一等对象的项的标签中出现，但可在其子项的标签中出现。
在互操作的意义上(@5.3) ，若实现对表示是否满足本节约定进行检查，不论是否假定存在，都应作为接口约束，以允许派生实现可靠地复用和扩展其它形式的表示。

@6.3.7.1 无环非真列表的表示：
无环非真列表(@5.5.2) 是不属于其它情形的非正规表示可表示的一等对象，具有至少一个子项表示一等对象。
不考虑所有权时，无环非真列表总是能被表示为一个元素和一个非列表元素构成的有序对(@5.5.1) 。
类似真列表(@6.2.1) ：
无环非真列表不支持环；
无环非真列表对其中的元素具有所有权，但其中的元素的销毁和释放顺序未指定。
除最后一个元素外，无环非真列表的元素依次由表示无环非真列表的项的子项表示。
若最后一个元素能以单一的 ValueObject 值表示，则表示无环非真列表的项的值数据成员是这个元素的表示；
否则，表示无环非真列表的项子项中的若干个后缀和值数据成员是这个元素的表示，其中第一个子项的标签具有粘滞位(@6.2.2) 。
表示一个无环非真列表的节点在具有粘滞位的子项前的子项是它的子节点前缀(prefix) 。其它节点的所有子项是它的子节点前缀。
推论：列表的前缀元素(@5.5.2) 是表示它的项节点的子节点前缀对应表示的元素，即其中忽略非列表有序对最后元素后的剩余元素。
**原理**
区分有序对和其它非平凡非正规表示可直接通过检查项中是否存在带有粘滞位的第一个子项。这一操作的时间复杂度是 O(1) 。
对象的前缀元素(@5.5.2) 是列表的前缀元素的保守扩展。两者的表示和 TermNode 子节点前缀对应。
预期非真列表相对真列表较少出现，因此和 cons 对为基础的传统 Lisp 不同，使真列表具有更简单的结构能减小初始化数据结构的整体的开销。
**注释**
cons 对的所有权及初始化和销毁的相对顺序和仍遵循作为其表示的项节点对其子对象的关系。

@6.3.7.2 子对象引用的表示：
子对象引用项(@5.8.3.8) 中，值数据成员持有 NPL::TermReference(@6.8.3) 类型的值，保留某个子项的引用。
子对象引用的项的子项数应为 1 ，该子项持有 shared_ptr 的实例的非空值且其指向的对象和值数据成员持有的 NPL::TermReference 值的 get() 结果应引用同一个 TermNode 对象。
**原理**
子对象引用使用的这种形式的表示通常因为需要更多的操作比其它引用值的类似操作低效，但这种表示可避免依赖宿主语言中的本机对象内部表示（如成员布局）的依赖。
一般地，在 C++ 的意义上不存在能满足语义要求且总是更简单高效的可移植表示，所以这种表示在和宿主语言的互操作上是必要的。
子对象引用的表示使用项引用，因此要求被引用对象具有一等对象表示。这同时允许子对象引用的被引用对象被提升得到一等对象。
使用 shared_ptr 的实例间接持有项，以满足项引用(@5.8.3.8) 对被引用对象作为一等对象的要求。
**注释**
典型地，子对象引用通过一个引用值构造，得到引用值的被引用对象的子对象的引用。
子对象引用的项不表示一等对象，但 shared_ptr 的实例的值指向的项具有一等对象表示(@6.3.2) 。

@6.3.7.3 带有记号值的非空列表：
表达式在求值过程中的中间表示可在非空列表的表示的基础上，用值数据成员附加记号值的表示作为辅助信息。
**注释**
非空列表满足 IsBranch(@6.2.3) 。

@6.4 资源管理：
NPLA 的实现约定统一的资源管理语义，并以此支持存储和对象模型(@5.6) 。
除非另行指定（如明确资源被共享使用），NPLA API 提供类型的对象按值传递(@4.4.6.5) 传递资源所有权（复制或转移资源）。
违反 NPLA 资源管理要求可引起宿主语言的未定义行为(@5.4) 并违反 NPLA 内存安全保证(@5.6.4.3) 。
基本的资源所有权约束由宿主语言的规则蕴含。
部分数据结构可有更进一步的上下文相关的约定，如 TermNode 对象在作为被归约项(@6.2) 和被绑定对象(@6.11.1) 时具有不同的规则（参见有关的所有权规则(@5.6.3.1) ）。
关于实现支持的间接值(@5.6.2) 访问和管理的特定的资源，详见间接值分类和所有权(@6.4.3) 。

@6.4.1 分配器(allocator) ：
分配器分配资源，用于提供供实现指定的宿主语言的存储资源的来源。这和对象语言的存储资源(@5.6) 管理机制类似，但不保证对应。
分配器隐含在被映射的类型中，不显式出现在对象语言。
NPLA 中的分配器具有可和 TermNode::allocator_type 互相隐式转换的类型，接受 YSLib::pmr::memory_resource 类型的存储资源。
这些分配器通常来自 TermNode(@6.2) 、ContextNode(@6.11.3) 的存储资源以及 NPL::BindingMap(@6.11.1.1) 的分配器，用于这些类型和 NPL::EnvironmentList(@6.11.1.1) 以及其它被运行时使用相同存储资源管理的项中的对象的初始化。
NPLA 和派生实现的本机实现(@5.3) 应保证分配器的使用符合以下小节的约定。

@6.4.1.1 相等性要求：
除非另行指定，对 ValueObject 等支持不同目标类型(@6.2) 的对象，可选地使用分配器。一般地，这表示不使用运行时检查分配器类型相等的带有分配器参数的复制或转移构造函数。
预期来自等价存储资源的分配器应相等，以避免分配器不相等的容器交换操作引起行为未定义（如 TermNode 交换，参见 @6.2 ）。
由 C++ 分配器要求，分配一个宿主语言对象时使用的分配器和其它特定分配器之间的相等性此宿主语言对象的生存期中确定不变。
以下关于 TermNode 的分配器相等性是 API 隐含的：
TermNode::Container 满足 C++ 标准库容器的分配器感知(allocator-aware) 要求，容器和作为容器元素的子节点使用的分配器相等；
TermNode::get_allocator 决定 TermNode 的分配器等价 TermNode 中的节点容器的分配器。
以下情形的分配器在实现中应保证相等：
由同一个 ContextNode 对象决定的分配器在 ContextNode 生存期内应相等（且通常使用这些分配器的对象的生存期是此生存期的子集）；
若分配器来自超过一个宿主语言对象，这些对象提供的分配器应相等。
一般地，以下关于 TermNode 的分配器之间不保证相等性：
TermNode 对象和它的值数据成员(@6.2) 的分配器；
TermNode 的值数据成员和其中持有的对象可能具有的分配器。

@6.4.1.2 分配器来源：
宿主语言对象的分配器可通过从存储资源初始化或由其它对象使用的分配器复制初始化取得。
部分类型（如 ContextNode ）的对象初始化可接受存储资源参数。提供实际参数作为存储资源的用户代码应适当维护被引用的存储，确保这些对象的生存期是存储资源的生存期的子集，以避免引用已释放的存储而引起宿主语言的未定义行为(@5.4) 。
NPLA 使用的多态分配器可保证分配器和初始化分配器的存储资源的对应。但若已存在可用的分配器，取分配器的副本而不是使用存储资源初始化新的分配器。
由 C++ 分配器要求，使用相等的分配器效果一致。但除非另行指定，若需要指定分配器，仍按以下规则（自上而下优先）尝试确定用于复制初始化的分配器的来源：
	引起表示对象语言的值(@6.3) 的 TermNode 对象创建时，若分配器必须依赖操作中的一个或若干个已知分配器相等的、表示对象语言的值的 TermNode 对象，后者中的任一个 TermNode 对象提供分配器。
	引起 TermNode 对象创建时，若这个对象被一个或多个其它 TermNode 对象共同所有，它的分配器以表示关联所有者的 TermNode 类型的值提供。
	引起 Environment 对象创建时，需要的分配器由关联的 NPL::BindingMap(@6.11.1.2) 的分配器提供。
		**注释** 参见 NPL::ToBindingsAllocator 和 NPL::AllocateEnvironment(@6.11.4.1) 。
	引起满足 allocator-aware 的容器要求的对象（至少支持迭代器和对其元素具有所有权）的元素的创建时，由符合容器要求的分配器提供。
	引起 ValueObject 的目标对象(@6.2) 通过复制初始化创建时，若需分配器且可通过源对象取得分配器，则分配器来自此对象。
	引起父环境(@5.7) 中的目标对象创建时：
		若通过现有父环境直接创建，则分配器等于现有父环境的分配器。
			**注释** 复制或转移初始化，不显式使用分配器。
		否则，若来自表示对象语言的值的 TermNode 对象，则分配器等于其中的分配器。
		否则，对象通过现有 ContextNode 对象创建，分配器等于现有对象的 ContextNode 的当前环境(@5.7.3) 关联的分配器。
			**注释** 参见 NPL::AssignParent(@6.11.4.3) 。
	创建 ContextNode 对象时：
		若通过现有 ContextNode 对象创建，分配器等于现有对象的 ContextNode 的分配器。
		否则，分配器应当使用特定的创建 ContextNode 的外部 C++ API 参数提供。
	其它情形的分配器对象由 ContextNode 的存储资源提供。
	否则，涉及指定分配器的 C++ API 应当指定使用的分配器。
按以上 Environment 对象创建规则，初始化 ContextNode 的分配器保证和其中的初始化的当前环境关联的分配器相同，但修改环境指针可使用具有不同分配器的环境对象。
	**注释** 两个分配器都来自 ContextNode 的存储资源，Environment 对象关联的 NPL::BindingMap 的分配器等于 ContextNode 经 NPL::ToBindingsAllocator 转换得到的分配器。
**注释**
实现可能需要显式指定的分配器，以满足相等性要求(@6.4.1.1) 或提供优化实现等。
可用的分配器始终满足操作的接口语义需要。
一般地，分配器的依赖性通过操作的接口语义和内部的实现限制判断。
表示对象语言的值的 TermNode 对象的一个典型例子是对象语言中函数的参数，引起创建的 TermNode 可作为对象语言中操作的结果。
对象被其它 TermNode 对象共同所有的主要情形是如节点的值被值数据成员所有，如非平凡非正规表示的子对象引用(@6.3.7.2) 。
涉及指定分配器的 C++ API 可能具有通过分配器形式参数的默认实际参数指定默认的分配器。

@6.4.1.3 取分配器的方式：
提供分配器的对象可能若干种隐式（如转移构造）或显式的方式决定被使用的分配器。
满足上述预期的分配器相等性能决定同一来源的不同方式取得的分配器相等时，取分配器使用的方式未指定，如：
一个表示对象语言的值(@6.3) 的 TermNode 对象提供分配器时，可直接取其分配器或子节点（若存在）的分配器。
否则，一般不能通用，如：
引起 TermNode 对象创建时，被初始化的值数据成员不能通过某个未知分配器来源也不具有相等性保证的被 ValueObject 值持有的对象取得。
**注释**
隐式使用的分配器可被默认初始化，如 TermNode::allocator_type 。
对 allocator-aware 等类型显式取对象分配器通常使用 get_allocator 调用，如 TermNode::get_allocator 。
不论是否使用分配器，都可能使用显式原地构造（如使用 YSLib::in_place_type 标记）创建对象，但直接复制或转移构造不使用原地构造。
参数直接转移时，可能不需要使用分配器（以确被构造的对象具有指定的分配器），此时一般不使用显式原地构造，以简化实现。
但是，特定的上下文中使用原地构造仍可能提升性能（可能和内联相关），因此不明确要求。

@6.4.1.4 典型分配器使用约定：
为实现风格的一致性和改进性能等质量目标，除满足以上各节的要求，NPLA 指定实现对一些常见的分配器使用的默认策略。
创建 ValueObject 对象时：
	复制 ValueObject 对象不显式使用分配器。
	TermNode::SetValue(@6.2.3) 对单一参数隐式使用分配器，当且仅当实际参数不是 ValueObject 左值或右值。
		隐式使用分配器时分配器来自 TermNode 对象，作为构造 ValueObject 对象的显式分配器。除非需使用其它分配器，不再在调用 TermNode::SetValue 使用显式分配器。
创建容器和保存容器的类型的对象时：
	复制 TermNode 、TermNode::Container 和其它 TermNode 的容器类型的对象显式使用分配器。
		**注释** TermNode 的复制构造函数总是使用被复制对象的分配器作为新创建的容器的分配器。TermNode::Container 需要显式指定分配器。
其它默认情形：
	无法使用分配器创建的对象不使用分配器，除非依赖可能使用分配器创建的对象的类型。
		**注释** 例如数组和不满足分配器感知的容器(@6.4.1.1) 的对象。
		仍可使用 ystdex::make_obj_using_allocator 等方式依赖可能使用分配器创建的类型，同时兼容创建可能和不能使用分配器的对象。
	创建缺少分配器分配收益的较小的类型的对象不显式使用分配器。
		bool 、算术类型、对象指针和枚举等标量(scalar) 类型在典型语言实现中复制开销较小的平凡(trivial) 类型视为此处的较小的类型。
		数组和容器类型不视为此处较小的类型。
			**注释** 但其中部分对象无法使用分配器创建。
		shared_ptr 、weak_ptr(@6.1.3) 的实例和 NPL::EnvironmentReference(@6.8.2) 不被视为此处较小的类型。
		基于 string 等典型实现中默认可能避免附加分配的类型也被视为较小的类型。
	转移对象不使用分配器。
		**注释** TermNode 等类型仍提供带有分配器参数的转移构造函数，以便必要时可使用分配器。这通常不保证性能最优。
	其它情形可使用分配器的情形总是使用分配器。
**注释**
若有必要（例如可重现的更好的性能），实现可以使用其它策略，但一般建议明确指出原因以避免风格混淆。
另见项节点访问(@6.2.3) 。

@6.4.2 值所有权：
TermNode 对构成值的表示(@6.3) 的子节点和值数据成员(@6.2) 具有所有权。和 @6.2 不同，非直接的所有权可能不是独占的。
TermNode 表示对象语言中一等对象的所有权规则符合求值和对象所有权(@5.6.3) 规则，且作为被归约项时，符合项对象和关联对象所有权(@5.6.3.1) 或派生实现指定的其它规则的所有权约束。
值对宿主对象(@6.3.3) 的所有权的机制由值数据成员（具有 ValueObject 类型）相关的 API 提供。
默认使用的 ValueObject 使用值的持有者 YSLib::ValueHolder ，直接作为对象的表示(@6.3) ，同时具有对象的所有权。
引用一个项可能有多种方式，不具有所有权。关于引用相关的值的所有权，参见以下各个小节。

@6.4.3 NPLA 间接值实现：
在 NPLA 对象语言公开接口约定的间接值(@5.6.2) 的基础上，本节约定实现定义的分类、所有权和具体使用规则。
使用 ValueObject 的特定持有者或约定特定的中间值(@6.8) 实现间接值允许和所有权分离的其它形式的表示，提供和非间接值不同的对象所有权和附加操作。
部分 NPLA API 可能引入间接值(@6.9.4.2) 。
实现通过值数据成员以外的机制也可隐含固定（不通过用户代码修改定制）的涉及间接值的所有权关系，如上下文(@6.11.3) 和环境(@6.11.1) 。
间接值所有权机制和中间值(@6.8) 正交：具有间接值的对象可能作为中间值，也可能不作为中间值。
本节以下小节定义除了 NPLA 一等对象间接值(@5.6.2) 外要求被 NPLA 实现支持的间接值。

@6.4.3.1 引用持有者：
使用持有者 YSLib::RefHolder 的实例可实现间接值，访问其它 ValueObject 对象。
被间接引用的值的类型和 TermNode 的值数据成员(@6.2) 取得的类型一致，可直接替换非间接引用的对象。
**注释**
引用持有者一般并不能替代引用值(@5.6.2.3) ，因为持有者仅影响存储来源和所有权，不区分类型，也无法要求用户代码使用明确的引用操作。
一般引用的持有者的项仅作为上述明确的引用操作的结果，作为中间结果继续以和非间接值一致的方式被规约（使用 NPL::LiftTermRef(@6.9.4.2) ）。

@6.4.3.2 非引用值间接值：
规约实现在特定情形的求值中使用 NPL::LiftTermRef 等(@6.9.4.2) 引入基于引用持有者(@6.4.3.1) 的间接值避免求值时改变泛左值(@5.8.1) 标识的非临时对象的所有权。
否则，引入的间接值引用环境所有的对象。
应注意存储环境以外的间接值时，不超出持有对象的存储期，避免未定义行为(@5.6) 。当前实现不对此附加检查。
注意不求值而仅替换项时，使用 NPL::LiftOther 或 NPL::LiftTerm(@6.9.4.1) ，这不引入间接值。
除构造间接值的例程(@6.9.4) ，当前不直接引入引用持有者。
如需要引入环境引用(@5.6.2.2) 外的间接值，一般使用引用值(@5.8.3) 而不是非引用值间接值，以统一处理无法直接持有的列表项和非列表项的引用。

@6.4.4 被归约项稳定性：
基于 TermNode 的性质，未被规约修改的项的子项的迭代器、指针和引用保持稳定(@6.2) 。
被规约项在取得求值结果(@6.10.1) 前不被删除，以避免项的迭代器、指针和引用失效。
结合 @4.2.7.1 得到推论：被规约项在取得求值结果起可被非内部对象(@4.2.7.1) 引用。
由 @5.6.1 ，项中的值数据成员(@6.2) 表示的宿主对象(@6.3.3) 保持固定。
子项的稳定性保证只要被规约的整个项不被作为对象被引用，直接转移被规约项仍保持子项中的宿主对象保持固定。
子项不直接保证其它稳定性。
在取得求值结果前，若项不改变可观察行为(@4.1.3)（例如，项不被作为对象语言中的表达式或求值结果的表示(@6.3) 或表示的值在对象语言中不可见），可能被转移。
这允许规约的本机实现内部在取得求值结果前保存表示不属于求值结果的中间结果的子项。

@6.4.4.1 规约操作资源：
规约时保持决定当前规约操作的状态的资源的独占所有权([Documentation::CommonRules @@1.2.4.6]) 的项应具有足够长的生存期，以避免调用时引起未定义行为。
实现 WHNF(@4.4.5.1) 时，第一个子项对此资源具有独占所有权。
在无法预知子项是否需要被进一步使用而不会在被调用前另行存储包含这些资源的项时，实现使用的操作应避免删除这里的子项（对实现 WHNF 而言即第一个子项），以免无法使用其中的状态。

@6.4.4.2 临时对象资源：
表示临时对象的项的子项的迭代器、指针和引用应保持稳定，以支持子项被绑定到对象语言中的引用值(@5.8.3) 。
表示临时对象的项自身不需被绑定到引用值，不保证稳定，可被直接存储为 TermNode（而不需要保存为指针等间接值）。
对临时对象分配资源可能转移表示临时对象的项，但不影响其子项的稳定性。

@6.4.5 项修改限制：
若规约需调整项的结构以便使用特定 API ，可使用 TermNode& 作为参数的规约函数(@6.10.5)（另见规约函数形式约定(@6.10.5) ）；
如不可行，一般需转移到新创建的项上进行调用，以免改变现有的项导致无法使用项独占所有权的资源（如 @6.4.4.1 的状态）。
单独转移可能具有宿主类型对象的子项会违反固定对象的约定(@6.4.4) ，因此除非确保子项不被引用，不单独转移或销毁可能带有宿主对象(@6.3.3) 的子项（包括引起子项对象被销毁的删除操作）。
若规约内部确定符合内存安全(@5.6.4) 或派生实现指定的假定满足的条件（至少应满足 @6.4 中的资源管理要求），子项可被转移或销毁。这些操作包括：
被规约项取得自求值结果起，在非内部对象引用此项前被整体转移的操作；
NPLA 指定删除或其它可能转移或销毁子项的操作；
派生实现指定的其它要求假定或可证明安全的操作。
其它情形应避免这类操作。特别地，一般应避免在被处理的 TermNode 上直接调用 RemoveHead(@6.2) 。

@6.5 异常处理：
异常处理在模块 Exception 声明。
NPL::NPLException 是 NPL 实现的异常基类。
其它 NPL 异常都从此类直接或间接派生。
这些异常类在 NPLA 模块中以 Doxygen 命令标识为 \ingroup exceptions 。
NPL 异常可能使用分配器(@6.4.1) 或依赖全局状态(@7.8) 实例内部的资源，需注意资源生存期并在必要时修改或复制异常重新抛出。
函数模板 NPL::GuardExceptionsForAllocator 替换可能抛出的 NPL 异常对象的分配器。
一般地，使用确切的异常类型以明确更具体的错误条件，如列表类型(@6.2.1) 错误代替一般的类型错误(@4.7.4) 。
除非规约节点操作(@6.15.2.1) 外，NPLA 实现可能抛出这些异常或派生实现定义的派生这些类的其它异常。
NPLA 实现可能抛出标准库异常。
一般地，不通过对象语言构造（而仅通过互操作(@5.3) 或实现缺陷）引起的异常（如检查宿主值(@6.3.3) 的值域(@6.3.3) ），不使用 NPL 异常基类。

@6.5.1 助手函数：
下列可能重载的函数帮助抛出异常：
NPL::ThrowInsufficientTermsError
NPL::ThrowListTypeErrorForAtom
NPL::ThrowListTypeErrorForInvalidType
NPL::ThrowListTypeErrorForNonList
NPL::ThrowTypeErrorForInvalidType
部分异常的消息由 NPLA 辅助项访问操作(@6.9.2) 格式化。

@6.6 词法类别支持：
在 NPLA 模块中以 Doxygen 命令标识为 \ingroup LexicalCategory 。

@6.7 规约相关类型别名：

@6.7.1 记号值：
参见 NPLA 记号值(@6.8.1) 。

@6.7.2 锚对象(@6.8.2) 指针：
NPL::AnchorPtr 是锚对象的指针的类型，是不确定类型的 shared_ptr 实例。
相关接口详见上下文 API(@6.11.3.1) 。

@6.8 NPLA 中间值：
中间值(@4.4.6.2) 可在 TermNode 的值数据成员(@6.2) 中存储。
和具体求值(@4.1) 的求值结果(@4.1) 及其它情形存储的对象不同，中间值可能参与特定的规约作为求值的中间步骤的表示。
为允许区分中间值和被映射的其它值，约定中间值具有特定的类型。但以中间值引入的类型，其值仍可能作为求值结果。后者实质被对象语言作为一等对象(@4.1) ，称为一等中间值(first-class thunk) 。
NPLA 提供名义(nominal) 中间值，即不是其它 NPLA 外类型的别名的类型，但这些类型考虑由其它类型转换或构造。
派生实现不提供不依赖于非 NPLA 和 NPLA 实现定义的类型的别名作为非名义中间值类型，即若提供非名义中间值类型，应为参数化类型，且其中至少包含一个实现自定义的类型作为模板实际参数。
其中：
记号值(@6.8.1) 构成的项可表示未求值的表达式。
记号值和项引用(@5.8.3.8) 可作为某些对象语言的表达式的表示(@6.3) 。
NPLA 扩展中间值(extended thunk) 是其它由派生实现定义的其它中间值。

@6.8.1 记号值(token value) ：
NPL::TokenValue 类型的值表示记号(@3.3.1) ，可使用 string 类型的值构造，记号值类型。
由类型映射(@5.3.1) ，记号值对应的词素(@3.3.1) 作为名称，宿主类型为 string 。记号值对应的词素的宿主值和构造记号的 string 类型的值相等。
记号值和词素在逻辑上非空，但因为除翻译单元外的外部表示(@1.2.4) 一般未指定(@4.1.1) ，不保证在 API 中取得的这些类型对应非空串，因此除特定的内部实现外不省略空串检查。
和字符串值不同，记号值求值的结果不会继续是记号值，以避免不经意的递归求值或无法和宿主语言字符串值区分的情形出现。
但在 API 层次上，记号值的求值不排除无限循环或递归，不保证对应的项作为表达式时具有强规范化性质(@4.4.5)。实现需注意保证作为名称表达式时满足强规范化要求(@5.2) 。
符号(@5.5.3) 的宿主类型(@5.3.1) 是 NPL::TokenValue 。符号值可作为一等中间值。
和 Kernel 类似，NPL 设计强调区分程序是否被求值的差异。符号是引入和表示为自求值项(@4.4.5) 的其它表达式的关键数据类型。
符号可能有外部表示。以未求值的记号值作为符号是其和外部表示关联的设计。由于外部表示未指定，这种关联是有限的。记号值蕴含了词素和符号的映射关系，即源代码文本；其余关系（包括源代码支持的文本编码）由派生实现指定。
记号值的相等性等价其对应的词素的相等性。
记号值可出现在词法分析(@6.1.5) 阶段，由单独的规约过程(@6.10.4) 通过调用 NPL::TokenizeTerm(@6.9.2) 转换词素或直接初始化分析的中间结果得到。
调用 NPL::TermToNamePtr(@6.9.2) 访问具有记号值的名称节点对应的字符串。
符号可能是空值，尽管语法上不能通过记号值从词法分析得到。
**注释** 不能通过通常词法分析得到的符号，一般可通过空的代码字面量(@5.2.4) 或其它数据转换得到。

@6.8.2 环境引用：
环境引用是引用 Environment 类型(@6.11.1) 的环境记录(@5.7.1) 并支持其共享所有权(@5.6.3) 的中间值。
环境引用类似引用值(@5.8.3) ，但隐含更复杂的所有权关系，因此不具有相同的类型(@5.8.6) 。
shared_ptr<Environment> 可引用环境对象，其非空值作为环境强引用(@6.11.1) 。
NPL::EnvironmentReference 可引用环境对象，封装 weak_ptr<Environment> 和锚对象(anchor object) 指针，其非空值表示可能具有共享所有权的环境弱引用(@6.11.1) 。
环境对象的弱引用的所有权关系使用其中的 weak_ptr<Environment> 确定。
因为 weak_ptr<Environment> 不提供可靠的弱引用计数，引用锚对象附加的引用计数用于确定弱引用的数量，详见上下文 API(@6.11.3.1) 。
默认构造的 shared_ptr<Environment> 是空的环境引用。
默认构造的 NPL::EnvironmentReference 具有空的 weak_ptr<Environment> 值，是空的环境引用。
非空的 shared_ptr<Environment> 和 NPL::EnvironmentReference 分别可作为对象语言的环境强引用和环境弱引用的宿主值。
预期作为表达式或一等对象的表示(@6.3.2) 的宿主值时，这些值应非空，这可通过接口约束被检查(@6.3) 。
NPL::EnvironmentReference 值通过锁定后取得的 shared_ptr<Environment> 值确定是否为空值。
因为当前实现不保证这些值在多线程环境下蕴含同步操作，存在数据竞争时行为未定义，可忽略并发访问冲突。
NPL::EnvironmentReference 可使用空 shared_ptr<Environment> 值初始化，此时锚对象指针为空指针值；否则，锚对象指针和指向的环境(@6.11.1.2) 的关联的值共享。
NPL::EnvironmentReference 也可显式分别初始化 weak_ptr<Environment> 和锚对象指针，此时不需要附加空指针检查，在确定环境存在时更高效。但调用者应确保锚对象关联的引用和 weak_ptr<Environment> 引用的环境共享，否则行为未定义。
**注释**
主要使用方式参见环境相关的宿主类型(@6.11.1.3) 和上下文数据结构(@6.11.3) 。

@6.8.2.1 空引用检查：
NPLA 实现提供在以下情形保证检查 shared_ptr<Environment> 的值非空：
Environment::EnsureValid(@6.8.1) ，失败时抛出异常；
shared_ptr<Environment> 值作为当前环境(@5.7.3) 的来源，同时提供指定为断言和具有异常的接口，参见上下文类(@6.11.3.1) ；
由 NPL_NPLA_CheckParentEnvironment(@6.1.2.1) 配置的可选的附加检查，失败时同 Environment::EnsureValid 。
对象语言的动态类型的值需要进行环境类型的类型检查(@4.7.4) 时，只区分对象语言中的类型，不特别排除具有宿主类型的非宿主值，因此不断言失败；
其余情形可能静态确定不存在来自可能通过互操作(@5.3) 来源取得的非空值，此时一般使用断言而不是异常。

@6.8.2.2 循环环境引用和环境引用所有权：
为避免引入循环引用(@4.2.7) ，环境强引用应仅在必要时使用，而避免被非预期地捕获（尽管保存环境弱引用和到强引用的转换可能有附加开销）。
特别地，注意和一等环境不同，NPLA 一等续延(@4.5.3.3) 允许通过一等对象作为其子对象进行构造，但这些子对象之后在对象语言中不保证总是能被访问。
因此，通常应避免在可从上下文(@6.11.3.1) 捕获的一等续延内部捕获环境强引用，以免之后的操作可能使某个无法预知的作为子对象的续延被捕获的环境强引用所有而构成循环引用（这无法通过选择对象语言的构造避免）。
修改当前环境的环境引用（上下文切换）应确保先前的当前环境具有合适的生存期，以避免通过环境弱引用锁定后取得空引用值。上下文切换 API(@6.11.4.4) 可保存此环境强引用。
被上下文切换保存的环境同样需要避免循环引用。
注意上下文切换保存的环境使用环境强引用而不是弱引用，因为它可能是唯一引用，为确保环境对象的生存期，这是必要的。
一般地，具有这些环境强引用的所有权的资源可能：
被作为宿主语言的自动对象，而不被上下文和其它上下文具有所有权的数据结构所有；
被续延或其子对象捕获。
不论必要性，被续延捕获强引用是可接受的，因为上下文的切换已修改了上下文的当前环境，在对象语言程序中不能作为一等对象通过创建绑定而构造循环引用。

@6.8.3 项引用：
宿主语言中，类 TermReference 是项引用(@5.6.2.3) 。
项引用是泛左值（即临时对象的引用值以外的引用值）的内部表示中存储在值数据成员中的目标类型(@6.2) 。
其中，子项只被子对象引用项(@5.8.3.8) 的情形使用，详见子对象引用的表示(@6.3.7.2) 。
项引用包含能以 C++ 引用的方式访问到被引用项(@5.8.3.8) 的状态。
通过项引用可访问引用值的被引用对象，即间接操作(@6.9.3) 。
引用值的被引用对象(@4.2.6) 应为一等对象(@4.2.4) 或被绑定对象(@5.7.1) 。
**原理**
子对象引用使用的这种形式的表示通常因为需要更多的操作比其它引用值的类似操作低效，但这种表示可避免依赖宿主语言中的本机对象内部表示（如成员布局）的依赖。
一般地，在 C++ 的意义上不存在能满足语义的更有效的可移植表示，所以这种表示在和宿主语言的互操作(@5.3) 上是必要的。
临时对象(@5.8.5) 不使用项引用，而直接使用具有临时对象标签的项表示(@5.8.5.6) 。这允许生存期延长(@5.8.5.4) 引入的临时对象不跟随引用项(@5.8.3.8) 而作为被绑定对象在环境中保存。
因为不确保能单独表示一等对象，当前项引用的值以互操作(@5.3) 目的使用，而不作为宿主值(@6.3.3) 。
这同时简化动态 PTC(@5.10.4.2) 的实现。当前实现参见 TCO 临时对象管理(@7.10.7) 。
**注释**
对 NPL::TermReference 和可能使用 NPL::TermReference 访问项的相关操作详见项引用和项引用访问操作(@6.9.3) 。
因为被引用对象是一等对象(@4.2.4) 或被绑定对象，被引用对象的表示在去除临时对象标签后是一等对象表示(@5.8.5.6) 。

@6.8.3.1 项引用的元数据(@4.2.6.3.1) ：
NPL::TermReference 包含一些附加的只通过引用形式访问对象的元数据作为优化设计(@4.2.6.3.2) ，包括标签(@6.2.2) 和关联的环境。
标签实现引用值的属性(@5.8.3.4) 。
项引用的标签可被传播，即一个项中的特定的标签的覆盖另一个项的对应标签的存在性。这实现引用属性的传播(@5.8.3.4) 。
部分元数据在初始化时决定。
NPL::TermReference 初始化时，初始化保存标签(@6.2.2) 。
NPL::TermReference 通过 NPL::EnvironmentReference(@6.8.2) 可选地指定关联的环境。
当前实现提供可选的运行时检查：
	当关联的环境不存在时，不提供对引入的对象内存安全(@5.6.4) 的检查(@5.4)。
	否则，在 NPL_NPLA_CheckTermReferenceIndirection 启用时，检查关联环境的生存期(@6.1.2.1) 。 
引用值关联的环境是可靠的，当且仅当关联的环境是被引用对象的所有者。
不保证可靠的关联环境的引用值是不安全引用值(unsafe reference value) 。除非另行指定，仅有不存在关联环境的引用值是不安全引用值。
另见非内存安全操作(@5.6.4.1) 和环境(@6.11.1) 。

@6.8.3.2 项的可转移条件：
可转移条件的判断基于表示表达式的值的项。可转移项(movable term) 通过以下方式确定：
非引用项(@5.8.3.8) 总是可转移的（非引用项表示右值）；
否则，若项引用具有的标签(@6.8.3.1) 决定它是被引用对象的唯一引用且非不可修改(@6.2.2) ，项是可转移的。
一般地，非引用值的对象是可转移的。
确定引用值关联的被引用对象可转移的条件有两类：
由可转移项确定：引用值由可转移项表示，在特定的上下文使被引用对象能转换为右值（用例如 @5.6.4.5 ）；
由被转发(@5.8.2.2) 表达式的值确定：除上述条件外，表示绑定临时对象的引用值（具有临时对象标签(@6.2.2) ）的项蕴含被引用对象(@4.2.6) ，也是可转移的（用例如 @9.11 ）。

@6.9 上下文无关节点处理 API ：
NPLA 实现提供不依赖一般项规约逻辑(@5.8) 的公共 TermNode(@6.2) 操作 API 。
以下 API 处理和 TermNode 或其中的成员数据类型相关但和 ContextNode(@6.11.3) 等上下文状态(@6.11) 无关的数据。

@6.9.1 规约合并项 API ：
规约合并项是满足以下结构约束的被规约项(@6.2) 之一：
	具有子项的枝节点(@6.2.1) 。
	特定的非平凡非正规表示(@6.3.7) 之一：
		符合作为带有记号值的非空列表(@6.3.7.3) 。
		无环非真列表(@6.3.7.1) 。
这些条件可使用函数 NPL::IsCombiningTerm 判断，以 NPL::AssertCombiningTerm 断言。后者对列表同时断言检查不具有粘滞位(@6.2.2) 。
函数 NPL::ClearCombiningTags 清除可能在规约合并项中遗留的标签而使之能作为一等对象的值的表示(@6.3) 。
**原理**
规约合并项支持求值算法(@4.4.1) 中函数合并(@4.5.3) 的实现。
对一般的规约合并，通常不直接蕴含 NPL::ClearCombiningTags 调用。对标签的维护通常延迟到正规化操作(@6.10.6.1) 实现。
因为规约合并项的合并子和合并子参数都表示一等对象，规约合并项是列表时，不会出现粘滞位。作为非局部性的不变量，这应在整个规约中保持，因此仅在断言中检查而不在谓词中判断，以避免调用 NPL::IsCombiningTerm 时的不必要的开销。
**注释**
具有子项的枝节点满足 IsBranchedList(@6.2.3) 。
利用规约合并项的一个实例参见 NPLA1 求值算法(@7.8.2) 。
另见对规约合并项的检查(@7.6.1.3) 。

@6.9.2 辅助项访问操作：
NPLA 提供访问若干访问 TermNode 的辅助接口，在 NPLA 模块中以 Doxygen 命令标识为 \ingroup TermAccessAuxiliary 。

@6.9.3 项引用和项引用访问操作：
表示项引用的类 NPL::TermReference(@6.8.3) 包括若干成员，其中主要有以下 API ：
IsMovable
GetEnvironmentReference
get
对 NPL::TermReference 的相关操作包括以下函数：
NPL::Collapse
NPL::PrepareCollapse
NPL::ReferenceLeaf
NPL::ReferenceTerm
除以上 API ，NPLA 还提供以下关于项引用和访问操作的便利接口：
类 NPL::ReferenceLeafOp
类 NPL::ReferenceTermOp
函数模板 NPL::ComposeReferencedLeafOp
函数模板 NPL::ComposeReferencedTermOp
类型 NPL::ResolvedTermReferencePtr 表示解析项后作为访问参数的项引用指针。
函数 NPL::ResolveToTermReferencePtr 转换项引用指针为项引用的访问参数指针。
函数和函数模板 NPL::IsMovable 判断解析后的项是否指示可转移项(@5.8.3.7) 。
若被判断的参数是 NPL::TermReference(@6.8.3) 值，则同 NPL::TermReference::IsMovable(@6.9.3) 。
否则，被判断的参数是指向指向项的指针（支持包括项引用指针和项引用的访问参数指针）。
NPLA 还针对考虑到项可能是 NPL::TermReference ，提供若干访问 TermNode 中的项引用的接口，在 NPLA 模块中以 Doxygen 命令标识为 \ingroup TermReferenceAccess 。

@6.9.4 项提升操作：
关于项的提升的基本概念，参见 @5.6.7.1 。
**注释** 以树表示项则为枝节点被子节点经变换后取代。项的子对象变换的一个例子是通过值数据成员保存的项引用(@5.6.2.3) 得到表示被引用对象的项。
提升项对象通过变换操作取作为项的值数据成员(@6.2) 。在此基础上有递归版本。
提升项操作可能修改的被替换的项中的对象(@5.6.7.1) 包括子项、值数据成员和标签(@6.2.2) 。
提升项可通过被引用的对象替换作为项的值数据成员的引用值(@5.8.3) 而消除引用值(@5.8.3.5) ，但不保证修改其中引用的元数据(@6.8.3.1) 。
提升项作为规约步骤，的求值结果(@6.10.1) 是消除引用值的结果。
提升操作辅助对项的操作，可用于实现规约函数(@6.10.5) ，包括以下各节中描述的 API 。其中：
	这些函数至少的第一参数是规约函数的被规约项(@6.10.5) 引用参数，指定提升的目标，在提升时可被替换。
		**注释** 即 TermNode& 或 TermNode::Container& 类型的参数。
	名称前缀为 Lift 的函数是一般提升操作。
		一般提升操作具有一个被规约项参数和其它可选的参数。
		若只有一个参数，则源项是参数的某个子项。
		若当第二参数也是被规约项时，则源项是第二参数指定的项。
	名称前缀为 Move 的函数是转移提升操作。
		转移提升操作具有两个被规约项参数和其它可选的参数，要求参数指定的两个项不相同且第二参数表示一等对象(@6.3) 。
		源项是第二参数指定的项。
当提升操作的被提升和被替换的项都是对象语言中一等对象的值的表示(@6.3) 时，不引入非一等对象的值的表示。
转移提升操作的第一参数在提升后保证表示一等对象。
**注释** 转移提升状态通常用于直接实现对象语言中的操作。
提升项的操作可能具有可被忽略的表示提升后中间状态的返回值。否则，返回类型是 void 。
**注释**
提升操作作用于项。被提升的项可能有具体的前置条件约束；提升可能满足特定的后置条件。
例如，一些项的提升操作预期被提升的项具有一等操作表示(@6.3) 。
不是所有项都满足前置条件，使用不适当的提升可能破坏接口约束。
为避免误用，一般地，尽量使用和特定的项相关的提升操作而非作用于一般的项的提升操作。

@6.9.4.1 基本提升操作：
基本提升操作包括直接转移赋值及以下 API ：
成员函数 ValueObject::MakeIndirect 取记号值或持有其它类型的值的引用的间接值(@6.4.3.1) 。
成员函数 ValueObject::MakeMoveCopy 转移或复制对象以消除间接值。
函数 NPL::LiftOther
函数 NPL::LiftOtherValue
函数 NPL::LiftTerm
函数 NPL::LiftOtherOrCopy
函数 NPL::LiftTermOrCopy
函数 NPL::LiftTermValueOrCopy
作为提升操作的 ValueObject 的成员函数只作用在项的值数据成员上。
其它基本提升操作修改项的标签来自被提升项。

@6.9.4.2 可能引入间接值(@5.6.3.1) 的提升操作：
以下值操作可能引入间接值：
函数 NPL::LiftCollapsed
函数 NPL::MoveCollapsed
函数 NPL::LiftTermRef 提升项引用：提升项的内容为参数指定的项或引用持有者(@6.4.3.1) 构成的间接值。
函数 NPL::LiftPropagatedReference 要求被提升的项是引用项(@5.8.3.8) ，提升引用项为引用项，实现不可修改标签的传播(@6.8.3.1) 。
函数 NPL::LiftToReference 提升项对象为引用。
若项对象表示引用值(@5.8.3) 则提升项，否则对 ValueObject 进行基于 ValueObject 所有权的检查（间接进行生存期检查）并取引用这个项的引用值。
运行时进行的检查类似于强制 C++ 的一元 & 对表达式值类别（另见 @4.2.6 ）的要求但更严格（尽管仍然不能保证避免未定义行为），避免临时对象(@5.8.5) 被保存为引用值。

@6.9.4.3 消除中间值的提升操作：
以下函数可消除参数中的中间值：
NPL::LiftMoved
NPL::LiftMovedOther
NPL::LiftToReturn
NPL::MoveRValueToReturn
NPL::MoveRValueToForward
NPL::LiftElementsToReturn
NPL::LiftPrefixToReturn
NPL::LiftSubtermsToReturn
NPL::LiftSuffixToReturn
本节的函数作用在被规约项时，对引用值的操作实现临时对象实质化转换(@5.8.4) 所在的求值规约的最后部分的操作，一般在尾上下文(@4.4.8) 中进行处理。
提升消除中间值只作用在被提升项，不作用在子项。需要递归复制的操作不在这里提供，以避免抽象泄漏。
为消除中间值需要进行复制消除(@5.8.5.3) ，其中使用不同的可转移条件(@5.8.3.7) 决定使用转移而非复制。
当前实现在转移项时使用的宿主转移操作总是使用宿主对象的转移（基于 NPL::SetContentWith(@6.2.3) ）而不是 TermNode 的转移。
在 TermNode 的操作以外，遍历多个子对象的复制操作不满足强异常安全，这包括：
NPL::LiftElementsToReturn
NPL::LiftPrefixToReturn
NPL::LiftSubtermsToReturn
NPL::LiftSuffixToReturn
另见局部间接值安全保证(@5.6.4.5) 。
**原理**
对象语言的语义不需要支持递归复制。
多个一等对象的复制不保证强异常安全。参见 NPLA API 异常安全保证(@6.1.4.2) 。
**注释**
对表示单一一等对象的项目的复制仍然基于 TermNode 上的操作提供强异常安全保证。

@6.9.4.4 辅助提升操作：
函数 NPL::LiftFirst 和 NPL::LiftLast 提升第一个和最后一个子项。

@6.9.4.5 非内存安全(@5.6.4.1) 的提升操作：
以上操作中，不保证引入的对象内存安全(@5.6.4) 且不提供检查(@5.4) 的操作有：
NPL::LiftTermRef ：通过 ValueObject::MakeIndirect 引入间接值。
NPL::LiftToReference ：非内存安全的项引用操作(@5.6.4.1) 。

@6.9.4.6 不支持嵌套调用安全(@5.4.2) 的提升操作：
以上操作中，作为例外，当前（因为直接或间接调用 NPL::SetContentWith(@6.2.3) 遍历节点）不支持嵌套调用安全的函数包括：
NPL::LiftTermValueOrCopy(@6.9.4.1) ；
NPL::LiftTermRef(@6.9.4.2) ；
消除中间值的提升操作(@6.9.4.3) 。

@6.10 规约接口：
NPLA 规约 API 约定默认使用 TermNode(@6.2) 和 ContextNode(@6.11.3) 类型的引用作为参数类型，分别表示被规约项(@6.2) 和使用的上下文(@4.6) 。
更具体的其它约定参见规约函数形式约定(@6.10.5) 。
一次规约局限在当前被规约项（一个 TermNode 对象）进行修改(@6.4.5) ，这个被规约项称为此次规约的当前项(current term) 。
表达式求值起始时，当前项是当前待求值项(@6.3) 。
规约 API 的 TermNode 参数指定当前项。必要时，当前项可被其它方式指定。
NPLA 约定列表表达式(@3.4.2.3) 子项作为被规约项需进行递归的树规约(@6.2) 。
部分规约 API 以函数（如 @6.10.5 ）的形式提供，其中：
ContextNode 可被递归地作为子项规约(@6.10.2) 的参数，因此可以不使用其它参数。
其它兼容实现可能使用其它参数。
规约 API 通常返回规约结果类型(@6.10.1) 。
以下的规约 API 和其它 API（如项提升 API(@6.9.4) ）配合，可用于实现规约操作：
规约范式检查 API(@6.10.3) ；
迭代规约结果合并(@6.10.4.4) ；
正规化 API(@6.10.6.1) ；
辅助规约函数(@6.10.7) 。

@6.10.1 规约结果：
规约过程返回描述一次规约调用操作结束后的状态的结果，包括以下几种情形：
部分规约(partial reduction) ：需要继续进行规约。表示不是完整的求值规约，也可以仅是管理规约(@4.4.2) 。一般仅用于异步规约(@6.12) 。
中立规约(neutral reduction) ：规约成功终止(@4.4.5) ，且未指定是否需要保留子项。
纯值规约：规约成功终止，且不需要保留子项。
非纯值规约：规约成功终止，且需要保留子项。
重规约：当前项需重新进行规约迭代(@6.10.4) ，而首先需要跳过当前项上当前一轮迭代的剩余的规约动作(@6.11.3) 。
取得重规约外的规约结果时，被规约项表示求值结果(@4.1) 。另见关于使用规约实现表达式求值(@6.3) 。
纯值规约的求值结果总是由值数据成员(@6.2) 决定。
非纯值规约为纯列表规约，当且仅当求值结果仅由子项决定而不需要访问值数据成员。
除不指定要求保留子项，中立规约和非纯值规约的作用相同，仅影响 @6.10.4 中的处理。
若被规约项已符合保留子项的要求，中立规约可以通过判断当前项是否已保留子项而分别指定为非纯值规约或纯值规约代替，但这带来不必要的项访问，不利于性能；因此本设计直接在规约结果中提供。
除非实现逻辑需要或另行指定，规约结果默认为纯值规约。因为通常求值结果的子项来自被规约项的子项，和表示规约后的项经常并没有关联而应被清除，默认规约结果设计为纯值规约便于处理这种常见情形。
规约结果作为规约实现的状态，设计原理如下：
基于实现的可扩展性、可复用性、复杂性和性能，判断规约终止的谓词（范式判断(@6.10.3.1) 谓词）不一定适合在单独的规约过程中指定。
引入可指定规约不终止的显式的重规约状态代替范式判断谓词应对这些问题，允许项在最终取得范式前附加可变状态，并优化范式判断(@6.10.3.1) 。
区分规约终止的不同情形能在一定程度上复用已有的列表节点(@6.2.1) ，避免规约时节点或其它数据结构的一些冗余创建。
规约结果(@6.10.1) 以枚举 NPL::ReductionStatus 表示，其枚举项的值具有含义：
ReductionStatus::Partial 指定部分规约；
ReductionStatus::Neutral 指定中立规约；
ReductionStatus::Clean 指定纯值规约；
ReductionStatus::Retained 指定非纯值规约；
ReductionStatus::Regular 指定已取得正规表示(@6.10.6) 的规约（当前实现的枚举值的数值同指定非纯值规约）；
ReductionStatus::Retrying 指定重规约。
已取得正规表示的规约未指定公开的规约结果覆盖行为(@6.10.4.3) ，可以实现为中立规约、纯值规约或非纯值规约；当前实现同非纯值规约会覆盖默认的纯值规约，避免不必要的清理(@6.10.2.1) 而有利于性能。

@6.10.2 子项规约：
由树规约的性质(@6.2) ，可假定规约不改变参数外部的项的有效性，不需要外部项的存在性及结构进行额外的检查以确保继续满足相关前置条件（如子项被规约后所在的项总是继续为枝节点(@6.2.1) ）。

@6.10.2.1 子项的清理(cleanup) ：
纯值规约(@6.10.1) 要求清理操作，即移除不被需要(@6.10.1) 的子项。
清理时子项所有的对象被销毁，可具有副作用(@4.1) 。
子项的清理属于删除子项的操作(@6.4.5) 。

@6.10.3 规约范式：
被规约项可能通过规约得到范式(@4.4.5) 。
不是范式的被规约项是可规约项(reducible term) 。
基于规约范式，提供以下规约检查 API ：
函数 NPL::CheckReducible 检查参数指定的规约结果是否可继续规约。
函数模板 NPL::CheckedReduceWith 循环规约直至不满足 NPL::CheckReducible 的判断结果。

@6.10.3.1 范式判断：
基于范式的定义，终止的(@6.10.1) 规约迭代应对 TermNode 参数进行规范化(@4.4.5) 以得到范式。
NPLA 提供以下等价的方式判断规约迭代后是否在 TermNode 得到范式：
除非另行指定，可直接使用 NPL::CheckReducible 以规约结果(@6.10.1) 决定是否为可继续规约的非范式；
通过检查节点结构的谓词确定是否为枝节点(@6.2.1) 等作为范式判断谓词进行判断；
其它派生实现指定的范式的判断方式。
以上等价性由特定的 NPLA 规则和规约实现机制保证。
**注释** 如规约表示的基本性质(@6.10.6.2) 。
因为只检查规约结果的值而不访问项，使用 NPL::CheckReducible 代替范式判断谓词(@6.10.1) 一般能优化性能。
基于上述等价性保证，上述等价方式中的范式判断谓词可蕴含 NPL::CheckReducible 的结果，必要时也可用范式判断谓词代替规约结果，详见 @6.10.6.1 。

@6.10.3.2 规范化规约(@4.4.5) 约定：
除非另行指定(@6.10.6.1) ，一次终止的规约迭代中若存在规范化规约，其发生的次数和时机未指定；一般在最后一遍(@6.10.4) 或之前存在一次即可。
注意规范化规约可能有副作用(@4.1) ，实现应保证规约行为可被预期。

@6.10.4 规约迭代：
对项的一次规约可分解为若干个对这个项的分步规约的有序的迭代过程，每个过程称为一个遍(pass) 。
包含所有遍都被调用并正常返回的规约是全规约(full reduction) 。
重规约(@6.10.1) 或包含通过抛出异常退出的遍的规约不是全规约。
一次规约中有且仅有最后一遍规约迭代终止(@6.10.1) 。
推论：非全规约的迭代是非终止的迭代。
一次不异常退出的规约按规约结果总是对应部分规约以外的规约结果(@6.10.1) 之一。
**注释**
关于遍的规约结果的迭代，参见规约结果覆盖(@6.10.4.3) 。

@6.10.4.1 规约迭代结果：
一次规约取得一个规约结果。
规约结果被用于在每次规约后维护被规约项的表示(@6.10.6) 。
若无法利用规约结果，在不需要保留项时，可能需要其它的显式的清理(@6.10.2.1) 操作。

@6.10.4.2 规约结果合并：
为避免保存规约结果的不必要开销，每一遍的规约结果不被提供给其它遍共享地访问。
不同遍的规约结果可能不同。项的一次规约的结果由被调用的一个或多个遍的结果顺序地迭代决定：
未经遍调用迭代的规约结果是中立规约（参见 @6.10.4.3 ）；
之后每一遍返回后，逐一合并(combined) 之前遍决定的规约结果和新的遍的结果，作为新一轮迭代后的规约结果。
（注意此处的合并操作不同于函数合并(@4.5.3) 。）
项的一次规约的结果是规约迭代的最后一遍合并后得到的结果。
迭代处理不同遍的规约结果仍有开销，但即便作为纯软件实现，通常仍远小于直接保存每个遍规约结果的开销。这也允许减少一次规约中不同遍之间的重复的维护操作(@6.10.6.1) 。

@6.10.4.3 规约结果覆盖：
一次规约中，某一轮被迭代处理的遍的规约结果可能和处理结果相同，即覆盖当前处理的规约结果。
规约成功终止的规约结果不被不表示规约成功终止的规约结果覆盖，以满足范式的语义(@6.10.3) 。
规约成功终止的不同规约结果可能支持互相覆盖。
由于规约结果作用不同，不同规约覆盖不一定被同等地支持。（这同时避免需要过多的不同的规约结果表示不同的覆盖操作。）
覆盖行为不应影响单一遍的规约结果的语义正确性。对子项的影响明确不同的规约不能互相替换。
例如，中立规约实现处理为纯值规约(@6.10.1) 或非纯值规约是未指定的。但中立规约明确不清理子项，一般不能用纯值规约代替，不论纯值规约是否按以下规则覆盖其它规约结果。而为避免实现细节，中立规约也不能用非纯值规约替换。
当前规约结果覆盖使用以下对称覆盖设计：
未被规约的初始状态假定为中立规约，不影响子项并允许被之后的规约结果覆盖。
规约成功终止时，明确指定纯值规约或非纯值规约的规约结果在合并过程中可覆盖其它规约结果。
一般地，一个项上的规约成功终止时已决定是否需要保留子项，通常不需要覆盖非默认规约结果。
所以相对地，被确定为非纯值规约的情形不严格需要支持被下一轮规约结果覆盖为纯值规约。若仍要求不保留项，则需其它的显式的清理操作(@6.10.2.1) 。
和纯值规约类似而和非纯值规约不同，中立规约不覆盖其它规约成功终止的规约结果，不影响子项是否需要被清理。

@6.10.4.4 迭代规约结果的合并算法：
根据以上讨论中的要求，可确定规约结果的合并算法。
成功终止(@6.10.1) 的遍规约迭代结果的合并符合以下规则：
若被迭代的新一轮的遍的指定可覆盖其它结果的规约结果(@6.10.4.3) ，则指定合并的规约结果是此规约结果；
否则，新一轮合并的规约结果是之前的遍合并的规约结果。
一般的序列规约结果合并符合以下规则：
若之前的遍合并的规约结果指定规约成功终止，则使用以上关于成功终止的规约结果的合并规则决定新一轮合并后的规约结果；
否则，新一轮合并的规约结果同之前的遍合并的结果。
注意和非纯值规约(@6.10.1) 不同，中立规约(@6.10.1) 不会影响保留的规约结果。
NPLA 实现提供支持可调用的遍(@6.10.4) 的集合作为一次规约迭代的基础可配置的边界。
NPLA 提供以下处理遍的规约结果合并(@6.10.4.2) 结果的 API ：
函数 NPL::IsOverridableReductionResult 判断参数指定的规约结果在合并中是否可被覆盖(@6.10.4.3) 。
函数 NPL::CombineReductionResult 和 NPL::CombineSequenceReductionResult 提供规约迭代结果(@6.10.4.1) 的成功终止和一般规约结果的合并操作。

@6.10.5 规约函数：
接受 TermNode 和其它参数进行规约的 API 主要以宿主语言的函数（子例程）的形式提供，称为规约函数。
规约函数以第一参数指定被规约项或其子项，可能返回规约结果(@6.10.1) 。
规约函数可以调用其它规约函数实现。
注意因为可直接忽略被调用的规约函数的返回值并指定其它值，规约函数的实现的分类不一定具有组合性。
规约函数(@6.10.5) 包括以下形式：
第一参数为被规约项，类型为 TermNode& ；
或者，第一参数是和 TermNode& 对应的容器的以下至少之一：
	有效的 TermNode::Container& 值或 TermNode::Container 对象上的连续序列的迭代器范围之一；
	可作为值数据成员(@6.2) 的有效的 ValueObject& 值。
替代 TermNode& 的参数的形式允许不构造完整的 TermNode 而允许更好的性能，但仅在保证不要求直接使用 TermNode （如取得 O(1) 的 size() 或调用遍(@7.4.1) ）时适用。
规约函数的返回类型是 ReductionStatus(@6.10.1) 或 void 。
返回 void 的规约函数在规约结果(@6.10.1) 的语义上同总是返回 ReductionStatus::Clean(@6.10.1) 。
部分遍(@6.10.4) 及规约函数以 ContextNode(@6.11.3) 的引用作为参数。声明时，ContextNode 不需要是完整类型。

@6.10.5.1 直接和间接规约函数：
一些规约函数被设计为兼容签名 ReductionStatus(TermNode&, ContextNode&) ，称为直接规约函数。
其余规约函数是间接规约函数。
直接规约函数可直接用于作为派生实现中的 EvaluationPass(@7.4.1.2) 遍的处理器(@7.2.1) 。
间接规约函数可能直接或间接调用直接规约函数。
规约函数对表示被规约项以及上下文（若存在）或其上述对应形式的形式参数的使用应符合 NPLA 实现的规约迭代默认的约定(@6.10) 。
构成直接规约函数类型的一个必要非充分条件是：
第一参数的类型是 TermNode& ，且当第二参数存在时，其类型可隐式转换为 ContextNode& 。

@6.10.5.2 名称约定：
以下规约函数的名称以 Reduce 起始：
直接规约函数(@6.10.5.1) ；
起始两个形式参数符合直接规约函数要求，且可能直接或间接调用其它直接规约函数的间接规约函数。
不调用其它直接规约函数的间接规约函数的名称以 Evaluate 起始。
其余规约函数的名称不以 Reduce 或 Evaluate 起始。
注意不同实现中的命名空间可能不同，在此不作限制。

@6.10.5.3 主规约函数：
NPLA 的派生实现可提供对一般的规约(@4.1) 的实现以蕴含对象语言表达式的求值规则。
NPL 的表达式的语法是递归表示的，因此包括对列表表达式子项的递归规约。使用单一规约函数实现的这种规约一般即树规约(@6.2) 。
规约实现作用在对象语言表达式上通用的求值算法(@4.4.1) ，符合规约性质(@6.3) 。
主规约函数是提供这种单一规约函数实现的直接规约函数(@6.10.5.1) 。
间接值(@6.4.3) 对主规约函数透明，不被直接处理。
推论：主规约函数实现的求值算法中，被求值的表达式不发生值类别转换(@5.8.4) 。这简化实现的复杂性，并允许派生实现单独处理需要间接值（如引用值）的情形，并在其它情形避免不需要的开销。

@6.10.6 规约和正规性(@6.3.6) ：
规约结果(@6.10.1) 和求值结果(@4.1) 或求值的中间结果(@6.3) 的表示有如下关系：
纯值规约(@6.10.1) 后，仅由被规约项的值数据成员(@6.2) 决定规约得到的值；
纯列表规约(@6.10.1) 后，仅由被规约项的子项决定规约得到的值，即得到真列表(@6.2.1) 。
满足上述约定的求值结果的表示(@6.3) 是正规表示(@6.3.6) ；否则，求值结果的表示是非正规表示(@6.3.6) 。
对待求值项(@6.3) 的任一遍(@6.10.4) 规约都可引入非正规表示，但应满足取得范式(@6.10.3) 的要求：
待求值项取得平凡非正规以外的表示是取得范式的必要非充分条件。
为取得范式，可能需要继续进行规范化规约(@4.4.5) 。
求值规约(@4.4) 可包含规范化规约。

@6.10.6.1 正规化操作：
一次规约后，被规约项中的值数据成员或子项仍然可保留其它状态而非范式；对表示求值的情况，也不是正规表示(@6.10.6) 。
因为规范化规约可能存在副作用(@6.10.3.2) ，NPLA 约定求值得到正规表示的规范化规约在抽象机(@2.5) 的意义上总是被进行，称为正规化操作。
正规化操作包含以下操作：
	清除项中作为规约合并项(@6.9.1) 而不是一等对象的表示(@6.3.2) 的标签。
	对纯值规约(@6.10.1) ，对子项进行清理(@6.10.2.1) 。
对同一个规约结果的正规化操作是幂等(@4.1) 的，超过一次的连续正规化操作无其它作用。
正规化提供以下 API ：
函数 NPL::RegularizeTerm 按规约结果正规化项。
**原理**
由纯值规约的语义，被清理的子项和被清除的标签不应影响项作为求值结果的表示。若应清理的子项存在，则清理前为平凡的非正规表示(@6.3.6) 。
若需避免子项的生存期扩展到所在的项，需确保对平凡非正规表示总是存在可预期的清理操作。
纯值规约中存在的清理、修改标签和修改值数据成员的作用仍非决定性有序(@6.2) ，因此一个项中的清理可能先序(@4.4.3) 最终确定作为值的表示的对值数据成员的修改操作。
因为子项的删除时机未指定(@6.2) ，不假定 NPLA 实现的规约总是清理求值后的节点，即正规化以外的清理由派生的具体规约实现指定。
一般在一个表达式取得求值结果(@6.10.1) 前，清理纯值规约要求排除的子项。
纯列表规约的规范化标记值数据成员为特定的值，可以是默认构造的空值或派生实现定义的表达式项(@6.3) 内的值数据成员外的记号值(@6.8.1) 。
除平凡非正规表示(@6.3.7)（通过先行判断值数据成员而排除）外，当前未从非纯值规约结果中区分纯列表规约，因此不对纯列表规约进行操作。
**注释**
注意正规化操作和之前的清理操作可能会影响项的生存期；另见规约操作资源(@6.4.4.1) 。

@6.10.6.2 规约表示(@6.3.6) 基本性质：
除非另行指定（参见非平凡非正规表示(@6.3.7) ），NPLA 实现应保证规约表示满足以下基本性质：
任一遍规约中，非正规表示应是平凡的(@6.10.6) 。
**原理**
规约表示基本性质允许在已知 TermNode 得到范式时通过直接判断项的节点结构(@6.2.1) 是否存在子项代替推断此次规约中之前的规约结果。
在对象语言输入可保证不存在非正规表示的前提下，这样的设计满足原则 @1.5.1.1 和 @1.5.2.2 。
**注释**
若不能保证不引入非正规表示，实现可通过正规化操作(@6.10.6.1) 约束规约后的项，以确保接口行为满足上述规约语义的保证。

@6.10.6.3 正规表示分类：
非纯列表规约的非纯值规约允许取得子项和值数据成员都有意义的非平凡非正规表示(@6.3.7) 。
这样的表示要求先通过值数据成员进行判断，以排除为列表项。
基于规约表示基本性质(@6.10.6.2) ，除非平凡非正规表示，不需要单独判断正规表示。
基于正规化操作规则(@6.10.6.1) ，通过以下逻辑对作为表示(@6.3) 的 TermNode 分类：
具有非空子项的 TermNode 表示非空列表(@6.2.1) ；
空节点表示空列表(@6.2.1) ；
其它项当值数据成员不是特定的值时，表示非列表表达式的值。
值数据成员为特定的值（如没有约定在对象语言中可表示的中间值(@6.8) ）的没有子项的 TermNode 不是任何表达式或一等对象的表示(@6.3.2) 。
注意值数据成员为 TermNode 类型的节点不表示列表节点。

@6.10.7 辅助规约函数：
可作为规约函数(@6.10.5) 的不依赖上下文的 API 的辅助函数称为辅助规约函数，能处理一般情形的项，不存在作为断言的要求项非空的前置条件。

@6.10.7.1 简单规约操作：
NPLA 提供只依赖项既有结构的项简单规约操作。这些操作是直接规约函数(@6.10.5.1) 。
函数 NPL::ReduceBranchToList 要求参数是枝节点(@6.2.1) ；移除第一个子项，剩余项作为列表的元素，并返回 ReductionStatus::Retained(@6.10.1) 。
函数 NPL::ReduceBranchToListValue 要求参数是枝节点；移除第一个子项，剩余项作为列表的元素，调用 NPL::LiftSubtermsToReturn(@6.9.4.2) 提升子项的值，并返回 ReductionStatus::Retained(@6.10.1) 。
这保证最外的第一级引用项(@5.8.3.8) 被提升，不影响被引用项(@5.8.3.8) 自身包含的引用。
函数 NPL::ReduceForLiftedResult
函数 NPL::ReduceHeadEmptyList
函数 NPL::ReduceToList
函数 NPL::ReduceToListValue

@6.10.7.2 间接辅助规约操作：
以下辅助规约函数按参数设置不同的项的值实现规约：
函数 NPL::ReduceToReference
函数 NPL::ReduceToReferenceAt
函数 NPL::ReduceToValue

@6.10.8 规约结果处理：
以下 API 简化调用时的规约结果设置：
函数模板 NPL::EmplaceCallResultOrReturn

@6.11 运行时状态管理：
NPLA 提供维护程序运行状态的数据结构的接口，包括求值环境(@4.6.1) 、持有程序执行的资源的上下文(@4.6) 和相关的其它 API 。

@6.11.1 环境数据结构：
NPL 中定义的类 Environment(@6.11.1.2) 表示环境记录(@5.7.1) 。
环境对象(@5.7.1) 以类 Environment 相关的类型表示。
显式的数据结构直接支持求值环境是一等环境(@5.7) 。
TermNode 对象在名称绑定映射中表示被绑定对象(@5.7) 。
当前实现中，环境中的绑定是平坦的映射，未依赖节点的递归性质；但是其中的被绑定对象(@6.11.1) 使用 TermNode ，也适用以下操作。
名称绑定映射释放变量绑定中的资源时，其中不同被绑定对象的销毁之间非决定性有序(@4.4.3) ，其它作用顺序未指定。
注意名称绑定映射中不同被绑定对象的生存期的起始和结束的顺序一般是不可追溯的，这和宿主语言在一些上下文中静态确定并保证销毁自动对象和创建对象的顺序相反不同。
Environment 支持定制名称解析和名称解析的重定向(@4.3.3) ，其中包含以下相关的定制状态：
重定向算法；
名称解析算法；
可在运行时确定宿主类型(@5.3.1) 的父环境(@5.7) 引用（用于重定向算法的实现)。
默认的名称解析算法首先在名称绑定映射中查找局部变量的绑定；若失败，调用重定向算法进行重定向，从父环境引用中取目标环境代替环境后代替环境继续使用其中的名称解析算法查找，直至没有可重定向的目标。
默认的重定向算法依次检查重定向目标的宿主值(@6.3.3) 的类型。
对象语言中的环境引用(@5.7.2) 类型的宿主类型是非递归的重定向目标类型。
不同宿主值类型具有不同的所有权。作为一等对象的环境引用的一般表达式值中，应根据是否需要具有所有权区分使用这些宿主类型的环境引用。
默认的重定向算法实现 NPLA1 环境(@9.9.2) 的搜索。

@6.11.1.1 环境和变量绑定相关 API ：
类 NPL::EnvironmentBase 是 Environment 和 NPL::EnvironmentReference 的基类。
类类型 NPL::EnvironmentParent
NPL::EnvironmentList 是 NPL::vector<ValueObject> 的别名，表示一个环境列表，作为父环境(@5.7) 时可用于递归重定向(@4.3.3) 。
NPL::BindingMap
NPL::NameResolution
函数 LookupName 在绑定集合中查找（一般作为局部变量的）标识符指定的名称，实现名称查找(@4.3.3) 。输入字符串指定（假定名称验证已通过的）名称。
接口 NPL::IParent
以下类实现 NPL::IParent ，支持父环境的实现：
NPL::EmptyParent 空父环境；
NPL::SingleStrongParent 包含一个 shared_ptr<Environment> 值(@6.8.2) ；
NPL::SingleWeakParent 包含一个 EnvironmentReference 值(@6.8.2) ；
NPL::ParentList 包含一个 NPL::EnvironmentList 值。
类 NPL::EnvironmentParent 表示父环境。
空父环境共享通过无参数构造的 NPL::EnvironmentParent 类表示，所有空父环境共享一个 NPL::EmptyParent 对象。
其它使用 NPL::EmptyParent 的对象不保证被视为空父环境。

@6.11.1.2 环境类：
类 Environment 中，指定变量绑定的名称绑定映射(@6.11.1) 类型为 NPL::BindingMap 。
类 Environment 提供父环境以及基本的名称解析(@4.3.3) 等操作的接口。其中的操作可被针对特定的环境对象重新设置。
类 Environment 包含以下相关的数据成员：
Parent ：父环境，作为可在运行时确定类型的父环境引用，用于重定向(@4.3.3) 算法的实现。
类 Environment 还包含其它一些维护内部状态和绑定(@4.1) 的 API 。
成员函数 IsOrphan 判断是否为孤立的环境，即锚对象(@6.8.2) 未被外部引用。
成员函数 IsFrozen
成员函数 GetAnchorPtr 取锚对象指针(@6.7.2) 。
成员函数 GetMap 取名称绑定映射的引用：类型为 NPL::BindingMap 的变量绑定容器，实现变量名称到表示被绑定对象的映射(@6.11.1) 。
成员函数 GetMapRef 取名称绑定映射的可变引用。
成员函数 Define 、Redefine 和 Remove 修改上下文中的值。
静态成员函数 Define 和 DefineChecked 在绑定映射中添加定义。后者在定义已存在时抛出异常。
静态成员函数 EnsureValid 提供失败时抛出异常的环境强引用空值检查(@6.8.1) 。
成员函数 Freeze
静态成员函数 Remove 和 RemoveChecked 以字符串为标识符在指定上下文移除定义。后者在定义不存在时抛出异常。
静态成员函数 Replace 和 ReplaceChecked 以字符串为标识符在指定上下文的名称查找结果中替换定义。后者在定义不存在时抛出异常。
成员函数 Unfreeze

@6.11.1.3 环境引用相关类型和检查：
类型 shared_ptr<Environment> 和类 NPL::EnvironmentReference 是环境强引用和环境强引用(@5.7.2) 作为宿主值(@6.3.3) 的宿主类型(@5.3.1) 。
访问环境的 API 可使用非空的环境引用值引用对象，或空的引用值指定不存在环境对象。
使用可能具有这些值的代码需要对空值进行检查。因为这些空值不出现在对象语言，一般通过 Environment::ThrowForInvalidValue(@6.11.1.2) 抛出 std::invalid_argument 而非 NPL 异常(@6.5) 。
使用环境弱引用可避免非预期的所有权(@4.2.5.3) 关系构成循环引用(@5.2) 。
当前支持循环引用检查的上下文有：
ContextNode::DefaultResolve(@6.11.3.1) 重定向父环境(@5.7) ；
以引用的环境作为动态环境(@4.6.1.2) 创建 vau 抽象(@8.4.5) 且创建的对象不对环境有所有权。
因为循环引用是对象语言的未定义行为，检查循环引用失败抛出 std::bad_weak_ptr 而非 NPL 异常(@6.5) 。
对象语言中不直接可见(@6.3.3) 但支持作为父环境的宿主类型是 ContextNode::DefaultResolve 中的重定向(@4.3.3) 目标的宿主值(@6.3.3) 的类型中公开的类型(@6.11.1.1) ，即 NPL::IParent 的实现。
重定向依次检查这些类型。
派生实现的其它重定向可定义提供明确支持的其它类型，包括公开的宿主值(@6.3.3) 的类型和作为非宿主值的其它宿主类型。
**注释**
环境引用可作为中间值(@6.8.2) 。 
实现可提供其它宿主类型，如 observer_ptr<Environment> ，用于内部实现而不要求所有使用环境的操作支持。
除 shared_ptr<Environment> 的 use_count 的结果外，环境的引用计数具体值是实现细节，不保证具有明确含义的稳定的结果。

@6.11.2 上下文相关的规约函数类型别名：
类型 NPL::ReducerFunctionType
类型 NPL::Reducer 是以上下文引用作为参数的规约器(@6.12.6) ，保存动作(@6.11.3) 。
NPL::Reducer 能以兼容 ReducerFuntionType 的方式调用，可选提供一个 ContextNode& 参数。
NPL::Reducer 以类型擦除(@4.7.3) 支持不同的目标类型(@6.2) 。

@6.11.3 上下文数据结构：
持有程序执行资源的上下文使用类 ContextNode 表示。
ContextNode 对象保存上下文相关的公共状态。
ContextNode 同时是 NPL-EMA(@5.2.1) 中和宿主语言线程一一对应(@2.6.1) 的实体。
上下文之间相互隔离，不同的上下文允许多线程并发执行，一个宿主线程至多同时执行一个上下文的程序。
一个宿主线程中执行的程序若从属不同上下文或和其它可能跨上下文的资源共享而被并发访问时应确保同步。
上下文的公共状态包括当前处理的环境的强引用(@5.7.2) ，指定活动记录中当前的处理的帧(@4.5.3.4) ，表示对象语言中对应当前处理的帧的当前环境(@5.7.3) 。
环境强引用决定上下文对环境具有共享所有权(@5.6) ，通过环境对象的引用可以取指向它的引用(@6.11.1.2) 。
只使用上下文中包含的当前环境时，可使用 ContextNode(@6.11.3.1) 和 Environment(@6.11.1.2) 的成员访问环境的数据。
需要上下文时，一般使用现有（通过规约函数的参数得到的）上下文，可能替换和重置状态；或通过现有上下文和环境创建新的上下文。
上下文支持设置对应规约迭代(@6.10.4) 中对应的规约动作(action) ，保存特定的当前动作(current action) 和若干后继的定界动作(delimited actions) 组成当前动作序列(current action sequence) 。
其中，当前动作和后继的动作分别表示元语言中处理当前和后继的求值上下文(@4.4.8) 中的操作。
规约动作可选地指定上下文参数。
当前动作作为宿主语言的函数对象被调用，激活(activate) 其中的规约操作，其中可覆盖当前动作为后继的动作。
NPLA 上下文中，被激活的动作被移除。因为没有全局的垃圾回收(@4.2.5.3) ，这保证激活的动作在执行后能保证其中直接或间接捕获的资源被及时释放。
若需通过重复使用动作（实现非正常控制(@4.8) 等），需在动作被激活前进行处理（例如，复制或另行构造动作）。
以循环实现重写(@4.1.2) 时，有效的当前动作可用于作为保持重写循环的条件。当不存在有效的当前动作时，规约在完成已激活的规约操作后终止。
以抽象机描述操作语义(@2.2.3) 时，定界动在尾上下文(@4.4.8) 外提供剩余的动作，作为一个序列，称为尾部动作(trailing actions) ，是当前动作的后继动作(subsequent action) 。另见 http://www.brics.dk/RS/03/41/BRICS-RS-03-41.pdf 。
当前动作起始的当前动作序列表示语言实现中（不作为一等对象(@4.1) 的）未被捕获的当前续延(@4.2.3) 。
动作和尾部动作整体构成求值上下文的实现。后者在元语言中提供操作，又称为元上下文(meta-context) 。
当前动作可作为尾上下文的实现，称为尾动作(tail action) 。特定的尾动作可实现符合 PTC 的尾调用(@5.10.2) 。
**原理**
配合重写循环提供基于尾动作的循环 API 可实现 CPS(contiuation passing style) 风格的异步调用(asynchnorous call) 。
参见其它相关 API(@6.11.4) 。
**注释**
派生实现可使用 ContextNode 的 public 派生类扩展更多的状态。
跨上下文的资源如全局状态(@7.8) 。其中，约定特定同时访问的资源可简化同步直至空实现。
注意一些其它语言实现可能使用不同的一般意义的上下文(@4.6) ：
	例如，V8 的 v8::Context 实际是包括求值环境(@4.6.1) 的一系列支持对象语言特性的上下文元数的的表示，接近 ContextNode 的是 v8::Isolate 。
	而 SpiderMonkey 和 JavaScriptCore 中名为 JSContext 的数据结构则接近 ContextNode 。
关于元上下文，另见 http://www.brics.dk/RS/05/16/BRICS-RS-05-16.pdf 。

@6.11.3.1 上下文类：
类 ContextNode 提供若干 API 。
成员类型 ExceptionHandler
成员类型 ReducerSequence
数据成员 Resolve
数据成员 TailAction
数据成员 HandleException
数据成员 LastStatus 保存最后一次规约状态，配合当前动作序列(@6.11.3) 决定之后的续延中的动作调用。
数据成员 Trace
成员函数 IsAlive
成员函数 GetCurrent ：访问上下文内部的保存当前动作序列，是类型为 NPL::ReducerSequence 的一遍规约序列的 const 引用。
当前动作序列可被作为尾动作(@6.11.3) 。
成员函数 GetCurrentActionType
成员函数 GetMemoryResourceRef 取存储资源(@6.4.1) 引用。
成员函数 GetRecordRef
成员函数 GetRecordPtr
成员函数模板 AccessCurrentAs
成员函数模板 AccessCurrentAsUnchecked
成员函数 ApplyTail
静态成员函数 DefaultHandleException
静态成员函数 DefaultResolve
成员函数 Rewrite
成员函数 RewriteLoop 以 IsAlive 的结果是条件的循环调用 ApplyTail ，作为跳板(@6.12.1) 实现一般规约重写。
成员函数 SaveExceptionHandler
成员函数模板 SetupCurrent 和成员函数模板 SetupFront 设置当前动作序列。前者具有前置条件 !IsAlive() 以避免重复设置覆盖当前动作的原始状态。
成员函数 Switch
成员函数 SwitchEnvironment 和 SwitchEnvironmentUnchecked 切换环境，即设置参数指定的环境并返回之前的环境。两者接受 shared_ptr<Environment> 的参数，区别为对空参数抛出异常或引起未定义行为。环境切换便于实现续延或过程调用(@4.5.3.1) 。
切换环境时，旧的环境若没有被引用，则被释放。由于环境具有对象的所有权(@5.6.3) ，内部绑定的对象作为自动变量也被一并释放(@5.6.6) 。
成员函数 ShareRecord 和 WeakenRecord 取环境的引用。
成员函数 get_allocator
成员函数 shrink_to_fit
友元函数 swap
部分 API 使用的参数类似规约函数(@6.10.5) 。
这些函数的参数可能在内部实现被预先绑定，调用时对应的实际参数被忽略：如 TermNode& 类型的形式参数被绑定，内部使用绑定时确定的项而不是实际参数指定的任意的项。
因为绑定参数引入附加的函数调用，一般仅在有必要时使用。

@6.11.4 其它环境和上下文相关的处理 API ：

@6.11.4.1 环境和上下文关联操作：
函数 NPL::AssertMatchedAllocators
函数 NPL::ToBindingsAllocator
函数模板 NPL::AllocateEnvironment
函数模板 NPL::SwitchToFreshEnvironment

@6.11.4.2 环境、绑定访问和解析操作：
基于环境的名称解析(@4.3.3) 操作可选地处理特设的保留名称(@5.2.4) 并查找名称(@4.3.3) 。
解析环境从 ValueObject 对象中取表示环境的宿主值(@6.3.3) 。这只包括作为一等对象(@4.1) 的环境引用(@6.11.1) 。
NPLA 提供绑定访问相关的操作，以 Doxygen 命令标识为 \ingroup BindingAccess 。
NPLA 中，在环境中指定标识符进行名称解析(@4.3.3) 。
使用标识符构成的名称表达式（求值进行名称查找(@4.3.3) ）的求值结果是引用值。
部分 API 实现引用折叠(@5.8.3.6) 。
直接的绑定访问 API 不处理引用值的标签(@6.2.2) 。派生实现可能改变查找结果。
**注释**
派生实现可能对保留名称的约定有更严格的限制。例如，另见 NPLA1 标识符附加规则(@7.1.1.1) 。

@6.11.4.3 父环境 API ：
以下函数或函数模板创建可作为 Environment::Parent(@6.11.1.2) 的值的父环境对象：
NPL::ToParent
NPL::MakeParent
以下函数或函数模板重载设置父环境：
NPL::AssignParent
NPL::AssignParentH
NPL::AssignParentWeak
NPL::MoveParent

@6.11.4.4 上下文切换：
仿函数 NPL::EnvironmentSwitcher 和 NPL::EnvironmentExchanger 用于切换上下文(@6.11.3.1) 中的当前环境(@6.11.3) 。

@6.12 异步规约(asynchronous reduction) ：
直接风格(direct style) 的语言实现利用宿主语言的函数调用实现图规约(@6.2) ，满足规约函数(@6.10.5) 的调用包含子项的规约，即同步规约(synchronized reduction) 。
非同步规约称为异步规约。异步规约允许在宿主语言中分离部分规约(@6.10.1) 的不同部分的实现，使之公开为一等对象表示控制状态(@4.1) 及被调度。
异步规约支持异步调用(@6.11.3) 。
NPLA 支持同步规约和异步规约中立(neutral) 的接口设计(@6.12.5) 。具体的异步规约在派生实现使用。
NPLA 实现支持异步规约，以避免 C++ 本机(@2.3.1) 资源限制下不限定数量(@5.10.2) 调用深度时可能引起的宿主语言的未定义行为(@5.4) 。
若资源分配失败，应满足常规宿主资源分配要求(@5.4.1) 。
**注释**
在不适合使用异步规约时，实现也可使用其它方式实现异步调用。

@6.12.1 异步规约动作：
NPLA 中，这通过以规约动作(@6.11.3) 作为 CPS(@6.11.3) 的被跳板(trampoline) 执行的中间值(@4.4.6.2) 例程的机制实现。此时，当前动作(@6.11.3) 是尾动作(@6.11.3) 。
跳板例程设置的规约操作将被异步调用，即当前动作(@6.11.3) 设置为异步动作，在跳板中被循环调用。上下文的重写循环(@6.11.3) 提供一个跳板调用当前动作(@6.11.3) 。
这种方式支持嵌套调用安全(@5.4.2) 。其它方式实现可能具有更好的性能，但存在限制而不被使用，如：
依赖不可移植的宿主语言扩展及实现假定，
对对象语言源代码中使用的语言构造（特别是影响控制流的合并子(@4.5.3.2) ）进行限制，使用单独的阶段进行抽象求值(@4.1) 。（这允许使用静态 TCO (@5.10.4.2) 所需的变换。）
异步规约动作不需要接受以宿主语言 API 的参数传递的当前项(@6.10) 。
必要时，由上下文或异步规约操作内部捕获保存的值确定当前项。
起始求值规约(@4.4) 的规约动作是异步求值规约动作。
异步求值规约动作应及时以当前待求值项(@6.3) 更新保存在上下文中保存的项，使之后新的表达式求值的动作可确定正确的表达式。

@6.12.2 异步规约操作流程：
调用当前动作(@6.11.3) 引导若干操作（可包括后继的动作对当前动作的更新）组成一个异步操作序列实现对一个项的规约，这和对应的同步操作的树规约(@6.2) 保证 CPS 等价：
除以下约定不支持的宿主行为关联的副作用，规约对应求值的副作用顺序满足可观察行为(@4.1.3) 等价（一般因为无法预测内容，需完全一致）；
组成异步序列的动作（即作用在单一项上的操作）的作用的顺序仍然满足顺序依赖规则(@4.4.6.1) ，但不指定其它的顺序；保持可观察行为等价时，子项不需要使用严格满足树规约的实现。
使用异步序列进行规约即异步规约，实现一个支持 TCO 的规约的一般流程如下：
明确下一步会在规约函数返回规约结果(@6.10.1) 后被异步调用的操作；
通过直接访问或使用 ContextNode::SetupTail 等 API(@6.11.3.1) 设置上下文中的当前动作(@6.11.3) 为此操作。
下一步设置的当前动作为下一动作(next action) 。

@6.12.3 和同步规约的对应关系：
因为不再通过宿主的活动记录保留同步操作对应的项，当明确异步动作及对应的项时，规约函数返回的规约结果(@6.10.1) 和对应同步操作不再具有一一对应关系；上述外层循环的循环条件仅考虑当前动作的有效性，具体同 ContextNode::Rewrite(@6.11.3.1) 的约定。
当前动作对应单一项的到当前待求值项(@6.3) 的有界续延(@4.2.3) 。后继动作(@6.11.3) 是这个边界外的被定界的续延。
实现过程调用(@4.5.3.1) 时，设置子项的当前动作前保存当前动作，和同步操作时保存活动记录帧(@4.5.3.4) 等价。保存当前动作的方式（具体调用的 API ）由调用方的实现指定。
异步规约所在的重写循环(@6.12.1) 中，每个动作返回的规约状态的含义不变；除当前项(@6.10)（若保持副作用顺序，也包括每个子项）上最后一步外，使用当前动作实现一个项内非最终步骤的异步操作，都为部分规约(@6.10.1) ，规约函数返回值应为 ReductionStatus::Partial 。
因为不记录规约的具体项，求值遍(@7.4.1.2) 中的动作序列在需要重规约时无法判断是否保留剩余的规约动作(@6.10.1) 。
是否继续需要剩余规约动作，由规约函数自行判断：
异步规约的实现通过重规约指定跳过剩余的规约动作；
上下文把规约动作的返回值保存在上下文的最后一次规约状态中；
由剩余的规约动作中访问上下文检查状态，根据最后一次规约状态判断是否继续异步添加或忽略（跳过）当前被规约项上的规约迭代(@6.10.4) 中剩余的后续的规约动作。
使用当前动作实现等效的规约时，应注意保存和恢复当前动作，以保持已有规约操作的连续性。
例如，调用 ContextNode::Switch(@6.11.3.1) 替换当前动作，返回被替换的当前动作可在当前动作后再次设置。
不指定当前动作的 ContextNode::Switch 也可用于清空当前动作以满足扩展当前动作操作的前置条件。
实现可使用扩展当前动作操作(@6.12.7) 配合这些调用组合当前动作。保存当前动作可在被保存的当前动作前添加其它操作。因为当前动作表示的续延有界，也可在当前待求值项之后添加操作。

@6.12.4 续延捕获(@4.5.3.3) 支持：
由于宿主语言不支持作为一等对象的续延，捕获续延需在异步动作的边界保存当前续延对应的状态。
一般地，当前异步动作可以是一般的可调用对象，设置组合的动作后不保证可以拆分，也没有限制异步动作的组合必须显式地保留外部可见的边界（保存到活动记录），因此边界需在当前动作外部。
考虑到性能开销和对象语言的基于规约实现表达式求值，约定仅在表达式边界允许保存续延状态。
若支持一等续延捕获，被捕获的续延应不包含在对当前环境具有所有权的定界动作(@6.11.3) ，以避免当前环境强引用的循环引用。这需要进一步在一等续延操作上的扩展支持，当前未实现。
**注释**
续延由 NPL::ContextNode::ReducerSequence(@6.11.3.1) 表示，提供续延捕获直接支持(@6.12.4) 。
当前 NPL::ContextNode::ReducerSequence 使用 YSLib::forward_list 的示例实现且作为 public 基类。因此，可从中取迭代器。
使用 YSLib::forward_list 的特性不被作为稳定的公开接口支持。
特别地，其中元素的稳定性不被保证。这允许未来可能的一些优化，参见 [Hi90] 和 [Br96] 。
分配和重复去配可能引起问题。尽管 NPL::ContextNode::ReducerSequence 没有支持连续的帧，分配缓存的实现已在实现中被考虑。
这个问题在 [Br96] 称为 bouncing ，其中使用类似的栈缓存以避免不可接受的性能开销。
其它实现可能因为类似的问题放弃分段的栈，并不支持续延，如：
https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html（类似的问题在此称作 stack thrashing ）。

@6.12.5 异步规约中立(neutrality) ：
一些实现对是否存在异步规约中立，即实现中被调用的操作可以是同步规约或异步规约。
这具有传递性：当底层实现依赖的被调用的操作都支持异步规约或对异步规约中立，此 API 实现支持异步规约。
所有间接依赖的 API 也都不涉及可观察行为(@4.1.3) 改变的上下文操作的情形称为严格中立。
注意因为可能实现为同步或异步操作，非严格中立上下文的行为仍然可能改变（然而不应被用户代码依赖）。公开的规约不能是返回 ReductionStatus::Partial 的部分规约(@6.12.3) 。
NPLA 及其派生实现的 API 中，依赖可能包括通过同步的回调等方式引入。仅在完全确定不涉及引入这些依赖时，操作被视为异步规约中立的。

@6.12.6 动作帧：
分离的当前动作序列中 NPL::Reducer 类型(@6.11.2) 作为规约器(reducer) ，保存抽象一遍规约的动作(@6.11.3) 。
被保存的规约动作表示续延的帧(frame)（和活动记录帧(@4.5.3.4) 不一定一一对应）。
这也可用于实现捕获(@6.12.4) 有界续延（如控制操作符(@4.4.5.1) shift ）。
被捕获的续延在适当的条件下可重新组合到动作中以实现控制流的切换（如 reset 控制操作符）。
**注释**
一种类似的标记特殊帧的方案参见 SRFI-157 。这种方案在对象语言中标记特定的帧以具现(@1.2.4) PTC 的一等续延，即只有特定的续延和标记具有关联，而不保证标记和一般的一等续延一一对应的关系。
NPLA 动作帧不强调标记依赖 PTC 或一等续延，但动作帧和对象语言续延的非一一对应关系和上述方案之间存在类似性。
关于标记 PTC 的 NPLA 动作帧的设计的实例参见 TCO 动作(@7.10.3) ；尽管这没有在对象语言直接提供关联接口。
另一类传统实现方案以元续延(metacontinuation) 区分出特殊的续延，如以下文献中提及的：
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.8645&rep=rep1&type=pdf
NPLA 的当前动作和当前动作序列(@6.11.3) 是其中和一般续延及元续延对应的实现实体。
ContextNode::ApplyTail 实现和元续延下溢(underflow) 类似的操作。
ContextNode::ApplyTail 中转移当前动作序列的起始元素到尾动作(@6.11.3) 并从当前移除被转移的元素。这种替换可释放原有的尾动作中的资源。
但动作和动作序列不保证维护当前项(@6.10) ，而不保证可直接作为续延被调用，因此也不直接提供类似的 API 。

@6.12.7 组合动作和扩展当前动作(@6.11.3) 的操作：
以下 API 集中实现基于当前动作的复合操作作为中继(relay) ，可用于兼容异步规约(@6.12.1) ：
函数模板 NPL::RelaySwitched 规约当前动作作为后继动作(@6.11.3) ，并在后继动作起始设置当前动作。
NPL::RelaySwitched 以当前动作或特定派生实现定义的其它动作调用时候，可支持 TCO(@5.10.4) 。

@6.13 其它 NPLA 辅助 API ：
NPLA 提供 NPL 语言实现诊断相关的操作，以 Doxygen 命令标识为 \ingroup NPLDiagnostics 。
函数 NPL::TraceException

@6.14 NPLA 数学功能：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla-%E6%95%B0%E5%AD%A6%E5%8A%9F%E8%83%BD 。
数学的基本功能支持提供为 C++ API ，为对象语言中的数值计算(@5.2.2) 等操作提供基本支持。
本节 API 位于内联命名空间 NPL::Math 。

@6.14.1 数值类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B 。
如其它大多数类型，数值类型符合正规表示(@6.10.6) ，只使用值数据成员(@6.2) 表示有效的数据。
Fixnum 和 flonum 在项的内部表示（在值数据成员(@6.2) 中）预期直接占据本机存储而不需要动态分配。

@6.14.2 数值操作约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A 。
除非另行指定，数值操作出错抛出 NPL::TypeError 异常(@6.5) 。

@6.14.3 标签类型：
以下类型具有 NPL::TypedValueAccessor(@6.9.3) 的相关特化。
NumberLeaf
NumberNode
相关的特化检查数值类型的操作数，若失败则抛出异常。
**注释** 使用这种方式访问的 API 可直接以操作数表示数值类型作为前置条件，而不需要在内部检查操作数的值是否具有数值类型。
对应的特化决定这些类型的不同。
NumberLeaf 直接传递数值类型中的值数据成员；
NumberNode 传递 NPL::ResolvedArg<>(@6.9.3) ，包含被 NPL::ResolveTerm(@6.9.3) 解析后的节点和访问引用的指针（ NPL::ResolvedTermReferencePtr(@6.9.3) 类型的值）。
**注释** 后者可以对引用中的标签(@6.8.3.1) 进行处理。

@6.14.4 数值类型谓词(@4.7.6) ：
以下一元函数判断 const ValueObject& 参数是否表示特定的数值类型的值：
IsExactValue
IsInexactValue
IsFixnumValue
IsFlonumValue
IsNumberValue
IsRationalValue
IsIntegerValue

@6.14.5 数值谓词：
以下函数判断 const ValueObject& 参数是否表示特定的数值或对表示数值类型的 const ValueObject& 参数进行比较：
IsFinite
IsInfinite
IsNaN
Equal
Less
Greater
LessEqual
GreaterEqual
IsZero
IsPositive
IsNegative
IsOdd
IsEven

@6.14.5 算术操作：
以下函数对包含数值类型的值的 ResolvedArg<>&& 参数进行算术计算：
Max
Min
Add1
Sub1
Plus
Minus
Multiplies
Divides
Abs

@6.14.6 数值表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA 。
以下函数提供和数值表示相关的操作：
ReadDecimal
NPLAMath 提供以下外部表示相关的 API ：
函数 ReadDecimal
对象 StringBufferSize
函数模板实例 WriteFPString
函数 FPToString

@6.14.6.1 优化实现：
WriteFPString 对浮点数的处理使用有限精度的算法，不保证内部表示完全精确。
NPLA 实现通过宏定义 NPL_Impl_NPLAMath_Has_UInt128 判断是否使用实现提供的 128 位无符号数以帮助改进精度：
	当 NPL_Impl_NPLAMath_Has_UInt128 没有定义时，检查实现是否存在。
		判断条件为 __SIZEOF_INT128__ == 16 和使用特定的实现。
	当 NPL_Impl_NPLAMath_UseQuadMath 定义为符合 #if 判断的值时，假定存在 128 位无符号数类型 __uint128_t 和相关支持。
	否则，忽略 128 位无符号数支持。
不使用实现提供的 128 位无符号整数支持时，使用自定义的 128 位整数类型和有限的操作提供替代实现。
NPLA 实现通过宏定义 NPL_Impl_NPLAMath_UseQuadMath 判断是否依赖外部系统库 libquadmath ：
	当 NPL_Impl_NPLAMath_UseQuadMath 没有定义时，判断 <quadmath.h> 是否存在。
	当 NPL_Impl_NPLAMath_UseQuadMath 定义为符合 #if 判断的值时，直接包含 <quadmath.h> 。
	否则，不使用 <quadmath.h> 。
若使用 <quadmath.h> ，则在包含后进行检查。若宏先前被定义，检查失败时出错；否则，忽略不符合预期的头。
仅当使用 <quadmath.h> 时，使用实现内建的 __float128 扩展类型和其中的 API 。当前实现已在构建中使用 -lquadmath 。
**注释**
GCC 4.6 以来提供 libquadmath 。<quadmath.h> 在 GCC 4.8 之前不直接支持 C++ ，需要添加 extern "C" 声明，但当前没有平台配置([Documentation::Designation @@5.1]) 支持这些实现。
Clang 当前没有提供头文件，也可以附加 libgcc 内部头文件路径包含使用，但默认没有配置相关的选项以支持搜索这些头文件。
尽管是系统库，现有实现中 libquadmath 不被默认链接。因为作为系统库被普遍提供，没有使用 <quadmath.h> 时，仍链接 -lquadmath 。
使用 libquadmath 时，内部表示的精度可被进一步改善，但仍不保证完全精确。
当前实现中不论是否使用 libquadmath ，使用 IEC 60559 的典型实现时，只有 binary32 的内部转换是完全精确的。

@6.15 派生实现和应用实例：
除 NPLA 公共实现和派生实现 NPLA1 外，NPLA API 还具有一些其它应用实例。

@6.15.1 NPLA1 应用实例：
在对象语言(@7) 外，NPLA1 的实现也被用于其它应用。
NPLA1 当前加入特定的序列化和反序列化作为配置文件，参见模块 NPL::Configuration ：
A1::NodeLoader 加载(@1.2.4) NPLA1 翻译单元（另见 @6.1.6.3 ）。
NPLA1 的上述配置文件加入特定的匹配和初始化机制作为 YSLib::UI::Loader([Documenatation::YSLib @@6.15.9]) 在运行时读取用户界面布局和配置的脚本。
NPLA1 用于 MIME 类型和文件名映射([Documentation::YSLib @@4.5.3]) 的实现，上述配置文件对应的外部配置格式。
注意这些应用不直接使用 NPLA1 的语义，其中使用的 TermNode 类型中名称直接表示上下文(@4.6) 中的实体名称。
计划使用完整的实现(@7) 取代这些应用的底层，使用 NPLA1 作为对象语言或作为附加的代码生成遍重新实现这些应用，但具体路线图未定。
关于当前提供的应用，另见依赖管理模块(@8.5) 和 @10 。

@6.15.2 NPLA 其它实现应用实例：
模块 SXML 的命名空间 NPL::SXML 提供的 API 部分支持以 NPLA 分析 SXML 及构造 NPLA 表示的节点并转换为 XML 输出。
NPL 自定义分析器被用于 NPL::Dependency 模块中的函数 NPL::DecomposeMakefileDepList 实现解析 GCC 输出的兼容 GNU make 包含依赖字符串。

@6.15.2.1 非规约节点操作：
模块 SXML (@6.15.2)在命名空间 NPL 提供的部分 API 用于不经过规约过程的变换，为纯语法操作。命名空间 NPL::SXML 依赖这些 API 。
其它操作包括向输出流打印节点的文本表示等。

@6.15.3 实现兼容性：
除非在此另行指定，YSLib 中的 NPL 实现保持兼容。
影响向前兼容的变更：
b449 增加对多个未命名节点（叶节点或第一个子节点未能解析为名称的分支节点）作为非名称子节点时的反序列化支持。多个值会被以 $ 前缀接序号（从 0 起始）命名。之前的版本中读取的节点名称为空串，值被覆盖为第一个节点值。

@7 NPLA1 解释实现：
NPLA1 解释实现是 NPLA 给定的 AST(@6.1.6) 作为输入的解释器(@5.1) 。
和 NPLA 类似，NPLA1 的实现也注重可扩展性。在限制修改语言规则的前提下，部分实现可被语义等价地使用更高性能的简化实现替代。
命名空间 NPL::A1 提供了特定于 NPLA1 的 API 。以下命名空间 A1 指 NPL::A1 。
命名空间 A1::Forms 提供了 NPLA1 的语法形式(@3.4.3) 对应的功能的实现(@8.4) 。
以下限定名称中，无歧义的嵌套限定命名空间使用非嵌套类型名称（如 Forms 指 A1::Forms ）。
除此以外，本章以 NPLA 总体架构(@6.1.3) 约定的限定名称的方式使用 API 中出现的 C++ 名称和项目模块命名空间。

@7.1 NPLA1 一般约定：
在 NPLA 的一般约定(@5.2) 外，本节概述不通过具体 API 指定的一般特性。
参见存储和对象模型(@5.6)（包括临时对象生存期(@5.6.3) 和内存安全(@5.6.4) ）的基本规则。
另见作为具体实现的 NPLA 间接值(@6.4) 使用规则的保证机制(@7.1.3) 、NPLA 间接值规则(@6.4.3) 、NPLA1 引用值使用约定(@9.9.1.1) 和求值对应的 API(@7.6.4) 。
NPLA1 实现可在实现中提供构建时确定的实现选项，以宿主语言的宏定义等方式启用。
除非另行指定，对 NPLA1 实现选项的宏的要求和约定同 NPLA 实现选项(@6.1.2) 。
和 NPLA 不同，这些选项主要用于提供参照实现，不应被直接作为公开接口；通常情形不需要更改。
特定的 API 可间接依赖这些特性，以便派生实现提供不同的优化实现，包括：
	A1::GlobalState::IsAsynchronous(@7.8.1)
部分 NPLA 安全保证(@6.1.4) 依赖：
	特定的实现选项支持（如 NPL_Impl_NPLA1_Enable_ThunkedSeparatorPass(@7.9.2) ），当没有启用时可能不满足。
	被调用的互操作(@5.3) 实现支持相应的安全保证。
**注释**
互操作的本机实现(@5.3) 接口的最简实现不一定允许在合理的开销内满足这些安全保证。
为满足整体保证，实现可能需要提供附加的机制。参见本机实现(@7.1.4) 。

@7.1.1 对象语言约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%BA%A6%E5%AE%9A 。
关于作为表达式的求值，参见表达式的表示(@6.3) 。
关于类型映射的实现，参见 @6.1.7 。
**注释**
引入过程(@4.5.2.2) 的具体形式参见过程抽象(@8.4.5) ，也可约定通过特定的本机函数(@5.3) 等其它方式提供。

@7.1.1.1 标识符附加规则：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A0%87%E8%AF%86%E7%AC%A6%E9%99%84%E5%8A%A0%E8%A7%84%E5%88%99 。

@7.1.2 项的结构：
项的结构（如项的分类(@6.2.1) 或子项数）和检查密切相关(@7.6.1.3) 。
遍的处理可能改变项的结构。应注意避免遍的处理器实现因此被改变自身或对此具有所有权的对象生存期导致未定义行为。
特定的项可具有非默认值的标签(@6.2.2) 。当前仅使用 TermTags::Temporary(@6.2.2) ，包含以下互不影响的情形：
在特定的被规约项(@6.2) 的管理规约(@4.4.2) 中，标记函数调用右值(@7.6.4.2) ；
在被绑定对象(@6.11.1) 或由被绑定对象通过调用 A1::EvaluateIdentifier(@7.6.4) 得到的被规约项的被引用对象(@4.2.6) 中，标记绑定临时对象(@7.7.3.2) 。
其它标签当前作为项的成员不直接被使用，这包括：
被绑定对象中，不使用其它标签；
在表示求值结果(@4.1) 的被规约项中，不直接使用其它标签，对应宿主语言的限定符在纯右值(@5.8.1) 忽略。
除非派生实现另行指定，NPLA1 实现可假定已知纯右值的项中不存在以上不直接被使用的标签：
本机实现(@5.3) 选择复制或转移（参见 @5.8.2.3 和 @6.3.4 ）时，不需要判断表示纯右值的项的标签是否包含 TermTags::Nonmodifying(@6.2.2) 以避免修改。
NPLA1 本机实现初始化引用项时，仍应使用其中的标签初始化，以避免依赖具体标签的逻辑。以不表示求值结果的被规约项（如被绑定对象）的初始化可在标签中排除作为求值结果时未被使用的标签值如 TermTags::Temporary 。
以上限制不包含标签的单独使用（如 A1::BindParameter(@7.7.4) ）。

@7.1.3 NPLA1 规约内存安全保证机制：
关于内存安全，参见 @5.6.4 。
在 NPLA 对象语言约定的间接值使用约定(@5.6.2.1) 以及相关互操作的约定(@6.4) 的基础上，NPLA1 规约附加以下约定以维护内存安全。

@7.1.3.1 修改限制：
部分关于间接值的操作依赖非内存安全操作(@5.6.4.1) ，其实现应满足一定限制以保证对外部调用者保证内存安全。
绑定操作(@7.7.3) 的 API 在实现内直接通过复制或转移立即使用可能创建的间接值而在复制或转移未失败时保证内存安全（仅当不按值传递(@4.4.6.5) 绑定的对象不保证内存安全）。
规约过程中可能使用 NPLA 项提升 API(@6.9.4) 。其中，消除中间值的操作(@6.9.4.3) 被用于实现内存安全的操作。

@7.1.3.2 非内存安全项：
引用持有者(@6.4.3.1) 仅存在有限的求值中间过程中。
调用引入间接值的 NPLA API(@6.9.4.5) 在 NPLA1 实现中仍可能保证内存安全(@5.6.4.2) 。
NPLA1 实现不直接调用非内存安全的提升操作(@6.9.4.5) ，除非之后立即同步地消除访问时无法保证内存安全的结果(@6.9.4.3) 。
提升引入引用值和消除引用值通常使用 NPLA API ：消除引用值的实现可局部间接值安全保证(@5.6.4.5) ；引入和消除间接值也可使用基本提升操作(@6.9.4.1) 。派生实现也可调用这些函数处理引用持有者。
其它 NPLA1 非内存安全操作(@5.6.4.1) 包括实现中调用的明确取无所有权引用的 API ，参见关于间接值的约定(@8.1.2) 以及 @8 中具体函数的描述。
NPLA1 对后者的使用可选地使用 NPLA 运行时检查(@6.1.2.1) 补充基于项引用(@5.8.3.8) 和环境的引用计数(@6.11.3.1) 的检查机制（如 @8.4.5.2 ）。

@7.1.4 NPLA1 互操作约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E4%BA%92%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A 。
**原理**
调用假定异步规约不存在的实现允许使用直接风格(@6.12) 代替异步调用(@6.11.3) ，一般能显著节约调用开销，但对非特定类型，这不保证提供（在宿主语言无法提供的）嵌套调用安全保证。
本机实现的 == 因为宿主语言的接口缺乏一般异步调用支持，不提供在宿主语言无法提供的嵌套调用安全保证。
由于宿主语言的接口限制，要求本机实现的 == 操作使用 NPLA1 异步规约(@6.12) 需要显著增加接口设计的复杂性和实现开销，因此在此不作要求。
为满足嵌套调用安全保证，实现需要避免异步调用，或自行使用其它的异步调用机制。

@7.2 NPLA1 中间值：
NPLA1 扩展了 NPLA 的中间值(@6.8) 机制。
NPLA1 规约使用 @6.8 约定的类型影响求值状态。
除这些中间值和以下节引入的中间值外，不引入其它中间值。

@7.2.1 处理器：
每一遍规约迭代(@6.10.4) 实现为一个事件处理器(handler) ，称为遍处理器。
这允许运行时修改求值执行的不同逻辑以取得较大的灵活性和可扩展性。
遍处理器持有目标对象并具有其所有权。
**注释** 这和 std::function 实例的目标对象(@6.2) 类似。
直接在值数据成员(@6.2) 储存的符合函数类型要求(@4.5.2) 的扩展中间值(@6.8) 是处理器，用于实现规约中的特定操作。
处理器可作为对象语言中的一等对象(@4.1) 的宿主类型(@5.3.1)。
处理器的调用是遍处理的规约过程中处理的。处理器类型不一定是在宿主语言中的函数。
使用基于 ContextNode 类型作为输入的事件处理器（ YSLib::GHEvent 的实例）作为中间值形式的处理器，可以组合不同的操作，用于实现规约(@6.10) 。
NPLA1 提供以下处理器类型的 NPLA 扩展中间值(@6.8) ：
A1::ContextHandler 以 TermNode(@6.2) 和 ContextNode(@6.11.3) 作为输入，实现一般的上下文处理，可作为 A1::EvaluationPasses(@7.4.1.2) 的事件处理器。
A1::LiteralHandler 以不可修改的 ContextNode 作为输入，用于和当前被规约的特定项无关的事件，典型地用于处理字面量引起特定的事件。
使用 NPL::EmplaceLeaf<A1::ContextHandler> 和 NPL::EmplaceLeaf<A1::LiteralHandler> 可设置环境或 ContextNode 的环境中的绑定的指定名称对应的处理器。参见 @6.11.4.2 。
关于 A1::ContextHandler 和遍处理、规约过程的关联和宿主类型，详见 @7.6.1 。
A1::LiteralHandler 可用于对特定单一记号(@6.8.1) 而不是记号组合作为输入时的处理，可配合交互式界面使用，参见 @7.8 。
处理器不构成 NPLA1 一等对象的表示(@6.3.2) 。
推论：可假定表示一等对象的表示的项不包含处理器。

@7.2.1.1 使用约束：
规约实现需满足被规约项稳定性(@6.4.4) 。
在 @6.4.4.1 决定操作状态的资源包含当前使用的遍处理器中的目标对象(@6.10.4.3.1) 。
规约前被规约项的第一个子项具有遍处理器的所有权，也对目标对象具有所有权。
假定满足限制而允许删除子项的情形(@6.4.5) 包括：
主规约函数(@6.10.5.3) 和 NPLA1 扩展实现(@8) 支持的本机函数(@5.3) 的实现可假定被在调用处理器前会转移子项的处理器调用；
规约合并求值函数在调用处理器前转移子项中的处理器右值(@7.6.4.2) ，以保证调用时生存期不会因为直接清理第一个子项而结束，因此处理器的实现内部可清理第一个子项。

@7.2.2 节点记号：
NPLA1 实现使用 A1::ValueToken 枚举类型表示用于特殊标记的扩展中间值(@6.8) 。
当前被保留未直接在规约例程(@7.4) 中使用。
A1::ValueToken::Null 用于作为规约(@7.4) 过程中值数据成员(@6.2) 的占位符，适合值数据成员(@6.2) 逻辑上为空但不符合其它要求（如需要保留节点但稍后规约中被移除）时的场合，当前实现对 NPLA1 实现都是透明的；
A1::ValueToken::Unspecified 用于表示未指定的值，是一等中间值(@6.8.1) 。
语言规范(@1.2.1.2) 可使用 A1::ValueToken::Unspecified 作为没有附加限制条件的未指定值(unspecified value) 的内部表示，但实现的 API（如 A1::Forms(@8.1) ）会明确指定使用这个值（如设置这个值作为对象语言中函数的返回值），用户代码仍然不应依赖此处使用的具体值。
注意当前 A1::Reduce 规约时不对空节点（表示空列表）和 A1::ValueToken 类型的值进行操作。

@7.2.3 NPLA1 续延(@4.5.2.2) ：
续延是依赖上下文状态(@7.4.3) 的一等中间值(@6.8.1) ，参见合并遍(@7.4.2) 。

@7.3 错误处理例程：
除非另行指定，NPLA1 实现优先使用以下包装 NPLA 异常(@6.5) 的错误处理 API ：
A1::ThrowInvalidSyntaxError
A1::ThrowNonmodifiableErrorForAssignee
A1::ThrowUnsupportedLiteralError
A1::ThrowValueCategoryError
**注释**
一般地，对预期有序对左值的参数，使用等价 Forms::CheckPairReference(@8.4.7) 的检查而不是 NPL::ThrowInsufficientTermsError(@6.9.2) 或错误处理例程。

@7.4 规约实现：
NPLA1 在 NPL::A1 中提供不同粒度的规约和求值实现 API 。
由于实现 NPLA 的宿主语言不支持 TCO(@5.10.4.1) ，在实现时显式使用尾调用(@5.10) 形式才能支持空间复杂度和规约调用的嵌套深度无关；详见 @7.10 。
命名空间 A1 中使用上下文参数的规约函数（参见 NPLA1 主规约函数(@7.4.4) 和一般规约函数(@7.4.6) ）要求 ContextNode& 类型的参数引用的对象是 NPLA1 上下文状态或 public 继承的派生类，否则行为未定义。

@7.4.1 遍类型：
基于 YSLib 事件（ YSLib::GEvent 的实例），NPLA1 提供若干的遍类型。
基于 NPLA 公共实现，NPLA1 使用上下文提供的可配置的公共遍(@7.4.3) ，其 API 详见 NPLA1 上下文状态(@7.4.3) 。

@7.4.1.1 遍合并器(pass combiner) ：
忽略部分规约(@6.10.1) 的多个遍的调用结果被实现为遍合并器 A1::PassesCombiner 定义的逻辑合并。
合并时使用的判断条件参见规约结果合并(@6.10.4.4) 。
遍合并器依次调用事件处理器，合并调用的结果是表示是否需要重规约(@6.10.1) 的值。当发现调用的结果对应遍的规约结果需要重规约时，调用停止。
遍合并器被 YSLib::GEvent 的模板参数依赖，可简化不使用异步规约(@6.12.1) 的同步实现。

@7.4.1.2 合并遍：
A1::GPasses 是用于作为可合并结果的遍的泛型类型。从事件处理器合并的结果被作为调用结果。
基于 A1::GPasses ，NPLA 提供处理不同的种类的合并结果的遍：
A1::TermPasses ：项合并遍，处理一般项的合并。项合并遍只使用项作为输入。
A1::EvaluationPasses ：求值合并遍，简称求值遍(evaluation pass) ，处理一般求值的合并。求值使用项和上下文作为输入。
A1::LiteralPasses ：字面量合并遍，处理已知为字面量的项的求值。
遍的返回结果是 ReductionStatus(@6.10.1) 。
字面量遍的处理器应翻译可接受的字面量，返回结果是 ReductionStatus::Clean ；
否则，返回 ReductionStatus::Retrying 。
后者包括标识符是符号(@6.8.1) 的情形。
当前字面量不支持列表项，返回 ReductionStatus::Retained 同 ReductionStatus::Clean ，但可能在未来改变。
当前字面量遍不支持异步规约(@7.9)，返回 ReductionStatus::Partial 同 ReductionStatus::Retrying ，但可能在未来改变。

@7.4.1.3 非合并遍：
直接基于 YSLib::GEvent ，NPLA 还提供以下不合并结果的遍：
NPL::GuardPasses ：作用域守卫遍，处理固定出口逻辑的遍，对应作用域守卫类型 NPL::Guard 。
最后一个作用域守卫的值被作为调用的结果。

@7.4.1.4 遍规约约定：
A1::Reduce(@7.4.4) 满足迭代顺序(@7.4.5) 提供的保证优先检查子节点数，列表遍仅用于子节点数大于 1 的非叶节点(@6.2.1) 求值。
这个特性允许在对象语言的对应确定被求值的子项的表达式外添加匹配的括号而不改变语义，且在列表遍中可简化子项求值（如 @7.6.4 直接使用 ReduceCombined(@7.6.4.2) 而不需检查节点数量是否大于 1 ）。
一般列表遍不依赖以上假设，可能对叶节点或具有一个节点的平凡列表节点对应的表达式求值。因此列表遍不是枝节点(@6.2.1) 遍。
遍的调用不一定需要维护共享状态，因此一般多个遍被调用时，不保证求值中异常时的状态完全确定；但除非另行指定，仍满足 NPLA API 异常安全保证(@6.1.4.2) 。
当前实现中，若实现包含以下操作实现，则不提供强异常安全保证：
涉及多个一等对象的复制。
除合并子调用创建操作(@7.6.4.2) ，NPLA1 规约实现不保证进行正规化操作(@6.10.6.1) ：
在正规化操作不保证存在时，实现列表遍的用户代码需注意清理(@6.10.2.1) 不需要的子项。
**原理**
参见 NPLA API 异常安全保证。
**注释**
不提供事务性保证的典型例子之一是消除中间值的提升操作(@6.9.4.3) 中对多个子节点表示的一等对象的复制。

@7.4.1.5 规约函数实现约定：
关于规约函数(@6.10.5) 的基本约定，参见规约函数形式约定(@6.10.5) 。
对 NPLA1 使用的规约函数(@7.4.6)（不含 NPLA 中引入的规约函数，下同），约定以下可被实现假定的使用要求：
	若具有上下文参数，则上下文的动态类型是 A1::ContextState(@7.4.3) 或其 public 派生类。
若规约函数包含异步求值规约且不排除可能调用续延，规约函数还应满足：
	若可能通过调用 A1::ContextState::ReduceOnce 调用续延(@7.4.2) ，应确保调用时下一求值项(@7.4.3) 被正确设置。
	以下情形要求规约函数具有指定 NPLA1 上下文的参数，以此和被规约项作为参数调用 ContextState::SetNextTermRef 更新 NPLA1 上下文中保存的下一求值项：
		对主规约函数(@7.4.4) 及名称包含通配符模式 ReduceCombined* 、Reduce*Subsequent 或 RewriteTerm 起始的规约函数，在下一步规约前以 TermNode& 参数指定的当前项(@6.10) 更新下一求值项。
		发生和当前项不同的被规约项（通常表示子表达式）的规约，首先以新的被规约项更新下一求值项。
	除以上要求以当前项更新下一求值项的函数，调用函数的当前项应和下一求值项相同。
使用不符合以上要求的实现的程序行为未定义。

@7.4.2 NPLA1 续延：
类 A1::Continuation 表示 NPLA1 的一等续延，即作为一等对象(@4.1) 的续延。
一等续延当前未完全在对象语言中被支持。
续延同时在规约中作为非一等对象使用，以支持异步规约(@6.12) 。
续延依赖 NPLA1 上下文状态(@7.4.3) 。
A1::Continuation 对象保存 A1::ContextHandler(@7.6.1) 对象实现具体操作。
A1::Continuation::operator() 以 ContextNode& 参数直接调用续延。
调用续延要求上下文对象的动态类型包含 NPLA1 上下文，取其中的下一求值项作为当前项(@6.10) 。
**原理**
NPLA 上下文中的续延提供续延捕获直接支持(@6.12.4) ，而 NPLA1 续延是这个机制上的扩充。
NPLA1 续延的必要性体现为对下一求值项(@7.4.3) 的支持（这隐含运行时对上下文状态类型(@7.4.3) 的要求），以支持对象语言中的一等续延(@4.5.3.3) 。
此外，也可存在其它的表示不支持被捕获为一等续延的内部续延的对象。例如，Forms::Sequence(@8.4.9) 中的内部续延不支持访问（因此不依赖）下一求值项，而不需要实现为 A1::Continuation 。
**注释**
另见动作帧(@6.12.6) 。

@7.4.2.1 一次续延调用检查：
NPLA1 内部提供调用检查类在一次续延(@4.5.3.3) 被捕获时共享状态，标记续延已被调用而确保不可重入(@4.5.2.2) 。
进入来自同一具现的一次续延的任何副本只允许一次显式（续延应用）或者隐式（如被函数调用的返回蕴含）的调用时，共享状态都应被标记。

@7.4.3 NPLA1 上下文状态：
类 ContextState 是 ContextNode 的 public 派生类，其对象表示 NPLA1 上下文状态，包含 NPLA 上下文的状态(@6.11.3) 。
A1::ContextState 包含作为之后的异步求值规约动作(@6.12.1) 使用的当前项(@6.10) 的下一求值项。
NPLA1 上下文状态可访问以下的供迭代的公共遍：
守卫遍(guard pass) ，类型是一个 GuardPasses(@7.4.1.3) ，用于提供调试回调等。
叶遍(leaf pass) ，类型是一个 EvaluationPasses(@7.4.1.2) ，用于实现叶节点(@6.2.1) 对应表达式的求值。
列表遍(list pass) ，类型是一个 EvaluationPasses ，用于实现列表节点对应表达式的求值。
字面量遍(literal pass) ，类型是附加 string_view 参数的 EvaluationPasses ，用于在叶遍的处理器内部调用，处理不同类型的扩展字面量(@5.2) 。
尽管 NPLA 已约定字面量的词法构成(@5.2) ，仍使用字面量遍而不是固定的扩展字面量处理逻辑以便派生实现决定具体字面量的关于不同字面量和不同语义的处理方式，同时能保证实现逻辑的局域性。
A1::ContextState 提供以下公开 API ：
数据成员 Global 指定全局状态(@7.8) 的引用，包含共享的公共求值遍。
数据成员 Guard 是上下文提供的公共遍守卫遍。
数据成员 ReduceOnce
成员函数 RewriteGuarded 和 ContextNode::Rewrite 类似，但首先调用成员 Guard 动作。
成员函数 Access 通过指定的 ContextNode 对象中访问对应的 ContextState 引用。
成员函数 GetCombiningTermPtr
成员函数 GetNextTermRef
若下一求值项的指针为空，抛出 NPL::NPLException(@6.5) 异常。
成员函数 SetCombiningTermRef
成员函数 SetNextTermRef
成员函数 ClearCombiningTerm
成员函数 ClearNextTerm
类 A1::ContextState 包含以下静态成员函数作为默认算法实现：
DefaultReduceOnce

@7.4.4 NPLA1 主规约函数：
函数 A1::Reduce 和 A1::ReduceOnce 是 NPLA1 规约使用的主规约函数(@6.10.5.3) ，返回类型为描述一次规约调用操作结束后的状态的 ReductionStatus(@6.10.1) 。
A1::ReduceOnce 转发操作到 ContextState::ReduceOnce 的处理器调用，后者提供默认实现为 ContextState::DefaultReduceOnce(@7.4.3) 。
A1::Reduce 是 A1::ReduceOnce 的包装，最终调用后者以支持异步规约(@7.9) 。
@7.4 及以下各节中对 A1::ReduceOnce 的行为描述默认由 A1::ContextState::DefaultReduceOnce(@7.4.3) 实现。替换的实现应保持的要求相同。
A1::ReduceOnce 的规约对列表和非列表分别进行处理，直接提供求值算法(@4.4.1) 的实现的入口，要求单一子项的项规约为其子项，而其它列表或非列表项的规约操作由遍(@7.4.1) 提供。其中，列表被先匹配。
注意 A1::ReduceOnce 中的处理器(@7.2.1) 作为应符合关于中间值的使用约束(@7.2.1.1) 。
若实现中使用的处理器不符合约束，可能不满足 @6.4.4.1 并可能引起未定义行为。
对支持异步规约的实现(@7.9.2) ，上述处理器还应符合和同步规约实现兼容性(@7.9.1) 中的规则。
A1::ReduceOnce 和辅助规约函数(@6.10.7) 类似，能处理一般的项，没有附加对项的内容的要求的前置条件。参数中 TermNode(@6.2) 表示的表达式语法意义(@3.4.2) 上非空，但没有实现限制（即不附加检查）。
A1::ReduceOnce 循环调用遍(@7.4.1) 即迭代规约。迭代规约响应必要的 ReductionStatus::Retrying 规约状态支持重规约(@6.10.1) 的实现，但在此仅处理规约实现的内部公共状态。具体的重规约由遍(@7.4.1) 的调用实现。
对异步规约中立的规约（包括遍的实现和 NPL 中如 ContextNode::RewriteLoop(@6.11.3.1) 这样的调用规约函数的重写入口）同时对重规约中立。默认实现中，仅有公共的叶遍(@7.4.3) 的实现直接实现重规约。这种实现方式是同步的，即判断需要重规约后不使用异步规约(@6.12) ，但仍保证嵌套调用安全(@6.1.4.1) 。
遍的同步实现一般通过 NPL::CheckReducible(@6.10.3) 判断是否需要同步的重规约。这同时处理 ReductionStatus::Partial ，同步已被异步规约的部分规约。
在具体操作的异步规约实现中实现的重规约，参见异步规约基本支持(@7.9.2.1) 和异步重规约(@7.10.8) 。当前默认实现中，这由列表遍(@7.4.3) 调用。
A1::ReduceOnce 的实现中不直接指定需要重规约；所有 ReductionStatus::Retrying 都来自遍的调用。
遍的调用在支持异步规约(@7.9) 的实现中明确指定作为尾上下文(@4.4.8) 。
名称表达式的求值不进行进一步规约(@4.5.1) ，这由具体遍(@7.4.1) 的实现保证。关于记号，另见记号值(@6.8.1) 。
使用设置遍的 API(@7.4.1) 修改 ContextNode 中的具体遍以使用不同的规约规则。
其它规约例程可直接作为规约函数实现遍规约，参见 @7.4.6 和 @7.4.7 。
NPLA1 主规约函数依赖 NPLA1 上下文状态(@7.4.3) 。

@7.4.5 迭代顺序：
A1::Reduce 定义节点次级结构分类(@6.2.1) 指定的规约迭代顺序被作为默认规约迭代顺序。
具体的分类和适用范围详见源代码文档。

@7.4.6 一般规约函数：
NPLA1 规约函数可能使用上下文，一般通过 ContextNode& 参数表明依赖上下文的状态(@6.11.3) ，且可能进一步依赖 NPLA1 上下文状态(@7.4.3) 。
若依赖 NPLA1 上下文状态的函数的上下文参数的动态类型不是 A1::ContextState(@7.4.3) 或其 public 派生类，则行为未定义。
若使用异步实现，满足和同步规约的对应关系(@6.12.3) 以能兼容其它操作使用不同的实现。
A1::ReduceArguments 从第二个子项起逐项规约。
这允许单一子项表示没有参数的情形，即便这不会通过 A1::Reduce(@7.4.4) 得到（因为子节点数为 1 时不调用列表遍），也可简化某些实现如过程抽象(@8.4.5) 。
A1::ReduceChildren 规约子项。
A1::ReduceFirst 对可能存在的第一个子项进行规约。
若第一个子项规约结果(@6.10.1) 可被作为列表遍(@7.4.3) 的事件处理器，整个项可继续规约。能进行此规约的形式称为 fexpr ，其中 f 表示 first 。
在某些其它语言中，符合类似求值规则的构造也称为 fexpr ，但语源不尽相同。
可组合使用 fexpr 的求值以及其它显式对 fexpr 子表达式的求值实现非严格求值(@4.4.6.5) 。
因为避免判断未指定子表达式是否需要规约（实现即非确定性求值(@4.4.6.5) ），A1::ReduceFirst 一般具有较小的解释开销。
A1::ReduceOnceLifted 先提升项(@6.9.4.1) ，再调用 ReduceOnce 规约。
A1::ReduceOrdered 顺序规约余下的子项，使用最后一个子项的值。
在 NPLA 生存期附加约定(@5.9) 的基础上，子项的求值被严格先序关系约定。
A1::ReduceTail 移除第一个子项并规约余下的项。
A1::ReduceToReferenceList

@7.4.7 NPLA1 辅助规约函数：
类似 NPLA ，NPLA1 提供若干辅助规约函数(@6.10.7) ，包括：
A1::ReduceReturnUnspecified

@7.4.8 其它辅助函数：
A1::SetupTraceDepth 设置跟踪深度节点，主要用于调试。

@7.5 NPLA1 节点处理 API ：
NPLA1 提供了对节点作为树形数据结构和整体处理的处理 API 。

@7.5.1 中缀变换：
NPLA1 提供中缀变换 API 实现中缀语法的变换(@9.7.1.1) 。
这些操作以函数对象类型 SeparatorTransformer 提供。
其中，函数成员 operator() 直接提供核心变换算法。
变换包含递归和非递归变换。
变换结果可被进一步规约。
另见异步规约实现(@7.9.2) 。

@7.5.2 叶节点分析 ：
叶节点(@6.2.1) 分析 API 作为标记器(@7.8) 的实现转换词素到包含记号的项，包括：
函数 A1::ParseLeaf
函数 A1::ParseLeafWithSourceInformation
后者在分析得到的符号中附加源信息(source information) ，被诊断 API(@7.7.5) 使用。
叶节点分析蕴含对特定词素的叶节点进行一次求值(@7.6.4) 使其在之后可作为自求值项(@4.4.5) 。

@7.6 遍处理：
除主规约函数(@7.4.4) 和一般规约函数(@7.4.6) 外，NPLA1 还提供若干 API 作为和特定节点内容相关的具有特定功能的遍(@7.4.1) 的事件处理器。
遍处理 API 中的规约函数作为 NPLA1 规约函数(@7.4.6) ，可能对上下文类型有类似的附加约定。
详细功能参见源代码文档。

@7.6.1 上下文处理器(context handler)：
基于 A1::ContextHandler(@7.2.1) ，NPLA1 提供了包含特定公共（检查或其它功能）逻辑的节点处理器包装其它事件处理器。
类模板 A1::WrappedContextHandler 是适配可选返回类型的包装模板。
当处理器返回类型为 void 时，可默认指定返回值为 ReductionStatus::Clean(@6.10.1) 。
注意上下文处理器不只适用于特定的规约实现如 A1::Reduce(@7.4.4) 。

@7.6.1.1 宿主类型：
A1::ContextHandler 是合并子(@4.5.3.2) 的宿主类型(@5.3.1) 。
迭代时，求值遍(@7.4.1.2) 可选使用基于 A1::ContextHandler 的处理器作为 A1::EvaluationPasses 事件处理器：
类 A1::FormContextHandler ：一般形式上下文处理器，表示可能不保证对操作数严格求值的非扩展合并子(@4.5.3.2) 。
当且仅当其中的处理器不是 A1::FormContextHandler 类型时，表示扩展合并子。
初始化 A1::FormContextHandler 提供包装数(@9.9.4) ，决定调用合并子时对操作数求值的次数。
包装数在初始化后由数据成员 FormContextHandler::Wrapping 保存。这是一个 size_t 类型的值，存在上限。
相对（单独分配的应用子的存储的）直接实现，这减少构造应用子时需要的分配。
其数据成员 Handler 为被包装的处理器，类型为 A1::ContextHandler 。
Handler 是合并子的底层合并子(@4.5.3.2) ，可被嵌套地多次初始化。嵌套初始化操作实现合并子的包装(@4.5.3.2) 。
其数据成员 Wrapping 是一个 size_t 类型的值，指定调用合并子时对参数求值的次数。
操作子(@4.5.3.2) 以具有 0 值的 Wrapping 的 A1::ContextHandler 对象表示。
应用子(@4.5.3.2) 以具有非 0 值的 Wrapping 的 A1::ContextHandler 对象表示。

@7.6.1.2 处理器调用：
A1::FormContextHandler::operator() 以构成函数合并(@4.5.3) 的语法构造作为参数，其中的项是规约合并项(@6.9.1) 。
宿主环境可访问比对象语言中的合并子(@4.5.3.2) 更多的数据。
被调用时，参数的项是函数合并，其中第一个子项是合并子对象；但若被调用的合并子是左值时，其中第一个子项（即 WHNF(@4.4.5.1) 第一项）的内容未指定。
A1::FormContextHandler::operator() 依次进行以下操作：
按 Wrapping 的次数指定调用合并子参数求值，每次调用 A1::ReduceArguments 求值每一个子项（函数参数）；
使用 CallHandler 成员函数调用被包装的处理器(@7.6.1.1) Handler 数据成员。
除此之外，附加操作参见前置条件检查和异常处理(@7.6.1.3) 。
注意直接在处理器中调用规约实现可导致无限递归；另见强规范化(@4.4.5) 。
特定的处理器构成具有非平凡非正规表示(@6.3.7.2) 的子对象引用项(@5.8.3.8) 。这种处理器是其它处理器的表示的对象语言值（合并子）的子对象。它被调用时：
清除 TermTags::Temporary(@7.1.2) 以确保不被作为函数右值(@7.6.4.2) ；
转发参数到包含这个子对象的处理器的 operator() 并返回规约结果。
**原理**
在进入调用前保留第一个子项允许实现复用项进行下一步操作（如保存从记号得到的函数左值的源信息(@7.5.2) ）而减小分配开销。
第一个子项可保存合并子对象及其中的资源。但当合并子是引用值时，这个对象不需要保存资源。此时，不指定第一个子项的内容允许外部调用者的优化，例如当确定 A1::ReduceCombinedReferent 和 A1::ReduceCombinedReferentWithOperator(@7.6.3) 调用时不需要依赖其中的内容，因此在其调用前可不访问第一个子项的内容。
为避免依赖第一个子项的内容，递归的合并子调用在本机实现中一般需要直接依赖已知目标类型(@6.2) 的具体本机实现，而非（在无法确保第一个子项的内容时）直接使用 A1::ReduceCombined(@7.6.3) 直接重规约(@6.10.1) 而重复求值递归的合并项。
当前实现中，第一个子项典型地是经过 A1::EvaluateIdentifier(@7.6.4) 等得到的引用值或者其它一等对象的表示(@6.3.2) 。经 A1::ReduceCombined 调用后进入处理器调用时，第一个子项表示的值是合并子。但这不在一般实现中被保证。
派生实现可能具有其它的使用方式，可能不表示一等对象。例如，优化的派生实现可结合 A1::EvaluateIdentifier 和 A1::ReduceCombinedReferent 直接调用找到的合并子，而不需要依赖第一个子项的内容。
**注释**
处理器调用在尾上下文(@4.4.8) 最终实现合并子调用。
本机实现(@5.3) 合并子应避免依赖合并中的子项的操作改变被对象语言要求以外的可观察行为(@4.1.3) 。
典型地，若不复用第一个子项，本机实现需在确保其中的内容不被依赖后的适当情形下调用 RemoveHead(@6.4.5) ，以确保处理器调用后得到预期的合并子调用的求值结果的表示(@6.3.5) 。

@7.6.1.3 前置条件检查和异常处理：
A1::FormContextHandler::operator() 调用时，按包装数(@7.6.1.1) 判断是否需要调用（被包装的处理器 Handler 数据成员）。
若需要调用，调用被包装的处理器 Handler 数据成员，并处理部分异常；
否则，以 A1::ReduceArguments(@7.4.6) 方式规约参数项并以减少包装数 1 的上下文处理器中的调用作为后继调用。
Handler 调用至少可断言项满足 IsBranchedList ，但这在 A1::FormContextHandler::operator() 没有检查。
NPLA1 实现中，作为被调用的处理器（如 @7.4.6 和 @8.4 中的 API ）中可能存在对参数数量的检查。这类检查中已对枝节点类别进行检查，即不需要指定 NPL::IsBranchedList 作为前置条件。

@7.6.1.4 比较操作：
包装模板和上下文处理器提供重载操作符 == 以支持比较谓词(@8.4.1) 。
比较是必要的；否则，实例化 GHEvent 的操作可能导致无限递归调用。
当前没有直接提供 != 和其它比较操作。

@7.6.1.5 规约结果选择：
设计上下文处理器时选择 ReductionStatus(@6.10.1) 一般使用以下策略：
若为部分规约，使用 ReductionStatus::Partial ；
否则，若需重规约，使用 ReductionStatus::Retrying ；
否则，若需在求值结果(@6.10.1) 中保留列表，使用 ReductionStatus::Retained ；
否则，若能确保求值结果由值数据成员(@6.2) 决定且已经过正规化(@6.10.6.1) ，使用 ReductionStatus::Retained 而避免冗余的清理(@6.10.6.1) 操作。
否则，使用 ReductionStatus::Clean 。

@7.6.2 助手 API ：
NPLA1 提供枚举 WrappingKind 标识初始化 A1::FormContextHandler 需要的包装数(@7.6.1.1) 。
基于 NPL::EmplaceLeaf(@6.11.4.2) ，NPLA1 提供注册处理器事件的助手函数模板，无需显式嵌套构造 A1::ContextHandler 和其它处理器(@7.6.1.1) 类型：
A1::RegisterFormHandler
A1::RegisterForm
A1::RegisterStrict
助手函数的模板传入被包装的处理器和检查例程。
NPL::TypedValueAccessor(@6.9.3) 的相关特化可简化注册处理器(@7.6.2) 的操作数。

@7.6.3 项检查和辅助 API ：
A1::CheckArgumentList
A1::CheckVariadicArity
A1::FetchArgumentN

@7.6.3.1 保留(retain) 操作：
保留形式是特殊形式，对项进行空求值(@4.4.4) ，同时属于项检查 API 。
A1 提供以下函数实现对象语言中的保留形式或在其它本机实现(@5.3) 中进行子项数量的检查：
A1::Retain 断言求值合并项并返回 ReductionStatus::Regular(@6.10.1) 。
A1::RetainList 同 A1::Retain 但返回前检查项是列表项，否则抛出 NPL::ListReductionFailure(@6.5) 异常。
A1::RetainN 类似 A1::RetainList 并检查子项作为函数时的实际参数数(@7.6.3) 符合预期，否则抛出 NPL::ArityMismatch(@6.5) 异常。

@7.6.4 项求值 API ：
NPLA1 提供规约处理器若干 API 实现基于节点的表达式求值。被求值的标识符项构成对象语言中的名称表达式(@4.5.1) 。
包括以下函数：
A1::DefaultEvaluateLeaf
A1::EvaluateIdentifier
A1::EvaluateLeafToken 对作为叶节点记号的项求值，其中会判断字面量并按需调用字面量合并遍(@7.4.1.2) 或 A1::EvaluateIdentifier 。
A1::EvaluateLiteralHandler
A1::ReduceCombined 规约作为上下文列表的规约合并项(@6.9.1) 。
A1::ReduceCombinedBranch
A1::ReduceCombinedReferent
A1::ReduceCombinedReferentWithOperator
A1::ReduceLeafToken 规约叶节点记号，提取名称并调用 A1::EvaluateLeafToken 求值对应项。
**注释** 作为字面量等自求值项(@4.4.5) 的词素通常只求值一次重写为表示的值，而不必在求值算法中重复求值。
记号值类型(@6.8.1) 预期已在必要时被处理(@6.4.3.2) 。以上 API 没有区分得到的求值结果(@6.10.1) 是否可以是总是被复制的非临时对象的值。

@7.6.4.1 规约合并项结构要求：
作为被规约项(@6.2) ，规约合并项(@6.9.1) 的第一个子项应能规约到 A1::FormContextHandler(@7.6.1.1) 的值或引用 A1::FormContextHandler 对象的引用值(@5.8.3) 。
A1::FormContextHandler 对此进行检查(7.6.1.3) 。

@7.6.4.2 规约合并求值：
A1 中包含 ReduceCombined 前缀的函数名的规约函数(@6.10.5) 求值函数合并(@4.5.3.1) ，创建活动的(@4.5.3.1) 合并子调用(@4.5.3.2) ，蕴含其中所需资源的初始化。
这些规约函数的被规约项在求值后保存合并子调用的结果。合并子由蕴含它的上下文处理器(@7.6.1) 或其引用值的一个子项表示。
规约合并项(@6.9.1) 不依赖处理器内部的具体操作，不和具体的处理器类型耦合，以同时支持宿主语言的本机实现和对象语言(@8.4.5) 引入的合并子。
**注释** 当前处理器类型即 A1::ContextHandler 。保存这个处理器的子项通常被视为已规约的。
调用处理器时，对启用 NPL_Impl_NPLA1_Enable_Thunked(@7.1) ，首先以其通过 std::ref 得到的包装引用值为参数创建用于异步调用的对象，并异步调用这个对象；否则，进行直接调用。
异步调用的对象作用同 A1::Continuation(@7.4.2) 。
配合 A1::FormContextHandler 在提供中间值(@6.8) ，得到的项为 WHNF(@4.4.5.1) ，可实现 WHNF 的求值。
**原理** 通过上下文处理器中的逻辑指定是否对操作数子项求值，这节约严格性分析(@4.4.6.2) 开销。
派生实现可在必要时使用特定的处理器缓存实现以提升对应的处理器调用性能。
**注释** 当前不提供实现。
函数 A1::ReduceCombined 以规约合并项的第一个子项为上下文处理器求值函数合并。
调用处理器前：
	判断项满足 NPL::IsCombiningTerm(@6.9.1) ，否则直接返回 ReductionStatus::Regular(@6.10.1) 。
	通过判断节点的值数据成员(@6.2) 是否持有 A1::ContextHandler 类型的值或引用到 A1::ContextHandler 的值上的 NPL::TermReference 的值，确定节点中是否存在上下文处理器。
	**注释** 这可能是 A1::ContextHandler 对象的子对象引用项(@5.8.3.8) ，符合平凡非正规表示(@6.3.7.2) 。
	若不存在这样的值，则抛出 NPL::ListReductionFailure 异常(@6.5) 。
		其中，带有记号值的非空列表(@6.3.7.3) 中的记号值被视为函数名，构成错误消息。
	**原理** 因为失败包含子项是列表的情形，此时不抛出 NPL::ListTypeError(@6.5) 。这也避免提示错误时，和具体的上下文处理器的具体宿主类型（当前为 A1::ContextHandler ）耦合。
	对上下文处理器是左值和右值的情形，分别清空和设置被规约项的标签的 TermTags::Temporary(@6.2.2) 。
		**原理** 被调用的处理器必要时可利用它作为提示进行优化。
		**注释** 因为被规约项总是非引用项(@6.8.3) ，和 @7.1.2 的其它用法（由 A1::EvaluateIdentifier(@7.6.4) 保证求值结果是引用项）不冲突。（同时，尽管只在管理规约(@4.4.2) 而不在对象语言的表达式中出现，这仍符合引用值(@5.8.3) 的语义；这实际上是复用 TermTags::Temporary 的主要理由。）
		**注释** 上下文处理器的实现可能有必要使用 NPL::ClearCombiningTags(@6.9.1) 清除此处引入的标签，以确保规约表示可表示一等对象的值(@6.3.2) 。
	非（表示左值的）引用的上下文处理器和操作数中的临时对象被延长生存期(@5.8.5.4) ，但在尾上下文(@4.4.8) 之前结束(@5.10.2) ：
		A1::ContextHandler 对象总是从第一个子项转移，以在调用时维护上下文处理器的生存期。
		按对象所有权(@5.6.3) 的要求，实现可选择不同的内部存储保存这些临时对象，具体策略和是否支持异步规约(@7.9) 相关，详见临时对象管理(@7.9.3) 。
		另见 TCO 实现(@7.11.6) 。
调用处理器时：
	基本流程参见处理器调用(@7.6.1.2) 。
	不清理(@6.10.2.1) 参数；而即处理器中的第一个子项是已被清理的项(@7.2.1.1) ，可被实现使用。
调用处理器后：
	根据处理器返回的规约结果进行正规化操作(@6.10.6.1) 。
函数 A1::ReduceCombinedBranch 同 A1::ReduceCombined ，但调用前首先断言项是规约合并项(@6.9.1) 。
函数 A1::ReduceCombinedReferent 同 A1::ReduceCombined ，但有以下不同：
	使用第三参数指定的值指定表示处理器的项。
	只支持项表示处理器右值（其它值都视为失败）。
**原理**
调用处理器时，可创建的 A1::Continuation 对象允许对象语言的实现简化部分实现：
	保留 A1::Continuation 中的运行时元数据，用于诊断。
	直接捕获续延(@4.5.3.3) 作为一等对象，而不需要调整一等对象的表示。
考虑到利用 A1::Continuation 的情形相对较少，创建 A1::Continuation 一般不高效也并非总是必要。例如，续延捕获可直接基于 NPL::Reducer(@6.11.2) 。
因此，当前实现不再创建 A1::Continuation 对象，而使用等效的其它内部类型的对象代替。

@7.7 公共规约操作：
部分操作和 NPLA1 的规约的内部实现（特别是非本机函数实现的求值以及函数调用）相关。
使用这些操作实现对象语言对应操作的 API 详见 A1::Forms(@8.1)（以下简作 Forms ）。
部分公用的操作规则也在本节中约定。

@7.7.1 间接值(@5.6.3.1) 访问：
除因 NPLA1 引用值使用约定(@9.9.1.1) 保证内存安全(@5.6.4) 而消除引用值(@6.9.4) 的操作外，其它操作的求值结果(@6.10.1) 中的引用值被保留。
以间接值访问对象时，项的值类别(@5.8.1) 和根据其它语义规则（可能在以后添加，如是否可修改的限定符）确定是否可修改，可分别进行不同的操作。
直接区分参数的值类别分别进行处理的操作有：
规约合并求值(@7.6.4.2) API ；
绑定操作(@7.7.3) API 。

@7.7.2 上下文相关的求值规约操作：
基于 NPLA 合并动作(@6.12.7) ，NPLA1 提供动作合并规约操作 API ：
类型 A1::EnvironmentGuard
函数模板 A1::GuardFreshEnvironment
函数模板 A1::InvokeIn
函数模板 A1::GetModuleFor 加载代码作为模块(@1.5.6.4) 以提供特定集合的对象语言实体的定义。
函数模板 A1::LoadModule 和 A1::LoadModuleChecked 加载模块为变量。后者在指定名称的绑定已存在时抛出异常。
函数 A1::RelayForEval 直接求值(@4.1) 规约：规约并传递求值的结果。
函数 A1::RelayForCall 函数调用规约（ β 规约(@4.5.3) ）：规约并传递词法闭包规则(@4.6.1.2) 下求值的结果。
使用合并动作 API ，可定义依赖这些合并动作的求值规约操作，附加相同的约束。
为确保嵌套函数调用时允许引用绑定到非直接主调函数的临时对象(@5.8.5) 形式参数，已被匹配作为绑定目标的项所在的不表示操作数的项（参见 @7.7.3 ）可能被转移以保证其子项生存期足够长。
按 @6.4.4.2 ，此时被作为绑定目标的子项不需被修改（因此自动符合 @6.4.5 的要求）。
间接调用 A1::RelayForEval 或 A1::RelayForCall 的操作是求值规约操作。
求值规约操作附带绑定操作匹配被绑定的操作数树(@4.4.5.1) 。
忽略提升操作可允许对象语言的函数调用返回(@4.5.3.1) 引用值(@5.8.3) 。
**注释**
求值规约操作中可能具有为了满足内存安全要求的项提升操作(@5.6.4.5) 。
等效间接调用 A1::RelayForEval 的求值规约操作包括：
Forms::Eval(@8.4.4.1)
Forms::EvalRef(@8.4.4.1)
Forms::EvalString(@8.4.4.1)
Forms::EvalStringRef(@8.4.4.1)
Forms::Apply(@8.4.9)
Forms::ApplyList(@8.4.9)
间接调用 A1::RelayForCall 的求值规约操作包括通过过程抽象(@8.4.5) 中的函数引入合并子(@4.5.3.2) 的调用。

@7.7.2.1 求值规约提升项：
关于提升项的基本用例，参见 @5.6.4.5 。
部分求值规约操作使用同返回值转换(@5.8.4.2) 效果相同的方式实现消除引用值(@6.9.4) ：
A1::RelayForCall 和 A1::RelayForEval(@7.7.2) 间接依赖 NPL::LiftToReturn(@6.9.4.3) 。
对间接值的相关使用和检查另见 @7.6.5 。
非引用值间接值(@6.4.3.2) 对应复制或转移间接值参见关于间接值的约定(@8.1.2) 。
关于具体操作，另见 @8 中的保证，如过程抽象(@8.4.5) 。

@7.7.3 绑定操作：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%93%8D%E4%BD%9C 。
作为 TermNode ，操作数树(@4.4.5.1) 可以具有子项和值数据成员。
操作数树作为有序对是无环非真列表(@6.3.7.1) 。
作为符号的叶节点是记号值(@6.8.1) 。
绑定操作的 API 详见绑定支持(@7.7.4) 。
绑定操作符合以下小节的绑定规则。其它具体行为参见对应 API (@7.7.4) 的详细描述。
**注释**
关于对形式参数树的具体的语法要求，另见 <ptree>(@9.2.2.1) 的定义。
DAG 要求和 Kernel 类似，但通过无环列表(@6.2.1) 的性质蕴含而不需要另行限制。
和 Kernel 不同，操作数树同时支持作为引用的左值(@5.8.1) 和非引用的右值(@5.8.1) ，在实现上需要解析引用（类似 @6.9.2 的部分操作）。

@7.7.3.1 绑定初始化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96 。

@7.7.3.2 绑定临时对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1 。
**原理**
关于规范求值算法保证求值标识符得到的结果是左值引用(@9.9.1.1) 的实现，参见 A1::EvaluateIdentifier(@7.6.4) 。

@7.7.3.3 绑定匹配：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E5%8C%B9%E9%85%8D 。
当前没有实现绑定匹配并行化。
**注释**
关于匹配机制不同，另见 @9.9.4 。
关于 cons 对，另见 @6.3.7.1 。
关于无环列表，另见 @6.2.1 。
关于词素，另见 @6.8.1 。

@7.7.3.4 引用标记字符：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E5%AD%97%E7%AC%A6 。

@7.7.3.5 非递归绑定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A 。
绑定操作数的引用时，要求引用的是列表中的项，否则抛出 NPL::InvalidReference(@6.5) 异常。
绑定结尾序列创建新的有序对并绑定元素子对象时，若操作数是非真列表：
	**注释** 此时需初始化组合中非空的值数据成员(@6.2) 。
	当组合中的最后一个元素是新创建的子对象引用(@5.8.3.1) 时，其被引用对象的表示中，以共享操作数的表示中的值数据成员的非引用值间接值(@6.4.3.2) 作为值数据成员。
	**注释** 操作数可能存在非正规表示(@6.3.7) 。
**原理**
关于指定过程调用的形式参数，参见过程抽象(@8.4.5) 。
绑定结尾序列和非结尾序列的非递归绑定规则略有不同。
	关于简化了的一些重要的派生实现，例如 list 应用子(@11.4.1) 。
		若不依赖无引用标记字符影响被初始化的元素的规则，使用基本派生操作(@11.4.1) 中在 list 前定义的操作，list 的派生近似（和内部表示实现细节相关仍不确保完全正确）：
			$def! list wrap ($vau% (.x) #ignore
				($vau% (x y) d (wrap ($vau% #ignore #ignore (eval% (move! y) d)))
					(eval (move! x) d))
					($def! lacc wrap ($vau% (&x) #ignore
						($if (pair? x)
							(wrap ($vau% ((%x .%xs)) #ignore cons (idv (expire x)) (lacc (move! xs)))) idv) x))
					(lacc ((wrap ($vau ((.@xs)) #ignore xs)) x)));
		而允许使用这些规则时，可简化为可移植的派生：
			$def! list wrap ($vau (.x) #ignore move! x);
	为创建子对象引用时避免被引用对象的复制，不复制被引用对象的子项（即便被引用对象可能具有非正规表示(@6.3.7) ），且使用非引用值间接值作为被绑定对象的值数据成员。
		和引用值的间接访问可被配置运行时检查(@6.1.2.1) 不同，对通过非引用值间接值的访问不被检查(@6.4.3.2) 。但和引用值的间接访问类似，这种情形已违反内存安全(@5.6.4) ，且可能引起宿主语言的未定义行为(@5.4) 。因此，不另行保存子项。

@7.7.3.6 递归绑定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A 。
**注释** 与绑定匹配使用的操作数标签不同，当前实现中，若表示求值结果，其标签应为默认值(@7.1.2)。

@7.7.4 绑定支持 API ：
绑定支持 API 包括引入绑定的 API ，通过引入新的绑定(@4.1) 修改求值环境(@4.6.1) 。
用于辅助引入绑定的 API 包括：
函数 A1::IsIgnore
函数 A1::Ensigil
函数 A1::CheckParameterTree
函数 A1::CheckEnvironmentFormal
实现引入绑定的绑定操作(@7.7.3) 的 API 包括：
函数 A1::MatchParameter 匹配操作数树(@7.7.3) 。
函数 A1::BindParameter 匹配并绑定操作数到参数上。
对实际参数，检查尾部参数是否为省略(@7.7.3.3) 后，匹配前判断是否为 TermNode 以支持引用(@5.6.4.5) 。
绑定尾部参数列表时，若对应的操作数是右值，直接转移子项(@7.7.3.6) 。
一般地，对操作数树的递归操作应在分配资源失败时，引起（可能派生）std::bad_alloc 的宿主异常而非宿主语言的未定义行为(@5.4) 。
为支持嵌套调用安全的约定(@6.1.4.1) ，实现应避免无法预测嵌套深度的递归调用，但实现内调用的重定向操作以尾调用形式进行递归调用，类似使用跳板的异步规约动作(@6.12.1) 。
引入绑定的规则参见绑定操作(@7.7.3) 。
另见环境修改操作(@8.4.4.3) 和过程抽象(@8.4.5) 。
函数 A1::BindParameterWellFormed
函数 A1::BindSymbol

@7.7.5 上下文访问 API ：
以下 API 用于辅助尾上下文访问：
函数 A1::SetupTailContext

@7.7.6 规约诊断 API ：
NPLA1 提供一些提供辅助诊断消息的 API 以 Doxygen 命令标识为 \ingroup NPLDiagnostics 。
**注释** 类似 NPLA 诊断 API(@6.13) 。

@7.7.7 辅助公共实现 API ：
一些使用以上特性的公共实现以 API 的形式公开，以允许派生实现复用：
函数模板 A1::KeepGuard
别名模板 A1::GKeptGuardAction
函数模板 A1::MoveKeptGuard
**注释** 另见续延名称(@7.11.7) 和解释(@8.6.2) 。

@7.8 REPL API ：
NPLA1 提供 API 通过解释器的各个模块的组件组装 REPL(read-eval-print loop) 的交互式界面。
函数 A1::SetupDefaultInterpretation 初始化默认解释，包括一般事件处理例程。
默认解释初始化符合主规约函数实现对其中处理器的约定(@7.4.4) 。
别名模板 A1::GParsedValue 提供词法解析器(@6.1.5) 的解析结果类型中的元素类型。
别名模板 A1::GTokenizer 提供标记器，即和解析器的解析结果类型中的元素类型为参数的转换为 TermNode 的例程。对应解析器类型提供以下实例：
类型 A1::Tokenizer
类型 A1::SourcedTokenizer
类 A1::GlobalState 提供全局状态，可直接作为 REPL 原型。
其中，数据成员 EvaluateLeaf 、EvaluateList 、EvaluateLiteral 是全局公共遍(@7.4.3) ，分别为叶遍、列表遍和字面量求值遍。
A1::GlobalState 以 ContextNode::EvaluateList(@6.11.3.1) 为第二参数调用 A1::SetupDefaultInterpretation 初始化，之后默认解释配置 ContextNode 具有以下能在 A1::ReduceOnce(@7.4.4) 运行的规约算法：
A1::GlobalState 使用 @7.5.2 的 API 实现标记器。
若项是具有一个子项的列表节点，则规约为这个子项；
若项是具有多个子项的列表节点，依次调用 NPL::ReduceHeadEmptyList(@6.10.7.1) 、A1::ReduceFirst(@7.4.6) 和 A1::ReduceCombined(@7.6.4.2) 规约列表项；
否则调用 A1::ReduceLeafToken(@7.6.4) 规约叶节点。
A1::GlobalState(@7.8.1)
函数模板 A1::TryLoadSource

@7.8.1 类 A1::GlobalState ：
A1::GlobalState REPL 是上下文对象类。
类 A1::GlobalState 还提供以下 API ：
数据成员 Preprocess 是内部保存的求值表达式一次预处理的处理器。这在 NPLA1 规范求值算法(@7.8.2) 前生效，不处理子表达式。
成员函数 IsAsynchronous 判断是否启用异步规约实现(@7.9.2) 。

@7.8.2 NPLA1 规范求值算法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E8%A7%84%E8%8C%83%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95 。
NPLA1 规范求值算法是 A1::GlobalState(@7.8.1) 配置的主规约函数实现的(@7.4.4) 具体求值算法(@4.4.1) 。
取得 WHNF(@4.4.5.1) 以外的子项是否被求值由被调用的第一个子项的处理器 A1::FormContextHandler::operator() (@7.6.1.2) 决定。
求值符号同 A1::EvaluateIdentifier(@7.6.4) .
要求一个子项的列表总是使用其列表元素求值由 A1::ReduceOnce 决定。

@7.8.2.1 函数合并求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%E6%B1%82%E5%80%BC 。
**注释**
求值为一个函数合并的第一种情形通过 NPL::ReduceHeadEmptyList(@6.10.7.1) 实现。

@7.8.2.2 空列表求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%A9%BA%E5%88%97%E8%A1%A8%E6%B1%82%E5%80%BC 。

@7.8.2.3 记号求值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AE%B0%E5%8F%B7%E6%B1%82%E5%80%BC 。
**原理**
求值算法在名称解析后不特别处理引用值，允许结果保留(@8.1.2) 被求值表达式中的引用值，同时避免实现需要分别检查列表和作为符号求值结果的引用值类型的开销。
**注释**
一些求值算法的性质在实现上由 NPLA1 引用值使用约定(@9.9.1.1) 、A1::EvaluateIdentifier(@7.6.4) 和 A1::GlobalState 配置的求值遍保证。

@7.9 异步规约支持：
异步规约(@6.12) 支持基于异步规约动作(@6.12.1) 实现。
在 NPLA1 API 中同时提供对应的完全非异步规约的实现，不满足 TCO 要求(@5.10.4) ，仅供参考。
NPLA1 API 的异步规约依赖上下文中的当前动作(@6.11.3) 。
以下讨论的由上下文(@6.11.3) 支持的 NPLA API 使用方式和 NPLA1 相关。其它非 NPLA1 的派生实现可使用其它方式或选择不支持。

@7.9.1 和同步规约实现兼容性：
基本内容参见和同步实现的对应关系(@6.12.3) 。
同步规约时，在当前待求值项(@6.3) 之后添加的操作可包括调用 A1::ReduceCombined(@7.6.4.2) 的清理操作(@6.10.2.1) 。
和 NPL::CheckedReduceWith(@6.10.3) 单独判断规约结果(@6.10.1) 保持循环条件不同，清理操作对应的异步规约默认不清除当前动作。
这种实现允许通常没有 TCO 且不访问当前动作或不暴露当前动作状态改变的同步实现兼容被调函数实现的子项规约为异步操作的实现，即异步调用安全(asynchronous call safety) 。
允许这种兼容性有利于迁移 API 的实现至异步操作的实现，也允许支持按不同运行时配置启用 TCO 以平衡时间和空间开销及优化性能（但当前不考虑支持）。
注意支持异步规约的实现不保证能被同步调用而维持当前动作状态的正确。
这允许异步规约的实现中最后的操作以直接内联(direct inline) 同步的实现代替异步规约动作组合(@6.12.7) 。其主要的应用参见动作内联(@7.9.4) 。
异步规约允许提供同步规约实现不支持的控制作用(@1.2.4) 的实现，一些步骤可能被跳过。特别地，NPLA 的上下文总是使用依赖异步调用的错误处理等机制。
一般应避免在异步调用中直接清理资源（包括直接依赖宿主语言的析构函数的调用），而使用在异步规约动作(@6.12.7) 内蕴含生存期的守卫(guard) 值代替。否则，若调用被跳过，资源泄露，和同步规约的行为也不再一致。
**注释**
异步调用安全的位置相对同步调用更受限。
例如，异步实现的规约合并求值(@7.6.4.2) 应仅在最后一遍的最后的操作中被同步调用。

@7.9.2 异步规约 API 支持：
部分 NPLA1 API 提供同步和异步的不同实现。一些 API 明确支持异步规约。
启用异步规约的实现定义为实现选项(@7.1) NPL_Impl_NPLA1_Enable_Thunked 。
此外，启用分隔符中缀变换(@7.5.1) 的异步的实现定义为实现选项 NPL_Impl_NPLA1_Enable_ThunkedSeparatorPass ，使用单独的异步实现保证嵌套调用安全(@6.1.4.1) 。
NPL::NPLA1Forms(@8.1) 等同时支持同步和异步规约的 API 可基于这些 API 实现。

@7.9.2.1 异步规约基本支持：
以下 NPLA1 API 可保存当前动作，支持和实现异步规约：
A1::FormContextHandler::operator()
A1::ReduceChildren
A1::ReduceChildrenOrdered
A1::ReduceCombinedBranch
A1::ReduceCombinedReferent
A1::ReduceCombinedReferentWithOperator
A1::ReduceOnce
A1::ReduceOrdered
A1::RelayForEval
A1::RelayForCall
以下 NPLA1 API 对异步规约中立(@6.12.5) 而支持异步规约：
A1::ReduceArguments
A1::ReduceCombined
A1::ReduceFirst
A1::ReduceTail
A1::ReduceToReferenceList
NPLA1 主规约函数(@7.4.4) 隐含设置下一求值项(@7.4.3) 以维护约定(@7.4.1.5) 。
A1::Reduce 通过 ContextState::RewriteGuarded(@7.4.3) 在内部实现异步规约，自身可被作为同步规约函数调用。
规约函数通过 A1::ReduceOnce 的实现设置上下文中的当前动作(@6.11.3) 支持异步规约相关操作。
和同步规约类似(@7.4.4) ，异步的重规约(@6.10.1) 不由求值遍(@7.4.1.2) 的实现规约状态处理。一般地，调用异步重规约的代码需插入 A1::ReduceOnce(@7.4.4) 等价的操作作为起始动作引导重规约。
和同步规约不同，一般不使用 NPL::CheckReducible(@6.10.3) 而允许和异步的部分规约(@6.10.1) 区分。
ContextState::A1::DefaultReduceOnce(@7.4.3) 是 A1::ReduceOnce 的默认实现。其中，规约状态 ReductionStatus::Retrying(@6.10.1) 被用于判断是否跳过当前求值的子表达式支持重规约。
ContextState::ReduceOnce(@7.4.4) 的默认实现（及要求的替代实现）支持异步分发求值遍。
在每个表达式求值时，每个求值遍(@7.4.1.2) 的中间结果保存在 ContextNode::LastStatus(@6.11.3.1) 中，其中非 ReductionStatus::Partial(@6.10.1) 的结果被通过调用 CombineSequenceReductionResult 合并。
在表达式求值规约中，A1::ReduceOnce 对 ContextNode::LastStatus(@6.11.3.1) 置为 ReductionStatus::Retrying(@6.10.1) ；之后再在求值后判断是否需要重规约。因为后续的求值是尾调用，可支持 TCO(@7.10) ；另见 @7.10.8 。
之后在判断应跳过上下文当前处理的表达式的剩余求值或没有剩余的求值遍时，求值完毕，再次置空。
A1::ReduceOnce 在完整遍的异步调用前设置 ContextNode::LastStatus 为 ReductionStatus::Neutral 以标识完整的遍的开始。
A1::ReduceOnce 在遍的结束时确保后续异步动作返回 ReductionStatus::Retrying ，以跳过多余的下一个不完整遍而支持异步重规约。
其它仅对表达式内的规约操作可直接返回规约状态而不设置上下文中的状态。
**注释**
在已知所有求值遍时，A1::ReduceOnce 可以有等价的更高效实现。此时，不一定判断遍的结果是 ReductionStatus::Retrying ，也可能实现等价的程序语义。
替换实现仍应当符合规约迭代(@6.10.4) 中对规约结果的处理。
另见 TCO 互操作(@7.10.8) 。

@7.9.2.2 异步规约派生支持：
以下 NPLA1 API（可能包含直接或间接调用异步规约基本支持(@7.9.2.1) 中异步规约中立(@6.12.5) 外的 API ）依赖当前动作支持和实现异步规约：
包含规约作为子表达式的子项的规约函数；
Forms 下 API 引入的 vau 处理器的 operator() 。

@7.9.2.3 当前动作前置条件：
为减小不必要的判断和重复维护当前动作开销，NPLA1 API 中只有特定规约函数(@6.10.5) 及其调用的 API 支持保存当前动作。
这些 API 包括 @7.9.2.1 和 @7.9.2.2 中明确支持异步规约的 API 。其中保存当前动作时，要求当前动作非空。
此外，A1::ReduceOnce 直接覆盖当前动作。
其它 NPLA1 API 对异步规约中立，不直接访问当前动作。
非 NPLA1 API 若支持异步规约，可能以关联的上下文中的当前动作为空作为前置条件以允许直接调用 ContextNode::SetupTail(@6.11.3.1) 等设置当前动作。
对具有前置条件的 API ，调用者应按需在其他操作前保存当前动作以维护符合预期的作用顺序。

@7.9.3 临时对象(@5.8.5) 管理：
规约时，对象语言的函数右值和操作数右值需要被保存以避免引起宿主语言的未定义行为(@5.4) 。
特别地，对象语言语法意义上的嵌套函数调用应能引用外层对象而不引起宿主语言的未定义行为(@5.4) 。
**注释** 例如，通过绑定引用参数(@7.7.3.5) 。
A1::ReduceCombined(@7.6.4.2) 在同步规约时通过宿主语言的规则自然地实现此要求，转移子项(@7.2.1.1) 时只需以宿主语言的自动对象作为新建的项。
而异步规约时，需要另行单独保存函数临时对象和操作数临时对象。这通过使临时对象保存在动作中实现。
排除本机函数(@5.3) ，合并子(@4.5.3.2) 中的求值都通过 A1::RelayForEval（直接求值）或 A1::RelayForCall（合并子调用）实现，转移子项保存临时对象不晚于 A1::RelayForCall(@7.7.2) 的调用。
宿主语言直接实现的本机函数通常仍使用同步规约以避免转移子项等操作的复杂性；若使用异步规约，也需要保证子项的生存期以满足上述要求。
实现需自行决定是否使用内部存储保存临时对象以及需要保存临时对象的内部存储的位置。若需支持异步规约，不能使用宿主语言的自动对象。
一般地，因为 TermTags::Temporary(@6.2.2) 允许原地标记被绑定的临时对象而非引用其它存储(@5.8.5.3) ，不需要对被绑定的操作数临时对象特别处理。
当前不提供 API 辅助实现本机函数中的临时对象维护。
按 @6.4.5 ，本机实现可对表示临时对象的子项分别转移，但转移前不应有非内部对象(@4.2.7.1) 引用被转移的子项。

@7.9.4 动作内联(inlining) ：
特定的异步规约实现可能要求引入的操作总是尾动作(@6.11.3) ，否则行为未定义。
这允许直接使用同步动作代替异步动作调用，即动作内联。
动作内联可减少操作 ContextNode 中当前动作序列(@6.11.3.1) 的开销。
注意这项要求具有传递性，即在宿主语言中直接或间接同步调用的操作也应满足要求的条件。
因此，除非能确保不限制接口语义，当前 NPLA1 不使用这样的实现方式。
启用使用这种方式的实现定义为实现选项(@7.1) NPL_Impl_NPLA1_Enable_InlineDirect 。
派生实现应明确指定影响接口语义的动作内联的使用。

@7.10 TCO 支持：
因为要求对宿主语言中立(@5.10.4.1) ，基于 CPS 调用(@6.11.3) 的上下文 API 实现异步规约(@7.9) ，带有上下文状态的前置条件(@6.11.3.1) 。
这样的实现方式性能相对直接使用体系结构相关的方式较低，但仍可被接受。
这样实现的 TCO 同时允许可移植地在对象语言中实现某些引入控制作用(@1.2.4) 的一等实体(@4.1) （如续延(@4.5.2.2) ）。
当前未支持宿主栈展开(stack unwinding) 的互操作(@5.3) 。
C++ 异常调用重写循环(@6.11.3) 内资源对象的析构函数顺序是未指定的。但是，对 C++ API 异常安全保证的要求(@7.4.1.4) 仍然不变。
在 NPLA1 API 中同时提供对应的异步规约但不使用 TCO 的实现，不满足本节要求，仅供参考。
TCO 应能按 NPLA 尾上下文约定(@5.10) ，支持在尾上下文(@4.4.8) 实现 PTC(@5.10.2) 。
在启用异步规约实现(@7.9.2) 的基础上，启用 TCO 的实现定义为实现选项(@7.1) NPL_Impl_NPLA1_Enable_TCO 。
以下指定当前对 TCO 的有限支持。没有明确指出的情形不保证支持 TCO 。

@7.10.1 TCO 支持实现 PTC ：
要支持 PTC ，需保证 O(1) 的空间复杂度（通常需要分配大于 O(1) 的活动记录帧(@4.5.3.4) 资源），此外需要确保宿主语言的活动记录不会在运行时耗尽。
后者通过经验方法验证确保，因此实现符合复杂度要求即可。
NPLA1 实现支持的 TCO 包括以下形式：
直接在实现中变换宿主语言的递归调用为循环可实现宿主 TCO(@5.10.4.2) ；
基于异步规约 API(@7.9.2) ，使用重写规则（直接通过现有 API 支持的即重规约(@7.4.4) ）代替直接使用宿主语言的递归形式可实现目标 TCO(@5.10.4.2) ；
动态 TCO(@5.10.4.2) ，具体机制详见 TCO 操作复用(@7.10.4) 。
NPLA 除个别例外(@6.1.4) 均支持宿主 TCO ，不需要其它形式的静态 TCO(@5.10.4.2) 。
在此基础上，NPLA1 通过允许和动态 TCO 互操作的异步重规约的方式支持目标 TCO(@7.10.8) ；但当前 NPLA1 部分 API 不保证支持宿主 TCO(@6.1.4) ，这可能在以后完善。
NPLA1 支持的动态 TCO 按实现策略即 TCM(@5.10.4.2) 。
综上，使用 NPLA1 的 PTC 有三类实现策略：
通过直接重写宿主语言的实现（使用循环代替部分递归）提供宿主 TCO ；
通过 TCO 动作(@7.10.3) 提供动态 TCO ；
基于异步重规约和 TCO 的互操作提供目标 TCO 。

@7.10.2 整体设计约束：
TCO 要求尾上下文的续延(@4.5.2.2) 保持等效。考虑到计算资源的限制，排除构造相同的外部的求值环境(@4.6.1.2) 的实现方式，这蕴含同一性。
NPLA 的 TCO 基于异步规约(@7.9) ，基本方式是尾调用合并(@7.10) 。TCO 动作(@7.10.3) 是支持了尾调用合并的动作。
考虑到当前动作(@6.11.3) 预期直接构成当前续延(@6.11.3.1) ，对 NPLA1 ，这需要限制尾动作(@6.11.3) 的下一动作(@6.12.2) 不是 TCO 动作。

@7.10.3 TCO 动作：
TCO 动作是用于实现 TCO 的动作帧(@6.12.6) 。
TCO 动作支持实现符合 PTC 的尾调用(@5.10.2) 的尾动作(@6.11.3) 。
TCO 动作支持动态 TCO(@7.10.1) 。
TCO 动作具有特定的非公开类型。为简化实现，减小判断开销，当前是单一的非公开的类型，被直接作为 Reducer(@6.11.2) 的目标类型(@6.2) 。
**注释**
为避免 TCO 实现失效，实现在尾上下文中应注意当前动作(@6.11.3) 是 TCO 动作(@7.10.3.2) 。
使用 TCO 动作可实现和 TCO 无关的其它行为同时保持当前动作，参见组成(@7.10.3.1) 。

@7.10.3.1 组成：
TCO 动作包含当前项的引用，以指定一些操作(@7.10.4) 的默认目标。
TCO 动作也包含以下各节中描述的机制使用的状态：
	操作结果(@7.10.6.2) 请求状态。
	帧记录列表(@7.10.5.1) ，可包含暂存的函数对象(@7.10.7.1) 。
	当前处理的尾环境(@7.10.6.1) 的守卫。
	当前项作为临时对象的守卫(@7.10.7.4) 。
	用于诊断的操作数名称。
	可选的附加信息，包括：
		加载翻译单元的元数据(@7.10.5.3) 。
		一次调用检查守卫(@7.10.5.4) 。
当前项的引用可在当前项的守卫中蕴含。
**原理**
TCO 动作的组成(@7.10.3.1) 的成员能使被调用时能具有一般其它动作的行为。
若当前组成（因实现性能等原因）需被扩展，应注意在没有使用这些扩展时的一般开销。
可选的附加信息预期支持这类不频繁创建和访问的信息。

@7.10.3.2 创建：
TCO 动作应在依赖 TCO 动作实现 PTC 的尾上下文时已被创建。若能静态确定创建，可不在之后的操作中检查是否已经存在。
对应尾上下文的被创建为当前动作的 TCO 动作是当前 TCO 动作。以下各节中，被访问的当前 TCO 动作应已被及时创建。
一般地，TCO 动作应通过合并子调用创建操作(@7.6.4.2) 或 A1::SetupTailContext(@7.8) 创建，以确保复用 TCO 资源的调用的存在。
TCO 动作创建时初始化当前项(@7.10.3.1) 的引用，不在生存期内改变。

@7.10.3.3 销毁：
TCO 动作销毁时释放其中(@7.10.3.1) 的资源。
这蕴含以下顺序确定的操作：
释放临时对象守卫(@7.10.7.4) 的资源；
释放当前处理的尾环境(@7.10.6.1) ；
顺序释放所有已知的函数对象(@7.10.7.1) ；
顺序释放帧记录列表(@7.10.5.1) ；
返回调用处理调用结果的规约结果(@7.10.6.2) 。
**原理**
TCO 动作的资源释放的顺序不是任意的。特别地：
环境守卫(@7.10.3.1) 先于帧记录释放以确保项引用在帧记录释放前不再依赖帧记录中的环境强引用(@7.10.5.1) ；
每个帧记录中，临时对象先于环境释放，以首先确保临时对象不再依赖对应的环境(@7.10.5.1) 。
**注释**
通过合理使用数据类型，可被隐式地实现。

@7.10.3.4 TCO 操作序列：
典型地，用于支持函数应用替换(@4.5.3) 或求值函数(@7.10.10) 的实现，包括如下序列：
保存当前的环境并更新环境(@7.10.6) ；
分配活动调用关联(@5.6.3) 的临时对象(@5.9) ；
可选地请求异步重规约(@7.10.8) ；
异步规约被替换或求值的项；
可选地提升项（变换函数应用替换的结果是非引用；当前具体实现在 A1::RelayForEval 或 A1::RelayForCall(@7.7.2) 内部提供）；
结果的正规化(@6.10.6.1) 。
对应的不支持 TCO 的异步实现中，以上每个操作都可以是一个动作。
为减少判断 TCO 动作的复杂性，这些操作中的一部分被合并到 TCO 动作内，TCO 动作的类型保持唯一。
这些操作步骤在规约调用动作（即 NPL::Reducer::operator() (@6.11.3.1) ）被调用时生效，被执行的操作序列包括：
处理调用结果(@7.10.6.2) ；
释放临时对象守卫以外的 TCO 动作资源(@7.10.3.3) ；
返回调用处理调用结果的规约结果(@7.10.6.2) 。
因为资源释放和 TCO 动作自身蕴含的释放，且 TCO 动作在作为尾动作(@6.11.3) 被调用后在被替换(@6.12.6) 前不会被修改，规约调用动作的实现只需确保：
处理调用结果；
解除临时对象守卫(@7.10.7.4) ；
返回规约结果。
而资源的释放操作延迟到作为尾动作的 TCO 动作被替换时生效。
**原理**
TCO 操作序列的顺序应满足：
处理调用结果应在环境释放前进行；
解除临时对象守卫在释放 TCO 动作资源进行，以确保正常(@4.8) 调用的求值结果(@4.1) 能被保留；
释放 TCO 动作资源应符合 TCO 动作释放的顺序约束。
环境释放被释放 TCO 动作资源蕴含，以上序列的设计可以自然满足这些约束。
利用 TCO 动作销毁复用资源释放减少逻辑上的冗余，同时可具有更好的性能。

@7.10.4 TCO 操作复用：
TCO 操作序列(@7.10.3.4) 中的一些操作是幂等的(@4.1) 。这些操作一一对应 TCO 动作内部的某个状态，表示是否存在此操作。
需要支持 TCO 的上下文检查当前动作(@6.11.3) 是否是 TCO 动作。当检查到 TCO 动作而需要继续补充上述操作时，不创建新的动作或分配其它资源，而修改当前 TCO 动作(@7.10.3.2) 的状态表示启用对应的操作。
启用的对应操作可即时生效。剩余的操作在规约调用动作时生效。生效时操作被调用。这种机制支持一个 TCO 动作上实现的对象语言中的多个合并子调用。
因为不同幂等的操作分配的资源不冲突，操作可以按类别归类。
上述多次生效的操作满足同类幂等操作的相对顺序不变即可，而不需保证实际调用的次数和非 TCO 情形一致。
这种机制称为操作压缩(operation compression) 。
操作压缩允许释放预期不引起行为改变的一些资源而对之后的操作进行准备，使之被保留的已再次分配的资源总量不超过先前调用使用的资源，而可能满足 PTC 的要求。
调用处请求操作压缩前，需确保当前动作是 TCO 动作。
一般地，操作压缩依序包含：
处理调用结果(@7.10.6.2) ；
扫描和回收资源(@7.10.5.2) 的帧压缩(frame compression) ；
按需转移资源(@7.10.5.1) 。
处理调用结果在其它操作之前。这允许首先移除调用结果中依赖可能在之后被释放的关联环境(@6.8.3.1) 的项引用。这和调用 TCO 的操作序列(@7.10.3.4) 中的顺序类似。
当前设计中的操作压缩是同步操作。
连续出现的幂等操作不受递归嵌套深度的影响。若操作序列(@7.10.3.4) 最后一项以外的操作都是幂等的，则可支持不受限制递归尾调用，即实现了 PTC 。
由于语义规则限制，不在任意情形下避免非幂等的操作而保证 PTC（这些操作随着嵌套深度的增加随之需要分配存储）：
捕获动态环境(@4.6.1.2)（通过 vau 抽象(@4.5.2.5) 的创建(@8.4.5) ）时，所在的环境记录(@6.11.3) 作为帧(@4.5.3.4) 占据的存储不保证有上界(unbounded) ；
包含非平凡析构(trivially destructible) 对象的帧的存储是否支持 PTC 未指定（另见 TCO 相关的生存期的实现注记(@7.11.6) ）。

@7.10.4.1 非幂等操作：
非幂等的操作和生存期相关，包括：
设置环境时，确保被设置环境的父环境(@5.7) 的生存期；
分配临时对象(@5.8.5) 时，确保临时对象最终能被及时释放。
这些操作在一个 TCO 动作的生存期内可能有多个实例，因为以下几个原因而无法合并：
存储模型和对象模型(@5.6) 要求生存期开始和结束的顺序；
对象模型相关的语义规则没有允许合并不同的对象；
需提供宿主语言(@5.2) 互操作(@5.3) 支持，一般无法证明实现这些合并不影响可观察行为(@4.1.3) 。
但注意调整语义规则或通过区分出非平凡析构等方式证明可观察行为不变后，减少父环境被隐藏的变量而完全实现 PTC 是可能的。
基于语义规则的许可，实现应支持部分非幂等操作的被合并，以支持 PTC ：
若设置前的环境是被设置的环境的直接或间接父环境，其中可能影响可观察行为的变量都被新的环境隐藏，可确定父环境不再使用且不影响可观察行为，则仍然合并操作，并释放该父环境的资源。
NPLA 尾上下文约定允许可合并临时对象分配的非幂等操作实现 PTC ，即若存在已在 TCO 动作中分配的相等（以宿主环境(@2.6.1) 约定，参见 @7.11.6）的临时对象，则不再分配。

@7.10.4.2 非幂等操作合并约束：
同一个 TCO 动作内，以下尾调用合并的效果仍然有效：
相同类别的不同实例的操作仍然被尾调用合并集中；
非幂等操作和幂等操作之间的顺序被调整；
两类非幂等操作之间的顺序被调整，不再交错。
最后一项变换是被允许的，因为尾上下文内环境的生存期被子表达式内的调用（如过程抽象(@8.4.5) 的实现）约束；而临时对象生存期在尾上下文中可以延长到整个 TCO 操作结束(@5.10) 。

@7.10.5 TCO 相关的资源管理：
TCO 动作(@7.10.3) 持有尾上下文的活动记录帧(@4.5.3.4) ，包括环境和被规约表达式中的右值对应的临时对象。
复用 TCO 操作(@7.10.4) 和以下资源管理的操作在 A1::RelayForCall 和 A1::RelayForEval(@7.7.2) 的调用中被蕴含。
另见临时对象管理(@7.10.7) 。

@7.10.5.1 帧记录(frame record) ：
帧记录是保存最终无法被帧压缩(@7.10.4) 安全释放以完全复用资源的活动记录保存的对象和中间状态。
帧压缩操作的序列和结束后的数据结构维护在帧记录构成的列表中，称为帧记录列表(frame record list) 。
帧记录列表添加的操作在帧压缩以及资源回收后(@7.10.5.2) 进行。
添加的帧记录项来自被转移的维护当前状态的资源，依次包括：
TCO 动作保存的非本机函数临时对象(@7.10.7.1) ；
环境强引用。
顺序关系确保在销毁帧记录时，环境在对应的临时对象之前释放。
**注释** 与之不同，尾环境(@7.10.6.1) 以环境守卫保存，但其中同样蕴含环境强引用。
因为活动记录帧的资源以环境引用(@6.11.1) 的形式管理，帧之间的引用影响其中包含的环境的引用计数。
帧记录中的环境总是具有环境强引用(@6.11.1) 以确保直接可用且避免资源回收(@7.10.5.2) 发生时机的非确定性。
在调用 TCO 动作(@7.10.3.4) 时，活动记录帧最终被释放以恢复状态。
**原理**
对构成帧记录的资源的顺序要求确保其中的资源的释放具有确定的相对顺序。
一般地，帧记录的中的环境（若存在）是过程调用创建的局部环境(@8.4.5.4) ，不对临时对象中的合并子的静态环境(@4.6.1.2) 或其直接具有所有权的环境（若存在）所有权。
因此，环境比对应的临时对象晚创建而早释放。
另见函数临时对象(@7.10.7.1) 。

@7.10.5.2 资源回收：
除非证明移除活动记录帧不影响对象语言的语义，活动记录帧不是帧压缩(@7.10.4) 的可合并的目标。
因为帧记录(@7.10.5.1) 具有环境强引用，不通过其它操作引起的引用计数改变而释放，回收帧记录引用的资源是显式的操作。这需要同时避免循环引用。
在切换环境的操作（如过程调用(@8.4.5.4) ）时，无法合并的帧在当前 TCO 动作(@7.10.3.2) 中分配并储存。
紧接储存帧的操作之前，对现有的活动记录进行压缩，以确保新的帧后不再形成冗余。PTC 要求存储的帧不无限增长，依赖此处活动记录被成功压缩。
压缩活动记录会对现有储存的帧中的环境和父环境进行遍历，以环境为单位回收不再被引用的环境对象和对应帧中的其它资源。
环境对象及其关联的锚对象(@6.11.3.1) 的引用计数为是否引用提供依据：
环境自身以 shared_ptr 的实例确定强引用计数；
锚对象确定其弱引用计数。
被从 TCO 对象中移除的环境对象是没有 NPL::TermReference 引用其锚对象的对象。当强引用计数为 1 时，压缩后最终会被清除而释放，持有的对应资源被回收。
这一过程在局部上类似基于引用计数的 GC(@5.6.5) 机制。
**原理**
因为帧记录中资源释放的相对顺序的确定性(@7.10.5.1) ，帧压缩时，仅通过判断环境的引用决定是否能移除整个帧在资源回收的意义上是安全的。

@7.10.5.3 翻译单元元数据：
在 TCO 动作保存源名称，可实现在尾上下文中加载翻译单元后恢复先前的源名称，同时满足 PTC 要求。
保存的源名称可用于诊断。

@7.10.5.4 一次调用检查：
TCO 动作的一次调用检查守卫(@7.10.3.1) 保存能在一次续延(@4.5.3.3) 被捕获时的检查对象(@7.4.2.1) 。
因为捕获续延通过对象语言的合并子调用进入，可假定上下文中总是存在 TCO 动作。
这使捕获续延的调用满足 PTC 。
**注释**
续延捕获调用满足 PTC 的一个例子参见 [Hi90] 。

@7.10.6 状态维护：
和 TCO 操作序列(@7.10.3.4) 对应，规约调用动作时影响状态。
在最后一项操作前，状态需要被维护，保证被语义和非 TCO 的实现语义的差异不违反语义规则。
求值退出尾上下文时，需恢复原始的求值环境（正常退出或异常退出），或显式设置被保存的环境（通过修改当前动作返回，可实现续延返回）。
NPLA 的 TCO 实现较一般实现（直接设置及恢复下一环境）更复杂。除为支持有界续延公开当前动作为单一对象外，原因主要来自尾动作支持的操作需要适应 API 的设计和语言特性的要求：
不在规约函数中传递环境参数，避免在不切换环境的操作中频繁传递环境的开销，同时需维护作为一等对象的环境自身的生存期，因此需要在切换环境时进行附加的操作；
存储模型和对象模型支持临时对象(@5.6.3) ，需要非幂等的操作(@7.10.4) 维护临时对象的生存期；
不要求支持 GC(@5.6.5) ，而一等函数的结果默认需要维护内存安全(@5.6.4) ，因此需要提升项(@6.9.4) ；
规约函数支持返回规约结果(@6.10.1) ，需要附加的操作进行维护（为减小开销仅表达式求值状态）。
注意其它一般实现若要保证内存安全，仍然可能需 GC 对环境的维护提供支持（如设置 GC 根对象，避免环境记录(@6.11.3) 被回收）。
另见 TCO 资源管理机制(@7.10.5) 。

@7.10.6.1 尾环境(tail environment) ：
退出尾上下文时恢复原始的环境由尾环境 ，即在 TCO 操作前设置的环境提供。
因需支持本机实现的异常退出和显式设置当前动作，使用单独的守卫（ A1::EnvironmentGuard(@7.7.2) ）实现。
TCO 构造时的守卫(@7.10.3.2) 不包含尾环境的守卫。
帧记录(@7.10.5.1) 保存环境的守卫(@7.10.6.1) 。
若退出时尾环境不是保存的环境，表明并非尾上下文(@4.4.8) 求值，则直接设置尾环境为空（为实现 PTC 的 TCO 动作不应有这种情形）。
设置的非空的尾环境前复用 TCO 操作(@7.10.4) 。这可导致先前被保存的环境被释放。
同时，在保持尾环境时，基于环境的引用值的内存安全检查(@6.8.3.1) 失效，因为在抽象机语义中应释放的环境的生存期被延长而改变可观察行为(@4.1.3) ；但检查失败表明已存在未定义行为，所以被允许。

@7.10.6.2 操作结果：
为支持 TCO 操作上的不同调用，调用的结果需被反馈到 TCO 动作中。
操作压缩(@7.10.4) 的和在最后一项操作都包含这样的处理调用结果的请求。
请求包括当前项(@7.10.3.1) 上的以下非幂等操作(@7.10.4.1) ：
指定项表示合并子(@4.5.3.2) 调用的结果而需正规化(@6.10.6.1) ；
指定项表示需被提升的调用结果(@6.9.4) 。
处理操作结果返回规约结果(@6.10.1) ：
若提升结果，同 NPL::ReduceForLiftedResult(@6.10.7.1) ；
否则，是上下文中保存的规约结果(@6.11.3.1) 。

@7.10.7 TCO 临时对象(@5.8.5) 管理：
一般机制参见临时对象管理(@7.9.3) 和 TCO 资源管理(@7.10.5) 。
TCO 异步规约对临时对象的管理基本策略同一般的临时对象管理，但因为操作压缩(@7.10.4) 具有更多的变化和限制，所以实现较复杂。
和非 TCO 异步规约的实现相比，临时对象不仅因为引用绑定子项需保证子项的生存期足够长(@7.7.2) 的原因，还可因为操作压缩的需要，而可被转移。后者的情形应符合 @6.4.5 中取得求值结果后不被引用的项修改限制条件。

@7.10.7.1 函数临时对象：
函数临时对象是构成操作符(@4.4.5.1) 而被调用的活动(@4.5.3.1) 的函数纯右值。在 NPLA1 中，此处的函数即合并子(@4.5.3.2) 。
在调用函数时，若函数是纯右值，则需在当前 TCO 动作(@7.10.3.2) 中保存函数临时对象。
最近的活动的函数临时对象由暂存的函数对象(@7.10.3.1) 表示，被附加(attach) 到 TCO 动作的帧记录列表(@7.10.5.1) 的最前一项：创建新的帧记录(@7.10.5.1)，其中的环境引用是空值。
**原理**
在临时对象管理的基础上，在确定在 TCO 动作中保存函数临时对象前，可能尝试对其与暂存的函数对象(@7.10.3.1) 比较而进行去重(deduplicate) ，以在资源回收(@7.10.5.2) 前即尽可能接近 PTC 的要求：若函数相等，则不添加到已知的函数对象中。
这不同于帧压缩(@7.10.4) 的资源回收(@7.10.5.2) ，后者针对帧记录列表(@7.10.5.1) ，且不对其中的函数临时对象进行特别的操作。
纯右值在对象语言中不被别名(@5.8.1) ，但以函数临时对象调用时，仍可通过调用同一个合并子左值的不同副本等方式重入(@4.5.2.2) 。
一般地，重入的不同调用的函数临时对象是不同的对象，其资源管理相互独立。
释放不同函数调用的资源被视为可具有不同的可观察行为，需和对应的局部环境的释放保持顺序上的确定性。
因此，实现一般不能合并这些调用中不同的函数临时对象的存储。但是，若支持去重，则通过本机的实现语义约定，被去重的函数临时对象的不同副本视为具有同一性的相同对象(@4.1) 。
对被去重的函数临时对象，在帧记录(@7.10.5.1) 保存时，只保存其中的一个不重复的函数副本。
因去重一般并不能确保提升性能，也对本机函数的相等实现有更明确的限制（符合上述约定），因此在当前实现中不再支持。
转移暂存的函数对象到同一个帧记录，能维持重入的临时对象和对应的环境的资源释放的相对顺序(@7.10.5.1) 。
去重自身存在开销。考虑到可去重的情形远不如添加函数纯右值频繁，当前实现不进行去重。

@7.10.7.2 非本机操作数临时对象：
资源回收支持处理操作数临时对象。资源回收以环境为单位，因此操作数临时对象应绑定到由 TCO 操作对象持有的环境对象上以便回收(@7.10.5.2) 时引用。
操作数临时对象作为实际参数在环境中绑定后是固定(@5.6.1) 的，这要求保存操作数临时对象提前到 A1::RelayForCall(@7.7.2) 的调用之前。
虽然求值规则中的所有权(@5.6.3) 和一般资源管理都未指定临时对象的存储，对非本机的实现，过程调用创建的局部环境(@8.4.5.4) 作为当前环境(@5.7.3) 中使用 TermTags::Temporary 标签(@6.2.2) 标记被绑定的临时对象，不需在待求值项或其它位置存储临时对象。
即当前实现中，临时对象分配由过程抽象(@8.4.5) 引入的合并子的处理器在参数绑定(@8.4.5.3) 时进行。
未能被资源回收释放的环境应被保存到帧记录列表(@7.10.5.1) 中，以确保保存操作数临时对象的环境不会过早地在过程抽象(@8.4.5) 恢复环境时被销毁。

@7.10.7.3 本机临时对象：
因为没有公开 API ，当前不支持外部的本机函数(@7.9.3) 实现访问 TCO 动作(@7.10.3) 实现以上的类似操作。
不使用 A1::RelayForCall 和 A1::RelayForEval 调用的本机函数若需支持 TCO ，应使用 TCM(@5.10.4.2) 以外的替代 TCO 实现方式。
本机函数的实现和以上的普遍机制略有不同，和需要被保存的临时对象相关。
一般地，本机函数对应的合并子由宿主函数决定，不一定保存状态。这使遍处理器的目标对象(@7.2.1.1) 不需要被本机函数调用时持续保留，即不需要保留对应本机函数临时对象。
但若保存状态，则应注意作为右值调用(@7.10.7.1) 时可提前释放资源(@7.10.5) 。
以下本机临时对象仅讨论操作数临时对象。
若临时对象不需要保留被求值，则可在求值之后移除临时对象。否则，需保存临时对象。
这在支持 TCO 本机函数的实现中可通过以下尾重写(tail rewriting) 的方式实现：
转移临时对象，使之被确保足够涵盖预期生存期的动作（另见 @7.9.3 ）或当前合并的某个不作为被规约项(@6.2) 的子项所有；
在表示当前函数合并的项整体作为求值结果前，移除被规约项。
向 TCO 动作添加临时对象使之被 TCO 动作所有。此时，转移临时对象对应的子项(@7.9.3) 。
尾重写中释放和临时对象相关的资源及对象销毁的顺序要求同 @6.11.1 。这和 @7.10.7.3 中释放环境时遵循 @6.11.1 一致。

@7.10.7.4 临时对象守卫：
临时对象守卫在清理非正常退出（未调用动作时析构）调用 TermNode::Clear 清理当前项的临时对象资源。
这确保当前项作为临时对象时的生存期在求值以异常终止时(@5.6.3) 符合所有权隐含的生存期要求(@5.9) 。
临时对象守卫应能被解除，以支持正常调用(@7.10.3.4) 。

@7.10.8 异步重规约(@7.9.2.1) 的 TCO 互操作：
主规约函数（通过调用跳板(@6.12.1) ）保证调用的异步的重规约可以支持 PTC(@5.10) 。
异步重规约不是 TCO 。当前的实现直接操作上下文(@6.11.3) 中的状态（参见 @7.9.2.1 ），不需要依赖 TCO 动作(@7.10.3) 。
当前异步重规约的 TCO 互操作由 A1::ReduceOnce(@7.4.4) 内部遍的调用实现。另见动作内联(@7.9.4) 。
若使用 TCO 动作中保存状态，则不需要依赖上下文中的状态，但这样的异步重规约和 TCO 不直接兼容。此时，不维护 TCO 动作的异步重规约可导致之后紧随的 TCO 动作无法进行操作压缩(@7.10.4) 而无法支持 PTC 。
使特定异步重规约操作感知 TCO 动作，允许和 TCO 操作序列(@7.10.3.4) 中的操作兼容且非决定性有序(@4.4.3) 地组合以支持 PTC 。
通过静态地决定使用异步重规约和 TCO 互操作，这种组合实现目标 TCO(@7.10.8) 。

@7.10.9 TCO 动作消除：
部分上下文的实现静态地已知不需要切换当前环境(@6.11.3) 而直接规约。
这些上下文可省略创建环境并切换当前环境。
因为不需要创建环境，在尾上下文也不需要操作压缩(@7.10.4) ；实际不依赖 TCO 动作，可省略 TCO 动作创建(@7.10.3) 。
这种实现实际不区分尾上下文。之后不能消除 TCO 动作的上下文不能省略检查 TCO 动作是否存在并按需创建。
若能进一步确保退出上下文时没有切换当前环境为和之前不同的环境（这一般仅在使用本机实现的情形出现），之前不需要保存当前环境。

@7.11 实现注记：
本节指定当前不作为公开接口的一些实现具有的性质和修改实现的导引。

@7.11.1 性能优化：
NPLA1 预留分配器支持(@6.4.1) ，但未直接指定使用分配器。
派生实现可使用分配器并预期提升整体性能，但使用分配器并非总是保证任意情形提升性能。
特别地，使用带有状态的多态分配器，导致 C++ 容器的空间开销变大，而增加典型 C++ 实现的寄存器压力开销。这使分配器支持的实现相对某些动态链接修改分配函数（如 Linux 使用 LD_PRELOAD ）的实现极限情形下仍不占性能优势，但自定义分配器的其它应用（如统计分配资源开销，指定不同的资源池等）不能被后者取代。
因为上述原因，且完全避免使用 C++ 默认分配函数和去配函数不是本实现支持的目标，当前在某些预期局部实现中，已显式地避免使用分配器。
作为原型实现(@5.1) ，相较性能，NPLA1 在语言设计和实现上都强调扩展性。
即使替换扩展实现实现对象语言语义等价但削弱 NPLA(@6) 和 NPLA1 API 的变体，一般也不能预期能和常见其它典型动态语言的解释器实现。这主要是由于：
使用了解释开销较大的 AST 解释器(@6.1.2) ；
缺乏清单类型(@4.7.3) 等提供支持更明确执行路径的元数据；
使用异步规约(@6.12) 和局部的异步调用保证嵌套调用安全(@7.11.8) ；
为支持合并子可能具有的动态环境(@4.6.1.2) ，规约合并时(@7.6.4.2) 没有优化，可能有不必要的重复开销。
进一步优化的一般目标是寻找更多可消除的解释开销，这一般可通过以下方法（可能不再使用 NPLA ）：
派生实现提供契约(contract) 和类型标注(type annotation) 等附加元数据，使对象语言程序可利用这些设施提供更利于优化执行的实现；
在特定的函数构造器（如通过过程抽象(@8.4.5) 实现的对象语言操作符(@4.4.5.1) ）支持缓存等调用优化；
实现直接接近机器表示的翻译，通常为 JIT(just-in-time) 编译；
使用和 NPLA 不同的表示以支持特定体系结构相关优化。

@7.11.2 动作组合：
动作组合通过调用 NPL::RelaySwitched(@6.12.7) 。
这和通过续延并保证异步调用不同，不把维护状态的操作放在待组合的后续操作中。
这能同时支持同步和异步实现，同时在当前动作以序列表示时，不需要无效化被组合的动作的宿主对象。
**注释** klisp 实现的 kapply_cc 是通过续延并保证异步调用的一个例子。

@7.11.3 函数合并(@4.5.3) 的实现：
NPLA1 规范求值算法(@7.8.2) 相对 Kernel 更简单以支持函数合并的 TCO 实现(@7.11.6) 。
对应地，函数合并在处理器调用(@7.6.1.2) 实现参数列表中参数的求值。
**注释** 这和 klisp 的 eval 实现略有不同。
NPLA1 使用包装数(@7.6.1.1) 处理包装调用，支持多重包装（这在 [RnRK] 被求值算法蕴含）；而当前 klisp 的实现没有正确地支持多重包装调用，参见：https://bitbucket.org/AndresNavarro/klisp/issues/11 。
**注释**
和 klisp 类似，参数列表求值前检查不存在实际参数（而无需求值）的情形进行优化。
klisp 实现缺陷的一个例子：((wrap (wrap ($lambda (x) x))) 1) 无法终止求值。

@7.11.4 PTC 和尾调用本机实现：
符合 PTC 的尾调用通过 TCO 动作(@7.10.3) 实现。
TCO 动作(@7.10.3) 作为 NPLA 续延和之后在 PLDI 2020 公开的论文 https://doi.org/10.1145/3385412.3385981 中的 extra continuation frame 类似。
TCO 动作可扩展实现类似 SRFI-157 的续延标记(continuation mark) 的特性。
在 NPLA1 规范求值算法(@7.8.2) 的 PTC 通过显式构造 TCO 动作以及在此基础上的操作压缩(@7.10.4) 实现。
可能引入新的环境的操作，如 [RnRK] 的 eval（对应 NPLA1 对象语言函数 eval 和 eval% 等，参见 @11.3.7 ），需要另行调用比 A1::ReduceOnce 更复杂的操作压缩。
和 Kernel 要求以外，因为维护资源(@7.10.5) 的需要，TCO 动作在函数合并的底层操作子合并前被构造，因此进入参数求值时在资源管理的意义上也在所在函数合并的同一个尾上下文(@4.4.8) 。
另见 TCO 实现(@7.11.6) 。
**注释**
PTC 实现对应 klisp 的 ktail_call 实现 Kernel 的默认求值算法（包括 [RnRK] 的 eval 应用子的底层的操作子）；但和后者依赖 GC 不同，TCO 动作可对环境有所有权(@7.10.6) 。
类似地，NPLA1 在 A1::ContextState::ReduceOnce(@7.4.3) 实现默认求值算法。
一般地，klisp 使用 ktail_call 中访问续延或操作子中蕴含的函数指针提供本机实现。NPLA1 也可在动作中对应使用 A1::Continuation(@7.4.2) 或 A1::FormContextHandler(@7.6) ，在调用时对应从 A1::ContextState(@7.4.3) 取下一求值项(@7.4.3) 的本机实现。
其它更一般的情况下，在求值上下文(@4.4.8) 中隐含已构造 TCO 动作为前提，通过直接或间接调用 A1::ReduceOnce(@7.4.4) 提供 PTC 保证。后者调用 A1::ContextState::ReduceOnce 。
这对应 klisp 的 ktail_eval ；但 A1::ReduceOnce 调用确切地只对应不显式引入新的环境的操作。若需要改变当前环境(@5.7.3) ，在 TCO 动作或其它个别的操作中实现。
这种设计避免如 klisp 的实现每次需要更新状态中的 next_env 。和 klisp 依赖 next_env 区分是否在尾调用不同，NPLA1 直接访问上下文中的当前动作(@6.11.3)（尾动作的下一动作(@7.10.2) ）是否为 TCO 动作即可确定。

@7.11.5 资源回收限制：
当前 TCO 操作压缩不保证回收（通过 #ignore 指定）被忽略外的动态环境(@4.6.1.2) 。
注意 [RnRK] §3.3 仅保证的应用子调用是尾上下文(@4.4.8) ，使用任意环境作为动态环境的操作子调用时不需要满足 PTC 。
这可能有误，因为造成应用子的底层合并子(@4.5.3.2) 和不作为底层操作子的其它操作子不一致，并且和这里的操作压缩限制一样，实际无法总是保证具有动态环境的应用子在动态环境被用用时能满足的调用 PTC 。
**注释**
事实上，Kernel 语言的实际实现一般无法保证回收非 #ignore 的动态环境，即便动态环境只被用于尾调用中。
上述无法 TCO 的情形在其它语言中因为可达性分析等可能具有实现缺陷也不会释放存储，如以下 Kernel 程序在 klisp 中实测不支持 PTC ：
($sequence ($define! f ($lambda (n) ((($vau (x y) e (eval ($sequence x y) e)) n (f n))))) (f 1))
而当前实现中，对应上述 Kernel 程序的 NPLA1 程序支持 PTC ：
$sequence ($def! f ($lambda (n) ((($vau (x y) e (eval ($sequence x y) e)) n (f n))))) (f 1)
以下 Kernel 程序和对应的 NPLA1 程序支持 PTC ：
($sequence ($define! $f ($vau () #ignore (($f)))) ($f))
$sequence ($def! $f ($vau () #ignore (() $f))) (() $f)
但替换动态环境不被忽略，则都不支持 PTC（对 NPLA1 ，因为 e 没有在尾上下文中被引用，而无法被压缩）：
($sequence ($define! $f ($vau () e (($f)))) ($f))
$sequence ($def! $f ($vau () e (() $f))) (() $f)
以上 Kernel 程序使用 klisp 和 SINK 中（后者需替换 #ignore 为 %ignore ），效果一致。

@7.11.6 TCO 动作(@7.10.3) 实现和其它限制：
因为维护资源(@7.10.5) 的需要，NPLA1 规范求值算法(@7.8.2) 不处理 WHNF(@4.4.5.1) 以外的操作数且允许宿主类型的调用(@7.6.1.2) 处理 WHNF 的第一项。
当前在 TCO 动作中被分配的临时对象(@5.8.5) 的操作都针对作为 WHNF 的第一项的合并子(@4.5.3.2) ，其中合并子的相等关系由相等性(@8.4.5.5) 或不影响可观察行为的其它宿主环境提供的 == 操作确定。
由相等性(@8.4.5.5) ，捕获不同环境的 vau 合并子不相等；不论是否具有相等的外部表示(@1.2.4) 和来源，其右值不会被直接操作压缩(@7.10.4) 避免多次添加而被 TCO ；若其嵌套调用因为捕获不同的存在引用关系的环境，不支持其它形式的 TCO ；因此，不支持 PTC 。
实现依赖 Environment::IsOrphan(@6.11.1.2) 等判断确保内存安全(@5.6.4) 。
忽略非平凡析构判断（假定所有对象都可平凡析构），允许移除可证明不被继续引用(@5.10) （如被总是新的环境隐藏）的变量。
被移除的对象生存期提前结束(@5.10) 。
除被隐藏的变量被单独移除外，若一个活动记录帧（环境）内存在任意不满足可证明幂等的操作的情形，整个帧的剩余部分都被保持存储（因为不支持对 NPL::TermReference(@6.8.3) 分别保存引用计数）。
当前实现并没有显式支持 evlis tail recursion(@5.10.3) ，但因为调用前切换环境时已提前进行了收集，所以以 TCO 动作为边界，保存的帧应与之等效。
尽管可能有更优的渐进复杂度，所需空间的大小仍取决 TCO 活动记录最终保留帧前分配对象和碎片所占空间大小之和的最大值；实现应该不依赖这项特性。
回收使函数对象在表达式求值外完毕之前结束，这仍然符合尾上下文约定(@5.10) 的要求。
当前 NPL::LiftToReturn(@6.9.4.3) 的调用非嵌套调用安全(@6.1.4.1) 。在项的嵌套深度依赖调用深度时，不满足 PTC 。
**注释**
需要注意，在 WHNF 的第一项嵌套调用时，Kernel 不保证递归调用的 PTC ，因为这不是尾上下文：
($sequence ($define! $f ($vau () #ignore (($f)))) ($f))
($sequence ($define! f (wrap ($vau () #ignore ((f))))) (f))
($sequence ($define! f ($lambda () ((f)))) (f))
（关于以上 klisp 在没有支持 PTC 的情形的第一个例子的疑问，另见 https://bitbucket.org/AndresNavarro/klisp/issues/12 。）
类似地，对应的 NPLA1 程序同样不保证 PTC ：
$sequence ($def! $f ($vau () #ignore (() $f))) (() $f)
$sequence ($def! f (wrap ($vau () #ignore (() f)))) (() f)
$sequence ($def! f ($lambda () (() f))) (() f)
应用子递归调用对应的 Scheme 程序也类似：
(begin (define f (lambda () ((f)))) ((f)))
(begin (define f (lambda () (f))) (f))

@7.11.7 续延名称：
模块 NPL::NPLA1 提供特定可由函数 A1::QueryContinuationName(@7.7.5) 查询得到的续延名称。
其中查询结果的名称和 A1::Continuation::Handler 或 Reducer 的特定目标类型关联。
除非另行指定，关联的类型是非公开的内部类型。
在 NPLA1 实现中引入的这些名称包括：
combine-return
eval-argument-list
eval-combine-operands
eval-combine-operator
eval-guard
eval-lift-result
eval-sequence
eval-tail ：关联 TCO 动作(@7.10.3) 。
sequence-return
若特定对象语言操作使用非本机实现(@5.3) ，可使用其它续延。
另见其它 NPLA1 实现模块中引入的续延名称(@8.6.1) 。

@7.11.8 嵌套调用说明：
当前实现显式包含保证嵌套调用安全(@5.4.2) 机制的异步调用 API 包括：
NPL::SContext 中的递归遍历 API(@6.1.6.4) ；
环境数据结构(@6.11.1) 的可重入 API ；
中缀变换(@7.5.1) ；
递归绑定支持 API(@7.7.4) 。
例外参见：
NPLA 安全保证例外(@6.1.4) 。
其中，压缩活动记录(@7.5.10.2) 的扫描帧的实现包含直接遍历参数节点的操作，属于此例外的实例。
另见异步规约 API 支持的相关实现选项(@7.9.2) 。

@8 NPLA1 对象语言扩展实现：
基于 NPLA1 的语言扩展主要在模块 NPL::NPLA1Forms 中提供；另见 @8.4.13 。

@8.1 语法形式支持：
模块 NPL::NPLA1Forms 提供的 API 专用于实现语法形式对应的功能而不是 NPLA1 的核心语言(@9) 一般机制。
其中，主要操作的实现在命名空间 A1::Forms 中提供。
作为对象语言中可用的语言特性(@2.1.2) ，一部分功能是基本的(@1.5.5.1) 。其余功能是派生的(@1.5.5.1) ，可在对象语言源代码的形式通过组合这些已有的其它特性实现。
功能以操作(@4.4.5.1) 提供，可作为对象语言中的合并子类型的被绑定对象(@7.6.1.1) 的本机实现(@5.3) 。
派生操作的功能对 NPLA1 实现并非严格地必要，但适合使用宿主语言实现，被 NPLA1 代码间接地调用。
因性能等原因，一些基本派生操作在此直接提供 API 。
这些 API 的实现中：
可能使用重规约(@6.10.1) ；
可假定使用默认解释(@7.8) 的合并遍(@7.4.1.2) 等价的实现。
推论：和默认解释不同的遍是否在这些 API 的实现中被调用是未指定的。

@8.1.1 实现要求：
以上允许的未指定的实现差异可能造成在修改合并遍（如 A1::SetupDefaultInterpretation(@7.8) 的遍参数）时，只使用对象语言的派生实现和使用这些 API 的本机实现(@5.3) 的行为可能不同。
典型例子有：
Forms::Apply(@8.4.9) 等操作在需调用上下文处理器(@7.6.1) 时不需要保证和 A1::ReduceCombined(@7.6.4.2) 无关的列表遍(@7.4.3) 的处理器的调用；
保证能以处理一等对象的进行派生的 Forms::Import(@8.4.9) 等操作可忽略 A1::LiteralHandler(@7.2.1) 的求值的作用。
实现应保证以上差异不影响满足对象语言关于特定操作的语义要求。
以上下文处理器调用的操作应满足上下文需要的状态：
在进入调用前已使用 A1::ReduceCombined 确保存在 TCO 动作(@7.10.3) ，以允许尾上下文(@4.4.5) 求值。
基本派生操作包括 Forms::First(@8.4.3) 等针对特定类型的操作。关于不同类型的其它综合操作参见通用基本派生操作(@8.4.9) 。
A1::Forms 的公开 API 提供合并子的本机实现时确保调用这些合并子经过遍处理器依赖的检查(@7.6.1.3) 。这可使用如保留操作(@7.6.3.1) 实现。
这些 API 不被 A1::Forms 以外的 API 及实现依赖，且符合本节的以下约定。
除非另行指定，这些形式不是特殊形式(@5.2) ，一般作为按值传递(@4.4.6.5) 的函数(@4.5.2) ；其中的值对象(@6.1.7) 表示引用时，传递引用(@4.4.6.5) ；表示访问的值不被修改时，是否传递引用未指定。
这些 API 接受的输入被视为正规表示(@6.10.6) ，但用于求值表达式时，依赖 NPLA1 的约定，输出不需要保证规约后的项是正规表示(@6.10.6) ，而通过这些 API 以外的正规化操作(@6.10.6.1) 保证（参见 @7.4.1.4 ）。
推论：正规表示以外的宿主值是否被保留以及保留的时机未指定。
本章中的 API 中的规约函数(@6.10.5) 具有间接断言：第一参数指定的项是枝节点。

@8.1.2 间接值(@5.6.3.1) 访问：
基本规则参见 @7.7.1 。
部分 API 同时提供结果中消除引用值(@5.6.4.5) 和不消除引用值的版本，这些函数以 API 后缀名称区分：
以 At 、Fwd 和 Ref 的后缀表示保留未折叠的引用值(@5.8.3.6) 、转发(@5.8.2.2) 参数值和保留折叠的引用值；
部分不带有特定后缀的函数为参数和返回值转发操作（仅当参数指定引用值时保留参数值），同时以 Val 的后缀表示消除引用值；
其它不带有特定后缀的函数消除引用值。
**注释**
对象语言中，被保留的引用值(@9.4.4) 若来自参数且被折叠，通常经过调用 NPL::Collapse(@6.9.3) 折叠。
显式涉及区分是否在结果中保留间接值(@9.4.4) 的 API 包括：
求值规约操作(@7.7.2) API ；
元素和列表操作(@8.4.3) 。

@8.2 支持 API ：
本节中的操作 API 实现的 API 不在 A1::Forms 而是在 NPL::A1 中直接提供。
本节中的 API 作为操作的实现是非上下文操作，不依赖上下文，无 ContextNode(@6.11.3.1) 参数。

@8.2.1 支持类型：
以下 API 支持具体操作的实现：
类 EncapsulationBase
类 Encapsulation
类 Encapsulate
类 EncapsulateValue
类 Encapsulated
类 Decapsulate

@8.2.2 记号操作：
A1 提供以下和记号相关的函数，支持对象语言对符号的操作：
A1::IsSymbol
A1::StringToSymbol
A1::SymbolToString

@8.3 调用助手：
通过提供包装上下文处理器注册(@7.6.2) 的 API（以下都为函数模板），可简化需要的回调形式。
Forms 提供以下函数和函数模板简化调用：
Forms::CallRawUnary
Forms::CallResolvedUnary 和 Forms::CallResolvedUnaryAs 调用 NPL::ResolveTerm(@6.9.3) 解析节点的子节点并调用一元函数。
Forms::CallRegularUnaryAs 访问节点的子节点，以正规值(@6.10.6) 调用一元函数。
使用 NPL::CheckRegular(@6.9.2) 访问正规值。
Forms::CallUnary 和 Forms::CallUnaryAs 访问节点并调用一元函数，支持设置对象语言返回值。
Forms::CallBinary 和 Forms::CallBinaryAs 访问节点并调用二元函数，支持设置对象语言返回值。
以 As 为后缀的版本使用模板参数指定节点转换的目标类型作为提供回调的参数类型；否则参数类型为 TermNode& 。
Forms::CallBinaryFold 访问节点并以指定的初始值为基础逐项调用二元函数。
Forms::UnaryExpansion 、Forms::UnaryAsExpansion 、Forms::BinaryExpansion 和 Forms::BinaryAsExpansion 提供对应的扩展调用，允许回调省略没有使用的 ContextNode& 类型的参数。
基于以上调用助手 API 和 A1::RegisterStrict(@7.6.2) 注册严格上下文处理器的 API 包括：
Forms::RegisterUnary
Forms::RegisterBinary

@8.4 语法形式对应功能的实现：
在语法形式支持(@8.1) 的基础上，命名空间 A1::Forms 的 API 包含直接用于调用助手(@8.3) 注册的例程，可作为对应对象语言中的操作的本机实现(@5.3) 。
这些操作中的一部分可能通过不同的顺序和依赖关系在非本机实现中派生。

@8.4.1 内建谓词：
Forms 提供以下实现谓词(@4.2.1) 的函数：
Forms::EqLeaf ：比较项中的值数据成员(@6.2) 相等。
Forms::EqReference
对引用值的判断满足引用(@4.2.6) 的相等关系，其结果是准确的。
语义接近 [RnRS] 的 eq? 。
Forms::EqValue
语义接近 [RnRS] 的 eqv? 。
Forms::EqualTermValue
以上通过值的比较基于 YSLib::GHEvent 的相等。
上下文处理器(@7.6.1) 对未支持 == 比较的函数对象提供默认的相等实现，相同类型的函数对象的值视为恒等。
若需改变行为，需补充 operator== 。

@8.4.2 分支和逻辑操作：
Forms 提供以下函数实现对象语言中的控制和逻辑操作：
Forms::If
Forms::Cond
Forms::When
Forms::Unless
Forms::Not
Forms::And
Forms::Or

@8.4.3 列表操作：
Forms 提供以下函数实现对象语言中的列表操作：
Forms::Cons
Forms::ConsRef
Forms::ForwardFirst
Forms::First
Forms::FirstAt
Forms::FirstRef
Forms::FirstVal
Forms::Rest
Forms::RestRef
Forms::RestVal
Forms::SetFirst
Forms::SetFirstAt
Forms::SetFirstRef
Forms::SetRest
Forms::SetRestRef

@8.4.4 环境和求值操作：
Forms 提供环境相关的操作，以支持对象语言中的环境(@9.9.2) 。

@8.4.4.1 求值操作：
Forms 提供以下函数实现对象语言中的求值(@7.1.1) ：
Forms::Eval
Forms::EvalRef
Forms::EvalString
Forms::EvalStringRef
Forms::EvalUnit
Forms::RemoteEval
Forms::RemoteEvalRef

@8.4.4.2 环境创建和访问操作：
Forms 提供以下函数实现对象语言中的环境创建和访问：
Forms::MakeEnvironment 创建空环境(@4.6.1) 。
Forms::GetCurrentEnvironment 取当前环境(@6.11.3) 的引用。
Forms::LockCurrentEnvironment

@8.4.4.3 环境修改操作：
Forms 提供以下函数实现对象语言中的环境修改，包括定义和修改名称绑定映射(@6.11.1) ：
Forms::DefineLazy
Forms::DefineWithNoRecursion
Forms::DefineWithRecursion
Forms::SetWithNoRecursion
Forms::SetWithRecursion
Forms::Undefine

@8.4.5 过程抽象：
过程使用 A1::FormContextHandler(@7.6) 实现。
后者包含的实际求值使用使用 A1::ReduceArguments(@7.4.6) 实现。
**注释** 当前实现中使用从左到右的子项规约，和 [Shu10] 实际使用的不同。
Forms 提供以下函数支持 lambda 特殊形式创建以过程为基础的 λ 抽象(@4.5.2.4) ：
Forms::Lambda
Forms::LambdaRef
Forms::LambdaWithEnvironment
Forms::LambdaWithEnvironmentRef
Forms 提供以下函数支持更一般的 vau 抽象(@4.5.2.5) 。
Forms::Vau
Forms::VarRef
Forms::VauWithEnvironment
Forms::VauWithEnvironmentRef
以上函数中不带有 WithEnvironment 的版本和 Kernel 的 $lambda 及 $vau 操作合并子类似，而指定 WithEnvironment 的版本进一步支持在创建抽象时指定静态环境。
Vau 抽象可包含的捕获(@8.4.5.1) 静态环境的数据结构，以非公开类型的对象存储，进一步初始化处理器类型 A1::ContextHandler(@7.2.1) 的值，被待规约的项或环境所有(@5.6) 。
Vau 抽象的应用在的新创建的空的但以上述静态环境为父环境(@5.7) 的局部环境(local environment) 中对抽象中指定的表达式（函数体）的副本求值，以包含局部环境(@4.6.1.2) 的数据结构作为活动记录帧(@5.6) 。
记号值(@6.8.1) 可表示待替换的符号(@6.8.1) ，用于实现形式参数(@8.4.5) 。
λ 抽象可通过 vau 抽象实现，但由于简单和性能原因，直接提供 API 支持。
创建过程抽象的调用时递归检查形式参数树的叶节点是否为符号。当前递归检查符号非嵌套调用安全(@6.1.4.1) 。

@8.4.5.1 捕获：
环境中的变量被隐含地捕获。
捕获通过调用时设置在初始化保存的父环境指针实现。
因为实际指称的确定发生应用中对表达式副本的求值时的名称查找(@4.3.3) ，所以这是延迟到应用的按名称捕获(capture by name) 。这也在引入抽象时实现递归指称。
由于使用 NPL::EnvironmentReference 值保证有效性，无效的父环境访问会出错，但行为仍可预测；详见 @8.4.5.2 。
被 A1::EvaluateIdentifier(@7.6.4) 求值的变量按引用捕获(@4.5.2) 。
若修改被捕获的变量对应的对象，可引起调用过程的可观察行为(@4.1.3) 的改变。

@8.4.5.2 内部数据所有权：
存储在 vau 抽象对象内的数据包括：
形式参数对象；
上下文原型；
捕获的静态环境(@4.6.1.2) ；
作为过程实现的求值结构(evaluation structure)（对应表达式中可能被求值的函数体(@4.5.2) ）；
决定是否在调用后提升返回结果(@8.4.5.4) 的标记。
这些数据都是可被共享的。复制 vau 抽象的处理器对象共享这些数据。
其中，作为父环境的静态环境以 NPL::EnvironmentReference 弱引用值保存，并附加 shared_ptr 实例以可选被 vau 抽象所有；其它数据都以 shared_ptr 的值保存，被 vau 抽象所有。
这允许调用(@8.4.5.4) 引用父环境时对之前确定的绑定（如捕获(@8.4.5.1) 时) 进行生存期检查，发现循环引用(@5.2) 等引起未定义行为的错误(@7.6.5) 。注意在对象语言中出错时未定义行为，不应依赖此行为。
除可选的静态环境 shared_ptr 实例，所有指针数据在 vau 抽象对象的生存期内都保持非空。
形式参数树(@7.7.3) 作为数据成员同 vau 抽象对象被项或环境所有，可能被不同值类别的表达式标识，但它作为表达式和子表达式时不被直接求值，且子表达式中的符号被复制而不是以间接值引用(@6.4.3.2) ，因此是纯右值(@5.6.3.1) 。

@8.4.5.3 参数绑定：
通过 vau 抽象引入的函数调用(@4.5.3.1) 在求值时，以 TermNode 的项而不是 ValueObject 的值对象替换上下文中的形式参数(@4.5.2.1) 树，用于在调用时被操作数树(@7.7.4) 作为实际参数替换。
绑定参数通过调用 A1::BindParameter(@7.7.4) 实现，其中对参数和操作数进行匹配。
按值传递时需使用效果等价返回值转换(@5.8.4.2) 的方式确保在被保存(@8.4.5.2) 前不再引用其它项对象而维护内存安全。
注意提升项不是递归的，按值传递的操作数的项的只提升直接子项（同 @6.9.4.3 ）。

@8.4.5.4 过程调用：
在调用过程时，求值结构(@8.4.5.2) 可能被其它的调用转移，因此先检查以确保存在。若不存在，则抛出 NPL::NPLException(@6.5) 异常。
调用创建局部环境，持有此调用的活动记录帧(@4.5.3.4) 。
若求值结构未被共享且被规约项(@6.2) 具有调用时设置的 TermTags::Temporary 标签(@7.6.4.2) ，则指定之后函数不会被再次调用，求值结构可转移。
**注释** 当前实现中，仅 TCO 提前转移表示合并子右值中的资源。但这个要求不依赖 TCO 。
求值结构的共享判断允许本机实现(@5.3) 直接复制 vau 抽象的处理器(@8.4.5.2) 。
在判断可转移后，第一个子项被移除。余下的子项即为参数绑定(@8.4.5.3) 使用的操作数。
被绑定的参数被添加到局部环境。
参数绑定后对求值结构的项或其副本进行规约，使函数体(@4.5.2) 被求值。这通过 A1::RelayForCall(@7.7.2) 或其等效的内部调用实现。
之前判断可转移时，直接使用求值结构的项，否则使用副本。
规约在局部环境进行名称解析(@6.11.1) ，通过保存的 NPL::EnvironmentReference 值对静态环境(@4.6.1.2) 的所有权进行检查，若失败则抛出异常。
保存在静态环境以外的对象的引用不受到以上机制保护，需要对形式参数对象可包含的对象进行限制以保证项对象和关联对象所有权要求(@5.6.3.1) 。
因此，vau 抽象初始化时对形式参数对象检查，确保其中的非列表项中只存在调用 NPL::LiftTermRef 后也不引入间接值(@5.6.3.1) 的对象的值，即记号值(@6.8.1) 。
恢复被切换的环境(@6.11.4.2) 时，环境内的对象被释放。
若需保证内存安全(@5.6.4)，返回值(@4.5.3.1) 不能是在调用后生存期结束的对象的引用值(@5.8.3.8) ，以避免引用被释放或之后被正规化(@6.10.6.1) 清理的值引入未定义行为。
避免返回(@4.5.3.1) 引用值(@5.8.3.8) 的通用机制为提升返回结果，即求值后的求值结果(@6.10.1) 进行进行返回值转换(@5.8.4.2) ，同时消除引用值(@5.8.3.5) ，使返回值总是按值传递(@5.6.4.5) 。

@8.4.5.5 相等性：
相等性作为弱函数应用规约等价谓词(@4.5.3.2) 提供，操作为对所有成员进行相等比较，当且仅当都相等时，结果是真。
其中，上下文相等由同一性决定；其它成员的比较由宿主环境(@2.6.1) 的相等操作决定。
除非能证明总是不影响调用时的可观察行为，构成过程抽象的不相等的组成部分蕴含过程不相等：
包装数(@7.6.1.1) 不相等的过程不相等；
处理器(@8.4.5.2) 不相等的过程不相等。
其中，处理器的相等由宿主环境的 == 操作定义。
注释实现对象语言允许包装或解包装的作为一等对象的合并子(@4.5.3.2) 不能证明包装数不被程序访问，因此包装数的合并子不相等。
当前实现相等比较捕获的静态环境(@4.6.1.2) 。静态环境使用父环境(@6.11.1.3) 相同的表示。不同宿主类型(@5.3.1) 的父环境总是不相等，因此对应包含这些父环境的过程实体视为不相等。

@8.4.6 合并子类型转换操作：
Forms 提供以下在对象语言中实现合并子(@4.5.3.2) 之间的非规约函数(@6.10.5) 转换函数：
Forms::Wrap 包装(@4.5.3.2) 合并子为应用子(@4.5.3.2) 。
Forms::WrapOnce 包装操作子为应用子。
Forms::Unwrap 解包装(@4.5.3.2) 应用子为合并子。
其中后两者会对合并子按 @7.6.1 的约定进行类型检查(@4.7.4) ，若不满足条件则抛出异常。
当被解包装的应用子参数是引用时，解包装的结果是构成子对象引用的处理器(@7.2.1) 。

@8.4.7 错误检查：
Forms 提供以下可能抛出异常的错误检查函数：
Forms::CheckEnvironment
Forms::CheckParent
Forms::CheckListReference
Forms::CheckPairReference

@8.4.8 封装类型操作：
Forms 提供以下实现封装类型操作的函数：
Forms::MakeEncapsulationType 创建封装类型操作的应用子(@4.5.3.2) 。
其中，结果第二项的应用子用于取被封装类型的值。
作用于右值时，使用引入不安全引用值(@6.8.3.1) 的项引用操作(@6.9.3) 而不提供检查(@5.4) 。
因为访问的是右值，不影响内存安全(@5.6.4) 。

@8.4.9 通用基本派生操作：
Forms 提供以下可通过对象语言派生的操作的对应本机实现的函数：
Forms::Apply 函数应用：应用参数指定的函数和作为函数参数的对象。
操作的语义同 [RnRK] ，但在可选参数多余 1 个时的错误情形抛出 NPL::ArityMismatch(@6.5) 异常。
保证最后一项的规约是尾上下文，允许 PTC 。
Forms::ApplyList 函数应用：应用参数指定的函数和作为函数参数的对象。
同 Forms::Apply ，但对参数进行检查，若失败则抛出异常。
Forms::Sequence 序列有序参数规约：移除第一项后顺序规约子项，结果是最后一个子项的规约结果(@6.10.1) 。
此操作对列表形式的操作数的子项有序求值，其顺序约定同 A1::ReduceOrdered 。
当操作数非空时，保证最后一项的规约是尾上下文(@4.4.8) ，允许 PTC(@5.10) 。
Forms::ListAsterisk
Forms::ListAsteriskRef
Forms::AccL
Forms::AccR
Forms::FoldR1
Forms::Map1
Forms::ListConcat
Forms::Append
Forms::ListExtractFirst
Forms::ListExtractRestFwd
Forms::Let
Forms::LetRef
Forms::LetWithEnvironment
Forms::LetWithEnvironmentRef
Forms::LetAsterisk
Forms::LetAsteriskRef
Forms::LetRec
Forms::LetRecRef
Forms::AsEnvironment
Forms::BindingsWithParentToEnvironment
Forms::BindingsToEnvironment
Forms::SymbolsToImports
Forms::ProvideLet
Forms::Provide
Forms::Import
Forms::ImportRef
Forms::Assq
Forms::Assv
同时，提供以下宏作为实现选项(@7.1) 修改实现行为：
NPL_Impl_NPLA1Forms_LetAsterisk_ExpandLevel ：
指定 Forms::LetAsterisk 和 Forms::LetAsteriskRef 实现内部展开调用的等级。
可选值是 0 到 3 之间的整数。默认值为 3 或 2（优化目标代码大小时）。
NPL_Impl_NPLA1Forms_LetParent_ExpandLevel ：
指定 Forms::Let* 实现内部对判断是否求值环境（包括但不限于所有空绑定列表）时展开调用的等级。
可选值是 0 到 3 之间的整数。其中 2 以上的值没有差异。
默认值为 NPL_Impl_NPLA1Forms_LetAsterisk_ExpandLevel 。
**注释**
部分实现在使用非一等对象的内部列表表示。
Forms::FoldR1 和 Forms::Map1 当前可使用不在对象语言中的右值的表示中支持的标签(@6.2.2.1) 。

@8.4.10 一等续延支持：
一等续延的实现依赖实现选项 NPL_Impl_NPLA1_Enable_Thunked 启用异步规约(@7.9.2) ，否则应用续延的行为未定义。
Forms 提供以下在对象语言中实现一等续延(@4.5.3.3) 相关操作：
Forms::Call1CC
Forms::ContinuationToApplicative
Forms::ApplyContinuation

@8.4.11 外部调用：
Forms 提供以下在对象语言中调用实现环境外部功能的函数：
Forms::CallSystem 实现到 YFramework 提供的 usystem 函数的调用转发，用于调用外部命令。

@8.5 依赖管理模块：
模块 NPL::Dependency 基于 NPLA1 提供 SHBuild 使用的一些 API 。

@8.5.1 外部加载 API
包含以下函数：
A1::OpenFile
A1::OpenUnique
A1::PreloadExternal
A1::ReduceToLoadExternal
A1::RelayToLoadExternal

@8.5.2 对象语言加载 API
函数 Forms::LoadGroundContext 提供 SHBuild 初始 REPL 环境（包含的上下文是基础上下文(@10.1.1) ），其中支持：
使用 A1::SeparatorTransformer(@7.5.1) 启用预处理的分号和逗号转换，分别为有序和无序列表求值的语法糖。
上述语法糖实现为 REPL 对象内部的无状态的预处理器求值遍，仅包含中缀变换(@7.5.1) ，不需要向环境中添加名称。
变换后仍然具有 WHNF(@4.4.5.1) 形式，其中第一个子项是一个合并子右值，具有以下性质：
对之后的子项构成的序列有序或无序列表求值；
若存在操作数，有序求值保证最后一项是尾上下文（实现同 @8.4.9 ）；
不保证是真合并子(@4.5.3.2) 。
在对象语言中的对应接口参见 NPLA1 参照实现环境(@10) 。
模块 NPL::Dependency 还提供其它一些函数。
调用函数 Forms::LoadGroundContext 初始化上下文后继续调用。这蕴含调用以下函数初始化特定操作的环境：
Forms::LoadModule_std_continuations 提供一等续延(@4.5.3.3) 相关操作(@12.1) ；
Forms::LoadModule_std_promises 提供延迟求值等操作(@12.2) ；
Forms::LoadModule_std_math 提供数学功能相关操作(@12.3) ；
Forms::LoadModule_std_strings 提供字符串操作(@12.4) ；
Forms::LoadModule_std_io 提供输入/输出操作(@12.5) ；
Forms::LoadModule_std_modules 提供模块管理操作(@12.7) ；
Forms::LoadModule_std_system 提供系统操作(@12.6) ；
Forms::LoadModule_SHBuild 提供其它一些供 SHBuild 间接调用的操作(@13.1.1) 。
Forms::LoadStandardContext 调用 Forms::LoadGroundContext 并加载基础上下文中提供的库模块(@10.2) ；另见 NPLA1 参照实现扩展环境(@12) 。
当前实现中，以下情形可能修改共享的资源，因此需要附加宿主环境的实现机制以避免宿主语言的未定义行为：
Forms::LoadModule_std_modules 可修改保存在环境对象(@5.7.1) 中的共享资源。

@8.6 实现注记：
本节指定当前实现的一些非公开接口性质。

@8.6.1 NPLA1 实现模块的续延名称：
在模块 NPL::NPLA1Forms 中引入的续延名称(@7.11.7) 包括：
as-environment-return
bindings-to-env
captured-one-shot-continuation
combine-let-return
conditional-eval-sequence
equal-subterm
equal-siblings
eval-acc-head-next
eval-acc-nested
eval-accl-accl
eval-accl-tail
eval-accr-accr
eval-accr-sum
eval-bindings-to-env
eval-booleans
eval-cond-list
eval-foldr1-kons
eval-let
eval-let*
eval-let-parent
eval-letrec-bind
eval-lift-sum
eval-map1-appv
eval-remote-eval-env
eval-vau-parent
import-bindings
match-ptree
match-ptree-recursive
provide-let-return
select-clause
set-eval-obj
在内部实现模块 NPL::NPLA1Internals 中引入的续延名称包括：
restore-source-name
在模块 NPL::Dependency 中引入的续延名称包括：
eval-$binds1?-env
eval-lazy-parent
get-module-return
load-external
promise-handle-result
require-return
在模块 NPL::Dependency 中，若特定对象语言操作使用非本机实现(@5.3) ，可使用不同的续延名称。

@8.6.2 和 klisp 续延名称的关系：
NPLA1 续延名称(@7.11.7) 和上述续延名称(@8.6.1) 中，部分名称和 klisp 0.3 中作用近似的续延的名称一致，功能近似。
一致但存在附加不同用法的名称包括：
eval-let ：同时用于 Forms::Provide 和 Forms::ProvideLet(@8.4.9) 。
set-eval-obj ：同时用于 Forms::SetWithNoRecursion 和 Forms::SetWithRecursion(@8.4.4.3) 。
import-bindings ：同时用于 Forms::Import 和 Forms::ImportRef(@8.4.9) ，但不用于 Forms::Provide 。
不一致的名称包括：
as-environment-return ：Forms::AsEnvironment(@8.4.9) 返回环境。
captured-one-shot-continuation ：通过 Forms::Call1CC(@8.4.10) 捕获的一次调用续延(@4.5.3.3) 。
combine-let-return ：非 TCO 的规约合并求值(@7.6.4.2) 实现中的 Forms::Let 、Forms::LetRef 、Forms::LetWithEnvironment 、Forms::LetWithEnvironmentRef 、Forms::LetAsterisk 、Forms::LetAsteriskRef 、Forms::LetRec 、Forms::LetRecRef 和 Forms::AsEnvironment(@8.4.9) 的实现中设置规约合并最后的返回结果。
combine-return ：非 TCO 的规约合并求值实现中设置规约合并最后的返回结果。
equal-subterm ：Forms::EqualTermValue(@8.4.1) 比较直接子项。
equal-siblings ：Forms::EqualTermValue 比较同一个项中的剩余其它子项。
eval-$binds1?-env ：Forms::LoadGroundContext(@8.5.2) 实现 $binds1?(@11.4.2) ，类似 klisp 的 eval-$binds-env 。
eval-acc-head-next ：Forms::AccL 和 Forms::AccR(@8.4.9) 公共操作后分派的不同操作。
eval-acc-nested ：Forms::AccL 和 Forms::AccR 嵌套调用抽象列表余下的元素的公共操作。
eval-accl-accl ：Forms::AccL 递归调用。
eval-accl-tail ：Forms::AccL 调用取抽象列表余下的元素的函数。
eval-accr-accr ：Forms::AccR 递归调用。
eval-accr-sum ：Forms::AccR 调用取抽象列表部分和的函数。
eval-bindings-to-env ：Forms::BindingsWithParentToEnvironment(@8.4.9) 在创建的环境中绑定变量并返回。
eval-foldr1-kons ：Forms::FoldR1(@8.4.9) 应用子调用。
eval-guard ：A1::MakeKeptGuard(@7.7.7) 引入的守卫操作，用于：
非 TCO 的求值实现重置守卫的附加动作帧(@6.12.6) ；
异步规约(@7.9.2) 的 LoadModule_std_io(@8.5.2) 实现 get-module(@12.5) 和 LoadModule_std_module(@8.5.2) 实现 require(@12.6) 加载翻译单元时以守卫保护当前环境。
eval-lazy-parent ：惰性求值指定父环境求值。
eval-let* ：Forms::LetAsterisk 和 Forms::LetAsteriskRef(@8.4.9) 的递归求值。
**注释** 仅实现内部使用 NPL_Impl_NPLA1Forms_LetAsterisk_ExpandLevel == 3 时生效，否则仍同 eval-let 。
eval-let-parent ：Forms::LetWithEnvironment 和 Forms::LetWithEnvironmentRef 中求值过程抽象(@8.4.5) 的父环境的表达式。
eval-letrec-bind ：Forms::LetRec 和 Forms::LetRecRef 中的变量绑定。
eval-lift-result ：非 TCO 的求值实现调用 NPL::ReduceForLiftedResult(@6.10.7.1) 以及非尾上下文(@4.4.8) 求值提升返回结果。
eval-lift-sum ：Forms::AccR、Forms::FoldR1 和 Forms::Map1(@8.4.9) 公共的部分和提升调用。
eval-map1-appv ：Forms::Map1(@8.4.9) 应用子调用。
eval-tail ：TCO 动作尾上下文求值。
**注释** 和 klisp 不同，不依赖 GC(@5.6.5) 而在 TCO 动作单独保存资源(@7.10.5.1) 。
eval-vau-parent ：Forms::LambdaWithEnvironment 和 Forms::VauWithEnvironment(@8.4.5) 创建操作子时求值过程抽象的父环境的表达式。
get-module-return ：异步规约的 LoadModule_std_io 实现 get-module 返回结果。
load-external ：A1::RelayToLoadExternal(@8.5.2) 加载外部翻译单元。
match-ptree-recursive ：支持延迟递归绑定（ Forms::DefineWithRecursion 和 Forms::SetWithRecursion(@8.4.4.3) ）。
provide-let-return ：Forms::ProvideLet(@8.4.9) 返回环境。
restore-source-name ：非 TCO 的以下函数的实现在求值后恢复 GlobalState(@7.8) 中保存的源代码名称：
	求值后：Forms::EvalString 和 Forms::EvalStringRef(@8.4.4.1) 。
	加载模块后：A1::ReduceToLoadExternal 和 A1::RelayToLoadExternal(@8.5.1) 及 Forms::LoadModule_std_modules(@8.5.2) 。
require-return ：异步规约的 LoadModule_std_module 实现 require 加载翻译单元后设置和返回结果。
sequence-return ：非 TCO 的 A1::ReduceOrdered(@7.4.6) 实现中设置规约合并最后的返回结果。
**注释**
klisp 的 equal? 直接使用自动机实现，在比较操作中没有对应的续延。NPLA1 支持互操作(@5.3) 允许相等的子对象以异步规约实现，不能使用这种方式而排除续延。
klisp 的 $vau 不具有应保证被求值的实际参数，不需要异步调用(@6.11.3) ，没有 eval-vau-parent 对应的续延。
import-bindings 和 Forms::Provide 使用的 provide-let-return 共用部分本机实现(@5.3) 。
klisp 的 call/cc 直接捕获当前续延而不进行其它操作。控制作用(@4.1) 对续延的调用在本机函数 kcall_cont 实现，并被 apply-continuation 的本机实现调用，其中可调用本机函数 do_interception ，但没有指派具体的续延名称。
和 klisp 不同，Forms::Call1CC 需检查一次续延调用的约束，在不修改宿主类型 A1::Continuation(@7.4.2) 时，不能单独把控制作用的实现放在调用处，而是和 Scheme 这样直接把续延具现为过程的方式，在内部的 A1::ContextHandler(@7.4.2) 中指定其实现。
这样的实现方式在捕获时单独指定不同的特性（包括续延名称）而不是在其它位置（如应用或扩展续延）时指定信息，同时不需要修改 A1::Continuation 的实现。这些信息原则上是可选的，减少 A1::Continuation 的实现意味着减小实现开销（但 TCO 实现当前仍然无法避免类似的开销）。

@9 NPLA1 核心语言设计：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%A0%B8%E5%BF%83%E8%AF%AD%E8%A8%80 。
NPLA1 支持和宿主语言的互操作，其实现应满足互操作(@7.1.4) 。

@9.1 NPLA1 程序实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0 。
关于对象语言派生实现，参见 @10.7.3 。

@9.1.1 外部环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83 。

@9.1.2 附加元数据：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%99%84%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE 。

@9.1.3 NPLA1 扩展支持：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E6%94%AF%E6%8C%81 。

@9.1.4 NPLA1 未定义行为：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA 。

@9.1.5 NPLA1 实现注记：
使用 REPL API(@7.8) 创建 REPL 实例用于实现解释器。
使用 A1::Forms(@8.1) 的成员指定需要内建支持的语法形式。
一般在初始化时自行绑定初始环境(@10.1) 的名称。
以下实现中的 C++ 名称和项目模块命名空间的使用同 @7 。

@9.2 接口文法约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A 。

@9.2.1 元文法基本约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%83%E6%96%87%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A 。

@9.2.2 实体元素文法约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E4%BD%93%E5%85%83%E7%B4%A0%E6%96%87%E6%B3%95%E7%BA%A6%E5%AE%9A 。
未求值的操作数作为数据结构和 AST(@6.1.6) 同构，是符号或未求值操作数构成的真列表(@9.9.3) 。
关于 eval ，参见 @11.3.7 。
**注释**
本节约定的实体元素可在求值算法及核心库(@11.4.3) 的描述中引用。
关于操作数转换，另见常规函数约定(@10.4) 、函数分类(@11.2) 和具体操作的约定。

@9.2.2.1 未求值的操作数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%AA%E6%B1%82%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0 。
关于未指定值，参见 @7.2.2 和 @10.7.1 。
**注释**
未求值的操作数是未求值的 AST 子项或特定表达式的求值结果(@6.10.1) 。
求值规约(@4.4) 中，构造和 AST 同构的操作数或不修改输入的项而直接提升(@6.9.4) 操作数项或其子项，可以取得作为未求值的操作数的求值结果。

@9.2.2.2 求值得到的操作数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E5%BE%97%E5%88%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0 。
当前实现中，关于 <string> ：
宿主值类型为 string(@6.8.1) 。
字符串是包括数据字面量(@5.2.4) 求值的结果类型，以 string 类型表示，编码和表示要求同 YFramework 默认约定([Documentation::YFramework @@3.3.1]) 。
**注释**
对外部来源的 <string> 的值不要求检查，直接视为 NTCTS(@7.1.1) 。
关于 <pair> ，另见表示的说明(@6.2.3) 。

@9.2.2.3 文法元素补充约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%96%87%E6%B3%95%E5%85%83%E7%B4%A0%E8%A1%A5%E5%85%85%E7%BA%A6%E5%AE%9A 。
关于合并子基本操作，参见 @11.3.8 。
针对 <formals> 的假设，派生实现可进行附加的语义检查。在 NPLA1 的当前实现（特别地，使用绑定支持 API(@7.7.4) ）中，没有这样的检查。
为对 <environment> 和 <parent> 进行类型检查(@9.5.4.1) 取得环境强引用(@6.11.1) 时，可附带进行内部的检查(@9.5.4) 确保 shared_ptr<Environment>(@6.8.2) 类型的宿主值非空。
**注释**
和 [RnRK] 类似，个别的应用子和底层合并子接受不同形式的参数（尽管 [RnRK] 没有约定），例如：
	[RnRK] 的 list 接受列表，但底层合并子也接受和非列表对象构成的有序对。
	NPLA1 对应的函数参见 list 和 list%(@11.4.1) 。

@9.3 NPLA1 对象语言语法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95 。

@9.3.1 NPLA1 字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AD%97%E9%9D%A2%E9%87%8F 。

@9.3.1.1 字符串字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F 。
**注释**
字符串字面量的类型同时是 NPLA 整体约定(@5.2) 和 NPLA 记号值(@6.8.1) 的约定的推论。

@9.3.1.2 NPLA1 数值字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC%E5%AD%97%E9%9D%A2%E9%87%8F 。

@9.3.1.3 NPLA1 扩展字面量：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%89%A9%E5%B1%95%E5%AD%97%E9%9D%A2%E9%87%8F 。
**原理**
#inert 和 #ignore 的值是 ValueToken 宿主类型唯一直接在对象语言中提供的宿主值，分别为 ValueToken::Unspecified 和 ValueToken::Ignore(@7.2.2)。
它们不具有单独的宿主类型（因此也不需要提供如 [RnRK] 的 inert? 和 ignore? 谓词）。

@9.3.2 函数合并：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6 。

@9.4 对象语言内存安全保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81 。

@9.4.1 对象语言基本内存安全保证：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81 。

@9.4.2 间接值实现规则：
基本规则参见 NPLA 间接值规则(@6.4.3) 和 NPLA1 引用值使用约定(@9.9.1.1) 。
环境引用(@5.6.2.2) 和引用值(@5.6.2.3) 在对象语言中可见。
环境总是通过环境引用在对象语言中被访问；被引用的环境对象(@6.11.1) 在对象语言中不可见。
引用持有者(@6.4.3.1) 及其访问操作仅在有限的不保证内存安全的上下文中引入，其它限制同 NPLA1 非内存安全项(@7.1.3.2) 。
被引入的引用持有者仅用于特定的内部表示和互操作，不是对象语言中的一等对象，仅包括：
在函数值中保留其它间接值的操作(@10.6.3) ；
非子列表引用的子有序对引用(@9.9.3.1) 中对最后一个元素的间接引用。

@9.4.3 不安全间接值访问：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%B4%E6%8E%A5%E5%80%BC%E8%AE%BF%E9%97%AE 。
当前实现中，由实现定义的其它不安全间接值访问包括未检查的不安全引用值(@6.8.3.1) 访问。
**注释**
实现可能检查不安全引用值(@6.8.3.1) 访问。

@9.4.3.1 无效的环境引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8 。

@9.4.3.2 无效的引用值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC 。
对互操作，未绑定对象(@9.7.4.3) 也可能引入悬空引用。
**注释**
关于通常的实现，参见 @8.4.5.4 。
另见可提供以引用标记字符结尾变体的函数(@11.2.1) 。
关于间接保留引用值，参见 @9.10.3 。

@9.4.3.3 其它无效的间接值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%85%B6%E5%AE%83%E6%97%A0%E6%95%88%E7%9A%84%E9%97%B4%E6%8E%A5%E5%80%BC 。

@9.4.4 保留间接值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC 。

@9.4.4.1 被保留的引用值的目标：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E7%9B%AE%E6%A0%87 。

@9.4.4.2 被保留的引用值的来源：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A2%AB%E4%BF%9D%E7%95%99%E7%9A%84%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E6%9D%A5%E6%BA%90 。

@9.4.4.3 保留间接值的操作：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C 。
**注释**
通过函数值保留参数中的间接值蕴含，以包含间接值作为间接值的目标的情形，典型地出现在构造器(@9.11.5) 中。

@9.4.4.4 保留间接值和内存安全：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E9%97%B4%E6%8E%A5%E5%80%BC%E5%92%8C%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8 。
间接值依赖无效的环境引用如引用值引用已被销毁的关联环境(@6.8.3.1) ，可能被实现检查。

@9.4.5 不安全操作：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C 。
这些操作(@4.4.5.1) 可能因不同理由在操作中或操作之后的程序中引入未定义行为：
保留可能无效的间接值(@9.4.4) ：
	保留可能无效的引用值(@9.4.3.2) ；
	保留可能无效的环境引用。
可能因为操作环境强引用(@6.11.1) 而引入循环引用(@9.9.1.2) ；
可能引入数据竞争(@5.6.4) ；
其它另行指定的可能引入未定义行为的操作。

@9.4.6 对象语言接口的安全保证机制：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6 。
对函数值(@4.5.3) 中涉及到的安全保证机制，参见作为函数值使用的间接值(@9.10.2) 。
**注释**
可由 NPLA1 参考环境(@10) 提供的不安全操作的具体约定参见不安全操作约定(@10.6) 和索引(@11.1) 。

@9.4.6.1 安全性附加证明：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%89%E5%85%A8%E6%80%A7%E9%99%84%E5%8A%A0%E8%AF%81%E6%98%8E 。

@9.5 诊断：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%AF%8A%E6%96%AD 。

@9.5.1 NPLA1 错误：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E9%94%99%E8%AF%AF 。
求值特定的函数应用引起错误由具体操作指定（参见 @11.2.1 ）。
关于求值算法实现步骤中的要求，另见 @6.10.5.3 。

@9.5.2 NPLA1 异常：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%BC%82%E5%B8%B8 。
其异常类型由 NPLA 提供，参见 @6.5 。
除非由宿主环境(@2.7.1)（包括 @9.5.3 中指定的情形）、对 TermNode(@6.2) 的操作内部实现或另行指定的来源，被抛出的异常对象的类型总是 NPL::NPLException(@6.5) 或其 public 派生类。
若语法错误(@9.5.1) 使用抛出异常实现，则异常对象的类型是 NPL::InvalidSyntax(@6.5) 或以其作为无歧义 public 基类的类。
除显式指定的情形，抛出的具体异常类型未指定。通常实现可根据接口的含义使用 @6.5 中最合适的异常。

@9.5.3 运行时错误条件：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E6%9D%A1%E4%BB%B6 。
若规约不符合资源耗尽条件，则在满足一般 TCO/PTC(@7.10) 保证和限制(@9.7.4) 时继续规约可能符合的资源耗尽条件应保证与继续规约的次数无关。

@9.5.4 错误检查：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5 。

@9.5.4.1 NPLA1 类型检查：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5 。
关于项的表示的对象，其中动态类型由值的表示(@6.3) 决定。

@9.6 NPLA1 外部表示：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%A4%96%E9%83%A8%E8%A1%A8%E7%A4%BA 。
**注释**
用户可自行通过调用 NPLA1 宿主语言中的实现的 API(@7) 扩展。

@9.6.1 文本形式：
除非另行指定，外部表示共享 NPLA 词法分析(@6.1.5) 兼容的字符串格式。另见 NPLA 约定(@5.2) 。
对和实现环境(@1.2.3) 交互的操作，当前使用外部表示附加约定如下：
对来自任意外部文件的文本流的输入和输出：
	首先忽略 UTF-8 BOM（若存在），不保证检查其余的内容相对使用的编码的有效性。
	和 @6.1.5 一致的方式使用二进制模式处理内容（如处理换行）。
若程序的实现逻辑依赖具体编码，处理相对编码非法的流内容的程序行为未指定。

@9.7 表达式语义：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E4%B9%89 。

@9.7.1 对象语言求值算法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95 。
在 REPL(@7.8) 中输入求值算法接受的语法形式之前，总是应用对象语言求值算法的变换。

@9.7.1.1 中缀语法：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%B8%AD%E7%BC%80%E8%AF%AD%E6%B3%95 。
关于函数 $sequence ，参见 @11.4.1 。
关于函数 list% ，参见 @11.3.5 。
关于中缀变换的实现，参见 @8.5 。
为避免可能引入非真合并子(@9.9.4) ，参照实现对分隔符的使用附加限制(@10.7.4) 。

@9.7.1.2 实现风格：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A3%8E%E6%A0%BC 。
NPL 仍提供 $quote(@11.4.1) 以避免用户可能的不必要的冗余代码；但参照实现限制使用(@10.7) 。

@9.7.2 值类别和类型：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%80%BC%E7%B1%BB%E5%88%AB%E5%92%8C%E7%B1%BB%E5%9E%8B 。
**注释** 相关 API 另见谓词(@10.5.2.1) 。

@9.7.3 绑定构造：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%BB%91%E5%AE%9A%E6%9E%84%E9%80%A0 。
**注释**
另见绑定支持 API(@7.7.4) 。

@9.7.3.1 强递归绑定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BC%BA%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A 。
未指定的内部表示是 NPLA1 中间值(@7.2.1) 。
当前实现的中间值是未指定的派生间接值(@6.4.3) 作为持有者的 A1::ContextHandler 值(@7.2.1) ，是对象语言中的非真合并子(@9.9.4) ，调用时总是引起错误(@9.5.1) 。

@9.7.3.2 参数转发：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91 。

@9.7.3.3 作用顺序(@4.4.3) ：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BD%9C%E7%94%A8%E9%A1%BA%E5%BA%8F 。

@9.7.4 一般 TCO/PTC(@7.10) 保证和限制：
NPLA1 使用 NPLA 的规则(@5.10.2) ，不保证在所有理论允许的情形下支持明确尾上下文以支持 PTC ：
调用位于尾上下文，当且仅当所有的对象都可被调整生存期而支持 PTC 。
满足实现行为(@4.1.3) 要求的前提下，实现可支持比这里的要求更多的 TCO 和 PTC 尾上下文。
**注释**
当前实现一般支持使用自由存储分配，以尽可能地避免宿主语言的未定义行为(@5.4) ：
其中，异步规约(@7.9) 实现使分配以环境(@6.11.1) 表示的活动记录失败时满足常规宿主资源分配要求(@5.4.1) 。
另见语法分析(@6.1.6) 和绑定支持 API(@7.7.4) 的类似的资源分配失败的约定。
具体实现方式参见一般实现策略(@7.10.1) 和部分实现限制(@7.11.6) 。
当前实现的规约（如 A1::Reduce(@7.4.4) ）直接递归规约子表达式支持的尾上下文(@4.4.8) 较少（详见 @9.7.4.1) ，和 Scheme 对大量特定的形式提供明确的尾上下文上的 PTC 保证不同。
和 Kernel 类似，这是由于缺少针对特定的特殊形式(@5.2) 的特设规则。
因为程序实现(@2.2.4) 等限制，当前设计和实现支持的合并子调用以外的上下文(@9.7.4.3) 较 Kernel 也更少，但实际涵盖范围却可能更大(@7.11.6) 。

@9.7.4.1 支持 PTC 的尾调用尾上下文：
当允许忽略非平凡析构(@7.10.4) 时，可以在尾上下文求值中进行 TCO 并支持 PTC 。
**注释** TCO 实现依赖 NPL_Impl_NPLA1_Enable_TCO(@7.10) 。
注意尾上下文中被求值的子表达式中的对象生存期可被调整(@5.10) ，是否调整和具体调整的方式未指定，不同的实现可能不同。
提供 PTC 保证的尾上下文和 Kernel 类似，当前仅包括 PTC 不改变可观察行为(@4.1.3) 时的：
	**注释** 应用子对参数的求值明确非 PTC 。
	函数调用(@4.5.3.1) 中，以对象语言中的合并子抽象引入的合并子(@9.9.4) 的调用。
		**注释** 合并子抽象包括 $vau(@11.4.1) 和 $lambda(@11.4.1) 等。
		**注释** 不保证互操作(@5.3) 引入的外部函数的调用。
	对 <body>(@9.2.2.1) 的求值。
	对 <expression-sequence>(@9.2.2.1) 中最后一个子表达式（若存在）的求值。
	由 <test>(@9.2.2.1) 控制或 <test>... 中最后一个被求值的子表达式（若存在）求值。
		**注释** 这包括 $if(@11.3.3) 、$and(@11.4.1) 和 $or(@11.4.1) 的最后的参数（若存在）的求值。
	函数 eval(@11.3.7) 、eval%(@11.3.7) 、$quote(@11.4.1) 、id(@11.4.1) 、idv(@11.4.1) 、eval-string(@12.2) 和 eval-string%(@12.2) 的调用中蕴含的求值或替换。
		**注释** 这不是作为参数的 <expression> 的求值。
	函数 apply(@11.4.1) 对 <applicative> 和 <object> 在 <environment> 或默认的动态环境中的应用(@4.5.3) 。
	函数 accl(@11.4.1) 、map-reverse(@11.4.3) 和 for-each-ltr(@11.4.3) 蕴含的在尾上下文中的递归调用。
	其它具体操作定义的求值。

@9.7.4.2 支持 PTC 的非调用尾上下文：
通过环境(@9.9.2) 支持的名称解析(@6.11.1) 的实现在符合嵌套调用安全的约定(@6.1.4.1) 。
名称解析可能是尾上下文。

@9.7.4.3 未绑定对象：
按尾上下文约定(@5.10) ，项上未被绑定到活动记录上的项中的对象生存期可提前结束。
实现 PTC 时被规约时替换结果的清理(@6.4.4) 若实现支持 TCO(@7.4) 且没有实现保存未绑定操作数引起这种情形。
当前通过参照实现环境(@10) 引入的合并子已经支持了保存操作数，但若互操作(@5.3) 没有保存操作数，则可能产生问题。
应注意合并子的参数绑定引用值(@7.7.3) 在同一个尾上下文求值引起清理导致悬空引用(@9.4.3.2) 破坏内存安全(@9.4) 。
**注释**
这里的求值典型地可通过显式求值引入。具体地，这主要包含使用引用值作为函数 eval 或 eval%(@11.3.7) 的参数的进行函数应用表达式求值的方式。
对合并子的直接的函数调用求值较不容易引起这种情形，因为 <body> 内使用的参数是被绑定的，其中临时对象(@5.8.5) 即便传递引用也会被转移值(@7.7.3) 。悬空引用通过其它方式（如在合并子的动态环境内显式求值）才被直接引入。
考虑在调用前使用总是不保留引用值(@9.10.3) 的 list 和 list* 而不是保留引用值(@9.10.3) 的 list% 和 list*%(@11.4.1) ，或单独调用 idv(@11.4.1) 提升被传递项中的值避免此类问题。

@9.7.4.4 限制影响：
在不保证支持 PTC 时，实现循环可控制结构的程序应注意避免无限递归。如以下 Kernel 程序：
($define! (f g) (list ($lambda (x) (g (- x 1))) ($lambda (x) (f (- x 1)))))
对应 NPLA1 程序（设 - 是减法，保证为纯函数(@4.5.3.1) 和全函数(@4.8.2) ）：
$def! (f g) (list ($lambda (x) (g (- x 1))) ($lambda (x) (f (- x 1))))
使用任意数值作为参数调用 f 时，若实现不支持 TCO ，以数值调用函数 f 或 g 可引起宿主语言的未定义行为（非异步规约(@7.9) ）或最终无法分配存储（异步规约）而不是保持不终止求值。
实际实现当前支持这个例子的 TCO 。

@9.8 对象语义：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E4%B9%89 。

@9.8.1 NPLA1 对象同一性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E5%90%8C%E4%B8%80%E6%80%A7 。

@9.8.2 NPLA1 子对象：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AD%90%E5%AF%B9%E8%B1%A1 。
**注释**
子对象的引用值可能使用具有非平凡非正规表示(@6.3.7.2) 的子对象引用项(@5.8.3.8) 而非通常的项引用(@5.8.3.8) 实现。
库可以使用函数的形式提供访问特定的子对象的操作，如访问器(@9.11.5) 。

@9.8.2.1 子对象访问约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%BA%A6%E5%AE%9A 。
这类访问操作包含访问器(@9.11.5) 和其它同时蕴含对象访问的操作。
**注释**
关于使用返回值转换的实现，如不保留引用值(@9.10.3) 的函数返回非引用值(@9.11.3) 。

@9.8.3 对象的修改和改变：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E5%8F%98 。
当前实现因为表示的限制，不保证修改非引用值间接值(@6.4.3.2) 表示的被引用对象(@4.2.6) 所在的项，而直接修改非引用值间接值自身。这包含通过 .& 等绑定结尾序列(@7.7.3.5) 得到子有序对引用(@9.9.3.1) 所在的项中以非引用值间接值作为值数据成员的情形(@7.7.3.5) 。

@9.8.3.1 赋值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%B5%8B%E5%80%BC 。
复制赋值在自赋值时的源操作数复制仍可能出错。使用基本提升操作(@6.9.4.1) 实现时，一般使用 NPL::LiftTermOrCopy 而不是检查自赋值的 NPL::LiftOtherOrCopy 。

@9.8.3.2 转移导致的修改：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BD%AC%E7%A7%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BF%AE%E6%94%B9 。

@9.8.4 驻留(interning) ：
出现在表达式中多个位置的值在实现中可共享一个对象作为内部表示。这个对象被驻留(interned) 。
因为子对象(@9.8.2) 允许通过引用值被直接修改(@9.8.3) ，驻留对象创建的共享可能影响可观察行为(@4.1.3) 。
因此兼容 NPLA1 语义的驻留要求排除可修改的操作(@9.8.3) ，且被驻留的值对应的对象的同一性(@4.1) 不被外部依赖。
当前实现不使用对象驻留，以简化存储对象的互操作(@5.6) 。
**注释**
驻留的对象在实现上共享存储，但仍区分同一性。
一般地，驻留仅适合不可变对象，或改变后提供不同副本（写时复制(@4.2.6.4.4) ）区分同一性的可变对象。
[RnRS] 等不可变的符号可被驻留，但没有特别要求。
[R7RS] 明确要求空列表的唯一性。和驻留一致，这可实现为全局共享对象。

@9.8.5 等价比较：
和 Kernel 不同，一些类型的对象若可修改(@9.8.3)（如环境(@9.9.2) ），不保证 eq? 和其它等价谓词(@11.3.2) 的比较结果等价。
但是，基于环境类(@6.11.1.2) 已约定宿主值的类型(@6.11.1.3) ，在对象语言中传递环境引用(@6.11.1) 不改变环境的这些等价性。
为了满足不依赖引用的一等对象(@4.1) ，区分引用和被引用的对象都作为一等实体，这是必要的。
一般地，谓词 eq? 用于判断两个参数对象的同一性(@4.1) 。

@9.8.6 无效化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%97%A0%E6%95%88%E5%8C%96 。

@9.8.7 类型分类：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB 。
**原理**
NPLA1 的类型判断谓词是一元谓词也避免对实现 map(@11.4.3) 等库函数的依赖。
**注释**
列表节点的实现的表示详见 @6.2.1 。

@9.9 NPLA1 对象语言数据结构：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84 。

@9.9.1 NPLA1 引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8 。
使用项引用（宿主类型为 NPL::TermReference ）表示（使用 TermNode 表示的）其它对象的引用，即引用值(@5.8.3) 。
按 NPL::TermReference 初始化时保存的引用来源可区分被引用的对象是否是左值。
不安全引用值(@6.8.3.1) 可以是有效的引用值，但运行时无法通过元数据验证其有效性。

@9.9.1.1 NPLA1 引用值使用约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%BC%95%E7%94%A8%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A 。
**注释**
可通过 NPLA API（如 NPL::IsBoundLValueTerm(@6.9.3) ）间接判断绑定的对象的是否为右值引用。
引入绑定的 API(@7.7.4) 可引入引用值(@5.8.3) 。已有的引用值的引用总是左值引用，否则是右值引用。
为实现求值(@7.8.2.1) ，A1::EvaluateIdentifier(@7.6.4) 保证名称表达式求值的结果是左值引用(@7.8.2.3) ，保证结果是左值(@5.8.1) 而不立即引入左值到右值转换(@5.8.4) 及复制对象。这和宿主语言的行为（除枚举器等个别不在此支持的宿主语言特性外）类似。
A1::EvaluateIdentifier 在求值访问引用值时，结果经过一次引用折叠(@5.8.3.6) 。

@9.9.1.2 循环引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8 。
**注释**
不显式访问环境的操作也可能引入循环引用（而引起未定义行为），例如：
$def! l ();
$def! l list% l;
典型实现中，具有所有权的循环引用可引起资源泄漏如内存泄漏(@5.6.5) ；无条件遍历访问循环引用子对象(@9.8.2) 的求值不具有终止保证(@4.8.2) 。
例如 NPLA1 参照实现环境(@10) 下求值以下表达式：
$let ((nenv () make-environment)) $set! nenv self nenv
可引起被捕获的环境中存储的对象无法释放。
能同时保证避免资源泄漏的实现引起一般意义上更根本的设计限制，因此不被使用。详见自引用数据结构和循环引用(@4.2.7) 。
此外，为了避免 $lambda 等引起不经意的循环引用误用，根据易预测性原则(@1.5.5.2) ，这些组合子的构造器(@9.11.5) 默认不使用强引用(@6.11.1) 作为静态环境。
若需保持静态环境的所有权，使用显式指定静态环境的构造器（如 $lambda/e ）和 lock-current-environment 等。
否则，容易引起循环引用，如以下表达式：
$def! f $lambda ()
会相当于当前设计的：
$def! f $lambda/e (() lock-current-environment)
此处锁定的当前环境(@6.11.3) 的强引用被作为闭包的一部分绑定到当前环境中，引起循环引用。
而求值当前设计中等价的：
$def! f $lambda/e (() get-current-environment)
不引起未定义行为。
同时，若访问悬空引用(@9.4.3.2) ，实现可利用 NPL::EnvironmentReference(@6.11.1.2) 在闭包中对引用进行检查，使用户无需像 lock-current-environment 一样特别关照 get-current-environment 引起的风险。

@9.9.1.3 自引用数据结构：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%87%AA%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84 。

@9.9.2 NPLA1 环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E7%8E%AF%E5%A2%83 。
关于表示，参见 @6.11.1 。
关于名称解析的实现，另见 @6.11.4.2 。

@9.9.2.1 隐藏环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%9A%90%E8%97%8F%E7%8E%AF%E5%A2%83 。

@9.9.2.2 新环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%96%B0%E7%8E%AF%E5%A2%83 。

@9.9.2.3 环境的宿主值和所有权：
和 Kernel 不同，环境可使用环境强引用和环境弱引用(@6.11.1) 蕴含不同的所有权。
环境对应多个宿主值类型(@6.11.1.3) 。
除非另行指定，使用不同宿主值类型的环境引用被视为相同类型的一等环境。
**注释**
另见开放类型映射(@5.3.1) 和相关的其它数据结构(@6.11.1) 。

@9.9.2.4 环境的稳定性：
环境对象符合默认的等价比较规则(@9.8.5) ，不提供不同等价谓词的结果一致性。
环境中的绑定的对象可以在引入后通过对象的引用(@9.9.1) 被修改(@9.8.3) 。
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7 。
**原理**
和 Kernel 不同，环境(@11.3.7) 和合并子操作(@11.3.8) 及基于这些操作的一些派生操作(@11.4) 的操作数树(@7.7.3) 构造时不检查其中的非列表项是否都为符号或 #ignore（而延迟到匹配时检查）；匹配时不检查符号重复；若形式参数中的符号重复，则绑定的目标未指定。
此外，NPLA1 提供单独的递归绑定符号(@5.5.3) 的机制，且明确支持在操作数中同时递归绑定之前未被绑定的多个符号(@9.7.3.1) 。
要求隐藏环境稳定允许实现共享隐藏环境作为父环境而提供标准环境(@11.4.1) 。
**注释**
环境对象符合默认的等价比较规则以及绑定的对象可通过引用被修改和 Kernel 不同。
关于要求的环境稳定性，存在推论：稳定环境中的同名被绑定实体(@5.7.1) 可证明排除通过对象的引用使其改变的副作用（如被修改）(@9.8.3) 或总是具有同一性(@4.1) 。

@9.9.2.5 环境生存期：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E7%94%9F%E5%AD%98%E6%9C%9F 。
**注释**
当前实现对环境引用(@6.11.1) 是 NPL::EnvironmentReference(@6.11.1.2) 的情形提供一定程度的检查(@6.1.2.1) ，这通过引用环境时检查 NPL::EnvironmentReference 中的弱引用是否可被实现。
特别地，这可针对在 vau 抽象(@8.4.5) 中捕获的静态环境。
如以下程序（假设 + 是可接受 2 个整数值的应用子）引起无效引用错误（抛出 NPL::InvalidReference 异常(@6.5) ）：
$def! addn ($lambda (a) ($lambda (n) + a n)); (addn 1) 2;
正确的参照实现为：
$def! addn ($lambda (a) ($lambda/e (() lock-current-environment) (n) + a n)); (addn 1) 2;
其它情形不受检查。
注意正常的操作不应有生存期错误。
引起这些错误时应已导致未定义行为如循环引用(@9.9.1.2) ，因此程序行为不应依赖检查(@8.4.5.2) 。

@9.9.2.6 环境中的绑定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A 。
基于环境对象的数据结构(@6.11.1)，环境绑定中的对象是环境对象的子对象(@9.8.2)。

@9.9.2.7 重绑定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%87%8D%E7%BB%91%E5%AE%9A 。
因为设计原则禁止无法避免的实现开销，这里的 NPLA 未定义行为没有检查而直接指定为无法满足保证所有权条件的未定义行为(@6.4.3.2)。
关于无效化，参见 @9.8.6 。
**注释**
类似赋值(@9.8.3.1) ，重绑定不保证子对象的同一性不被改变；子对象的引用仍可能被重绑定无效化(@9.8.6) 。

@9.9.2.8 被绑定对象的值和可观察行为：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%A2%AB%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E5%92%8C%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA 。

@9.9.2.9 冻结：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%86%BB%E7%BB%93 。
关于对象语言接口的安全保证机制，参见 @9.4.6 。
**原理**
同 [RnRK] ，环境中的绑定不确保可完全枚举（参见其中 $bind? 的原理），所以和 ECMAScript 的惯用法不同，一般无法在实用上确保通过嵌套遍历环境子对象的实现环境的深度冻结。
和 [RnRS] 及 [RnRK] 不同，NPLA1 对象语言不仅有 set-car! 和 set-cdr! 这类针对列表对象的改变操作(@4.1.4.2) ，还有修改一等对象引用值的被引用对象的操作（参见列表基本操作(@11.3.5) 和基本派生操作(@11.4.1) ）。
这意味着创建标准环境(@11.4.1) 不仅依赖隐藏环境中的绑定有效稳定性(@9.9.3.7) ，还依赖值稳定性(@9.9.3.8) 。
因此，隐藏环境的对象的引用值是不可修改的。
可修改的对象若通过隐藏环境中的绑定提供，环境可为在隐藏环境提供的不被冻结的环境子对象，或其中的合并子返回的值。

@9.9.3 NPLA1 广义列表：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%B9%BF%E4%B9%89%E5%88%97%E8%A1%A8 。
关于真列表，另见 @6.2.1 。
关于非真列表，另见 @6.3.7.1 。
表示列表的宿主类型为 TermNode(@6.2) 。
真列表直接被表示为子项元素的列表节点的序列(@6.2.1) 。非真列表同时使用值数据成员构成其表示(@6.3.7.1) 。
**注释**
广义列表是容器(@9.11.5) 。
列表的元素以 TermNode 的子项表示。
利用 TermNode 中可选的值数据成员(@6.2) ，列表节点可以退化为非列表的值的表示；列表自身也可作为其它列表的节点。列表节点的实现的表示详见 @6.2.1 。

@9.9.3.1 有序对的子对象和子对象引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%9C%89%E5%BA%8F%E5%AF%B9%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8 。
关于子对象被修改，参见 @9.8.3 。
关于子对象被转移，参见 @9.8.3.2 。
**原理**
有序对的元素以 TermNode 的子项及值数据成员表示。其中，列表的元素以 TermNode 的子项表示。
有序对对表示元素的节点所有权由 TermNode 的性质得到。
NPLA1 支持的真列表和非真列表内部表示带来对元素引用的一些限制：列表的引用(@9.9.1) 只限引用完整的列表对象，而不引用部分列表（如 cons 的组成部分）。
因此，引入有序对的子对象的引用可涉及具有非平凡非正规表示(@6.3.7.2) 的子对象引用(@5.8.3.1) 。
子列表引用是这种情形的子对象引用。

@9.9.4 NPLA1 合并子：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%90%88%E5%B9%B6%E5%AD%90 。
因为包装操作(@4.5.3.2) 不符合 TCO/PTC 的条件(@9.7.4) ，包装操作允许具有附加的开销。包装数使用的宿主类型的上限(@7.6.1.1) 足以保证修改包装数的开销严格不大于直接实现。
合并子的调用的实现满足嵌套调用安全(@6.1.4.1) 。合并子内部的本机实现(@5.3) 需自行保证嵌套调用安全。
**原理**
关于合并子嵌套异常安全的支持，参见相关原理(@6.1.4.1) 的讨论。
**注释**
可能直接引入非真合并子的 API 包括项变换 API (@7.6.3) 。

@9.9.5 NPLA1 数值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E6%95%B0%E5%80%BC 。
**注释**
和 Kernel 不同，当前 NPLA1 不提供依赖数值的接口（用于描述列表长度等）；核心库函数(@11.4.3) 的实现也不需要依赖数值。

@9.10 函数的间接值使用约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%BF%E7%94%A8%E7%BA%A6%E5%AE%9A 。
引入函数时需注意避免未绑定对象(@9.7.4.3) 等关于环境生存期的问题，以维护内存安全(@9.4) ；另见绑定操作(@7.7.3) 。
关于实现，参见间接值实现规则(@9.4.2) 。

@9.10.1 间接值作为实际参数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%97%B4%E6%8E%A5%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0 。
**注释**
左值到右值转换只作用在间接值上，不蕴含对关联对象(@6.4.3) 的子对象(@9.8.2) 的转换。
例如，对列表元素是引用值的情形，提升项不是递归的(@6.9.4.3)（另见参数绑定(@8.4.5.3) 实现中的类似说明）。
其它另行指定的例子如 @11.2.2 。
另见实际参数约定(@10.4.3) 和函数值转发(@9.11.4) 。

@9.10.2 间接值作为函数值：
**注释**
等价返回值转换(@5.8.4.2) 的实现可使用消除引用值的本机实现(@8.1.2) 。

@9.10.3 保留引用值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E5%BC%95%E7%94%A8%E5%80%BC 。
函数是否保留引用值以及保留引用值是否被折叠的要求，参见常规函数约定(@10.4) 、函数名称约定(@10.5) 和 NPLA1 参照实现环境(@10) 中的函数名称的约定(@11.2.2) 。
考虑内存安全时，因无法保证如引用值通过关联的环境(@6.8.3.1) 追溯被引用对象(@4.2.6) 类似的机制可用，环境引用(@5.6.2.2) 外的非引用值间接值(@6.4.3.2) 视为不具有内存安全保证(@9.4.3) 。
间接保留引用值可包含部分直接转发引用值(@9.11.2) 的情形。包含这种情形的操作不因此被视为直接保留引用值，即便部分引用通过直接转发引用值被保留。这保证以上两个子类不相交。
直接保留引用值覆盖常规函数约定的实际参数约定(@10.4.3) ，指定参数不隐含左值到右值转换(@5.8.4) ，可按引用值直接访问。

@9.10.4 保留环境引用：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BF%9D%E7%95%99%E7%8E%AF%E5%A2%83%E5%BC%95%E7%94%A8 。
**注释**
关于只允许通过环境引用在对象语言中访问环境对象及其子对象，参见间接值实现规则(@9.4.2) 。

@9.11 函数参数和函数值传递约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%BA%A6%E5%AE%9A 。

@9.11.1 传递非引用值参数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E4%BC%A0%E9%80%92%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0 。

@9.11.2 函数参数转发：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E5%8F%91 。

@9.11.3 返回非引用值：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BF%94%E5%9B%9E%E9%9D%9E%E5%BC%95%E7%94%A8%E5%80%BC 。
通过补充约定(@10.5) ，返回非引用值可实现操作总是具有非引用值结果(@9.10.2) ：
若初始化函数的初值符经过至多一次折叠(@10.5.3.1) 即可消除(@5.8.3.4) 引用值，返回非引用值保证函数值总

@9.11.4 函数值转发：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E8%BD%AC%E5%8F%91 。
关于标准库的相关函数，参见 @11.2.2.4 。

@9.11.5 创建和访问对象的函数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0 。

@9.11.6 转发参数或返回值的实现：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0 。
特别地，被转发的函数值若需支持 PTC(@9.7.4.1) ，则不能作为操作使用的实际参数，以避免不满足在尾上下文(@4.4.8) 求值的条件。

@9.12 实现注记：
NPLA1 中提供的一些名称以及实现架构和 klisp 相似，且都为 AST 解释器，但实现方式略不同。
作为比较实现的备注，以下是 klisp 中（除当前不支持的 [RnRK] 特性外）相较 NPLA1 的一些主要实现差异：
	使用 GC ，被 GC 管理的对象都支持跟踪回收，不特别处理 TCO（另见 TCO 实现(@7.11.6) ）。
	使用紧凑的（类似 lua ）的对象布局，依赖体系结构的数据模型假设（只实现了 32 位）。
	使用 C 函数实现规约。
		使用 setjmp/longjmp 恢复跳板中的上下文。
		支持 FFI 。
		总是支持异步规约(@7.9) ，没有可选的类似动作内联(@7.9.4) 的机制。
		使用 klisp_CFunction 而不是规约动作(@6.12.1) 的目标函数(@6.2) 作为本机函数进行调用。
		在上下文中支持当前续延（和 NPLA 当前动作对应的数据结构被拆分为 next_function 等 C 数据结构）。
			下一求值项(@7.4.3) 直接以对象语言的值（表示为 TValue ）保存（对象语言的值总是引用）为上下文中的 next_value 。
			包含下一求值对象 next_obj 以维护不被 GC 过早回收。
			包含下一环境 next_env 指定是否正进行合并子调用(@4.5.3.2) 。
			本机调用中不指定下一求值项（ klisp_CFunction 没有 TValue 参数），而非 A1::ContextHandler(@7.6.1) 和 A1::Continuation(@7.4.2) 对所有需要依赖下一求值项的实现提供不同层次的封装。
			一等续延依赖 GC 而不维护对本机函数资源的所有权。
			直接使用一等续延的表示 Continuation 作为内部使用的非一等续延的表示且共享相同的规约实现，而非 A1::Continuation 在特定的捕获操作(@8.4.10) 中仍需在其蕴含的 A1::ContextHandler 的目标函数中添加特定的逻辑。
				**注释** 这些逻辑实现一次调用检查(@7.10.5.4) ，并确保按引用捕获规约动作，和非一等续延的实现可能直接具有目标函数的所有权不同。
		使用当前续延的应用（ kapply_cc ，非对象语言的 apply-continuation ）和合并子调用操作（如 ktail_call ）等修改上下文的操作实现异步调用(@6.11.3) 。
			通常不使用组合到当前动作的调用中的（可能同步调用的）函数调用的本机实现。
			通常不单独设置下一求值项。
		使用 ktail_call 和 ktail_eval 使规约函数的实现被调用。
			不使用宿主语言中的函数应用，因为使用的数据结构不是 C 函数类型 klisp_CFunction ，且宿主语言不支持这些类型的函数应用。
			首先区分续延和操作子调用，而不是在规约中按需单独设置下一求值项和环境。
			对操作子调用，首先以形式参数树(@7.7.3) 作为下一求值项，使用异步规约而不是在具体规约实现内部单独实现的其它机制维护嵌套调用安全性(@6.1.4.1) 。
		使用 C 函数调用产生对象语言错误，不直接使用和支持本机的其它机制（如 setjmp/longjmp 和 C++ 异常）的交互。
	使用更多的对象语言机制（尽管在 [RnRK] 中没有要求）：
		使用对象语言机制实现词法处理。
			源代码中的位置被作为对象语言的有序对。
		使用对象语言机制实现绑定。
			使用 pass-value 续延。
	若干诊断消息(@1.2.4) 具有不同的实现方式：
		在全局上下文中支持名称表，包括源信息(@7.5.2) 支持。
		具有若干不同的续延名称(@7.11.7) 。
		抛出异常，引起的错误消息中包含 *ERROR* 。
		错误消息中，输出的续延序列不包含当前的续延（其中的对象的源信息出现在 *ERROR* 行中）。
此外 klisp 还有一些在 NPLA1 参照实现中不存在的实现缺陷：
	不支持多重包装调用(@7.11.4) 。
	特定上下文的 PTC 失败(@7.11.6) 。

@10 NPLA1 参照实现环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%8F%82%E7%85%A7%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83 。
关于 NPLA1 参照实现环境的实现约定，另见实体实现的限制(@10.7) 。
以下各章的实现中的 C++ 名称和项目模块命名空间的使用同 @7 。

@10.1 NPLA1 初始求值环境：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%88%9D%E5%A7%8B%E6%B1%82%E5%80%BC%E7%8E%AF%E5%A2%83 。
上述忽略的特性可由派生实现补充（如以类似特性描述(@11.4) 的形式）。

@10.1.1 NPLA1 实现环境初始化：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#npla1-%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96 。
初始化通过 Forms::LoadGroundContext(@8.5.2) 实现。

@10.1.2 导入符号：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AF%BC%E5%85%A5%E7%AC%A6%E5%8F%B7 。

@10.2 模块：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97 。
关于参照实现扩展环境，参见 @12 。

@10.2.1 标准库模块的初始化和加载：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%8A%A0%E8%BD%BD 。
关于标准环境，参见 @11.4.1 。
替代的检查如通过 eq?(@11.3.2) 。

@10.2.2 模块稳定性：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A8%A1%E5%9D%97%E7%A8%B3%E5%AE%9A%E6%80%A7 。
用户程序应自行保证加载的其它模块具有足够的生存期，以避免访问悬空引用(@9.4.3.2) 导致的未定义行为，特别是使用在环境中保留引用值的操作(@10.6.4) 的情形。
**注释**
另见可能破坏环境稳定性的操作(@10.6.7) 。

@10.3 库接口约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E7%BA%A6%E5%AE%9A 。
关于 NPLA1 根环境特性，参见 @11 。

@10.3.1 库接口实体：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BA%93%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BD%93 。
这些操作中的大部分具有特定的名称，符合函数名称约定(@10.5) ；其分类详见函数分类(@11.2) 。

@10.3.2 库特性实现分类：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%BA%93%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%88%86%E7%B1%BB 。
实现加载本文档要求的模块的本机 API 入口参见 @8.5 。
**注释**
基本的和派生的的区分同 NPLA1 实现的支持(@8.1) 。

@10.3.3 标准库：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%A0%87%E5%87%86%E5%BA%93 。
关于参照实现扩展环境，参见 @12 。

@10.3.4 扩展库：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E6%89%A9%E5%B1%95%E5%BA%93 。
扩展库如 SHBuild 实现环境(@13) 。

@10.4 常规函数约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%E7%BA%A6%E5%AE%9A
**注释**
另见参照实现的实现函数约定(@10.7.3.1) 。

@10.4.2 函数值约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%87%BD%E6%95%B0%E5%80%BC%E7%BA%A6%E5%AE%9A 。
**注释** 关于引用值是否被折叠的操作分类，详见可提供以引用标记字符结尾变体的操作(@10.5.4) 。

@10.4.3 实际参数约定：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E7%BA%A6%E5%AE%9A 。

@10.4.4 错误处理：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86 。

@10.4.5 非常规函数：
参见 https://frankhb.github.io/YSLib-book/Features/NPL.zh-CN.html#%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0 。

@10.5 函数名称约定：
除非另行指定，以指定名称的函数表示具有名称的操作时，其命名由本节的规则约定。

@10.5.1 前缀：
同 [RnRK] ，确定为求值为操作子的函数名以 $ 作为命名的前缀。

@10.5.2 后缀：
函数名的最后的字符表示函数预期满足特定的约束或具有特定的目的。
除去本节后缀，以引用标记字符(@7.7.3.4) 结尾的表示涉及引用的操作，参见以下(@10.5.3) 约定。

@10.5.2.1 谓词：
类似 [RnRS] 和 [RnRK] ，谓词的名称使用 ? 结尾。
NPLA1 中谓词是返回类型为 <boolean> 的函数。
除非另行指定，以下引入的对象语言中的谓词对应的函数调用的求值是纯求值(@4.4.4) 。
为提供库的描述，约定以下谓词的典型实例：
	类型谓词(@4.7.6) ：接受一个 <object> 参数，判断参数是特定的类型的对象。
		调用这些类型谓词不引起错误。
		仅当参数指定的对象具有对应类型时结果是 #t 。
		除非另行指定，这些类型谓词忽略值类别的差异。
	等价谓词(@4.2.1) ：接受两个参数，判断参数是否属于同一个等价类。
因为 <boolean> 是 <test> 的子类型(@9.5.4.1) ，按照返回值为 <test> 的函数可在不严格要求 <boolean> 的上下文中起类似的作用，视为广义谓词(general predicate) 。
谓词是广义谓词的子类型。
**注释**
大多数上下文接受 <test> 而不严格要求 <boolean> 。这和 [RnRK] 不同(@9.2.2.2) 。
大多数类型谓词判断的类型一般同文法约定(@9.2) ，而无关值类别(@9.7.2) 。
以具名的函数提供的类型谓词，其函数名称通常和文法指定的类型(@9.2.2) 对应。
引起错误可具有副作用，其求值不保证是纯求值。
广义谓词不使用后缀 ? 。另见 [RnRK] 6.1.2 关于 $and? 的原理及 [R6RS-Rationale] 15.1 。

@10.5.2.2 赋值操作：
修改(@9.8.3) 一个对象而不要求第一参数是引用值且不改变被赋值对象类型的赋值操作(@9.8.3.1) 以 <- 结尾。
这通常和宿主语言的赋值操作对应，可能有附加的副作用而不是简单地替换值。

@10.5.2.3 视为改变操作的修改操作：
函数名除 <- 结尾外的操作中，目的是（不直接通过求值操作数或其子表达式产生的副作用的）修改(@9.8.3) 的函数的名称使用 ! 结尾。
类似 Kernel ，可变管理状态(@9.8.3) 的改变不需要指示可修改；此外，类似地，不改变可观察行为(@4.1.3) 的隐藏状态的修改不属于上述修改。
类似 [RnRS] 和 [RnRK] ，这类操作同时是改变操作(@9.8.3) 。
一些其它情形下，特定的函数不被视为改变操作但其调用仍可能产生副作用，这样的函数名不要求带有 ! 后缀：
和 [RnRK] 类似，直接求值操作数、其子表达式关联的对象可能产生副作用，如 load(@12.5) ；
和 Kernel 不同，一些操作包含使操作数指称或引用的对象的值有效但未指定(@5.6.3) 的修改，如隐式的转移操作(@9.8.3.2) 。
带有 ! 后缀的函数的调用的求值可能因为不同的操作数的影响，不一定总是具有能视为修改的副作用，可能不改变任何对象：
当通过操作数指定的条件确定是否修改时；
当通过操作数确定被修改的对象时；
当通过操作数确定引起修改的对象时（如 $provide! 和 $import(@11.4.1) 可能指定空符号列表）。
和 [RnRS] 相同但和使用可用谓词 inert? 判断的惰性(inert) 值的 [RnRK] 不同，带有 ! 后缀的函数名的调用结果是没有附加限制条件的未指定值(@7.2.2) 。
这些未指定值的类型未指定，因此用于修改的函数可能返回 A1::ValueToken::Unspecified(@7.2.2) 外的其它值；但应满足实现限制(@10.7) 。
作为一等实体的未指定值和 Kernel 类似，仍为 #inert(@9.3.1.3) ，但不提供谓词确定其未指定。
**注释** 惰性值仍可通过比较确定相等性。

@10.5.3 引用标记字符的函数名后缀：
一些操作以结尾引用标记字符(@7.7.3.4) 和不以引用标记字符结尾的名称提供多个变体。其中不含结尾的引用标记字符的表示操作的结果(@10.3.1) 不是引用值，要求按值传递(@8.4.5.4) 。
其它一些操作可能只提供以 % 结尾的变体。
不使用引用标记字符的函数及其函数值时，不因引入引用值违反内存安全(@9.4) 。这允许通过避免公开带有引用标记字符后缀的操作提供一个内存安全的子集，以在派生实现对语言进行裁剪。
为满足适用性(@1.5.5.2) ，同时考虑避免误用和允许使用引用避免复制，对一些操作显式使用以 % 或 & 结尾的函数名称以得到特别关注。
名称以引用标记字符结尾的操作属于以下分类之一：
可能直接保留引用值的操作：结果(@4.4.5.1) 及作用(@4.4.5.1) 依赖实际参数（需要时经过隐含的左值到右值转换(@7.7.3.4) ）的值；
可能间接保留引用值的操作：可涉及不同的环境，结果和作用依赖实际参数（需要时经过隐含的左值到右值转换(@7.7.3.4) ）在这些环境中被求值后确定。
对可能在函数值中间接保留引用值的操作，以 % 结尾表示对应的函数返回时不要求返回非引用值(@9.10.2) 。
其它可能在函数值中直接保留引用值的提供不同引用标记字符的多个变体的操作：
以 % 结尾表示函数使用不进行左值到右值转换(@5.8.4) 的折叠(@5.8.3.6) 的引用值参数，或返回折叠的引用值；
以 & 结尾表示函数使用不进行左值到右值转换的折叠的引用值参数，或返回折叠的引用值；
以 @ 结尾表示函数使用不进行左值到右值转换的未折叠的引用值参数，或返回未折叠的引用值。
以上引用值参数的使用指以依赖这些参数的方式构成函数的调用结果和/或决定产生的相应的副作用；返回的引用值来自引用值参数（若存在）。
**原理**
因为语义相关，结尾引用标记字符使用和绑定的引用标记字符(@7.7.3.4) 相同的字符，但不复用具体规则。
尽管设计时没有参照，使用函数结尾的引用标记字符和其它一些语言的类似特性的使用惯例也一致，如 PHP 的 function & 语法：
https://www.php.net/references.return
**注释**
按这些规则，以 % 结尾的操作在取折叠的引用值时，可能同时实现被引用对象(@4.2.6) 的转发。这相当于被访问的被引用对象作为宿主语言的 std::forward 的参数后的调用结果作为操作的结果，但此处一般仍然保证支持 PTC(@9.7.4) 。
以 & 结尾的操作取得的折叠的引用值可能是唯一引用。

@10.5.3.1 引用折叠：
取得折叠的引用值的默认约定同间接值实现规则(@9.4.2) 蕴含的 NPLA1 默认规则(@9.9.1.1) 。
以上函数调用结果中：
	折叠的引用值对调用时引入的引用值（不论是否来自参数）有效。
	除非另行指定，不对同一个对象引用折叠多次。
	**注释** 这些规则不保证结果是完全折叠的引用值(@5.8.3.3) 。返回折叠引用值的函数可因未完全折叠的引用值参数等返回未折叠的引用值。
这允许函数的内部实现引入一次引用值时，对来自每个参数的引用值至多只需要实现一次折叠。
推论：若参数都不是未折叠的引用值，调用不以 @ 结尾的函数不引入未折叠的引用值。
若指定的操作按不同操作数可涉及或不涉及和当前不同环境下的求值，提供不保留引用值和保留引用值的多个变体的操作以便保证内存安全，包括 @11.2.1 和 @11.2.2 指定的操作。

@10.5.3.2 与内存安全的关系：
利用区分引用标记字符结尾的操作，可指定具体关于具体操作的对象语言接口的安全保证机制(@9.4.6) 。
结尾的引用标记字符用于强调无法总是保证内存安全的危险操作(@1.5.5.2) 。
不带有引用标记字符结尾的操作通过避免保留引用值(@9.10.3) 提供一定的内存安全保证(@9.4) ，而带有引用标记字符结尾的操作较容易引起注意。
这符合易预测性(@1.5.5.2.1) 。
一个典型例子是在函数中返回标识符求值(@9.7.1) 的表达式：
标识符求值后指称左值引用值(@7.8.2) ，这个引用值的有效性依赖合并子调用(@4.5.3.2) 时创建的新环境(@9.9.2) 的可被访问；
这个环境在调用后通常被销毁，若使用带有引用标记字符结尾的操作关于对应的函数返回引用值的语义，在函数值中保留引用值，返回为悬空引用(@9.4.3.2) ，容易误用。
一般地，仅在明确需要引用值时使用引用标记字符结尾的操作，而避免返回悬空引用（这类似宿主语言函数的 auto 而非 auto&& 的返回类型，但宿主语言中返回非引用类型的表达式两者含义不同）。

@10.5.3.3 保留引用值(@9.10.3) 的约定：
可能直接保留引用值(@9.10.3) 的操作中，不带有引用标记字符的操作传递非引用值参数(@9.11.1) ，其它函数转发参数(@9.11.2) 。
可能直接保留引用值的操作包括容器构造器或访问器(@9.11.5) ，以及可能使对象中包含引用值(@9.4.4.1) 的修改操作(@9.8.3) 。
这些操作的结果(@10.3.1) 或产生的副作用完全由实际参数（根据是否存在引用标记字符 % 指定是否不经过隐含的左值到右值转换）的值确定。
其中，带有引用标记字符结尾的操作是直接保留引用值操作。
容器构造器可在元素保留参数的引用值。作为结果的容器总是作为非引用值返回(@9.10.2) ，即在结果中保留参数的引用值。
**原理**
以上操作是否确定地保留引用值在一些情形容易证明附加调用安全(@9.4.6.1) ，此时可放宽安全子集(@10.6.8) 的条件确保安全性；在此不作要求。
对构造器及部分修改操作区分引用标记字符结尾可强调一些非预期保留引用值的容易误用情形：
尽管总是返回非引用值。
因转发参数而被保留的引用值(@9.10.3) 不会被返回值转换(@9.10.2) 或类似的操作影响，在构造的容器对象作为非引用值返回时，仍会保留引用值。
（对应宿主语言中，可有更显著的差异，如构造器对应的 std::tuple 的 std::make_tuple 和 std::forward_as_tuple 。）

@10.5.4 可提供以引用标记字符结尾变体的操作：
部分操作使用以引用标记字符结尾的函数名(@10.5.3) 。
可提供不同变体的操作被严格限制，以避免过度区分造成在使用上不必要的复杂性。

@10.5.4.1 可能使结果包含引用值的容器构造器：
容器构造器作为包括典型的构造器，可提供不同的变体（或其中之一）：
不在函数值中保留引用值，实际参数发生左值到右值转换作为容器的元素，这减少误用悬空引用(@9.4.3.2) 的可能性；
在函数值中保留引用值，实际参数不发生左值到右值转换而直接作为容器的元素，是不安全操作(@9.4.5) ，但可以确保构造的对象中包含参数指定的引用值。
（当只提供没有结尾引用标记字符对应名称的操作时，不需要满足以下(@10.5.5) 的约定。）
**注释**
在结果中保留参数的引用值的容器构造器(@10.5.3.3) 可能保留可能无效的间接值(@9.4.4) 而属于不安全操作。

@10.5.4.2 可能使结果包含引用值的容器元素访问器：
其中，带有引用标记字符结尾的操作是直接保留引用值(@9.10.3) 操作；
函数名不带有标记字符结尾的访问器属于参数转发操作(@9.11.2) 和函数值转发操作(@9.11.4) 。

@10.5.4.3 可能使对象中包含引用值的修改操作(@9.8.3) ：
修改对象或对象的子对象(@9.8.2) 可无效化引用值(@5.6.2) 而影响内存安全。
对可能保留参数中的引用值(@9.4.4.2) 的操作，内存安全也依赖这些操作的指定修改后的值的内存安全性。
在判定内存安全(@9.4) 的意义上，以下操作的所有参数都可能是被保留的间接值(@9.4.4) ：
简单赋值(simple assignment)（包含于赋值操作(@9.8.3.1) ）；
列表元素改变器(mutator) 。
修改的结果由实际参数（必要时经过隐含的左值到右值转换(@10.4.3) ）的值确定。
以上操作都要求检查表示被修改的参数是左值。
以上操作中，带有引用标记字符结尾的操作在对象中直接保留引用值(@9.10.3) 。

@10.5.4.4 可能间接保留引用值(@9.10.3) 的操作：
一些操作可涉及不同的环境，参数在这些环境中被求值可能得到引用值。
这些操作包括求值为操作子的以下函数：
以求值 <body> 作为尾上下文(@4.4.8) 的操作(@9.7.4.1) ；
以求值 <expression> 或视为 <expression> 的 <object>（及可能发生的返回值转换(@9.10.2) ）作为唯一作用的函数。
以上操作中，带有引用标记字符结尾的操作是间接保留引用值操作，表示求值结果不要求按值传递并可返回引用值。
不提供函数值转发(@9.11.4) 的形式，因为：
选用经过返回值转换(@5.8.4.2) 得到的值已可保证避免求值结果中的悬空引用(@9.4.3.2) ；
直接返回可能是引用值的值具有更简明直观的语义；
若需转发，可直接在被求值的表达式中显式构造(@9.11.6) ；
不需要假设求值结果初值符(@5.8.2) 作为函数值转发依据的参数。
和此处直接在参数中给出被求值表达式不同，应用子中的一些求值的操作不属于上述操作，而不提供结尾引用标记字符对应名称的操作(@10.5.5.5) 。

@10.5.5 不提供结尾引用标记字符对应名称的操作：
其它操作不使用以引用标记字符结尾的函数名(@10.5.3) 。
若这些操作的结果直接来自操作数或其子对象(@9.8.2)（和以 % 结尾操作的情形类似），则：
	可保留参数中的引用值(@9.4.4.2) 并在函数值中保留(@9.4.4.1) ；
	不提供避免保留值的对应操作，或仅在此基础上提供总是包含等价返回值转换(@9.10.2) 的对应操作。
否则，这些操作不具有引用值结果。
**注释** 部分操作的结果直接来自实际参数。此时，若不具有引用值结果，则隐含左值到右值转换(@10.4.3) 。
这些操作不会使用临时对象(@5.8.5) 作为环境，所以不需要使用以引用标记字符结尾的变体要求注意区分返回引用值而避免误用。
因此，不提供区分涉及引用的变体，这也使接口设计更清晰。
这些操作包括以下小节的情形。
部分操作涉及参数转发(@9.11.2) 和函数值转发(@9.11.4) 。这些操作不包含可提供以引用标记字符结尾变体的操作中的个别变体(@10.5.4) 。
另见具体函数分类(@11.2.2) 。
其它不提供结尾引用标记字符对应名称的操作暂不保证支持保留引用值。
部分操作的内存安全性和可提供以引用标记字符结尾变体的操作(@10.5.4) 类似，也是在函数值中保留引用值的不安全操作，但仅在引用值参数被保留且以此访问被引用对象(@4.2.6) 时体现。
这包括直接保留引用值和间接保留引用值(@9.10.3) 的不同情形。
除可直接以引用值作为结果的操作(@10.5.5.1) 和其它节的操作不相交，以下分类对操作的参数和函数值分别约定，可能相交。

@10.5.5.1 可直接以引用值作为结果的操作：
一些求值为操作子提供的函数选取特定的参数进行求值，作为控制操作。
操作数中被求值的参数直接决定是否为引用部分操作直接返回引用值。
被求值的 <test> 进行左值到右值转换，其它被求值的参数不进行左值到右值转换，调用者需负责决定是否求值其它参数。
这类似宿主语言中参数传递和返回 auto&& 类型。

@10.5.5.2 不以引用值作为结果的操作：
部分操作类似容器构造器(@10.5.4.1) 保证返回非引用值(@9.11.3) ，但并非直接以参数实现决定函数值：
若非构造器的操作总是返回列表和其它对元素具有所有权的容器对象，返回的对象总是按值传递。
为简化接口以及满足其它分类（如直接参数转发操作(@10.5.5.3) ），不提供不保留引用值的操作。
和提供不同的变体的作为构造器的操作不同，此处的情形的结果可能包含引用值（和以 % 结尾构造器的情形类似）。
若需要排除通过参数引入的引用值，应进行适当处理使参数中不含有会使这些操作引入引用值的构造。
类似保留引用值的容器构造器，这些操作可在结果中保留参数的引用值(@10.5.3.3) 。

@10.5.5.3 直接参数转发操作：
部分不带有引用标记字符的参数转发操作(@9.11.2) 是可能直接保留引用值的操作(@9.10.3) ，称为直接参数转发操作。
函数名不使用引用标记字符，和可直接保留引用值的函数名(@10.5.4) 使用引用标记字符不一致：
本节约定的函数和可直接保留引用值的函数名中带有 % 结尾的函数同属参数转发操作，但后者同时有不带有引用标记字符的变体；
本节不约定和可直接保留引用值的函数名中不带有引用标记字符结尾的函数对应的操作。
这种不一致（和函数值转发操作(@10.5.5.4) 不同）是预期的特性：
和可直接保留引用值的操作不同：
	这些操作并非用于构造对参数具有所有权的对象，不适合提供不保留引用值的操作；
	这些操作并非用于取子对象(@9.8.2) ，返回值不一定是引用值，和具体操作相关，不适合使用引用标记字符区分；
为简化接口及满足其它分类（如不以引用值作为结果的操作(@10.5.5.2) ），不适合提供不保留引用值的操作。
本节约定的函数对引用标记字符的使用和可提供以引用标记字符结尾变体的操作(@10.5.4) 的函数名的使用不一致，含义相当于前者的结尾的 % 。
以下的函数值转发操作(@10.5.5.4) 同时也是直接参数转发操作。
其它函数的参数传递的一般规则参见引用值作为实际参数(@9.10.1) 、函数参数和函数值传递约定(@9.11) 和实际参数约定(@10.4.3) 。

@10.5.5.4 函数值转发操作：
若其它情形确需非转发操作取得引用值，可使用带有 % 或 & 结尾的操作(@10.5.4) 及可直接以引用值作为结果的操作(@10.5.5.1) 替代实现。
本节约定的函数不使用引用标记字符，和容器元素访问器(@10.5.4.2) 的函数名不使用引用标记字符一致：
本节约定的函数和上述容器元素访问器的函数名中不带有引用标记字符结尾的函数同属函数值转发操作，但后者同时有带有引用标记字符的变体。
**原理**
和容器构造器(@10.5.4.1) 引入引用值的情形不同，不带有后缀 % 相对不容易引起误用，因为返回值保留的引用可以继续被返回值转换(@9.10.2) 影响。
例如，使用保证返回非引用值的涉及环境中求值的操作(@10.5.4.4) ，引用值会在引用的对象生存期结束前被返回值转换而不影响内存安全。

@10.5.5.5 可能间接保留引用值的操作：
类似可提供以引用标记字符结尾变体的对应操作(@10.5.4.4) ，部分不带有引用标记字符的操作可能间接保留引用值(@9.10.3) 。
这包括由类型为合并子的参数（而非 <body> 或 <expressions> ）决定是否保留引用值同时对其它参数进行转发的操作。

@10.5.6 中缀：
中缀 -> 在函数名中可能出现一次，表示其（移除前缀和后缀之后的函数名中的）左边为源类型名的值到右边为目标类型名的值的转换操作。
除作为源类型的值外，可能支持可选的附加其它参数。
转换得到的值是纯右值。
除非另行指定，转换函数调用的求值是纯求值(@4.4.4) 。
除非另行指定，若被转换的值的复制可能影响可观察行为，被转换的值初始化返回值(@9.10.2) ，明确转移而不是复制其中的右值。
除非另行转定，按接口文法约定(@9.2) 引入的操作数作为对应名称之间的转换，仅在引入其中之一的模块提供。具体规则如下：
	源或目标具有在同一个根环境或跟环境下的环境引入的对象类型时，在根环境中提供转换函数的名称。
	源或目标具有从根环境下的 std.strings(@12.4) 以外的环境中引入的类型时，仅在引入其中之一提供转换函数的名称。
	否则，在模块 std.strings 提供转换函数的名称。
**原理**
如有可能，被转换的值一般应避免被复制。在接口上要求转发右值避免不必要的复制。
**注释**
一般地，转换操作是源类型的值作为单一实际参数的转换目标类型的构造器(@9.11.5) 。

@10.6 不安全操作约定：
除非另行指定，执行时蕴含以下操作的操作是不安全操作(@9.4.5) ：
以下不具有内存安全保证(@9.4) 的操作：
	使用函数名称约定(@10.5) 的命名的带有后缀的操作(@10.5.4) ；
	其它保留间接值的操作(@9.4.4) ；
以下可能引入循环引用的操作：
	引入引用现有环境对象(@9.9.2) 的环境强引用(@6.11.1) 的操作；
	引入共享持有者的值数据成员(@6.2) 而可能通过循环引用等引起未定义行为操作；
和以上不安全操作等效的互操作；
其它另行指定的操作。
按不安全操作引起不同的未定义行为和不同的间接值(@9.3.3) ，以下小节对不安全操作进行分类。
分类之间的关系详见保留间接值(@9.4.4) 。
分类可能不完全的且可能相交的（不安全操作可能不属于任何一个分类或同时属于多个分类）。

@10.6.1 在函数值中保留引用值的操作：
在函数值中保留引用值的操作包括按函数名称约定(@10.5) 具有引用标记字符结尾的操作。
直接保留引用值(@9.10.3) 操作可配合带有返回值转换(@5.8.4.2) 的操作，指定个别函数参数不再保留引用值。
这些操作可引起之后的不安全引用值访问(@9.4.2) 。
保留的引用值同时可能被构造循环引用(@9.9.1.2) 。
**注释**
一些修改操作无效化(@9.8.6) 引用值。这些引用值若被保留且被访问，可引起未定义行为。
不引起被绑定对象无效的修改操作不被视为不安全操作，即便它们无效化子对象(@9.8.2) 的引用值。

@10.6.2 在函数值中保留环境引用的操作：
环境引用(@5.6.2.2) 被返回时，总是被保留(@9.10.4) 。
创建环境强引用的操作(@6.11.1) 是在函数值中保留环境引用的操作。
这些对象可能因为没有及时保存环境引用使环境对象和其中的绑定一并被销毁，而使引用值访问其中的对象的程序具有未定义行为。
通过非引用的形式引入环境循环引用的操作同时可破坏环境的资源所有权。
**注释**
直接返回有效的环境弱引用(@6.11.1) 的操作不引起环境失效，不在此列。

@10.6.3 在函数值中保留其它间接值的操作：
特定的支持强递归绑定(@9.7.3.1) 而在函数值中保留其它间接值，可能是无效的间接值(@9.4.3.3) 。
在函数值中保留其它间接值的操作的强递归绑定过程中引用共享对象（参见 $defrec!(@11.3.7) ）的中间值。
NPLA1 参照实现环境中，在函数值中保留其它间接值的操作的实现内部可能引入引用持有者(@6.4.3.1) 。

@10.6.4 在环境中保留环境引用的操作：
环境中的被绑定对象可具有环境引用子对象(@9.8.2) ，间接地在环境中保留环境引用。
这些操作使当前环境或参数指定的环境（而不是合并子调用(@4.5.3.2) 时创建的新环境(@9.9.2) ）中的变量绑定包含间接值，后者可能依赖合并子调用时创建的新环境。
被绑定的对象中可能保留环境引用，而使用环境间接地保留对象中的引用。
使用这些操作时应总是注意被依赖的环境的可用性。
若环境对象销毁，所有直接和间接依赖环境对象的间接值被无效化(@9.8.6)。这些间接值的不安全间接值访问(@9.4.2) 引起未定义行为。
**注释**
绑定的对象中可能保留环境引用的典型的例子是合并子对象的静态环境。
创建合并子可在合并子中的环境中保留环境引用，如 $lambda/e(@11.4.3) 。

@10.6.5 无效化被绑定对象或环境引用的操作：
特定的操作蕴含被绑定对象的存储期的结束而无效化它的引用值。
若子对象(@9.8.2) 的引用值已被绑定，这些引用值不需要通过其它不安全操作，而仅通过之后访问标识符求值(@9.7.1) 的结果(@7.8.2) 即可引起未定义行为。
因为环境稳定性(@9.9.2.4) 要求，NPLA1 实现环境不提供这类绑定，因此这些操作不是不安全操作。
但派生实现可能在语言实现中提供不满足环境稳定性的一等环境，其中对象的子对象的引用值被绑定为变量，且前者可能被修改。
此时，这些操作可能允许无效化引用后的被引用对象(@4.2.6) 被访问，成为不安全操作。
类似地，无效化环境引用而无效化环境对象也可使其中包含的被绑定对象的引用无效化。
但环境生存期(@9.9.2.5) 要求，除非作为不满足环境稳定性的环境的被绑定对象，NPLA1 实现环境不提供唯一的环境强引用(@6.11.1) 可被用户程序(@2.2.4) 修改而使环境对象被销毁。
在这个前提下，要通过使环境引用作为子对象被修改而结束环境对象的生存期，首先要求通过在函数值中保留环境引用的操作(@10.6.2) 取得环境引用，得到包含环境引用作为子对象的对象，且保证只有这个对象保存环境强引用(@6.11.1) 。
因此，若不存在其它不安全操作，即蕴含不存在在对象语言操作中无效化环境引用的情形。
类似地，派生实现可提供不满足环境生存期中的销毁顺序的环境，而使用户无效化对应的环境对象。
此时，这些操作可能允许无效化环境引用后的环境对象被访问，成为不安全操作。

@10.6.6 副作用可能引入循环引用的操作：
一些操作不依赖其它不安全操作（保留引用值或环境引用）即可引入循环引用：
自赋值(@9.8.3.1) 可能引入循环引用值。
**注释**
通过已有的不安全操作构造的引用值也可能引入循环引用（而引起未定义行为），但不是单一操作的副作用，不属于本节的实例。
例如循环引用(@9.9.1.2) 中使用 list% 的例子，$def! 或 list% 不会因此被视为此处的不安全操作，因为单一操作的语义不引入循环引用值。

@10.6.7 可能破坏环境稳定性的操作：
通过引用值进行的修改操作(@9.8.3) 可因破坏环境稳定性(@9.9.2) 而引起扩展 NPLA 未定义行为(@9.1.4)（不一定违反内存安全）。
这包括以下可无效化对象包含的引用值而使可通过环境访问的某个子对象(@9.8.2) 的同一性被改变，从而破坏环境稳定性(@9.9.2) 的操作：
对可能具有对象语言中可访问的子对象的对象的赋值操作(@9.8.3.1) ；
可修改被绑定对象(@6.11.1) 的操作（包括重绑定(@9.9.2.7) ）。

@10.6.8 安全操作子集：
作为对象语言安全性保证(@9.4.6) 的一部分，用户程序通过限制或避免依赖特定的不安全操作，在特定情形下可实现对象语言内存安全保证(@9.4) ，而不需要分析具体操作的语义：
不依赖操作命名(@10.5) 约定的带有后缀的操作；
若使用保留环境引用的操作，如在函数值中保留环境引用的操作(@10.6.2) 和在环境中保留环境引用的操作(@10.6.4) ，总是保存被依赖的环境以确保相关的环境对象及其中的被绑定对象(@6.11.1) 在间接访问对象时不被销毁；
不使用引入最终不被保留的子有序对引用(@9.4.2) 以外其它间接值的操作。

@10.7 参照实现约定：
本节约定对 NPLA1 参照实现内部有效，不作用在用户程序。
除非另行指定，NPLA1 参照实现环境作为公开接口提供的变量在根环境(@10.1) 中绑定。
除非另行指定，以变量绑定的提供接口没有严格的跨版本兼容性保证，但一般可预期在 YSLib 发布版本([Documentation::ProjectRules @@2.2.5.5]) 之间保持向后兼容。

@10.7.1 接口描述：
除非显式指定，空环境没有父环境(@9.9.2) 。
约定的接口通过绑定在根环境中的名称提供，参见以下各节。
除非是语义蕴含的操作结果或另行指定，所有作为函数值的操作(@10.3.1) 的结果(@4.4.5.1) 是未指定值(@7.2.2) 。另见函数名称约定(@10.5) 。
未指定值可等于 #inert(@9.3.1.3) 或其它值，但满足忽略值时不引起可观察行为(@4.1.3) 的改变（这排除了引入 volatile 类型或非平凡析构的宿主值）。
若操作(@10.3.1) 在 Kernel 或 klisp 中存在结果是 #inert 的对应的操作，且未指定作为函数值的结果，则返回等于 #inert 的右值。
操作中隐式分配的和按接口约定转移所有权给操作实现的资源不存在资源泄漏(@5.6.5) 。这包括抛出异常(@9.5.2) 时，操作的实现提供基本异常安全保证(@6.1.4.2) 。
**原理**
#inert(@4.7) 是单元类型的值。但是，未指定值并不依赖单元类型的性质，而只是需要一种可在对象语言中判断是否为实现（如 [RnRK] 的 inert? ），而避免使用特设的规则。
取而代之，一些语言或运行时支持非一等的特设返回类型：void(@4.7.10) ，在对象语言中无法构造其值。这种特性引起一些实用上的困难而被考虑改进，替换成一等类型，如：
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0146r1.html
https://github.com/dotnet/csharplang/discussions/1603
即便被改进，这通常只是单元类型，而不够清晰地反映未指定的意图。
未指定值蕴含的不确定性在对象语言中难以建模，因此直接作为内建的支持特性能使语言的设计更简单(@1.5.3.2) 。
未指定值的未指定性在接口意义上仍然不是一等实体，因为当前不提供如 inert? 这样的谓词（提供 inert? 也仅仅是判断值是否为 #inert 而不是任意的未指定值）。
相对 inert? ，这类谓词可能是有用的，例如元语言可能需要判断未指定性质以简化其派生实现。但这类需求和实现细节相关，且当前缺乏实例显示在对象语言中无条件提供的必要性。更重要的是，若要求提供这种谓词，限制派生实现在未指定值的类型上维持开放类型(@5.3.1) 设计。
未指定值作为内建特性时，用户也无法直接提供这类谓词的派生（而不符合可扩展性(@1.5.5.1) ）。在需要这类谓词时，派生语言设计可能视具体实现需要满足的条件补充。

@10.7.2 操作符合性：
除非另行指定，以下关于操作实现的行为未指定。
对运行时错误条件(@9.5.3) 的检查及诊断(@9.5) 的顺序；
满足运行时错误条件(@9.5.3) 时，按要求诊断之后的操作内部分配的资源的状态；
变量的绑定(@4.1) 或其它可选地由派生实现定义的可调试实体的引入是否由本机实现(@5.3) 的机制提供；
是否存在不改变操作语义的附加的可被捕获的续延和这些续延的操作数；
操作的实现使用的续延名称(@7.11.7) 。
以上未指定行为允许同一操作的接口约定和实现之间及不同实现之间允许存在引起调用操作时的可观察行为不同的次要差异。

@10.7.3 实体实现(@1.2.1.2) 约定：
在实现意义上，库特性(@2.2.4) 提供的实体的方式分为两类：
直接调用 NPLA 或 NPLA1 API（参见 @7 、@7 和 @8 ）绑定定义，提供本机实现(@5.3) ；
通过组合既有对象语言提供的接口实现，即派生(derivation) 。
因不预期通过派生实现，一些特性被设计为基本(primitive) 特性，总是通过直接调用本机 API 的本机实现(@5.3) 提供。
其它特性都是派生特性，通过派生(derived) 实现提供。
典型地，派生实现通常不依赖实现特定的互操作(@1.2.3) 接口的本机实现(@5.3) ，这类派生实现是非本机的(non-native) ；其它的派生是本机的。
直接调用本机 API 提供绑定和本机的派生实现都是本机实现。
类似 [RnRK] ，派生特性可通过基本特性及其它已提供实现的派生特性实现。
以下的派生操作(@11.4) 应能以派生的方式提供。派生操作是否以派生的形式提供未指定。
派生的操作不依赖隐式求值风格(@9.7.1.2) ，除非语义明确要求避免操作数的求值（如 $deflazy!(@11.4.1) ）且对实现可提供必要的简化，应避免依赖 $quote(@11.4.1) ；$quote 自身通过派生实现引入。
与引入绑定不同，实现内部不要求类似的优先使用，在需要明确实现需要符合的要求或减小实现开销时，可使用提供以引用标记字符结尾变体的操作(@10.5.4) 替代其它操作。
作为扩展，操作的非本机实现也允许假定纯右值(@5.8.1) 的项不包含不被项的结构(@7.1.2) 约定直接使用的标签(@6.2.2) 。
**注释**
接口的派生实现可作为派生语言实现提供新的库特性的方式。
派生语言也可以提供新的本机实现的库特性。
基本特性类似 [RnRK] ，但和 [RnRK] 不同(@2.2.4) ，也属于库特性。
基本特性通过本机实现提供的实现方式不被接口设计(@10.3.2) 严格要求。基于简化设计和平衡功能丰富性的实际考虑，在设计中蕴含的是否预期通过派生实现的决策并不排除理论上可能允许的其它替代方式。
本机的派生通常以使用宿主语言的本机 API 和组合现有派生特性的符号，通过本机 API 初始化构造求值绑定的方式引入。
非本机的派生实现通常以求值特定的对象语言源代码引入。
非本机的实现最终依赖本机实现。

@10.7.3.1 函数约定：
名称使用 $def 起始的函数用于在当前环境引入绑定。
需引入绑定时，优先使用核心库(@11.4.3) 中的函数；当使用这些函数并不能简化实现时，使用 $def!(@11.3.7) 。
除以下例外，优先使用函数名中不带有 % 及 %! 结尾的函数：
当实现操作的语义要求时；
调用的结果明确是非引用值（此时是否使用带有 % 的函数的效果应一致）。
以上的实现方式可减少一部分不安全操作(@10.6) 并明确函数值是否可能只是非引用值。
如果可能，函数实现使用转移，避免不必要的对象复制。
强调使用没有 % 或 %! 结尾的函数避免一些可能的误用(@10.5.3.2) 。

@10.7.3.2 预定义对象：
除操作外，派生实现可定义特定名称的对象以变量绑定的形式在库中初始化，直接提供具有预设目的的可编程特性。

@10.7.4 操作实现注记：
部分本机实现不支持嵌套调用安全(@6.1.4.1) ：
copy-environment(@11.3.7)
通过派生实现的操作不依赖非真合并子(@9.9.4) ，因此以合并子实现操作时，其中不使用分隔符(@9.7.1) ，也不需要实现在初始化(@10.1.1) 时支持中缀变换(@7.5.1) 。
但是，不同操作之间的定义可能使用分隔符。因为不需依赖 $sequence(@11.4.1) ，这种实现也更简单(@1.5.3.2) 。
除非另行指定，当前实现中，操作引发错误对象(@9.5.2) 以抛出异常实现(@10.4.4) ，涉及具体的异常类型未指定。
**注释**
这允许引起错误处理(@10.4.4) 的使用引发错误对象的派生实现。

@11 NPLA1 根环境特性(@10.2) ：
本章指定在根环境(@10.1) 提供的 NPLA1 标准库特性(@10.3.3) 。
根环境基本特性(@11.3) 提供在基础上下文(@8.5.2) 初始化的根环境基本(@10.7.3) 特性，作为单独的模块。
基础派生特性(@11.4) 起的各节提供其余要求 NPLA1 实现直接支持的各个模块的操作。
**注释**
一些特性可约定处理的值的宿主类型(@9) 。

@11.1 不安全操作(@9.4.5) 索引：
本节按不安全操作约定(@10.6) 的分类对根环境中的不安全操作进行归类。
在函数值中保留引用值的不安全操作已被操作命名(@10.5) 归纳和函数分类(@11.2) 枚举，此处从略。
不安全操作中，在参数以外直接引入间接值的操作仅有以下的在函数值中保留引用值的不安全操作：
ref&(@11.3.4) 。
附加调用安全(@9.4.6.1) 包括在函数值中保留引用值的不安全操作(@10.6.1) 的调用。
当前，这种操作包括 assign!(@11.4.1) 。
隐藏环境排除可修改对象的引用，通过冻结(@9.9.2.9) 环境保证而提供静态的证明。

@11.1.1 在函数值中保留环境引用的操作(@10.6.2) ：
包括基本操作(@11.3.7) ：
make-environment
copy-environment
lock-environment
包括派生操作(@11.4.1) ：
lock-current-environment
derive-current-environment
make-standard-environment
derive-environment
$provide/let!
$provide!

@11.1.2 在函数值中保留其它间接值的操作(@10.6.3) ：
包括：
$defrec!(@11.3.7)
$setrec!(@11.4.1)

@11.1.3 在环境中保留环境引用的操作(@10.6.4) ：
包括派生操作(@11.4.1) ：
$provide/let!
$provide!

@11.1.4 无效化被绑定对象的操作(@10.6.5) ：
当前不提供此类操作。
这可包含直接移除变量绑定的操作。

@11.1.5 副作用可能引入循环引用的操作(@10.6.6) ：
包括可能自赋值(@10.6.6) 引入循环引用值的基本操作(@11.2.1.3) ：
assign@!
assign%!

@11.1.6 可能破坏环境稳定性的操作(@10.6.7) ：
对可能具有对象语言中可访问的子对象(@9.8.2) 的对象的赋值操作(@9.8.3.1) 包括：
简单赋值(@10.5.4.3) 。
可直接修改被绑定对象(@6.11.1) 的操作包括：
move!(@11.3.4) 。

@11.2 函数分类：
本节对函数按名称和其它不同性质进行分类。
在 NPLA1 参照实现环境提供的函数具体详见根环境基本特性和基础派生特性。
除非另行指定，本节约定的函数属于 NPLA1 参照实现环境。
本节约定的函数提供的部分操作属于转发(@9.11) 。
**注释**
转发参数或返回值的实现(@9.11.6) 中可使用 forward!(@11.4.1) 。

@11.2.1 可提供以引用标记字符结尾(@10.5.4) 变体的函数：
本节内的以下分类不相交，但部分分类中函数名不带有引用标记字符结尾的操作可能和 @11.2.2 中的操作相交。
除非另行指定，符合以下分类的操作：
不指定保留引用值时，不保留引用值；
指定保留引用值时，同指定在结果中保留引用值；
指定在结果中保留引用值时，根据结果是否为未指定值，应总能直接区分被保留的来源(@9.4.4.2) 和目标(@9.4.4.1) ；
**注释**
函数值约定(@10.4.2) 已指定函数值默认不保留引用值；这没有涵盖 <body> 的求值结果。

@11.2.1.1 可能使结果包含引用值的容器构造器(@10.5.4.1) ：
包括：
cons(@11.3.5)
cons%(@11.3.5)
wrap(@11.3.8)
wrap%(@11.3.8)
list(@11.4.1)
list%(@11.4.1)
list*(@11.4.1)
list*%(@11.4.1)
box(@11.4.3)
box%(@11.4.3)

@11.2.1.2 可能使结果包含引用值的容器元素访问器(@10.5.4.2) ：
包括：
first(@11.4.1)
first@(@11.4.1)
first%(@11.4.1)
first&(@11.4.1)
rest%(@11.4.1)
rest&(@11.4.1)
restv(@11.4.1)
注意 restv 和 rest% 总是构造列表，并不直接返回子对象(@9.8.2) 的引用（另见引用值构造(@11.2.4) ）；其它访问器若带有引用标记字符，可直接返回引用值。
此外，标准库中的函数值转发操作(@11.2.2.4) 中部分函数也符合容器元素访问器的要求，但当前不提供带有后缀标记字符的变体。这些函数包括：
unwrap(@11.3.8)
unbox(@11.4.3)

@11.2.1.3 可能使对象中包含引用值的修改操作(@10.5.4.3) ：
简单赋值，包括：
assign@!(@11.3.4)
assign%!(@11.4.1)
assign!(@11.4.1)
列表元素改变器，包括：
set-rest!(@11.3.5)
set-rest%!(@11.3.5)
set-first!(@11.4.1)
set-first@!(@11.4.1)
set-first%!(@11.4.1)

@11.2.1.4 可能间接保留引用值的操作(@10.5.4.4) ：
以求值 <body> 作为尾上下文的操作，包括：
结果是合并子或用于在环境中绑定合并子的构造器操作；
以及核心库函数(@11.4.3) 中的绑定操作；
在尾上下文中求值视为 <expression> 的 <object> 的函数，包括 eval 和 eval%(@11.3.7) 。
参见环境基本操作(@11.3.7) 和核心库(@11.4.3) 。
**注释**
以上操作中的求值符合词法闭包(@4.6.1.2) 规则，可使用 A1::RelayForEval 或 A1::RelayForCall(@7.7.2) 实现。

@11.2.2 不提供结尾 % 或 & 对应变体(@10.5.5) 的函数：
通常使用 forward!(@11.4.1) 转发实现上述保证(@9.11.2) 。

@11.2.2.1 可直接以引用值作为结果的操作(@10.5.5.1) ：
包括：
$if(@11.3.3)
$sequence(@11.4.1)
$cond(@11.4.1)
$when(@11.4.1)
$unless(@11.4.1)
$and(@11.4.1)
$or(@11.4.1)

@11.2.2.2 不以引用值作为结果的操作(@10.5.5.2) ：
这些返回值总是按值传递的操作涉及的容器包括列表、箱(@11.4.3) 或其它的封装类型(@11.3.10) 对象。
包括库函数：
map1(@11.4.1)
list-concat(@11.4.1)
append(@11.4.3)

@11.2.2.3 直接参数转发操作(@10.5.5.3) ：
包括合并子基本操作(@11.3.8) ：
unwrap
包括核心库函数(@11.4.1) ：
accl
accr
foldr1
map1
核心库函数(@11.4.3) 中的绑定操作的非 <environment> 的形式参数支持转发。
参数形式上被转发但操作的语义并非总是转发到其它操作的操作不使用本节的名称约定，如以下仅有第二参数支持转发的操作是提供结尾 % 或 & 对应名称的函数(@11.2.1) ，有对象基本操作(@11.3.4) 中的：
assign%!
assign@!
**注释**
map1 同时是不以引用值作为结果的操作(@11.2.2.2) 。

@11.2.2.4 函数值转发操作(@10.5.5.4) ：
NPLA1 参照实现环境的函数值转发操作包括以下访问对象或被引用对象自身或子对象(@9.8.2) 的函数：
unwrap(@11.3.8)
id(@11.4.1)
forward(@11.4.1)
forward!(@11.4.1)
unbox(@11.4.3)
基本操作(@11.3) 的不具有名称的相关操作中参数和函数值原生支持的转发操作包括：
使用 make-encapsulation-type(@11.3.10) 返回的访问器合并子。

@11.2.2.5 可能间接保留引用值的操作(@10.5.5.5) ：
包括：
apply(@11.4.1)

@11.2.3 引用折叠(@5.8.3.6) 相关操作：
只有函数名以 @ 结尾的函数(@10.5.3) 可能引入未折叠的引用值，包括：
assign@!(@11.3.4)
set-first@!(@11.4.1)
first@(@11.4.1)
此外，在参数保留引用值的修改操作可能使现有的引用值成为未折叠的引用值，包括：
assign@!(@11.3.4)
assign%!(@11.4.1)
set-first@!(@11.4.1)
set-first%!(@11.4.1)
函数 uncollapsed?(@11.3.4) 区分未折叠的引用值。
蕴含左值到右值转换的函数可以消除引用值(@5.6.4.5) ，如：
idv(@11.4.1)
collapse(@11.4.1)
其中，collapse 依赖 uncollapsed? 而针对未折叠的引用值消除引用值，实现引用折叠。
其它一些函数可能在非本机实现(@10.7.3) 中依赖未折叠引用但不在接口中体现，如 rulist(@11.4.1) 。

@11.2.4 引用值构造：
当前构造子对象引用(@5.8.3.1) 的操作有：
unwrap(@11.3.8) 创建合并子的子对象引用；
rest&(@11.4.1) 创建列表的子对象引用；
使用带有省略(@7.7.3.3) 的形式参数树(@7.7.3)（如 <formals>(@9.2.2.1) ）绑定操作数为结尾列表(@7.7.3.3) ，创建列表的子对象引用(@7.7.3.5) 。
子对象引用具有非平凡非正规表示(@6.3.7.2) 。
注意子对象引用在宿主语言中不存在有效的共享状态的表示(@6.8.3) 。
特别地，由绑定使用引用标记字符的非递归绑定(@7.7.3.5) 的规则，绑定列表的子对象引用(@9.9.3.1) 不直接共享操作数列表对象，而共享元素是原容器元素的（经折叠的(@7.7.3.4) ）引用值的列表。
**注释** 这类似宿主语言的容器对象一般不能转换为共享容器部分元素的 C++ 对象引用。

@11.2.5 非引用值构造器：
一些函数构造非引用值：
包括核心库(@11.4.1) 转换函数：
$bindings/p->environment
$bindings->environment
symbols->imports
包括续延库(@12.1) 转换函数：
continuation->applicative
其中，明确转移被转换的右值(@10.5.6) 的函数有：
continuation->applicative

@11.3 根环境基本特性(@10.2) ：
和 [RnRK] 不同，为简化设计，NPLA1 不提供可选(optional) 的合并子，而通过预定义对象(@10.7.3.2) 的形式提供可选的模块(@12) 。
根环境基本特性是除了这些模块的以变量绑定形式提供的不要求可派生实现的特性。
根环境基本特性的被绑定对象(@6.11.1) 包括基础环境(@10.1) 提供的预定义对象(@10.7.3.2) 和在基础上下文(@8.5.2) 的根环境中初始化的基础基本操作(grounded primitive operations) 的实现。
派生实现可以通过提供不公开不安全操作(@9.4.5) 的根环境，但不符合此处的规格要求(@1.2.1.2) 。
若派生实现不提供在函数值中保留其它间接值的操作(@11.1.2) ，可以简化部分 @11.3.4 中与之关联的操作的实现。
部分可选的 Kernel 合并子被直接提供。
和 Kernel 不同，一些函数显式地操作引用值(@5.8.3) ，包括未折叠的引用值(@5.8.3) 。
和 Kernel 不同，求值算法(@9.7.1) 不直接处理对象的引用值(@6.10.5.3) 。
为简化实现，部分提供 % 等后缀的函数(@11.2.1) 不被派生。
因为设计原因，不提供以下 Kernel 合并子对应的操作：
copy-es-immutable
inert?
ignore?
考虑（可变对象的）一等引用和绑定构造(@9.7.3) 绑定引用的的平摊复杂度，不提供需要同时转换不同层次子项的 copy-es-immutable 操作。
部分其它原理参见根环境对象(@11.3.1) 。关于引用值的处理另见函数分类(@11.2) 。
其它没有包含在以下节中的 Kernel 操作可能会在之后的版本中被支持。
当前在根环境中的直接提供绑定的特性不依赖 <number>(@6.14.1) 。
**原理**
可选功能不应被必要功能依赖。
根环境的基本特性为组合其它实用特性提供，而数值在设计中不是必要的功能特性。

@11.3.1 对象定义：
当前根环境不定义对象。
以下各节引入的变量都表示操作。

@11.3.2 等价谓词(@4.2.1) ：
模块约定：
本节的操作不修改参数对象。
本节的操作的结果是 <boolean> 类型的纯右值。
用户定义的类型提供的等价谓词应满足和 NPLA1 提供的等价谓词的语义一致的等价关系，否则若谓词被求值，行为未指定。
一些具有项节点作为表示的对象的子对象(@9.8.2) 具有递归相等性，仅当子对象符合以下递归相等关系：
对不表示有序对的节点，同 eqv? ；
否则，同每个元素对应 eqv? 对应满足 eqv? 。
判断子对象递归相等性的对象相等时，其续延未指定。
若右值之间 eqv? 比较结果是 #t ，eq? 比较结果未指定。
操作：
eq? <object1> <object2> ：判断参数同一。
当且仅当两个参数是指定同一对象时，比较结果是 #t 。
eq? 的复杂度是 O(1) 。
eql? <object1> <object2> ：判断表示参数的项的值数据成员(@6.2) 相等。
忽略表示参数的项的值数据成员以外的子对象：若参数是列表，则视为空列表；若参数是有序对，则视为仅具有最后一个元素。
若参数是引用值，则被比较的项是表示它的被引用对象(@4.2.6) 的项。
当且仅当被比较的项的值数据成员相等时，比较结果是 #t 。
值数据成员相等蕴含参数的动态类型(@4.7) 相同(@4.7.2) 。
eqr? <object1> <object2> ：判断表示参数的项的数据成员同一。
当且仅当表示被比较的项的值数据成员指定宿主语言中的同一对象（即引用相等）时，比较结果是 #t 。
eqv? <object1> <object2> ：判断非枝节点(@6.2.1) 表示的值相等。
若参数是引用值，则被比较的值是它的被引用对象。
当表示值的项都是枝节点时，同 eq? ；
否则，若这两个参数的类型不同(@4.7.2) ，则结果是 #f ；
否则，若这两个参数的 eql? 比较结果是 #t ，则结果是 #t 。
若两个参数的 eqv? 比较结果是 #f ，则这两个参数以 eq? 比较结果总是 #f 。
除非互操作(@1.2.3) （参见以下描述）或派生实现另行指定，不等价(@4.5.3.2) 的函数的 eqv? 比较结果是 #f 。
除以上规则确定的结果外，eqv? 对合并子或列表的比较结果未指定。
在互操作的意义上，当前 eqv? 定义的合并子的相等性由过程相等性(@8.4.5.5) 或不影响可观察行为的其它宿主环境提供的 == 操作通过和 eql? 比较相同的方式确定。
除非另行指定，具有本文档引入的类型且不涉及互操作意义上用户自定义值的比较的操作数使用以上 eq? 以外的谓词比较的求值应保证能终止。
**原理**
除任何其它类型都可作为 <object> 的子类型(@9.2.2.2) ，开放类型映射(@5.3.1) 的类型系统(@4.7.1) 通常要求避免依赖 <object> 上的其它的良序和良基的理论(@4.2.1) ，以避免对现有类型系统的扩展时需要修改已有的类型的相关操作。
不需要依赖序的等价谓词可为名义类型(@4.7.2) 提供直接的支持。
NPLA1 提供默认相等为抽象相等(@4.2.1) ，对任意的值适用。
NPLA1 还提供对一等对象保证结果有意义的引用相等(@4.2.1) 操作。非一等实体的引用相等关系未指定。
当前 NPLA1 不支持 EGAL(@4.2.1) ，因为 EGAL 要求存在分辨任意对象的值是否可被修改的元数据。
因为对应等价的不变性(@1.2.1.1) 关系不具有唯一性(@4.2.1) ，且可能允许不唯一的方式产生副作用（如缓存），和 Kernel 不同，不以基本操作提供 equal? 对任意对象提供一般的相等操作。
未指定 eq? 的比较结果可允许实现复用存储右值的驻留(@9.8.4) 对象。
eql? 实际比较宿主值的相等。允许 eqv? 和 eql? 的不同可允许一对多的类型映射(@5.3.1.1) 下比较对象语言的值的相等。（而多对一的类型映射 eql? 和 eqv? 可一致地比较。）
但是，当前实现中，大多数一对多映射的类型（如环境）都没有引起使 eql? 和 eqv? 不同的比较实现，因为不同宿主值类型的对象具有足够显著的差异，在大多数上下文不通过一些具有不可忽略开销的转换机制（如锁定环境弱引用(@6.11.1) 转换为环境强引用(@11.3.7) ），无法直接相互替换而保证行为差异可被忽略，因此逻辑上不适合定义为相等的。
而基于性能等理由，等其它一对多映射的类型（特别是可能基于宿主类型的值的子集的，如 NPLA 数值类型(@6.14.1) 中的 <integer> ）的值的比较也没有特别的处理，而引起 eqv? 和 eql? 的不同。
这些类型可能需要其它针对特定类型的等价谓词（如 =?(@12.3) ）进行相等性的比较。
类似 [RnRS] ，不同类型决定 eqv? 的结果是 #f ，但此处类型相同的含义不通过类型分区(@9.8.7) 定义。
类似 [RnRS] ，行为不等价的函数的 eqv? 结果原则上应为 #f ，但这种等价性一般不可证明而无法保证，特别在关于语言实现以外的调用上。
为支持互操作使用本机实现(@5.3) 及避免限制合并子的子类型的开放性(@1.5.3.6) ，允许这些实现另行指定规则，假定引起程序可观察行为差异的函数调用调用名义等价。
宿主环境的 == 操作中不使用 NPLA1 异步规约(@7.1.4) 。
**注释**
通常，等价谓词比较的求值应保证能终止且对非列表项和 n 个子项的列表分别具有 O(1) 和 O(n) 平摊复杂度。这是依赖数据结构实现的细节；语言不需要约束这个性质。
实现中，值数据成员的相等由 ValueObject 的 == 操作定义。这对应 C++ 意义上的对象相等。
对仅由值数据成员决定值的表示的情形(@6.10.6) ，动态类型相等(@4.7.2) 即值数据成员的目标类型相等。
这种情形使用 eql? 和 eqv? 相同，即仅比较宿主值 TermNode 的值数据成员(@6.2) 相等。
由正规表示分类(@6.10.6.3) ：
	列表和非列表之间的 eql? 结果总是为 #f ，列表之间的 eql? 的比较结果总是 #t 。
	所有列表在 TermNode 的值数据成员中的表示都一致，在 eqr? 等价关系下视为相同的对象。
使用 eqr? 判断宿主值 TermNode 的值数据成员表示的左值(@5.8.1) 的标识，当且仅当为操作数比较同一个对象时比较结果是 #t 。
关于合并子相等，另见 TCO 实现(@7.11.6) 中关于函数右值去重(@7.10.7.1) 的说明。
因为枝节点和其它节点不共享除公共超类型(@4.7.7) <object> 外具有相同类型的表示，任意一个被比较的值是枝节点时，eqv? 的结果也同 eq? 。

@11.3.3 控制：
$if <test> <consequent> <alternative> ：条件分支，按条件成立与否返回 <consequent> 或 <alternative> 之一，可能是引用值。
$if <test> <consequent> ：省略第三操作数的条件分支，条件成立时返回 <consequent> 。
和 Kernel 不同而和 Scheme 类似，如 <test> 的求值结果非 #f 即选择 <consequent> ，且支持省略第三参数。
若省略 <alternative> 且 <test> 求值为 #f ，则结果未指定(@10.7) 。
**注释**
对 <test> 的处理的主要原理和 Kernel 的 $and 不要求尾上下文的表达式求值检查类型一致。
若需要检查类型避免误用，可以派生提供其它函数；相反的派生无法利用更简单(@1.5.3.2) 的实现。
**原理**
和 R7RS 类似，但和 Racket 及 Kernel 不同，省略 <alternative> 被支持。
这避免用户必须引入 #inert 等具体的值实现相同隐式效果而违反关注点分离原则(@1.5.2.4) 。
必要时（如派生结果等效 #inert 的操作(@10.7.1) ），#inert 的值仍可被显式使用，但这在接口意义上通常是不必要的。
另见关于 #inert 的原理(@10.7.1) 。
和 [RnRK] 中的相关讨论结论不同，是否省略 <alternative> 的形式应是一致的。这是因为：
NPLA1 不假设作为基本控制操作的 $if 的作用（仅要 <consequent> 或 <alternative> 求值的结果，或仅为了副作用）；
$if 不假设用户对 <consequent> 和 <alternative> 顺序选择性偏好，以避免限制用户选择否定谓词简化 <test> ，从而支持 @1.5.2.1 。
此外，NPLA1 使用显式的 <expression-sequence>（而不是 <consequent> 和 <alternative> ）语法表示顺序求值，这不适合基本的控制操作子：
若分离二操作数和三操作数其它形式，则二操作数可以使用 <expression-sequence> ，即 $when(@11.4.1) 。
但依赖 <expression-sequence> 的 $when 不应是比具有 <consequent> 的二操作数形式更基本的操作。
因此，仍然需要有 $when 以外的省略第三参数的基本控制操作子。基于同一性(@1.5.5.1) ，对应函数名仍然为 $if 。（尽管使用了相同的原则，这和 Kernel 的结论恰好相反。）
与此类似，和 [Racket] 的理由（参见 https://stackoverflow.com/questions/10863192 ）不同，不因为 $when 提供只强调副作用的操作而取消 $if 的 <alternative> 。
NPLA1 不会如 Racket 一样在此避免遗漏 <alternative> 导致的非预期结果。这并不违反 @1.5.5.2 ，因为不使用 <alternative> 的结果非常显然，同时选择使用 $if 这样的基本控制操作而不是更特定派生控制操作或更高级的抽象已蕴含注意误用的必要性。
一般地，NPLA1 不提供强调只存在副作用的操作。返回未指定（而不要求被使用）的求值结果的情形并不表示只有副作用(@10.7.1) ，因为副作用是否存在原则上依赖具体操作。这和 Kernel 的 #inert 以及 Racket 的 #<void> 值即便在实现上都一致，但含义不同。
另见 $when 的说明。

@11.3.4 对象：
模块约定：
注意因为真列表(@9.9.3) 的限制，列表左值只能引用完整的列表的对象，而不支持部分列表。
这影响 set-rest! 和 set-rest%! 的第一个参数。
操作：
null? <object> ：判断操作数是否为空列表。
nullv? <object> ：判断操作数是否为空列表纯右值。
同 null? ，但不支持引用值。
branch? <object> ：判断操作数是否具有枝节点(@6.2.1) 表示。
branchv? <object> ：判断操作数是否为具有枝节点表示的纯右值。
同 branch? ，但不支持引用值。
pair? <object> ：<pair> 的类型谓词(@10.5.2.1) 。
pairv? <object> ：判断操作数是否为有序对纯右值。
同 pair? ，但不支持引用值。
symbol? <object> : <symbol> 的类型谓词。
reference? <object> ：判断操作数是否为引用值。
unique? <object> ：判断操作数是否为唯一引用(@6.2.2) 。
modifiable? <object> ：判断操作数是否为可修改对象或可修改对象的引用值。
temporary? <object> ：判断操作数是否为临时对象(@5.8.5) 或临时对象的引用值。
bound-lvalue? <object> ：判断操作数是否为被引用的被绑定对象(@5.7.1) 左值。
绑定临时对象的引用类型的参数不被视为左值引用。
配合 $resolve-identifier(@11.3.7) 和 % 引用标记绑定(@7.7.3.5) 的变量，可确定实际参数是否为左值；参见 $lvalue-identifier?(@11.4.1) 。
使用 bound-lvalue? 和 & 引用标记字符绑定(@7.7.3.5) 的变量，可确定实际参数是否为引用。
uncollapsed? <object> ：判断操作数是否为未折叠的引用值。
deshare <object> ：取指定对象取消共享的值。
同 idv(@11.4.1) ，但显式提升操作数中具有共享持有者的值数据成员(@6.2) ，且不转移宿主值。
因为提供在函数值中保留其它间接值的操作(@11.1.2) ，这个区别是必要的。否则，使用 idv 替代应不影响可观察行为(@4.1.3) 。
和通常的求值规约消除引用值（如求值规约提升项(@7.7.2.1) ）不同，以 NPL::LiftTermRef(@6.9.4.2) 和确保创建值副本的 NPL::SetContentWith(@6.2.3) 实现。
as-const <object> ：取指定对象的不可修改(@6.2.2) 的引用。
同 id(@11.4.1) ，但当参数是引用值时，结果是和参数引用相同对象的不可修改的引用值。
expire <object> ：取指定对象的消亡值(@5.8.1) 。
同 id(@11.4.1) ，但当参数是引用值时，结果是和参数引用相同对象的唯一引用。
可用于显式地指定之后被转移(@9.8.3.2) 的对象，而不需要直接转移参数。
**原理** 因此这个操作也不是修改操作(@9.8.3) ，函数名不以 ! 结尾(@10.5.2.3) 。
**注释** 这个函数类似宿主语言标准库中作用在对象类型实际参数的 std::move ，可能减少没有经过复制消除(@5.8.5.3) 的复制或转移(@5.8.2.3) 而改变使用这个函数的结果对象的副作用。
特别地，指定列表的引用值被转移时，不需要立即转移列表的每个元素，而允许之后通过绑定构造(@9.7.3) 等方式选择转移的子对象(@9.8.2) 。
可能包含立即转移的操作如 forward!(@11.4.1) 。
move! <object> ：转移对象。
若参数是不可修改的左值，则以复制代替转移；否则，直接转移表示参数对象的项(@6.3.4) 。
结果是不经返回值转换的项。
**注释** 另见转移的注意事项(@9.8.3.2) 。
transfer! <object> ：转移对象。
同 move! ，但使用对象的转移(@5.8.2.3) ，而不是项的转移(@6.3.4) ，避免宿主对象转移消除而允许调用宿主对象的转移构造函数(@6.3.4.1) 。
项被转移后，和返回值转换等引入实质化临时对象时可能具有的转移的效果（仅在互操作(@1.2.3) 时可见）相同。
ref& <object> ：取引用。
对引用值同 id(@11.4.1) ；对具有共享持有者的值数据成员的对象也视为左值。通过后者构造的引用值不被检查。
取得的引用值是不安全引用值(@6.8.3.1) 。
因为提供在函数值中保留其它间接值的操作，对共享持有者的值数据成员的对象使用不同的处理。否则，对引用值参数的情形，使用 id 替代应不影响可观察行为。
以 NPL::LiftToReference(@6.9.4) 实现。
assign@! <reference> <object> ：赋值(@9.8.3.1) 被引用的对象为指定对象的值，且 <object> 不隐含左值到右值转换且不被折叠。
检查 <reference> 是可修改的左值。
赋值对象直接修改(@9.8.3) 被引用的对象，但不无效化(@9.8.6) 参数指定的引用。
**注释** 另见赋值的注意事项(@9.8.3.1) 。
**注释** 被赋值替换的子对象的引用可被无效化。Scheme 的 set! 在 SRFI-17 提供具有类似作用的支持，但第一操作数限于 set! 且为特定的过程调用；Kernel 没有类似的操作。

@11.3.5 有序对(@9.2.2.2) ：
cons <object1> <object2> ：构造参数指定的两个元素构成的有序对。
结果是 <pair> 类型的值。
**注释** 不保留 <object2> 的引用值，但这不涉及 <object2> 是有序对或有序对的引用值时其中可能具有的元素。若 <object2> 中存在元素，直接被作为结果的元素，不经过返回值转换。
cons% <object1> <object2> ：构造参数指定的两个元素构成的有序对，保留引用值。
同 cons ，但参数是引用值时，直接以其值作为元素的值，而不以其被引用对象的值创建有序对。
**注释** 这允许被构造的结果中存在和参数相等的引用值，而非其被引用对象的副本。
set-rest! <pair> <object> ：修改列表的第一个以外的元素。
**注释** 和 Kernel 的 set-cdr! 类似，但检查列表是左值，且不保留被添加元素中的引用值。
set-rest%! <pair> <object> ：同 set-rest! ，但保留引用值。
**注释** 和 Kernel 的 set-cdr! 类似，但检查列表是左值。
**注释**
和 Kernel 不同，NPL 不支持列表中存在环。
不使用相同的对象左值的 cons% 调用或修改操作(@9.8.3) 导致循环引用(@9.9.1.2) ，用户应自行避免未定义行为(@5.4) 。
结果具有的属性不被影响。这和实现中的 NPL::LiftElementsToReturn(@6.9.4.3) 不依赖表示最后的有序对的元素项上的标签行为一致。

@11.3.6 符号：
desigil <symbol> ：移除符号中的引用标记字符 & 或 %(@7.7.3.4) 。
判断符号非空且以 & 或 % 起始，结果是移除起始字符的参数。否则，结果是参数。
不处理引用标记字符 @(@7.7.3.4) 。

@11.3.7 环境：
模块约定：
为避免引入过于容易引入循环引用(@9.9.1.2) ，仅通过个别操作引入环境强引用(@9.9.2)
make-environment
lock-environment
操作：
eval <object> <environment> ：在参数指定的环境中求值，结果作为函数值。
<object> 在求值前被视为 <expression> 。
若 <object> 为元素中有引用值的列表，元素不会被特殊处理，不隐含左值到右值转换(@9.10.1) 。
**注释** [RnRK] 中第一参数为 <expression> ，但这不是已求值的操作数的类型。
eval% <object> <environment> ：同 eval ，但保留引用值。
bound? <string> ：判断指定字符串对应的符号是否被绑定。
$resolve-identifier <symbol> ：解析当前环境中的标识符。
结果是解析结果中的项。
**注释** 参数不按成员访问规则确定值类别(@9.9.1.1) ，也不按解析名称表达式的规则确保结果总是左值(@7.8.2) ，可保留消亡值(@9.9.1.1) 。
$move-resolved! <symbol> ：转移解析标识符的对象。
和 $resolve-identifier 类似，但直接取被绑定对象(@5.7.1) 并尝试从环境中转移。
若环境被冻结(@9.9.2.9) ，则复制被绑定对象；否则，直接转移对象的项(@6.3.4) 。
一般应仅用于被绑定的对象不需要再被使用时。
() copy-environment ：递归复制当前环境。当前忽略父环境(@9.9.2) 中的环境列表(@6.11.1) 。
结果是新创建的环境，具有宿主值类型 shared_ptr<Environment>(@6.11.1.3) 。
使用类似环境数据结构遍历的 DFS 搜索(@6.11.1) 操作数的父环境和绑定的对象，若非环境则直接复制值，否则创建环境并递归使用 DFS 复制值。
当前只支持复制具有以下目标类型的父环境及被引用对象中的环境，其它对象直接视为非环境对象：
包含 EnvironmentReference(@6.11.1.3) 值的对应 NPL::IParent(@6.11.1.1) 的宿主值的环境，即 SingleWeakParent(@6.11.1.1) ；
包含 shared_ptr<Environment> 值的对应 NPL::IParent 的宿主值的环境，即 SingleStrongParent(@6.11.1.1) 。
空环境对应 NPL::IParent 的宿主值的环境，即 EmptyParent(@6.11.1.1) 。
除空环境，其它支持的环境对象都深复制为环境强引用，作为父环境设置为 SingleStrongParent 。
警告：这个函数仅用于测试时示例构造环境，通常不应被用户程序使用，且可能在未来移除。未确定环境宿主值时可引起未定义行为。
freeze-environment! <environment> ：冻结环境。
这个操作处理操作数指定的一等环境。对隐藏环境(@9.9.2.1) 初始化时的相同操作参见冻结操作(@9.9.2.9) 。
lock-environment <environment> ：锁定环境：创建环境强引用。
检查操作数的宿主值类型是 NPL::EnvironmentReference ，结果的宿主类型 shared_ptr<Environment> 。
强引用可能引起环境之间的不被检查的循环引用(@9.9.1.2) ，用户应自行避免未定义行为(@5.4) 。
make-environment <environment>... ：创建以参数为父环境的环境。
和 Kernel 不同，除对象类型外，没有对列表和绑定的附加检查。
结果是新创建的环境，是环境强引用，具有宿主值类型 shared_ptr<Environment> 。
weaken-environment <environment> ：使用环境强引用创建环境弱引用(@6.11.1) 。
检查参数类型是环境强引用，若失败则引起类型错误(@9.5.4.1) 。
**原理** 因为 NPLA1 需要精确控制所有权而不依赖 GC(@5.2) ，这可用于派生实现某些操作（如 $sequence(@11.4.1) 必要的）。
**注释** 实现检查操作数的宿主值类型(@6.11.1.2) 是 shared_ptr<Environment> ，结果的宿主类型 NPL::EnvironmentReference 。
$def! <definiend> <body> ：修改当前环境中的绑定。
类似 Kernel 的 $define! ，但满足绑定构造(@9.7.3) 的约定。
和 Kernel 的 $define! 不同，$def! 和 $defrec! 在求值 <body> 后，进行类型检查(@9.5.4.1) ，确保环境没有被冻结后添加绑定。
和 Kernel 类似，对在 <body> 中某些未被直接求值的子表达式（如 $lambda(@11.3.8) 的 <body>），因为其中的求值依赖 $def! 表达式求值后的环境，在之后仍可以实现递归。
由于递归调用依赖环境中的绑定，修改以上定义引入的绑定后可影响被递归函数的调用。
对 <definiend> 中已存在的标识符的绑定，保证直接替换对象的值，对象的引用不失效(@9.9.2.7) 。
$defrec! <definiend> <body> ：修改绑定，同 $def! ，但在绑定时针对 <definiend> 指定的操作数树(@7.7.4) 中的绑定名称有附加的处理以支持直接递归。
除和 $def! 相同过程的常规绑定（求值 <expression> 和绑定符号）外，支持强递归绑定(@9.7.3.1) ，其操作数树的附加处理分为两阶段；每个阶段深度优先遍历 <definiend> 指定的操作数树，对每个符号进行附加处理：
在常规绑定前，每个遍历的待绑定符号在目标环境（被定义影响的环境）中预先进行绑定，保证指称一个对默认对象的弱引用，其中默认对象具有调用总是抛出异常的 A1::ContextHandler 类型(@7.2.1) 的值；和这个弱引用的共享的强引用被临时另行保存。
在常规绑定后，再次遍历操作数树，对每个 A1::ContextHandler 的值，替换之前在环境中保存的共享定义为默认对象的共享强引用，最后释放先前临时保存的默认对象的强引用。
调用默认对象时，若默认对象的强引用存在，引起错误(@9.7.3.1) ；
否则，违反生存期规则，可因 NPLA 运行时检查(@6.1.2.1) 抛出由对象实现提供的引用不存在的异常。
和 vau 抽象对环境的检查(@9.9.2.5) 类似，后者在对象语言中已引起未定义行为(@5.4) ，不应被依赖。
常规绑定后转移未被 <body> 求值影响的绑定中的默认对象的所有权到环境中，但不影响绑定目标在对象语言中指称的值。
在环境中未被 <body> 求值替换的绑定，在 $defrec! 求值仍指称默认对象（而不会是持有合并子的宿主类型(@7.6.1.1) 的值），若被作为合并子调用，则显示存在循环递归调用。
和 $def! 不同，常规绑定后的操作使 <body> 不在尾上下文求值；而因为保证操作数树中的名称已存在默认定义，求值 $defrec! 的 <body> 前时可使用绑定。
**注释**
这允许递归定义的名称在绑定完成前指称对象。例如，当环境中未绑定变量 a 和 b 时：
求值表达式 $def! (a b) list b ($lambda () 1) 因为被求值的 b 未被绑定引起错误(@9.5.1) ；
求值表达式 $defrec! (a b) list b ($lambda () 1) 不需要 a 或 b 已被绑定（即便 b 并不在 $lambda 的 <body> 中），求值后 a 为默认对象；
求值表达式 $defrec! (b &a) list ($lambda () 1) b 绑定要求同上，但求值后 a 可能为默认对象（操作数树中的同级叶节点被未指定的绑定顺序影响）。
这也允许在 $vau/e(@11.3.8) 等表达式的 <environment> 指定的静态环境使 <body> 不能访问目标环境时，直接定义递归函数。
递归定义的对象中的值数据成员(@6.2) 可能具有共享的持有者。若为合并子，直接调用会利用替换的值重新访问所在的环境。复制和转移这样的值不会改变被访问的环境。若访问的环境失效，则抛出异常，或无限递归调用自身。
特定情形使用 deshare(@11.3.4) 可去除共享和避免以上可能非预期的行为。
**另见**
环境(@9.9.2) 。

@11.3.8 合并子：
和 Scheme 及 Kernel 不同，<body> 可以是多个项，而不在派生另外的变体支持顺序求值。
引入合并子的操作子不求值 <body> ，后者在被调用时替换操作数以后被求值。这允许安全地使用 $def! 而不需要 $defrec! 进行递归绑定(@11.3.7) 。
检查失败的错误(@9.5.1) 是（可能依赖(@9.5.1) 类型错误(@9.5.4.1) 的）语法错误(@9.5.1) 。
$vau/e <parent> <formals> <eformal> <body> ：创建指定静态环境的 vau 抽象(@4.5.2.5) 。
创建的对象是操作子(@7.6.1.1) 。
$vau/e% <parent> <formals> <eformal> <body> ：同 $vau/e ，但保留引用值。
wrap <combiner> ：包装(@4.5.3.2) 合并子为应用子(@7.6.1.1) 。
包装应用子可能符合包装数溢出的错误条件(@9.9.4) 。
wrap% <combiner> ：同 wrap ，但参数不隐含左值到右值转换，在结果中保留引用值。
unwrap <applicative> ：解包装(@4.5.3.2) 应用子为底层的合并子(@7.6.1.1) 。
左值参数解包装的结果是合并子的子对象引用(@11.2.4) 。
**原理**
指定 <parent> 作为静态环境可通过被绑定实体的所有权控制一等对象的生存期。同时，在没有 safe-for-space 保证时，仍可有效避免资源泄漏(@5.10.3) 。
**注释**
和 Kernel 不同，因为支持保存环境的所有权，$vau/e 被设计为比 $vau 更基本的操作。
不考虑所有权时，eval(@11.3.7) 和 $vau 可派生 $vau/e 。
和 Kernel 不同，参数是右值时解包装的子对象(@9.8.2) 被复制。由这些合并子创建的操作子当前仍不足以取代内置的一等操作子，因为不支持只能转移而不能复制的对象。传递这些对象作为操作数会引起构造失败的异常。

@11.3.9 错误处理(@10.4.4) 和检查：
raise-error <string> ：引发表示错误的异常。
实现引发错误对象(@9.5.2) 的异常对象类型具有 public 基类 NPL::NPLException 。
raise-invalid-syntax-error <string> ：引发包含参数指定的字符串内容的语法错误(@9.5.1) 。
实现引发错误对象的异常对象类型具有 public 基类 NPL::InvalidSyntax 。
raise-type-error <string> ：引发包含参数指定的字符串内容的类型错误(@9.5.4.1) 。
实现引发错误对象的异常对象类型具有 public 基类 NPL::InvalidSyntax 。
check-list-reference <object> ：检查对象是否是列表引用：若检查通过转发参数作为结果，否则引发错误对象。
check-pair-reference <object> ：检查对象是否是有序对引用：若检查通过转发参数作为结果，否则引发错误对象。
检查列表或有序对引用实现引发错误对象的异常对象类型是 NPL::ListTypeError(@6.5) 或 NPL::ValueCategoryMismatch(@6.5) 。
**注释**
当前实现默认抛出异常(@10.7.4) 。

@11.3.10 封装：
() make-encapsulation-type ：创建封装类型。
和 Kernel 类似，结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的封装(encapsulate) 构造器、判断封装类型的谓词和用于解封装(decapsulate) 的访问器。
构造器直接使用参数，在结果（构造的封装对象）中保留参数的引用值，类似(@11.2.1.1) 中带有 % 的容器构造器(@10.5.3.3) ；
访问器根据参数的值类别转发被封装的值。
创建的封装类型支持判断相等（参见 eqv?(@11.3.2) ），相等定义为被封装的对象的子对象(@9.8.2) 的递归相等性(@11.3.2) 。
**注释**
和 [RnRK] 不同，使用构造器初始化封装的对象作为容器，具有作为其子对象的被封装的对象的所有权。
需要注意保存被构造的封装对象。
另见 https://small.r7rs.org/wiki/UniqueTypesSnellPym/ 和 SRFI-137 。
和 Kernel 及 Scheme 的各种实现（如 http://www.r6rs.org/r6rs-editors/2005-August/000831.html ）不同，对相同类型的封装对象，eqv? 和 equal? 基于被封装对象的子对象（及子对象被引用的对象）递归比较，即使用封装的对象的 equal? 定义 eqv? 结果。
另见等价谓词的设计用例(@4.2.1) 。
使用 Forms::MakeEncapsulationType(@8.4.8) 的实现中，递归相等的比较不依赖当前上下文，也不支持捕获比较相等的续延。

@11.4 基础派生特性：
根环境特性(@10.2) 中，除根环境基本特性(@11.3) 的剩余接口是派生特性(@10.7.3) 。其中在基础环境中提供的特性时基础派生特性(grounded derived feature) 。
因为性能等原因，基础派生特性可能同时提供本机实现和非本机的派生实现(@10.7.3) 。
其中，本机实现在 NPLA1 API 中提供直接支持(@10) 。这些操作的派生实现同时在模块 NPL::Dependency 内被给出作为替代实现。
启用本机实现使用以下实现选项(@7.1) 控制：
NPL_Impl_NPLA1_Native_Forms
NPL_Impl_NPLA1_Native_EnvironmentPrimitives
NPL_Impl_NPLA1_Use_Id_Vau
NPL_Impl_NPLA1_Use_LockEnvironment
不直接使用本机实现的替代实现仅供参考，可能引入和本机实现不同的未指定行为（如子对象(@9.8.2) 的生存期(@5.6.7) 不同），且可能有和核心特性实现相关的限制，包括：
	以下不同实现可引起不同的诊断：
		由合并子调用的参数绑定(@8.4.5.3) 引起(@9.5.1) 的静态语法错误(@9.5.1) 。
		类型检查(@9.5.4.1) 可具有不同的顺序而引起不同的类型错误(@9.5.4.1) 。
		类型错误中关于元素的表示的诊断消息可能不同。
			例如，对要求为列表的参数的类型检查中的诊断消息(@1.2.4) 可能指示对象或其子对象不符合要求。
	使用 TCO 实现 PTC(@9.7.4) ，可能具有不同的支持(@9.7.4.1) 和实现（如 TCO 动作消除(@7.10.9) ）。
	操作的语义允许时，操作的结果和作用(@10.3.1) 引起改变的对象中可包含符合具体操作的约定的未指定值（但不含没有附加限制条件的未指定值(@10.5.2.3) ）。
	没有明确指定时，创建的对象的具体内部表示及其宿主类型。
	续延名称(@7.11.7) 等在特定条件下具有的可观察行为的差异。
其中，影响可观察行为的差异应为操作符合性(@10.7.2) 约定的实例。
NPLA1 中的操作的替代实现的没有被以上例外或操作自身的语义指定的其它行为（如符合诊断(@9.5) 和接口要求的诊断消息的内容）仍应和本机实现保持一致。
**原理**
因为本机实现可能提前判断空列表，所以能比访问元素的检查更加准确。
**注释**
类似基本特性(@11.3) ，当前在根环境中的直接提供绑定的特性不依赖 <number>(@6.14.1) 。
以上一致性要求和 [RnRK] 合并子的派生完全省略错误处理(@10.4.4) 而允许不同的诊断不同。
当前已知和派生实现的诊断消息不同的本机实现有：
Forms::Assq(@8.4.9)
Forms::Assv(@8.4.9)

@11.4.1 基本派生特性：
基本派生特性可使用派生实现。这可能蕴含使用根环境基本特性(@11.3) 或已在基本派生特性中提供的特性中的部分非派生实现。
模块约定：
引入合并子的操作子对 <body> 的约定同 @11.3.8 。
因互相依赖，一些操作实现为派生操作时，不能用于直接派生特定一些其它操作。
和 $vau/e 或 $vau/e%(@11.3.8) 以及 $lambda/e 或 $lambda/e%(@11.4.3) 不同，不指定静态环境的合并子构造器隐含总是使用环境弱引用(@6.11.1) 形式的静态环境，以避免过于容易引入循环引用(@9.9.1.2) 。另见环境数据结构(@6.11.1) 。
本节约定以下求值得到的操作数(@9.2.2.2) ：
<box> ：箱(@4.2.6.5.3) 。
操作：
() get-current-environment ：取当前环境：取当前环境的弱引用(@6.11.1) 。
结果具有宿主值类型 NPL::EnvironmentReference 。派生需要非派生实现的 vau/e 。
() lock-current-environment ：锁定当前环境：取当前环境的环境强引用。
结果具有宿主值类型 shared_ptr<Environment> 。
$vau <formals> <eformal> <body> ：创建 vau 抽象(@4.5.2.5) 。
类似 $vau/e(@11.3.8) ，但以当前环境代替额外的求值环境作为静态环境。
和 Kernel 不同，可通过 $vau/e(@11.3.8) 和（非派生的）get-current-environment 派生，不是基本操作(@11.3) 。
$vau% <formals> <eformal> <body> ：同 $vau(@11.4.1) ，但保留引用值。
$quote <expression> 求值引用操作。结果是返回值转换(@5.8.4.2) 后的未被求值的操作数。
考虑通常引用操作对符号类型未被求值的左值操作数使用，保留引用值没有意义，因此不提供对应保留引用值的操作。
这个函数的使用在实现中受限制(@10.7) 。
id <object> ：结果是不隐含左值到右值转换的参数，在结果中保留引用值。
其作用等价返回值转换，可能引起对象转移(@5.8.5.2) 。
idv <object> ：同 id ，但结果是返回值转换(@5.8.4.2) 后的值。
**注释** 使用 idv 可指定在函数值中保留引用值的不安全操作(@10.6.1) 的个别操作数不再保留引用值。
list <object>... ：创建列表（类型为 <list> ）对象。
list 的底层合并子(@4.5.3.2) 接受 <pair> （而不要求是列表）作为函数合并对象，结果是操作数的元素经隐含左值到右值转换的值。
**注释** 除元素的转换，类似 [RnRK] 的 list 。
$lvalue-identifier? <symbol>
解析当前环境中的标识符（同 $resolve-identifier(@11.3.7) ）并判断是否为左值（同 bound-lvalue?(@11.3.4) ）。
forward! <object> ：转发(@9.11.4) 可能是引用的值(@11.2.2.4) 。
转移可修改的右值操作数（包括消亡值和临时对象）。
其中，需转移时，使用使用项的转移(@6.3.4) 。这和对象的转移(@5.8.2.3) 不同，不保证调用宿主环境的转移构造函数。
**原理** 和宿主语言不同，直接转移允许区分消亡值和纯右值，同等地作为一等对象（如作为列表的元素）。
**注释** 被转发的值若是形式参数树(@7.7.3) 中的变量，一般应以带有标记字符 & 的形式绑定(@7.7.3.5) ；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。
**注释** 本机实现使用 NPL::MoveRValueToForward(@6.9.4.3) 可简化操作。
**注释** 这个函数类似宿主语言以对象类型参数和推断的函数参数类型作为模板参数调用 std::forward ，但若需转移，直接转移而非如 expire(@11.3.2) 返回指定结果是消亡值(@5.8.1) 的唯一引用(@6.2.2) 。
list% <object>... ：同 list ，但每个参数都不隐含左值到右值转换，在结果中保留参数的引用值(@10.5.3.3) 。
list% 的底层合并子接受 <pair> 作为操作数（而不要求是列表），结果是操作数。
**注释** 类似 [RnRK] 的 list 。
rlist <list> ：转换参数为引用列表元素的列表。
若参数是左值，则结果是参数的元素的左值引用值构成的列表；否则，结果同 idv 。
$remote-eval <expression> <environment> ：在动态环境求值第二参数得到的环境中求值第一参数，结果作为函数值。
$remote-eval% <expression> <environment> ：同 $remote-eval ，但保留引用值。
$deflazy! <definiend> <body> ：修改绑定。
同 $def! ，但不求值参数；在添加绑定前仍对冻结环境进行检查(@11.3.7) 。
$set! <environment> <definiend> <body> ：修改指定环境的变量绑定。
在当前环境求值 <environment> 和 <body> ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 $def!(@11.3.7) 。
类似 Kernel 的 $set! ，但明确使用 <definiend> 而不是 <formals> 。注意 <body> 的形式不同。允许的递归操作参见 $def! 。
和 Kernel 不同而和 NPLA1 的 $def! 等类似，在修改绑定前对冻结环境进行检查。
$setrec! <environment> <definiend> <body> ：修改指定环境的绑定，绑定效果同使用 $defrec!(@11.3.7) 。
同 $set! ，但允许不同的递归操作，参见 $defrec! 。
$wvau <formals> <eformal> <body> ：创建包装的 vau 抽象(@4.5.2.4) 。
同 $vau ，但创建的是调用时对操作数的元素求值一次的应用子(@7.6.1.1) 。
参数的作用同 $vau 的对应参数。
$wvau% <formals> <eformal> <body> ：同 $wvau ，但允许函数体求值返回引用值。
$wvau/e <parent> <formals> <eformal> <body> ：同 $wvau ，但支持显式指定求值环境参数作为静态环境。
$wvau/e% <parent> <formals> <eformal> <body> ：同 $wvau/e ，但保留引用值。
$lambda <formals> <body> ：创建 λ 抽象(@4.5.2.4) 。
同 $vau ，但创建的是调用时对操作数的元素求值一次的应用子(@7.6.1.1) ，且忽略动态环境。
**注释** 可通过 vau 抽象或 $lambda/e 和（非派生的）get-current-environment 派生。
除未提供的 <eformal> ，参数的作用同 $vau 的对应参数。
$lambda% <formals> <body> ：同 $lambda ，但允许函数体求值返回引用值。
$lambda/e <parent> <formals> <body> ：同 $lambda ，但支持显式指定求值环境参数作为静态环境。
$lambda/e% <parent> <formals> <body> ：同 $lambda/e ，但保留引用值。
list? <object> ：<list> 的类型谓词(@10.5.2.1) 。
若参数是列表或非真列表，时间复杂度不大于 O(n) ，其中 n 是其中的元素数。
**注释** 本机实现可实现 O(1) 时间复杂度。派生实现在使用 NPLA 的实现时，以 eql? 也可实现 O(1) 的时间复杂度。
$sequence <expression-sequence> ：顺序求值。
操作数非空时结果是最后的参数，可能是引用值。
**注释** 类似 Kernel 的同名操作。
求值每个 <object> 的副作用包括其中临时对象(@5.8.5) 的销毁都被顺序限制。
**注释** 这类似宿主语言的语句而不是保证子表达式中的临时对象的生存期延迟到完全表达式求值结束的逗号表达式。这也允许实现和 [RnRK] 同名操作类似的 PTC 要求。
collapse <object> ：折叠可能是引用的值。
forward <object> ：转发可能是引用的非临时对象的值。
同 forward! ，但对可修改的临时对象操作数，使用复制代替转移。
**注释** 按在所在的环境中解析的操作数的类型可选地提升项(@6.9.4) 作为结果，其作用 id 或 idv 之一。
**注释** 转移（而不是复制）可修改的右值操作数。注意若右值操作数不可修改（如本机实现引入带有 TermTags::Nonmodifying 标签(@6.2.2) 的引用操作数），复制不可复制构造的宿主对象会失败。
**注释** 本机实现使用 NPL::MoveRValueToReturn(@6.9.4.3) 可简化操作。
assign%! <reference> <object> ：同 assign@!(@11.3.4) ，但 <object> 是引用值时赋值的源操作数是 <object> 折叠后的值。
assign! <reference> <object> ：同 assign%! ，但 <object> 隐含左值到右值转换。
**注释** 因为左值到右值转换，即便 <object> 指定的值来自 <reference> ，也可赋值而不因此引起未定义行为。
**注释** 另见赋值的注意事项(@9.8.3.1) 。
apply <applicative> <object> ：在新环境(@9.9.2) 中应用。
apply <applicative> <object> <environment> ：在指定环境中应用。
**注释** 检查 <environment> 和 [RnRK] 的参考派生不同。
apply 的函数值保留引用值。
apply-list <applicative> <list> ：在新环境中应用参数列表。
apply-list <applicative> <list> <environment> ：在指定环境中应用参数列表。
同 apply ，但首先检查第二参数的类型，若失败则引发错误(@9.5.1) 。
list* <object>+ ：在列表前附加元素创建对象或有序对。
类似 cons ，但支持一个和多个参数。
对一个参数的情形结果同参数，否则结果同右结合嵌套调用参数的数量减 1 次的 cons 。
**注释** 一个参数的情形结果经返回值转换(@9.10.2) 。因为不需要如 Kernel 支持派生 $vau ，可直接使用 apply 派生。
list*% <object>+ ：同 list* ，但创建有序对类似 cons% ，且元素保留引用值。
**注释** 一个参数的情形结果不经返回值转换。
$defv! <variable> <formals> <eformal> <body> ：绑定 vau 抽象，等价 $def! <variable> $vau <formals> <eformal> <body> 。
$defv%! <variable> <formals> <eformal> <body> ：绑定 vau 抽象，等价 $def! <variable> $vau% <formals> <eformal> <body> 。
$defv/e! <variable> <parent> <formals> <eformal> <body> ：绑定指定静态环境的 vau 抽象，等价 $def! <variable> $vau/e <parent> <formals> <eformal> <body> 。
$defv/e%! <variable> <parent> <formals> <eformal> <body> ：绑定指定静态环境的 vau 抽象，等价 $def! <variable> $vau/e% <parent> <formals> <eformal> <body> 。
$defw! <variable> <formals> <eformal> <body> ：绑定包装的 vau 抽象，等价 $def! <variable> $wvau <formals> <eformal> <body> 。
$defw%! <variable> <formals> <eformal> <body> ：绑定包装的 vau 抽象，等价 $def! <variable> $wvau% <formals> <eformal> <body> 。
$defw/e! <variable> <parent> <formals> <eformal> <body> ：绑定包装的指定静态环境的 vau 抽象，等价 $def! <variable> $wvau/e <parent> <formals> <eformal> <body> 。
$defw/e%! <variable> <parent> <formals> <eformal> <body> ：绑定包装的指定静态环境的 vau 抽象，等价 $def! <variable> $wvau/e% <parent> <formals> <eformal> <body> 。
$defl! <variable> <formals> <body> ：绑定 λ 抽象，等价 $def! <variable> $lambda <formals> <body> 。
$defl%! <variable> <formals> <body> ：绑定 λ 抽象，等价 $def! <variable> $lambda% <formals> <body> 。
$defl/e! <variable> <parent> <formals> <body> ：绑定指定静态环境的 λ 抽象，等价 $def! <variable> $lambda/e <parent> <formals> <body> 。
$defl/e%! <variable> <parent> <formals> <body> ：绑定指定静态环境的 λ 抽象，等价 $def! <variable> $lambda/e% <parent> <formals> <body> 。
forward-first% <applicative> <list> ：取列表的第一元素并转发给指定的应用子。
设参数列表 (&appv (&x .)) ，作用同求值：
(forward! appv) (list% ($move-resolved! x)) ；
其中，调用 appv 的底层合并子(@4.5.3.2) 的当前环境同调用 forward-first% 的动态环境。
first <pair> ：取有序对的第一个元素的值。
当 <list> 是左值时结果是折叠的引用值，否则结果是返回值转换(@5.8.4.2) 后的值。
**注释** 类似传统 Lisp 及 Kernel 的 car 。命名和 SRFI-1 及 Clojure 等现代变体一致。
first@ <pair> ：同 first ，但结果总是未折叠的引用值。
首先调用 check-pair-reference(@11.3.9) 检查参数是有序对引用，对右值引发错误。
first% <pair> ：同 first ，但结果总是转发的值。
转发的值是经过折叠但没有返回值转换的列表元素的值，无论参数是否为引用值。
first& <pair> ：同 first@ ，但结果总是折叠的引用值。
若元素是引用值，在结果中保留元素中的唯一引用属性。
**原理** 详见 NPLA1 引用值使用约定(@9.9.1.1) 。
firstv <pair> ：同 first ，但结果总是返回值转换后的值。
rest% <pair> ：取有序对的第一个元素以外的元素值经过转发的值构成的有序对。
若结果构成子有序对(@9.9.3.1) ，可能引入子有序对引用(@9.9.3.1) 。
rest& <pair> ：取有序对的第一个元素以外的元素值的引用值构成的有序对的子对象引用(@11.2.4) 。
首先调用 check-pair-reference 检查参数是有序对引用，对右值引发错误。
若结果构成子有序对，引入子有序对引用。
restv <pair> ：取有序对的第一个元素以外的元素值构成的有序对。
结果是有序对对象。
set-first! <pair> <object> ：修改有序对的第一个元素。
和 [RnRK] 的 set-car! 类似，但可派生，检查列表是左值，且不保留引用值。
set-first@! <pair> <object> ：同 set-first%! ，但保留未折叠的引用值。
set-first%! <pair> <object> ：同 set-first! ，但保留引用值。
不检查修改操作(@9.8.3) 导致循环引用，用户应自行避免未定义行为(@5.4) 。
equal? <object1> <object2> ：判断一般相等。
类似 eqv?(@11.3.2) ，但同时支持表示中具有子项作为子对象的对象。
判断的相等定义为子对象的递归相等性(@11.3.2) 。
**注释** 类似 Kernel 和 Scheme 的 equal? 的二元谓词，但在此保证可通过 eqv? 直接构造。：
**注释** 因为列表的性质(@9.9.3) ，不需要支持循环引用(@9.9.1.2) ，可以直接派生。后者被视为基本的抽象而非实现细节。
**注释** 和 make-encapsulation-type(@11.3.10) 创建的对象的相等比较不同，本机实现和派生实现都依赖当前上下文，允许捕获续延，尽管续延是未指定的。
check-environment <object> ：检查环境(@9.9.2) 。
若参数是 <environment> 则检查通过，结果是转发的参数；
否则，引发错误对象(@9.5.2) 。
**注释** 当前实现中其它要求 <enviornment> 参数的操作中类型检查(@9.5.4.1) 失败和 check-environment 失败的行为一致。
check-parent <object> ：检查作为环境的父环境(@9.9.2) 的对象。
若参数是可以作为合并子环境的 <parent> 则检查通过，结果是转发的参数；否则，引发错误对象。
检查环境通过的条件同创建合并子时的检查(@11.3.8) 。
引发错误对象的作用同创建合并子时环境检查失败引起错误或引发其依赖(@9.5.1) 的错误对象（后者保证不是语法错误(@9.5.1) ）。
$cond <clauses> ：条件选择。
类似 Kernel 的同名操作，但 <test> 的判断条件和 <body> 形式不同。
$when <test> <expression-sequence> ：条件成立时顺序求值。
类似 klisp 的同名操作，但若 <expression-sequence> 被求值，结果是 <expression-sequence> 的最后一个 <expression> 的求值结果，而不是 #inert 。
**注释** 这类似 [Racket] 的 when 而和 [R7RS] 的 when 或 klisp 的同名操作不同，因为 $when 被作为和 $sequence 类似的操作处理（对应 Racket 中的 when 和 begin 并列）。
$unless <test> <expression-sequence> ：条件不成立时顺序求值。
类似 klisp 的同名操作，但若 <expression-sequence> 被求值，结果和设计原理同上。
not? <object> ：逻辑非。
被求值的参数同 <test> ，进行左值到右值转换。
若参数非 #f 时结果是 #f ，否则结果是 #t 。
**注释** 和 Kernel 不同而和 Scheme 类似，视所有非 #f 的值为 #t 。
$and <test>... ：逻辑与。
顺序短路求值。操作数为空时结果是 #t ；参数求值存在 #f 时结果是 #f ；否则结果是最后一个参数的值。
结果保留引用值。
**注释** 和 Kernel 的 $and? 不同，不检查类型，也不保证结果类型是 <boolean>（所以命名不以 ? 结尾(@10.5.2.1) ）。和 [RnRK] 中的原理描述的不同，这同时允许直接的满足对 PTC 要求(@9.7.4.1) 的派生实现。
$or <test>... ：逻辑或。
顺序短路求值。操作数为空时结果是 #f ，参数求值存在不是 #f 的值时结果是第一个这样的值；否则结果是 #t 。
结果保留引用值。
**注释** 和 Kernel 的 $or? 不同，具体差异参见以上 $and 的注释。
accl <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3> ：在抽象列表的元素上应用左结合的二元操作。
对 <object1> 指定的抽象列表进行处理，取得部分和。
当谓词 <predicate> 成立时结果是 <object2> ，否则继续处理抽象列表中余下的元素。
处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。
参数 <applicative1> 和参数参数 <applicative2> 应接受两个参数，否则引起错误(@9.5.1) 。
参数 <applicative3> 应接受两个参数，否则引起错误。
调用参数中的应用子的 <object1> 实际参数在不同的应用子调用中可能同一(@9.8.1) 。
调用参数中的应用子的底层合并子的当前环境同调用 accl 的动态环境。
accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3> ：在抽象列表的元素上应用右结合的二元操作。
操作方式同 accl 。
和 accl 不同，可保证合并操作是尾调用；相应地，递归调用不是尾上下文而无法确保 PTC(@9.7.4.1) 。
foldr1 <applicative> <object> <list> ：作用同符合以下要求的 accr 调用：
指定 accr 的参数为 <list> 、null? 、(forward! <object>) 、first% 、rest% 和 <applicative> ；
调用应用子 rest% 时不复制 <object> 或其子对象。
参数指定的应用子的调用不添加或移除列表元素，否则行为未定义。
**注释** 类似 SRFI-1 的 fold-right ，但只接受一个真列表(@9.9.3) 。
map1 <applicative> <list> ：单列表映射操作：使用指定应用子对列表中每个参数进行调用，结果是调用结果的列表。
参数 <applicative> 应接受一个参数，否则引起错误。
操作中的应用子和列表构造的结果的确定满足过程调用的因果性(@4.5.2.2) ；其余任意 <applicative> 调用的求值、列表构造操作和销毁列表中的元素的操作的相对顺序未指定。
**注释** foldr1 和 map1 名称中的 1 指 <list> 参数的个数。（更一般的其它形式可接受多个 <list> 。）
<applicative> 的调用不添加或移除列表元素，否则行为未指定。
**注释** 类似 Kernel 的 map ，但只接受一个真列表(@9.9.3) 。
first-null? <list> ：复合 first 和 null? 操作。
rulist <list> ：转换参数为可带有唯一引用的引用列表元素的列表。
同 rlist ，但在参数是左值时，参数中的非引用值元素在结果中对应转换为其唯一引用。
**注释** 消亡值处理和 rlist 不同。
list-concat <list> <object> ：顺序连接列表和对象。
**注释** 当且仅当 <object> 实际参数是 <list> 值时，结果是 <list> 值。
append <list>... ：顺序连接零个或多个列表。
**注释** 若没有参数，结果是空列表。
list-extract-first <list> ：以 first 在参数指定的 <pair> 的列表中选取并合并内容为新的列表。
设参数列表 (&l) ，结果同在新环境中求值表达式 map1 first l ，其中 map1 和 first 是标准库函数。
list-extract-rest%! <list> ：以 rest% 在参数指定的 <pair> 的列表中选取并合并内容为新的列表。
设参数列表 (&l) ，结果同在新环境中求值表达式 map1 rest% l ，其中 map1 和 rest% 是标准库函数。
list-push-front! <list> <object> ：在列表前插入元素。
要求 <list> 可修改，否则类型检查(@9.5.4.1) 失败。
<object> 被转发。
$let <bindings> <body> ：局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 <bindings> 指定的变量绑定，再求值 <body> 。
返回非引用值(@9.10.2) 。
**注释** 类似 Kernel 的同名操作，但返回非引用值。
创建的环境同合并子的局部环境(@8.4.5) 。
$let% <bindings> <body> ：同 $let ，但保留引用值。
$let/e <parent> <bindings> <body> ：指定静态环境并局部绑定求值。
同 Kernel 的 $let-redirect ，但使用 $lambda/e 而非 $lambda 作为抽象且支持 <parent> ，并返回非引用值。
这允许传递引用值并保证环境的宿主值类型（包含所有权）被正确传递作为求值的父环境，而无需支持扩展 <parent> 中的环境为右值时其中的环境临时对象的生存期。
注意此时 <parent> 中的环境中创建的环境对象在表达式求值后仍会因为 $lambda/e% 引入的合并子生存期结束而被销毁。
$let/e% <parent> <bindings> <body> ：同 $let/e ，但使用 $lambda/e% 而非 $lambda/e 抽象，保留引用值。
$let* <bindings> <body> ：顺序局部绑定求值。
同 $let ，但 <bindings> 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 <bindings> 中之前绑定的符号。
**注释** 类似 Kernel 的同名操作。
$let*% <bindings> <body> ：同 $let* ，但保留引用值。
$letrec <bindings> <body> ：允许递归引用绑定的顺序局部绑定求值。
**注释** 类似 Kernel 的同名操作。
和 $let 及 $let* 不同，操作求值 <bindings> 的初值符时保证使用和求值 <body> 时的同一环境作为当前环境，因此可配合 lock-current-environment 传递具有所有权的环境。
$letrec% <bindings> <body> ：同 $letrec ，但保留引用值。
注意以上 $let 等函数的 <body> 形式和 Kernel 不同。
derive-current-environment <environment>... ：创建当前环境的派生环境：以参数指定的环境和当前环境为父环境的空环境。
当前环境以外的父环境顺序同参数顺序。当前环境是最后一个父环境。
() make-standard-environment ：创建新(@9.9.2.2) 标准环境(standard environment) ：以基础环境(@10.1) 为父环境的空环境。
同 Kernel 的 make-standard-kernel-environment ，但创建的环境基于 NPLA1 基础环境。
**注释** 标准环境同 [RnRK] 约定的定义。
derive-environment <environment>... ：创建基础环境的派生环境：以参数指定的环境和基础环境为父环境的空环境。
当前环境以外的父环境顺序同参数顺序。基础环境是最后一个父环境。
创建的环境是标准环境，当且仅当没有实际参数。
**注释** 类似 make-standard-environment(@11.4.1) ，但具有参数指定的环境作为其它的父环境。
$as-environment <body> ：求值表达式以构造环境。
创建以当前环境为父环境的空环境，并在其中求值参数指定的表达式。
结果是创建的环境强引用。
$bindings/p->environment (<environment>...) <binding>... ：转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。
同 Kernel 的 $binding->environment ，但指定父环境，且具有适当的所有权。
使用 make-environment(@11.3.7) 而不是 $let/e(@11.4.1) 等绑定构造实现。
$bindings->environment <binding>... ：转换绑定列表为没有父环境的具有这些绑定的环境。
**注释** 类似 Kernel 的同名操作，但因为要求对内部父环境环境所有权，使用 $bindings/p->environment 而不是 $let/e 等绑定构造派生。
symbols->imports <symbol>... ：转换符号列表为未求值的适合初始化符号导入(@10.1.2) 列表的初值符列表。
结果是包含同 desigil(@11.3.6) 的方式移除标记字符(@9.2.2.3) 后的参数作为间接子项的列表。
求值这个列表，结果是同 forward!(@11.4.1) 的方式转发每个符号的列表，其元素顺序和 <symbols>... 中的值的顺序对应。
结果的结构和使用满足以下约定（可允许更有效的本机实现）：
结果中可能存在合并子作为其子对象，其包装数(@9.9.4) 未指定；
取结果中的子对象进行求值的行为未定义；
若结果被修改（如被转移），再求值时行为未定义；
若结果中的合并子在求值整个结果外的上下文被调用，行为未定义。
同 Kernel 的 $provide! 和 $import! 提供符号列表的方式，但有以下不同：
支持移除引用标记字符；
支持转发参数；
不带有引用标记字符和符号指称的对象不是临时对象(@5.8.5) 的默认情形复制值而不是初始化引用。
$provide/let! <symbols> <bindings> <body> ：指定局部绑定后在当前环境中提供绑定。
蕴含 $let <bindings> <body> ，在求值 <body> 后以结果作为操作数绑定到 <symbols> 的符号。
<symbols> 应能被作为 <definiend> 使用。
结果是对这些绑定具有所有权的环境强引用。
需要导入符号(@10.1.2) ，即 <symbols>... 具有至少一个实际参数时，以同 symbols->imports(@11.4.1) 的方式确定初值符。其中，等效的 symbols->imports 的求值次数未指定。
**注释** 绑定后的符号可通过作为 vau 抽象的父环境(@9.9.2.5) 等形式依赖这个环境，因此用户需适当保存返回值使其生存期(@9.9.2.5) 覆盖在被使用的绑定符号指称的对象生存期。
$provide! <symbols> <body> ：在当前环境中提供绑定。
同 $provide/let! 但不指定单独的 <bindings> 。
作用同 <bindings> 为空列表的 $provide/let! 。
结果是创建的环境的强引用。
需要导入符号时，以同 symbols->imports 的方式确定初值符。其中，等效的 symbols->imports 的求值次数未指定。
**注释** 类似 Kernel 的同名操作，但结果是创建的环境的强引用，且确定初值符的方式被显式要求。
仅当 <symbols> 类型检查通过时求值 <body> 。
检查当前环境可修改(@9.9.2.9) 失败时的副作用和以上任一等效求值 symbols->imports 应用子的结果可能具有的副作用非决定性有序(@4.4.3) 。
$import! <environment> <symbol>... ：从指定的环境导入指定的符号。
对第一参数之后的其余参数指定的符号列表中的每个符号，修改第一参数指定的环境，创建和指定的符号具有相同的名称和值的变量绑定。
同 Kernel 的同名操作，但需要导入符号时，以同求值 symbols->imports 应用子的结果的方式确定初值符。其中，等效的 symbols->imports 的求值次数未指定。
由于求值 symbols->imports 应用子的结果蕴含的转发语义，和 Kernel 不同，当指定的环境中的指定符号对应的绑定以临时对象创建时，导入符号可修改指定的源环境的被绑定对象。
检查 <environment> 可修改失败时的副作用和以上任一等效求值 symbols->imports 应用子的结果可能具有的副作用非决定性有序。
$import&! <environment> <symbol>... ：从指定的环境以引用绑定导入指定的符号。
同 $import! ，但以 ensigil(@11.4.2) 的方式指定绑定的符号。
nonfoldable? <list> ：判断参数是否不可被继续折叠映射：存在空列表。
参数是同 [RnRK] 的 map 操作可接受的列表参数或空列表，但排除非真列表(@6.2.1) 。
若参数是空列表，结果是 #f 。
assq <object> <lists> ：取关联列表中和参数的引用相同的元素。
第二参数指定的列表中的元素应为有序对。
以 eq? 依次判断第二参数指定的列表中的每个元素的第一个元素是否和第一参数指定的元素等价。
若不存在等价的元素，结果为空列表右值；否则是同 first% 访问得到的等价的列表的值。
**原理** 和 Kernel 不同，NPLA1 只支持真列表(@9.9.3) ，因此可以要求顺序，提供关于等价的元素的更强的保证。
**原理** 尽管和 Kernel 相同而和 Scheme 不同，<test> 支持非布尔类型的值(@11.3.3) ，不存在元素时的 #f 结果可以简化比较，但和 [RnRK] 的原理类似，这不利于提供清晰的类型错误，且没有如空列表值这样作为求值算法的特殊值的自然推论。使用空列表值和传统 Lisp 也一致。
**注释** 类似 Kernel 的 assq ，但保证顺序且转发参数。
**注释** 类似 Scheme 的 assq ，但失败的结果不是 #f 。
assv <object> <lists> ：取关联列表中和参数的值相等的元素。
第二参数指定的列表中的元素应为有序对。
以 eqv? 依次判断第二参数指定的列表中的第一个元素是否和第一参数指定的元素等价。
若不存在等价的元素，结果为空列表右值；否则是同 first% 访问得到的等价的列表的值。
**原理** 参见 assq 。
**注释** 类似 Kernel 的 assoc ，但使用 eqv? 而不是 equal? ，保证顺序且转发参数。
**注释** 和 Scheme 的 assv 类似，但失败的结果不是 #f 。
box <object> ：装箱：构造参数对象经左值到右值转换的箱（类型为 <box> 的对象）。
box% <object> ：同 box ，但参数不隐含左值到右值转换，在结果中保留参数的引用值(@10.5.3.3) 。
box? <object> ：<box> 的类型谓词(@10.5.2.1) 。
unbox <box> ：拆箱：从箱中还原对象。
作为函数值转发操作(@11.2.2.4) ，保留引用值。
以上 4 个函数除引用标记字符(@10.5) 对应处理引用值的差异外，功能和使用方式对应类似 SRFI-111 的 3 个过程 box 、box? 和 unbox 。
类型分区(@9.8.7) 使 box? 对 <list> 类型的参数的结果总是 #f 。若没有这个限制，用以下 <list> 的相关操作可整体替换进行功能等价的代替：
**原理**
[RnRK] 的 $and? 和 $or? 的实现使用 apply 和 wrap ，这没有必要：
	按 [RnRK] 的 apply 的原理，这种对任意合并子适用的操作 combine 容易实现且干扰意图的理解。
	对 NPLA1 的 apply ，还保证在第一参数是空列表时，为适应合求值函数合并（前缀 () ，参见 @7.8.2.1 ），被继续求值的对象仍是有序对（即函数合并，而不是单独的函数），但这在 NPLA1 的 $and 和 $or 中不必要，因为对应的情形（即 $and 或 $or 没有参数时）应被单独处理。
	对派生实现，apply 通常比 eval% 更低效（因为包含了无用的检查和更多的非本机实现）。
**注释**
不考虑封装性时，用 list 、list% 和 first 可代替 box 、box% 和 unbox 。
和 http://community.schemewiki.org/?scheme-faq-language 关于装箱的描述不同，这样的代替不一定保证有更好的性能。
以上这些函数可使用 make-encapsulation-type(@11.3.10) 实现。
和 Scheme 等不同，箱具有被装箱对象的所有权，因此使用 box% 和 unbox 时，需注意保存被构造的箱或被箱中引用值引用的对象。

@11.4.2 标准派生特性(standard derived feature) ：
同基本派生特性(@11.4.1) ，但其派生依赖标准库其它模块(@11) 。
ensigil <symbol> ：修饰引用字符。
确保非空的没有 & 前缀的符号以一个 & 引用标记字符。
结果是添加字符作为前缀的参数。
$binds1? <environment> <symbol> ：判断指定符号是否在指定表达式求值后指称的环境中绑定。
**注释** 和 Kernel 中的 $binds? 类似，但只支持判断一个符号。

@11.4.3 核心库(core library) ：
核心库提供以下操作，即核心库函数：
map-reverse <applicative> <list>... ：映射并反转结果。
参数 <applicative> 应满足以下要求，否则引起错误(@9.5.1) ：
<list>... 中的参数的元素数都相等；
<list>... 中的参数的元素数量等于 <applicative> 接受的形式参数的元数。
**注释** 映射类似 Kernel map 操作，但支持空的 <list>... 且保证顺序。
for-each-ltr <applicative> <list>... ：从左到右映射取副作用。
**注释** 类似 Kernel 的 for-each 但支持空的 <list> 且保证顺序。

@12 NPLA1 参照实现扩展环境：
类似 NPLA1 根环境特性(@11) ，NPLA1 以根环境(@10.1) 的形式提供其它一些模块(@10.2) 的操作，但默认不以根环境中的绑定而是以其中的环境子对象(@10.2) 中的绑定提供。
这些模块和 @10 的提供的特性一同构成了标准库(@10.3.3) 。
这些绑定不需要直接引入基础上下文(@8.5.2) 的根环境中，因为：
	同时满足以下关于接口依赖的约束，而不必要以基础环境(@10.1) 可访问的名称提供：
		它们不是使用作为环境的模块(@10.2) 时被依赖的主要操作。
			**原理** 为了使用非根环境的模块，需要绑定在根环境的函数引入其中的绑定。这样的接口应在根环境中提供而保证默认可访问，避免引入绑定这样的功能的在逻辑上的循环依赖。
			**注释** 这样的操作如 $import!(@11.4.1) 。
		它们不被根环境特性(@11) 的在接口意义上依赖。
			**注释** 在实现上仍可选依赖，参见标准派生特性(@11.4.2) 。
	接口的功能不对一般的实体具有足够普遍性，而不需要以基础环境默认可访问的名称提供。
判定上述的足够普遍性的具体规则包括：
	普遍性以实体类型体现为接口的功能对非特定类型的对象适用，最终不依赖具有更特定的类型特有的性质。
		**注释** 一般的实体作为一等对象，即具有 <object>(@9.2.2.2) 的值。<object> 是足够普遍的类型。
		**注释** <reference>(@9.2.2.2) 和 <box>(@11.4.1) 等由 <object> 构造的值最终依赖 <object> 的值，而非其它更特定类型特有的性质。
	在求值算法(@9.7.1) 中出现决定具体步骤的具体实体类型，被认为是足够普遍的。
		**注释** 这包括 <symbol>(@9.2.2.1) 、<list>(@9.2.2.2) 和 <combiner>(@9.2.2.1) 及其子类型(@9.2.2.1) 。
		**注释** <number>(@6.14.1) 或 <string>(@9.2.2.2) 等其它比 <object> 更具体类型的值不在此列。
	若接口的功能仅依赖比一般的实体更具体的特定类型的值，则不以基础环境默认可访问的名称提供。
		**注释** 功能上的依赖包含区分这些特定类型的值，如类型谓词(@10.5.2.1) 。
	接口的功能描述涉及的类型的足够普遍性对以基础环境默认可访问的名称提供是必要非充分条件。
		**原理** 这些类型仅决定接口功能的一部分。
		**注释** 若接口的功能仅依赖足够普遍的类型，但功能不足以涵盖它的任何的子类型(@4.7.7) 或者值，也可在参照实现扩展环境中提供。
		**注释** 一个主要特例：足够普遍的具体类型的类型谓词涵盖所有值，因此类型的足够普遍性可直接作为对应的类型谓词的足够普遍性的充分必要条件。
具有足够普遍性而应在根环境而非参照实现扩展环境提供的操作具体包括以下几类：
	创建非特定的不同名义类型(@4.7.2) 的对象使用的普遍机制的主要操作。
		**注释** 使用 make-encapsulation-type(@11.3.10) 可创建不同名义类型。
	不改变一般的实体可能蕴含的对象同一性(@4.2.4.1) 而同时附加非特定种类(@4.7.9) 的副作用(@4.1) 的操作。
		**原理** 同一性是所有对象的属性。显示同一性不依赖具体副作用的种类，因此要求特定种类的接口削弱普遍性。另见可变状态和普遍性(@4.2.4.2) 。
		**注释** 根环境中这样的操作如 box% 和 unbox(@11.4.3) 。
	不依赖特定对象类型，直接引入副作用的操作。
		**原理** 因为引入副作用可能是接口的关键功能及主要目的，此处的普遍性不限制非特定种类。
		**注释** 仅具有控制作用为副作用的操作仍被视为是普遍的。因此，可具有控制作用(@4.1) 的 $if(@11.3.3) 等函数仍在根环境中提供。
		**注释** 依赖一等续延(@4.5.3.3) 的控制作用(@4.1) 因续延类型而不视为足够普遍，因此根环境不直接提供一等续延(@4.5.3.3) 关联的操作。
在此基础上，这些绑定被设计为环境子对象(@9.9.2) 提供的子模块(@10.2) ，因为以下的一个或多个原因：
	它们可能具有非全局含义的名称而更适合隔离在不同命名空间(@4.3.4) 中以避免使用时的歧义。
	它们可能仅关注（如作为操作的参数或返回类型）特定的求值得到的操作数(@9.2.2.2) 类型。
	它们中的每一个模块具有足够或内聚性而不和其它子模块耦合，且绑定提供的实体关注相同的功能集合，适合被派生实现直接配置为可选的(@11.3) 特性分组。
	允许实现使用特殊的环境子类型延迟加载(@10.2) 。
		**注释** 当前 NPLA1 没有提供支持。
除非派生实现定义，每个标准库模块都不是可选的。否则，作为被加载的模块的环境的名称由派生实现定义。
修改(@9.8.3) 这些环境的程序行为未定义。
默认加载使用 . 分隔标识符得到的符号作为名称。
加载的模块依赖根环境，需通过 Forms::LoadGroundContext(@8.5.2) 或等价的方式初始化。
当前实现中部分加载的环境依赖之前加载的环境，这些环境的名称是固定的。用户程序需要保证这些环境在加载时的静态环境中可用。
在调用其中的合并子时，可能求值符号引用依赖的环境。其中的环境可能在求值定义时不依赖而不作为对应的本机 API 的前置条件。
环境是否具有依赖的环境的绑定绑定是未指定的。
用户程序需保持加载为环境的模块具有适当的生存期(@9.9.2.5) ，以避免其中的合并子调用(@4.5.3.2) 引起未定义行为。
本章的特性可使用本机实现(@5.3) 或非本机的派生实现(@10.7.3) ，分别符合根环境基本特性(@11.3) 和基础派生特性(@11.4) 的规则。具体使用何种实现是未指定的。
派生实现可定义更具体的实现要求，以便互操作(@5.3) 的兼容性。
**注释**
类似根环境特性(@11) ，一些特性可约定处理的值的宿主类型(@9) 。
当前实现中，本机实现的宿主类型和非本机的派生实现不同的实例有：
<promise>(@12.2) 。
使用 . 分隔标识符得到的符号类似 CHICKEN Scheme 的转换 R7RS 的标准模块名（参见 http://wiki.call-cc.org/eggref/4/r7rs#import ）。

@12.1 续延(@4.2.3) ：
通过初始化基础上下文后调用 Forms::LoadModule_std_continuations(@8.5.2) 初始化，默认加载为根环境下的 std.continuations 环境。
模块约定：
本节约定以下求值得到的操作数：
<continuation> ：一等续延(@4.5.3.3) 。
续延的宿主类型是 A1::Continuation(@7.4.2) 。
类似函数应用表达式(@4.5.3) ，续延应用(continuation application) 表达式是求值时蕴含续延调用(@4.5.3.3) 的表达式。
操作：
call/1cc <combiner> ：捕获一次续延(@4.5.3.3) ，具现(@1.2.4) 为一等续延作为参数调用合并子。
续延首先在尾上下文中(@9.7.4.1) 被按引用捕获(@4.5.2.1) ，再作为操作数，调用 <combiner> 。
来自同一具现的一次续延的任何副本只允许一次显式（续延应用）或者隐式（如被函数调用的返回蕴含）地成功调用；
否则，调用被重入(@4.5.4) ，引起错误(@9.5.1) 。
捕获的续延之后允许被复制。
continuation->applicative <continuation> ：转换续延为应用子。
结果是转换的 <applicative> 类型的值。
在构造结果时，<continuation> 被转发。
结果的底层合并子被调用时，传递操作数树给 <continuation> 。
apply-continuation <continuation> <object> ：应用续延。
以第二参数作为参数，以 apply 应用第一参数指定的续延转换的应用子。
**注释** 即同求值：apply (apply-continuation <continuation>) <object> 。
**原理**
类似 Kernel 语言，NPLA1 续延不是合并子。这一设计的基本原理参见 [RnRK] §7 ，但理由不充分。更完整的分析如下：
	使用守卫选择子(guard selector) 是 Kernel 的具体特性的设计，不是一般求值算法中蕴含需要实现的选项，因此仅在 [RnRK] 内部生效。
		这和类似的其它机制（如 [RnRS] 的 dynamic-wind thunk ）事实上都同以下关于续延组合性的理由类似，不需要单独列出。
	如 [RnRK] ，一般的合并子确实无法保证作为续延的父续延(parent continuation) 。
		[RnRK] 在此没有进一步明确：
			一般的合并子无法作为父续延的原因是因为（作为函数）不保证能接受操作数。
			父续延对续延组合（接受两个续延结果是和两者连续调用等效的续延）操作是必要的输入。
			更一般地，即便不支持续延组合操作，在抽象机语义描述续延的捕获得到一等续延依赖这种语义（即便父续延不是一等对象）。
				只要描述依赖可组合的求值算法，除了最后一个无界续延(@4.2.3) ，其它续延都对应可组合的求值步骤，因此这隐含续延的可组合性。
				其它在求值算法以外的机制的描述也可能依赖这种组合性，如：https://docs.racket-lang.org/reference/eval-model.html#(part._mark-model) 。
				最后一个无界续延可不考虑可组合性。但只要它不是唯一的，为作为一等续延被直接捕获和调用，它仍应当接受程序指定的操作数。
					仅当这个续延唯一时可不提供单独的续延类型。
						此时，这个续延被隐含而不当作一等续延，其中的操作数直接通过非续延的函数直接表示，如 ISO C 标准库的 exit 函数。
						然而这样的设计要求其它续延是可组合的，否则根本不支持一等续延。
					可组合续延时，这个唯一的续延会被这作为被组合的其它续延的公共后缀。
						此时仍然需要支持指定操作数，以便最后一个续延能表现程序指定的不同行为；否则，显式提供这样的续延缺少实际意义。
					[RnRK] 要求 root-continuation 和 error-continuation 这两个不同的一等无界续延能作为后缀，因此不是唯一的。
		所以，为符合正确性(@1.5.3.1) ，一般的合并子不是续延的子类型(@4.7.7) 。
	因为包装(@4.5.3.2) 是独立在具体合并子类型外的操作，[RnRK] 说明了一般续延不应作为应用子的子类型，而这并没有有效说明续延无法作为操作子的子类型。
	一些观点认为无界续延不能作为函数。但这实际依赖具体对象语言的规则，同样无法说明一般的续延无法作为操作子的子类型。
		典型的分析如 https://okmij.org/ftp/continuations/undelimited.html#introduction 。
		这仅论述了续延界限(@4.2.3) 和续延（调用）的某种可组合性(composablility) 的要求之间的关系。
			特别地，此处的可组合性局限于取得函数值。
		因为这种可组合性的限制，这隐含一个前提：函数不能不返回。这对一般的函数(@4.5.2) 并不成立，因为一般的函数允许存在副作用，这种副作用不一定局限于蕴含此处可组合的控制作用(@4.1) 。
		在类型系统中，不返回的函数仍可能是良型的(@4.7.1) ，因为函数类型的构造器(@4.7.9) 是否接受空类型(@4.7.7.1) 和具体类型系统的设计相关。
			类型系统规则能保证编码可组合的函数的机制是确保语法上可构造可组合的嵌套函数调用（函数值可作为另一个函数的实际参数），以此构成传统数学函数复合的自然扩展，并保证作用可复合，但这不保证函数值可复合。
				对总是不返回的函数，非终止(non-terminization) 是其作为后缀的一种单一副作用，吸收(absorb) 任何返回函数值的这一计算作用。这破坏函数调用具有返回值的预期，但并非在作用上不可组合。
			事实上，不提供一等控制作用机制的语言也可能允许这种类型规则。
				如 ISO C 的 _Noreturn 函数实质上返回类型就是空类型（因为没有任何值可作为返回值居留(@4.7.1) ），尽管 C 的类型系统编码中 _Noreturn 函数返回类型并不唯一（返回类型这在转换等其它类型检查中仍然有效）且空类型不被检查（违反 _Noreturn 约束是未定义行为）而可能显得不典型。
				**注释** ISO C 仅提供 setjmp/longjmp 改变通常的控制状态。此外，ISO C++ 的类似的 [[noreturn]] 用于标注总是抛出异常的函数，而提供异常的（替代）实现是一等控制操作符的一个典型使用场景。 
		根本地，使用这种值而非一般计算作用的可组合性定义的理由，仅来自某种描述语言规则的元语言上推理的要求或约定。
			**注释** 例如，为了便于使用等式理论(@4.2.6.5.5) 进行推理，证明被描述的对象语言总是符合某种静态的性质。
			一般地，基于目的的不确定性，元语言不总是遵循这种约定。
			对象语言更没有必要遵循这种约定，因为这蕴含对对象语言功能完整性的任意地、不必要的限制。
			避免非预期的终止性可很容易通过对维护外部语言实现环境的运行时的互操作实现：添加一个破坏维护非终止的运行时条件的操作（例如，撤除硬件电源），即便需要按某种方式保留运行时状态，通常仍远远比提供静态的证明更容易。
			此外，不论对象语言是否有必要表达，普遍的组合性不总是有益的，自身可能不被预期。
				易于排除非终止这种计算作用的实现方法，正好是得益于语言实现和外部系统之间的计算作用不能自发维持组合性的直接应用。
	实际决定对象语言中区分续延和合并子（且续延明确不使用合并子表示）的设计有不同的其它理由：
		求值算法对合并子的处理决定合并子对非正常控制(@4.8) 透明。作为引入非正常控制的机制，续延调用和遵循 β-规约(@4.5.3) 的合并子调用具有不同来源的语义规则，即便后者在元语言中可能实现前者。
			因此，是否把续延表示为传统的过程或合并子等其它蕴含 β-规约的实体是实现细节。抽象上，这支持保持续延的表示不透明而和合并子相互独立。
			对一等续延相关的控制操作的一种一般的语义描述参见 http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.8645&rep=rep1&type=pdf 。
		避免把续延作为合并子还有语用因素。具体地，续延调用通常使用续延应用的形式，而非操作子调用。续延应用不直接复用函数合并(@4.5.3) 的语法。
			以操作子的方式类似进行续延调用可能依赖对象的内部表示（例如 AST(@6.1.6) 形式的操作数）而暴露不必要公开的抽象，并不常用，也并不被当前语言普遍支持。
				**注释** 大多数语言根本不支持操作子。
				但禁用这种调用，在一等续延的调用规则中添加偶然耦合，阻碍功能完整性(@1.5.3.1.1) 和设计的简单性(@1.5.3.2) 。
			考虑到捕获的一等续延通过变量绑定提供，因为合并子不是应用子的子类型，若一等续延是合并子，只能是指称操作子的变量。
				于是，程序中的续延应用总是要求对其包装后使用。
				这种设计使程序的实现和简单性冲突，并违反多个结构设计规则(@1.5.4) ，而削弱提供这些绑定的续延捕获特性的可用性(@1.5.5.2.2) 。
			因此，一般的续延不是应用子的子类型，程序中一等续延的应用需转换续延为应用子。
			推论：一般的续延不是合并子的子类型。
	综上，结合以上合并子不是续延的子类型以及续延不是合并子的子类型，一般的续延和合并子类型是正交的。
		但和 [RnRK] 要求的类型分区不同(@9.8.7) ，派生实现仍可能提供同时是某个合并子的严格子类型(@4.7.7) 的续延。
NPLA1 首先提供关于一等续延而不是一等协程(@4.5.2.3) 的控制操作，因为：
	协程要求支持具有更多的原语，包括基于（而非并行于）一般的例程的创建操作（构造器(@9.11.5) ）。
	具有相等的一等协程的内部表示逻辑上更加复杂（总是涉及可变状态），即便具体实现并不一定更复杂（和内部表示相关）。
	使用非对称协程派生对称协程比使用有界续延(@4.2.3) 派生无界续延在逻辑上依赖暴露更多的细节，如包含分支的跳板(@6.12.1) 循环。
尽管逻辑上有界续延能不依赖其它副作用(@4.1) 而表达状态，提供有界续延或无界续延作为原语的差异相对次要，因为：
	NPLA1 不是纯函数式语言(@4.2.1.2) 而支持一等状态(@4.2.5.1) 在内的基本设计，在实现中不需要排除可变状态。
	NPLA1 不提供特设的和续延并行的异常或者其它替代的非正常(@4.8.1) 控制机制，而不具有如 https://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim 的这些控制作用之间的互操作难以组合的问题。
		异常基于续延提供，能确保可预测的互操作行为，尽管在基本操作中仍然可能使用异常作为实现。
		这类似 Racket 的“异常是派生的概念”的描述，但 NPLA1 异常并非如 Racket 内建，因为抛出异常(@10.4.4) 只是引起错误(@9.5.1) 的实现，而不是接口要求(@10.7.4) 。
			参见 https://docs.racket-lang.org/reference/eval-model.html#%28part._exn-model%29 。
	尽管逻辑上引入续延界限(@4.2.3) 可能是有益的，且有微妙的语义上的效果，这并没有简化用户程序和语言实现，因此当前不要求。
		当前不支持多次续延(@4.5.3.3) 和续延复制。
			当续延仅在同一个上下文中捕获时，缺少续延界限不会是一个明显的问题，因为被调用的续延总是会重新引入公共的动作序列(@6.11.3) 的后缀，即共享的子续延。
		一些当前语言设计在 [RnRS] 的操作上扩展了界限。
			例如，不同于 [RnRS] ，Racket 的 call/cc 也检查提示的存在，参见 https://docs.racket-lang.org/reference/cont.html#(def._((quote._~23~25kernel)._call-with-current-continuation)) 。
		缺少续延界限可能引起控制操作符关联的一些模型之间的语义不等价问题而难以使用其中的一种严格准确地表达其中的另一种。
			参见 http://ix.cs.uoregon.edu/~ariola/tpdc11.pdf 。
			在 SML/NJ 等语言中，因为不存在顶层的续延界限，这些问题容易成为在程序中真正阻碍使用有界续延的困难。
			在 [RnRK] ，正常程序运行的顶层续延界限以 root-continuation 提供。此外，提供 error-continuation 处理错误。
			在完善的设计中，提供一个顶层的续延界限并非困难。因此，可能缺少取得续延界限的方法的问题不是核心困难。此外，如 [RnRK] 的 error-continuation 显示了其它类似的续延的实用性。
				类似的特性可能会被加入此处的设计中 NPLA1 。
同 [RnRK] ，apply-continuation 不接受可选的环境，因为非正常控制忽略动态环境。
**注释**
call1/cc 的名称来自 https://legacy.cs.indiana.edu/~dyb/pubs/call1cc.pdf ，同 Chez Scheme 。
类似 Kernel 而不同于 Scheme ，续延具有单独的类型，续延应用也不是蕴含过程调用的函数应用。
另见关于一次调用检查的实现(@7.4.2.1) 。
apply-continuation 同 [RnRK] 。取得非 <list> 结果依赖 apply 对 <pair> 的支持，这在 Scheme 中无法实现。

@12.2 代理求值：
通过初始化基础上下文后调用 Forms::LoadModule_std_promises(@8.5.2) 初始化，默认加载为根环境下的 std.promises 环境。
模块约定：
本节约定以下求值得到的操作数：
<promise> ：求值代理：表示可被求值取得结果的对象。
保存待求值的表达式和这个表达式求值时的动态环境(@4.6.1.2) ，或已求值的结果。
除 $lazy/d 外，同 [RnRK] 的 promises 模块。
操作：
promise? <object> ：<promise> 的类型谓词(@10.5.2.1) 。
memoize <object> ：记忆化求值：以参数作为已被求值的结果创建 <promise> 对象。
在结果中保留参数的引用值(@10.5.3.3) 。
$lazy <body> ：延迟求值：以参数为待求值的表达式，以当前环境作为这个表达式被求值的动态环境，创建 <promise> 对象。
$lazy% <body> ：同 $lazy ，但保留引用值。
$lazy/d <environment> <body> ：同 $lazy ，但以参数指定环境替代动态环境。
$lazy/d% <environment> <body> ：同 $lazy% ，但以参数指定环境替代动态环境。
force <promise> ：立即求值指定的 <promise> 对象。
若参数在求值时修改为非 <promise> 类型的值，需要继续迭代求值时，引起类型错误。
**原理**
代理求值的原语可实现惰性求值和透明的记忆化。
和一些流行的误解不同，尽管这些原语的原始设计是关于并行处理的，这不必然蕴含并发的投机执行(speculative execution) ，只是因为解析(resolve) 内部状态并不在用户程序中可见，而蕴含必要的最小同步。
由于当前语言不支持并发访问，即使对 <promise> 的修改操作(@9.8.3) 导致变化，在语言中其状态也不可见，没有要求支持这种同步；未来可能会附加要求以提供更完善的并发支持。
关于 API 的设计，参见 [RnRK] 第 9 章和 SRFI-45 。
**注释**
在 <promise> 上的并发访问并不具有特别的同步保证和要求。
和 [RnRK] 不同，通过 force 引起 <promise> 对象的求值可能修改这个对象自身而使其中的状态失效（如通过 assign!(@11.4.1) 对这个对象赋值）。
因此，实现中需要重新访问状态，而重新进行类型检查。

@12.3 数学功能：
通过初始化基础上下文后调用 Forms::LoadModule_std_math(@8.5.2) 初始化，默认加载为根环境下的 std.math 环境。
以下操作中：
除非另行指定，对应的函数调用的求值是纯求值(@4.4.4) 。
涉及数值操作数的操作符合数值操作约定(@6.14.2) ；
所有除法和取余数的计算符合除法约定(@12.3.1) 。
number? <object> ：<number> 的类型谓词(@10.5.2.1) 。
complex? <object> ：<complex> 的类型谓词。
**注释** 同 number? ，因为当前 <number> 都是 <complex> 值。
real? <object> ：<real> 的类型谓词。
**注释** 同 complex? ，因为当前 <complex> 都是 <real> 值。
rational? <object> ：<rational> 的类型谓词。
**注释** 当前实现仅需排除无限大和 NaN 值。
integer? <object> ：<integer> 的类型谓词。
exact-integer? <object> ：判断参数是否为 <integer> 类型的精确数(@6.14.1) 对象。
fixnum? <object> ：判断参数是否为 fixnum(@6.14.1) 对象。
flonum? <object> ：判断参数是否为 flonum(@6.14.1) 对象。
exact? <number> ：判断参数是否为精确数。
**注释** 当前精确数都是 fixnum 。
inexact? <number> ：判断参数是否为不精确数(@6.14.1) 。
**注释** 当前不精确数都是 flonum 。
finite? <number> ：判断参数是否为有限值(@6.14.1) 。
infinite? <number> ：判断参数是否为无限大值(@6.14.1) 。
nan? <number> ：判断参数是否为 NaN 值。
=? <number1> <number2> ：比较相等。
<? <real1> <real2> ：比较小于。
>? <real1> <real2> ：比较大于。
<=? <real1> <real2> ：比较小于等于。
>=? <real1> <real2> ：比较大于等于。
zero? <number> ：判断参数是否为零值。
positive? <real> ：判断参数是否为正数。
negative? <real> ：判断参数是否为负数。
odd? <real> ：判断参数是否为奇数。
even? <real> ：判断参数是否为偶数。
max <real1> <real2> ：计算参数中的最大值。
min <real1> <real2> ：计算参数中的最小值。
add1 <number> ：计算参数加 1 的值。
sub1 <number> ：计算参数减 1 的值。
+ <number1> <number2> ：加法：计算参数的和。
- <number1> <number2> ：减法：计算参数的差。
* <number1> <number2> ：乘法：计算参数的积。
/ <number1> <number2> ：除法：计算参数的商。
abs <real> ：计算参数的绝对值。
abs 是幂等操作(@4.1) 。
**注释** 同 [RnRS] 和 [RnRK] ，当前仅支持 <real> ，尽管数学上这对 <complex> 也有意义。
floor/ <integer1> <integer2> ：数论除法：计算参数向下取整的整除的商和余数。
floor-quotient <integer1> <integer2> ：数论除法：计算参数向下取整的整除的商。
floor-remainder <integer1> <integer2> ：数论除法：计算参数向下取整的整除的余数。
truncate/ <integer1> <integer2> ：数论除法：计算参数截断取整的整除的商和余数。
truncate-quotient <integer1> <integer2> ：数论除法：计算参数截断取整的整除的商。
truncate-remainder <integer1> <integer2> ：数论除法：计算参数截断取整的整除的余数。
inexact <number> 取和参数值最接近的不精确数。
若参数是不精确数，则结果是参数值。否则：
若参数超过的任意不精确数内部表示的有限值的范围，则结果是未指定宿主类型的对应符号的无限大值。
否则，若不存在符合数值相等（以 =? 判断）的不精确数，则引起错误。
inexact 是幂等操作(@4.1) 。
**注释** 同 [R6RS] 和 [R7RS] 的同名过程，及 [R5RS] 的 exact->inexact ；因为当前实现不支持不是 <real> 的 <number> ，也同 [RnRK] 的 real->inexact 。关于 [RnRS] 中的命名，另见 https://small.r7rs.org/ticket/328/ 和 [R7RS] 的相关注释。
**原理**
关于比较操作：
同 [RnRK] 而不同于 [R5RS] 、[R6RS] 和 [R7RS] ，比较操作不明确要求传递性（但精确数仍然因真值的数学性质而保证传递性），以允许操作数存在不精确数时，转换不精确数 flonum 的简单实现。
[R6RS] 继承了 [R5RS] 要求过程 = 具有传递性（注释指出传统类 Lisp 语言的实现不要求），而 [R7RS] 的对应注释指出这不能通过把所有操作数都转换为不精确数实现。
不要求不精确数的传递性和除法约定(@12.3.1) 对除数为不精确数 0 值的处理兼容。
不同的语言在此可能有不同的规则，参见 https://codewords.recurse.com/issues/one/when-is-equality-transitive-and-other-floating-point-curiosities ，可见：
一些现代 Lisp 语言可能满足（即便不是 Scheme 实现，如 SBCL ）或不满足（即便是 Scheme 实现的派生，如 Racket ）此要求；
一些语言的不同版本的实现可能使用不同的规则（如 Ruby 1.8.7 和 Ruby 2.0 ）。
使用以上 URL 的测试用例，可发现一些 [RnRS] 的实现实际可能不符合 = 的传递性要求，如 x86-64 Linux 上：
Chez Scheme 9.5.6 、Chibi Scheme 0.10.0 和 Gauche 0.9.11 不符合要求；
Chicken 5.3.0 、Guile 2.2.7 和 Gambit 4.9.4 符合要求。
上述符合性问题在以下 URL 中报告：
https://github.com/ashinn/chibi-scheme/issues/812
https://github.com/cisco/ChezScheme/issues/606
https://github.com/shirok/Gauche/issues/805
关于 inexact 函数：
这个函数明确约定了错误条件，这和 [RnRK] 及 [RnRS] 宽松地允许引起错误（也允许不引起要求诊断的错误(@2.4.2) ）不同。
允许返回无限大值使程序容易判断非预期值的原因。使用浮点数作为不精确数，无限大值的结果符合 IEEE-754 的定义。实际 [RnRS] 实现及 klisp 普遍使用这种实现。
对其它情形保证 =? 比较的后置条件允许用户定义严格相等的转换函数（通过对结果应用 infinite? 可发现并排除无限大值）。
典型实现中，当参数是 fixnum(@6.14.1) 值时，结果通常不超过不精确数能表示的范围，也不需要引起错误。
**注释**
和数值操作约定不同，幂等操作要求超过一次应用时，结果和参数的宿主类型也相同。

@12.3.1 除法约定：
二元除法或者取余数的操作中，第一个参数是被除数，第二个参数是除数。
当除数是不精确数 0 时：
若被除数是非零有限数值或无限大值，则商的符号同被除数的符号；
否则，商的符号未指定。
当被除数是不精确数时，若除数是精确数 0 ，则结果除符号外同除数是不精确数 0 的情形。
同时计算商和余数的操作的结果是商和余数构成的列表。
**原理**
Scheme 方言及实现中普遍存在不同的除零错误的条件。
[R5RS] 的过程 / 除以零的条件没有被明确约定。
[R6RS] 则明确要求过程 / 中：
在所有参数为精确数，若除数存在零值时，引发条件类型为 &assertion 的异常；
否则，以例子指定除数存在零值时的结果：
	若被除数为非零有限数值，结果为符号同被除数的；
	否则，结果为正的 NaN 值。
[R7RS] 中修订 [R5RS] 的过程 / 中存在精确数 0 作为除数的除法结果是错误，但这不要求引起错误。实现可以引起错误，或结果具有未指定的错误的值。
[R7RS] 实际维持 [R5RS] 的条件不变，而非 [R6RS] 附加更多的要求；参见 https://small.r7rs.org/ticket/367/ ，但其中关于 [R6RS] 实现可转换操作数为不精确数和其它操作一致有误，因为 [R6RS] 的过程 = 不能以此方式实现（参见以上关于比较操作的原理的讨论）。
不同的 Scheme 实现对零值的处理（包括除零错误的条件）另见 https://small.r7rs.org/wiki/Zero/ 。
[RnRK] 的合并子 / ，存在任意除数为零值则引起错误。
因为 [RnRK] 的不精确数是可选模块，不讨论除数的零值是否精确值而保持简单性是合理的。
[RnRS] 明确要求支持精确数和不精确数（存在不同的字面量），但是只有 [R6RS] 要求存在不精确值时的确切结果。
NPLAMath(@6.14) 的数值操作约定和 [R7RS] 类似，但在此附加和 [R6RS] 类似的要求而覆盖数值操作约定，因为：
	不精确数 0 往往来自表示下溢(@6.14.2) 的计算结果，而不是精确的真值 0 ，因此数学上商应存在定义。
		参见 https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF 。
		另见 https://stackoverflow.com/a/14684474 。
	同 [RnRS] ，NPLAMath 支持的不精确数允许自然地定义除数为不精确数 0 时的结果：
		NPLAMath 明确要求支持不精确数（而非 [RnRK] 作为可选的特性提供），能区分不精确数 0 和精确数 0 的不同结果。
		NPLAMath 的不精确数 0 允许支持符号据此确定作为商的无限值的符号（而非 [RnRK] 无法区分符号而无法按数学定义确定极限值的符号）。
	这些规则允许更优化的实现：
		避免要求实现检查特定的精确数（在此是精确数 0 ）的存在，而允许更简单高效的直接使用 flonum(@6.14.1) 内部操作的实现。
		不在此转换不精确数到精确数，和当前实现没有提供精确数可能替换计算结果中的不精确数的机制(@6.14.2) 具有更好的一致性。
	不存在 [RnRS] 需要关心继续使用 [R6RS] 规则的一些问题（参见 https://small.r7rs.org/ticket/367/ ）：
		在被除数和除数都存在零值时，没有同 [R6RS] 的 / 的例子要求结果的符号，逻辑上仍然能保持一致。
		NPLA1 不需要考虑不完全支持不精确数的（不满足 [RnRS] 符合性）的实现的兼容性等问题。
**注释**
同 [R7RS] ，若被除数是零值，且除数不是精确数 0 ，计算结果可能是精确数 0 。但当前实现没有提供精确数替换计算结果中的这种机制。
NPLA1 std.math 中 floor 和 truncate* 起始的函数的语义同 [R7RS] 的定义，要求参数是整数。一些 Scheme 实现不严格要求整数。
[R6RS] 的整除基本操作（过程 div 、mod、div0、mod0 ）没有严格定义，仅通过例子说明一些差异，但明确不要求整数。
[RnRK] 的整除同 [R6RS] ，但描述和 [R6RS] 矛盾；klisp 实现行为同 [R6RS] 。
更一般的定义参见 SRFI-141 和其它相关参考文献：
http://dl.acm.org/citation.cfm?id=128862
http://people.csail.mit.edu/riastradh/tmp/division.txt
https://www.gnu.org/software/guile/manual/html_node/Arithmetic.html
https://github.com/johnwcowan/r7rs-work/blob/master/WG1Ballot3Results.md#185-add-sixth-centered-division-operator
https://wiki.call-cc.org/eggref/5/srfi-141

@12.4 字符串：
通过初始化基础上下文后调用 Forms::LoadModule_std_strings(@8.5.2) 初始化，默认加载为根环境下的 std.strings 环境。
模块约定：
本节约定以下求值得到的操作数：
<regex> ：正则表达式。
对宿主语言互操作(@5.3) 支持，正则表达式以 std::regex 类型表示，实现保证可通过 string 初始化。
除非另行指定，以上所有正则表达式的操作使用 ISO C++11 指定的默认选项，即：
std::regex_constants::ECMAScript ；
std::regex_constants::match_default ；
std::regex_constants::format_default 。
操作：
string? <object> ：<string> 的类型谓词(@10.5.2.1) 。
++ <string>... ：字符串串接。
string-empty? <string> ：判断字符串是否为空。
string<- <string1> <string2> ：字符串赋值(@9.8.3.1) 。
以第二参数为源，修改第一参数指定的目标。
string-split <string1> <string2> ：取第二参数分隔第一参数得到的字符串的列表。
string-contains-ci? <string1> <string2> ：判断第一参数是否包含第二参数作为子串，忽略大小写。
只在单字节字符集内的字符中区分大小写。
string->symbol <string> ：转换字符串为符号。
symbol->string <symbol> ：转换符号为字符串。
不检查值是否符合符号要求。
string->regex <string> ：转换字符串为以这个字符串作为串的正则表达式。
若正则表达式无效，则引起错误(@9.5.1) 。
regex-match? <string> <regex> ：判断字符串中是否匹配正则表达式的模式串。
若 <string> 匹配 <regex> 指定的模式串，结果是 #t ，否则结果是 #f 。
regex-replace <string1> <regex> <string2> ：替换字符串中的模式串，构造新字符串。
在 <string1> 的副本中搜索正则表达式指定的模式串的所有匹配，替换为 <string2> 指定的格式字符串。
结果是替换后的字符串。
**注释**
当前实现不处理宿主抛出的 std::regex_error 异常。

@12.5 输入/输出：
通过初始化基础上下文后调用 Forms::LoadModule_std_io(@8.5.2) 初始化，默认加载为根环境下的 std.io 环境。
readable-file? <string> ：判断参数指定的文件名对应的文件是否存在且可读。
readable-nonempty-file? <string> ：判断参数指定的文件名对应的文件是否存在、可读且文件内容非空。
writable-file? <string> ：判断参数指定的文件名对应的文件是否存在且可写。
() newline ：输出换行并刷新缓冲。
若无法输出，则没有作用。
put <string> ：输出字符串。
puts <string> ：输出字符串和换行并刷新缓冲。
**注释** 同 puts 和 newline 的组合。
load <string> ：加载参数指定的翻译单元作为源的模块(@10.2) 。
加载时创建新环境(@9.9.2) ，以此为当前环境读取翻译单元后求值，以求值后的这个环境对象作为调用的结果。
当前实现中，参数为文件系统路径。
被加载的翻译单元视为对象的外部表示(@4.1.1) ，经读取翻译为 NPLA1 对象。
类似 klisp 的同名操作。类似地，不使用 klisp 的 find-required-filename 机制，直接以宿主的运行环境为基准使用路径。
和 klisp 不同，在尾上下文中求值被加载后读取的对象，并以其求值结果作为表达式的求值结果。
[Shu09] 缺少 load 的详细描述而仅有标题。
get-module <string> <environment>? ：创建标准环境并在其中加载模块。
创建新(@9.9.2.2) 标准环境并以这个环境为当前环境加载 <string> 指定的翻译单元作为源的模块。
若第二参数非空，则在加载前首先设置创建的环境中的 module-parameters 变量为第二参数的值。
加载完成后取得调用结果。
结果是先前被创建的标准环境。
同 klisp 和 [Shu09] 中的同名操作。
**原理**
和 [R7RS] 不同，load 不支持指定环境，而总是使用当前环境。
类似 Kernel ，当前环境可通过不同机制改变，而不需由 load 提供特设的支持。例如，可使用 eval(@11.3.7) 指定蕴含 load 的调用的求值使用的环境。
load 的语义隐含从外部来源取得求值构造后在当前环境求值，其中的求值明确允许隐含副作用。这和其它一些语言的类似命名的功能（如 Lua 的 loadfile ）不同。在此，load 的求值被视为初始化加载的模块过程中的一部分。
因为当前不提供取得求值构造的读取(read) 等函数，不要求 load 具有非本机的派生实现。并且，取得求值构造可能有其它方式，如从二进制映像映射(map) 到内部表示等替代，这些实现通常不应被要求为总是具有本机派生实现而降低实现质量。
**注释**
关于 newline 、put 和 puts ：
实现使用 GlobalState::GetOutputStreamRef(@7.8.1) 。
在使用前，一般应初始化 GlobalState::OutputStreamPtr(@7.8.1) 指向特定的 std::ostream 对象；否则，总是失败，引起错误(@9.5.1) 。
关于 load 和 get-module ：
参数一般指定视为外部翻译单元的文件名。
http://klisp.org/docs/Ports.html#Ports 的 load 描述中求值环境有误：
	按 [Shu09] 一致的描述和 klisp 的实际实现，调用 load 时应在当前环境求值，而不同于 [Shu09] 的 get-module 中描述的使用创建的新标准环境进行求值。
	否则，使用 [Shu09] 的 get-module 的派生不能实现 klisp 和 [Shu09] 中描述的 get-module 的预期语义。

@12.6 系统：
通过初始化基础上下文后调用 Forms::LoadModule_std_system(@8.5.2) 初始化，默认加载为根环境下的 std.system 环境。
模块约定：
文件系统中创建或移除项的函数调用结果是表示操作是否成功的 <bool> 值。
除非另行指定：
对创建目录的函数，在若目录已存在，则视为操作失败且无作用；否则，若创建失败，则引起错误。
对创建多个目录的函数，仅在所有目录都创建成功时操作成功。操作失败可能仍存在部分目录被创建成功。
对象：
version-string ：当前实现的版本字符串。
类型为 <string> 。
**注释** 本实现使用 YSLib::FetchBuildNumber 取得值计算的结果，符合语义版本（参见 https://semver.org/lang/zh-CN/ ）的版本格式。
build-number ：当前实现的构建版本号。
类型为 <integer> ，值为正整数。
**注释** 本实现使用 YSLib::FetchBuildNumber 取得值。
revision-description ：实现的版本说明。
类型为 <string> 。
**注释** 本实现使用 YSLib::FetchVCSRevisionString 取得值。
操作：
() get-current-repl ：取表示当前 REPL 环境的引用值。
eval-string <string> <environment> ：在参数指定的环境中求值作为外部表示的字符串。
类似 klisp 的同名操作，参见 http://klisp.org/docs/Environments.html#Environments 。
eval-string% <string> <environment> ：在参数指定的环境中求值作为外部表示的字符串。
类似 eval-string ，但保留引用值。
eval-unit <string> <object> ：在参数指定的 REPL 环境中规约字符串表示的翻译单元以求值。
() cmd-get-args ：返回宿主环境(@2.6.1) 程序接受的命令行参数列表。
其中参数数组保存在函数 YSLib::LockCommandArguments 访问的对象中。
传递给 REPL 的命令行参数通常是宿主程序中主函数的 argv 参数数组中处理后去除特定参数后的程序。
宿主程序复制 argv 到这个数组作为副本后，作为函数值的列表的来源。
env-get <string> ：取宿主环境的环境变量字符串。
字符串参数指定环境变量的名称。
env-set <string1> <string2>：设置宿主环境的环境变量字符串。
两个字符串参数分别指定环境变量的名称和设置的值。
注意使用 env-get 和 env-set 及对应宿主环境的操作不保证线程安全。
env-empty? <string> ：判断字符串指定名称的环境变量是否为空。
system <string> ：以 std::system 兼容的方式调用外部命令。使用 YSLib::usystem 实现。
**注释** 类似 https://www.scheme.com/csug8/foreign.html ，但更接近 ISO C 和 ISO C++ 的原始含义，当前不提供关于信号等依赖特定实现环境的保证。
system-get <string> ：调用命令，返回命令调用结果。
返回一个两个元素的列表，分别是管道输出字符串和命令返回的 int 类型的命令退出状态。
调用命令和 system 的方式类似。
system-quote <string> ：检查参数，按需返回以半角双引号引用的用于命令行参数的字符串。
带空格或水平制表符的字符串、以半角引号开始或结束的字符串和空字符串会被引用。
remove-file <string> ：移除参数指定的路径命名的文件。
create-directory <string> ：创建参数指定的名称的文件系统目录。
create-directory* <string> ：创建参数指定的名称的文件系统目录及其必要的父目录。
create-parent-directory* <string> ：创建参数指定的名称对应的父目录及其必要的父目录。
absolute-path? <string> ：判断参数是否指定绝对路径。
make-temporary-filename <string1> <string2> ：取适合命名新创建的临时文件随机文件名。
参数分别指定前缀和后缀。参数可能为空。随机文件名以生成的有限长度的随机字符串添加前缀和后缀组成。
生成的字符串只包含 C++ 基本字符串的可打印字符，且不使用大写字母，以兼容大小写不敏感的文件系统。
随机的文件名被打开以检查是否可访问。若失败则重试，若最终失败，则引起错误。
**注释** 当前实现中的随机字符串长度为 6 。当前实现中重试的上限是 16 次（宿主平台）或 1 次（非宿主平台）。若最终失败，抛出 std::system_error 异常。
**原理**
create-directory 在一些其它语言的实现中命名为 make-directory 。
NPLA1 中，作为非正式约定，make 前缀被预留给通过函数值得到创建的对象的过程。
这和 Guache 不区分两者不同（参见 https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html ）。
使用 create-directory 的命名也和 SRFI-170 一致，但 NPLA1 中，目录存在时不引起错误而以函数值 #f 指示。
此外，ISO C++ 中存在类似名称的函数 std::filesystem::create_directory 。
NPLA1 中，create-directory 和 create-directory* 只创建一级目录时的行为确保一致。
**注释**
当前实现依赖可用的 std.strings(@12.4) 环境。
当前实现的文件系统操作失败可能修改宿主环境的 errno 。
remove-file 类似 [R7RS] 的 delete-file ，但通过函数值指定调用失败而费引起错误。
create-directory 类似：
	Checken 的同名过程，但不支持可选参数且函数值不同。
	Scsh 的同名过程，但不支持包括权限的可选参数且函数值不同。
	Chez Scheme 和 Guile 的 mkdir ，但不支持可选的权限参数且函数值不同。
	Bigloo 的 make-directory ，但可能引起错误。
	[Racket] 的 make-directory，但不支持非字符串参数和可选的权限参数，且通过函数值指定调用失败而非引起错误。
参见：
http://api.call-cc.org/5/doc/chicken/file#def:create-directory
https://scsh.net/docu/html/man-Z-H-4.html#node_sec_3.3
https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:h16
https://www.gnu.org/software/guile/manual/html_node/File-System.html
http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17247
https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28quote._~23~25kernel%29._make-directory%29%29
create-directory* 类似：
	Bigloo 的 make-directories ，但可能引起错误。
	Guache 的 make-directory* 和同名过程，但不支持可选的权限参数。
	[Racket] 的 make-directory* ，但不支持非字符串参数和可选的权限参数。
参见：
http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter5.html#G17256
https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#Directory-utilities
https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-directory%2A%29%29
create-parent-directory* 类似 [Racket] 的 make-parent-directory* ，但不支持非字符串参数和可选的权限参数。
参见：
https://docs.racket-lang.org/reference/Filesystem.html#%28def._%28%28lib._racket%2Ffile..rkt%29._make-parent-directory%2A%29%29
当前实现中，若创建目录失败而引起错误，抛出 std::system_error 异常。
absolute-path? 同：
	Guache 的同名过程。
	Chez Scheme 的 path-absolute? 。
	Guile 的 absolute-file-name? 。
参见：
https://practical-scheme.net/gauche/man/gauche-refe/Filesystem-utilities.html#Directory-utilities
https://cisco.github.io/ChezScheme/csug9.5/io.html#./io:h16
https://www.gnu.org/software/guile/manual/html_node/File-System.html
make-temporary-filename 的功能类似 POSIX ::tmpnam 和 ::mkstemp ，以及 Guile 对应的过程 tmpnam 和 mkstemp ，有以下不同：
	和 tmpname 类似，结果是文件名，而不是打开的文件或端口。
	和 mkstemp 类似，使用模板字符串作为文件名，但模板不在参数中指定。
	保证生成的文件名的兼容性。
参见：
https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html
https://www.gnu.org/software/guile/manual/html_node/File-System.html

@12.7 模块管理：
通过初始化基础上下文后调用 Forms::LoadModule_std_modules(@8.5.2) 初始化，默认加载为根环境下的 std.modules 环境。
模块约定：
需求字符串(requirement string) 是具有 <string> 类型的非空字符串。
若操作的形式参数是需求字符串，实际参数是空字符串，则引起错误(@9.5.1) 。
本模块共享可变管理状态(@9.8.3) ，以支持操作访问确定的模块字符串集合。
本模块隐含一个字符串序列作为需求字符串模板。
除非派生实现另行指定，需求字符串模板初始化后不可变。
需求字符串模板初始化的值由实现定义。
**注释** 当前实现中，若环境变量 NPLA1_PATH 的值非空，则需求字符串模板是这个值以单字符子串 ";" 分隔后的结果；否则，默认值是序列 "./?" 和 "./?.txt" 构成的序列。
操作：
registered-requirement? <string> ：判断参数是否是已在本模块注册的需求字符串。
register-requirement! <string> ：在本模块注册参数为需求字符串。
若已被注册，则引起错误；否则，在内部创建新标准环境。
结果是创建的环境的弱引用(@6.11.1) 。
unregister-requirement! <string> ：在本模块注册解除参数为需求字符串。
find-requirement-filename <string> ：查找需求字符串对应的文件名。
在需求字符串模板中顺序地搜索字符串。若不存在这样的结果，则引起错误；否则，结果是匹配字符串的搜索结果。
判断需求字符串模板中的每一个字符串是否能被需求字符串匹配时，首先替换字符串中的单字符子串 "?" 为需求字符串，取得替换结果，再判断它是否为可读的文件的文件名。
替换字符串时，每一个子串被同时一次替换；不对替换结果进一步递归地替换。
require <string> ：按需在新(@9.9.2.2) 标准环境加载需求字符串对应的模块。
若参数指定的需求字符串没有注册，则注册需求字符串并加载同调用 find-requirement-filename 等价的方式搜索得到的结果，并保存加载的结果；否则不进行加载。
结果是保存的加载的结果。
**原理**
为避免名称污染等问题，不提供显式指定命名环境的模块创建操作，如 Lua 5.1 的 module 函数（http://www.lua.org/manual/5.1/manual.html#pdf-module ）。
具体问题参见 http://lua-users.org/wiki/LuaModuleFunctionCritiqued 。
不提供访问创建的环境的操作，以避免污染外部的访问。若需公开其中的变量绑定，可使用返回或模块参数。
操作的设计同 klisp 的 ports 模块中的同名操作，但有以下不同：
同时保存创建的环境，以避免因程序没有保存环境引用而无效化(@9.8.6) ，使访问变量绑定的程序具有未定义行为；
结果是加载结果（同 std.io 模块中的 load(@12.5) ）而不是 #inert 。
**注释**
当前派生实现依赖可用的 std.strings(@12.4) 、std.io(@12.5) 和 std.system(@12.6) 环境。
通过不经过本模块的操作、重复字符串模板的重复项、符号链接和字符串大小写不敏感的文件名等可能绕过本模块的注册机制而重复加载同一个外部文件。本模块的操作不对这些情形进行任何检查。
当前使用 Forms::LoadModule_std_modules(@8.5.2) 实现，不对并发访问进行控制。
需注意外部环境(@9.1.1) 中不受到控制的并发访问可能引起宿主语言未定义行为(@5.4.3) 。

@13 SHBuild 实现环境：
SHBuild 实现环境是派生 NPLA1 参照实现扩展环境(@12) 的用于 SHBuild 和外部脚本的构建的初始环境(@10.1) 。
SHBuild 实现环境的初始化(@10.1.1) 可加载模块(@10.2) ，这些模块的加载适用和标准库实现相同的要求和假定(@10.2.1) 。
关于 SHBuild 的调用方式说明，详见 https://frankhb.github.io/YSLib-book/SHBuild.zh-CN.html 。
操作约定同 @10 ，包括 @10.4 和 @10.5 ；但除此之外，遵循 NPLA1 用户程序(@9.1) 的约定。

@13.1 NPL::Dependency 派生特性：
SHBuild 实现环境由 NPL::Dependency 提供初始的派生特性。
在基础上下文(@8.5.2) 上，SHBuild 实现环境通过切换新环境(@9.9.2.2) 并调用 Forms::LoadModule_SHBuild(@8.5.2) 初始化。
SHBuild 的基础环境(@10.1) 的子环境中提供对象引用 env_SHBuild_ ，其中包含这些特性。
部分 SHBuild 互操作特性(@13.1.1) 在 YFramework 的 NPL::Dependency 实现中提供。
此外，NPLA1 在默认实现的 SHBuild_BaseTerminalHook_(@13.1.1) 的实现被覆盖，以使 SHBuild_EchoVar(@13.1.1) 等和 SHBuild 的其它输出兼容。

@13.1.1 SHBuild 互操作特性：
以下互操作(@1.2.3) 特性用于 SHBuild 和外部脚本的构建。
通过初始化基础上下文后调用 Forms::LoadModule_SHBuild(@8.5.2) 初始化，加载为根环境下的 env_SHBuild_ 环境。
这些特性主要用于内部使用，不保证稳定（特别是带有 _ 后缀的非公开绑定）。
SHBuild_BaseTerminalHook_ ：内部对象，用于终端控制。
SHBuild_DirectoryOf_ <string> ：参数字符串视为路径，返回字符串指定的路径所在的父目录（当路径非根目录），或路径自身转换到的字符串。
返回的路径不带有结尾分隔符。不检查路径实际存在。
SHBuild_EchoVar <string1> <string2> ：在终端输出变量及其值。
SHBuild_Install_HardLink <string1> <string2> ：以参数作为目标和源路径，安装硬链接。
检查源路径不是目录。若目标路径已存在文件则首先移除。
然后在目标路径创建源路径指定的文件的硬链接。若创建失败，则复制源路径指定的文件到目标路径。
SHBuild_QuoteS_ <string> ：为字符串添加单引号，以允许在 Shell 代码中使用。
处理时复用词法分析(@6.1.5) 和语法分析(@6.1.6) 的部分实现。同词法分析规则(@3.3.5) ，不对空字符特殊处理。
SHBuild_RemovePrefix_ <string1> <string2> ：若第二参数是第一参数的前缀则结果是移除前缀的字符串，否则是第一参数。
SHBuild_SDot_ <string> ：替换字符串的点为下划线。
SHBuild_TrimOptions_ <string> ：清理选项字符串的空白符。

@13.2 外部派生特性：
以下 SHBuild 互操作特性及脚本调用接口可能在外部程序（包括提供 NPLA1 实现环境的程序如 SHBuild 工具和 NPLA1 脚本等）中实现。
因为相对其它外部 NPLA1 接口，作用和名称保持稳定，也在此提供文档。
此处的作用会影响加载所在翻译单元的其它翻译单元。
前缀 SHBuild_ 的特性被设计为可被其它程序使用，但接口仍可能改变。部分特性参见外部用户文档 https://frankhb.github.io/YSLib-book/Scripts.zh-CN.html 。

@13.2.1 序(prelude) ：
除 move!(@11.3.4) 及显式检查类型的赋值（如 string<-(@12.4) ）外的不安全操作(@9.4.5) 被禁用，调用时引起错误(@9.5.1) ：
assign%!(@11.4.1)
assign@!(@11.4.1)
copy-environment(@11.3.7)
lock-environment(@11.3.7)
$defrec!(@11.3.7)
$setrec!(@11.4.1)
创建以基础环境为父环境(@9.9.2) 的环境的以下函数(@11.4.1) 被重新定义返回禁用了上述操作的环境：
make-standard-environment
derive-environment
注意派生这些不安全的操作的操作如 lock-current-environment 未被禁用。

@13.2.2 简单扩展接口：
SHBuild 提供以下可仅依赖标准库(@10.3.3) 派生的可移植操作：
$redef! <definiend> <body> ：重定义。
同 $def!(@11.3.7) ，用于显式指定变量绑定在定义的环境中被替换，可能简化安全性证明(@9.4.6.1) 。
当前实现为 $def! 的副本。
$set-if-empty! <variable> <body> ：若第一参数指定的变量在当前环境中的值是空字符串，则修改绑定。
修改绑定的作用同当前环境中使用 $set!(@11.4.1) 。
cons-cmd <string>... ：串接命令。
参数指定构成命令的字符串。空字符串被忽略。结果是没有被忽略的字符串构成的串接，每个字符串附带一个后缀空格。
rmatch? <string1> <string2> ：简单正则匹配。
使用 std.strings(@12.4) 的操作：
设参数列表 (&x &r) ，结果同求值 regex-match? x (string->regex r) 。
putss <string>... ：输出串接的字符串。
以 puts(@12.5) 输出参数字符串的串接结果。
system-ok <string> ：调用外部命令并判断是否调用成功。
使用 system(@12.6) 调用外部命令。
若 system 调用的值等于 0 ，结果是 #t ；否则，结果是 #f 。
win32? <string> ：判断字符串是否等于 "Win32" 。

@13.2.3 SHBuild 错误和调用例程：
cmd-fail <string> ：为参数指定的命令字符串抛出异常。
抛出的异常消息包含参数值。
system-check <string> ：调用外部命令并检查。
使用 system-ok(@13.2.2) 调用命令和判断错误。
若调用失败，则使用 cmd-fail 抛出异常。
$set-system-var! <variable> <string> ：设置变量绑定的值为命令结果。
若第一参数指定的变量在当前环境中不存在绑定，则修改绑定为调用作为外部命令的第二参数的值的结果。
使用 system-get(@12.6) 调用命令。
判断错误的逻辑同 system-ok(@13.2.2) 。
若调用失败，则使用 cmd-fail 抛出异常。
$assert <variable> <predicate> <string> ：断言第一参数指定的变量在当前环境中存在绑定，且其值符合第二参数指定的谓词。
当断言失败时抛出异常。
抛出的异常消息包含第三参数值。
$assert-nonempty <variable> ：断言参数指定的变量在当前环境中存在绑定，且其值是非空字符串。
$assert-absolute-path <variable> ：断言参数指定的变量在当前环境中存在绑定，且其值是表示文件系统绝对路径的字符串。

@13.2.4 环境变量缓存：
脚本缓存环境变量并在访问缓存时可能按外部环境的要求以未指定的方式跟踪环境变量的访问操作。
缓存的环境变量的值在使用缓存的函数第一次访问时确定。若环境变量未设置，则缓存的值为空；否则，缓存的值被初始化为环境变量的值。
对环境变量的直接访问是使用系统模块(@12.6) 的 env-get、env-set 和 env-empty? 的访问，忽略缓存的环境变量。直接设置环境变量不更新缓存的值。
自本节起，除非另行指定，本章的特性访问环境变量时，使用缓存的环境变量。
带缓存环境变量的访问接口如下：
safeenv-get <string> ：同 env-get ，但使用缓存。
safeenv-set <string1> <string2> ：同 env-set ，但使用缓存。
ss-verbose-puts <string> ：若初始化时环境变量 SS_Verbose 的值非空字符串非空则调用 puts(@12.5) 输出参数。
safeenv-empty? <string> ：同 env-empty? ，但使用缓存。
safeenv-restore <string> ：重置参数指定名称的环境变量为缓存的值。
$lazy-env-val <string> <body> ：创建初始化参数指定名称的环境变量的值的求值代理对象(@12.2) 。
若第一参数指定名称的环境变量非空，则结果被求值时，求值 <body> 取得求值结果。
$env-de! <variable> <body> ：按环境变量定义变量的值。
使用 $def!(@11.3.7) 定义第一参数指定的变量绑定。
若变量同名的环境变量具有非空值，则定义的变量的值为等于这个值的字符串；否则，求值 <body> 并定义变量的值为求值结果。
定义变量使用的绑定的初值符是以 desigil(@11.3.6) 的方式移除标记字符(@9.2.2.4) 后的参数。

@13.2.5 其它 SHBuild 派生特性：
变量 SHBuild_Env_OS ：参见用户文档。
变量 SHBuild_Env_Arch ：参见用户文档。
() SHBuild_GetPlatformStrings ：取操作系统和体系结构字符串列表。
代替 shell 脚本的 SHBuild_PrepareBuild 初始化的宿主环境变量。
() SHBuild_Extend_CallVariables ：扩展特定的环境变量的值为 SHBuild 工具接受的环境变量。
环境变量扩展通过确定名称的被扩展的环境和扩展其的前缀环境变量指定。
若前缀环境变量的当前值非空，被扩展的环境被设置为一个新值。新值是其当前值被添加对应前缀环境变量的值，且在两者之间添加一个空格构成。
取被扩展的环境变量的当前值时直接访问环境变量。
访问环境变量的顺序未指定。
当前扩展的环境变量包括：
使用 SHBuild_LDFLAGS 扩展 LDFLAGS ；
使用 SHBuild_LIBS 扩展 LIBS 。
以下 API 的具体功能参见用户文档中脚本的说明；对函数 shell 脚本中存在的同名函数，参数可能不同。
SHBuild_2m <string> ：以 cygpath -m 转换参数指定的路径作为结果，若失败则结果是参数。
SHBuild_2u <string> ：以 cygpath -au 转换参数指定的路径作为结果，若失败则结果是参数。
SHBuild_2w <string> ：以 cygpath -w 转换参数指定的路径作为结果，若失败则结果是参数。
SHBuild_EchoVar_N <string> ：在终端输出环境变量及其值。
() SHBuild_GetTempDir ：取临时目录。
SHBuild_GetSystemPrefix <string> ：取系统前缀字符串。
SHBuild_Platform_Detect <string1> <string2> ：取系统前缀字符串。
SHBuild_CheckCXX <string1> <string2> ：尝试调用第二参数指定的编译器的特定命令行以检查 C++ 编译器风格。
结果是风格名称，为 "G++" 或 "Clang++" 之一。
第一参数指定的宿主操作系统字符串用于缓存结果。对所有参数都相同的调用，不重复调用编译器命令。

*/
////

