/*
	© 2012-2020 FrankHB.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file NPL.txt
\ingroup Documentation
\brief NPL 规格说明。
\version r14782
\author FrankHB <frankhb1989@gmail.com>
\since build 304
\par 创建时间:
	2012-04-25 10:34:20 +0800
\par 修改时间:
	2020-06-12 20:11 +0800
\par 文本编码:
	UTF-8
\par 模块名称:
	Documentation::NPL
*/


/*

@0 前言(Preface) ：
本文档适用于 NPL(@1.2) 及实现 。

@0.1 体例说明：
引用标记参见 [Documentation::CommonRules @@0.1] 。
项目范围参见 [Documentation::ProjectRules @@1] 。
编码细节和其它规范参见 [Documentation::Designation] 。

@1 绪论(Introduction) ：

@1.1 正式引用(Normative references) ：
@1.1.1 的简写引用的来源同 [Documentation::CommonRules @@1.1] 。
以下作为概念定义参考的文档的来源同 [Documentation::CommonRules @@1.1] ：
— ISO/IEC 2382 (all parts), Information technology — Vocabulary
以下其它文档也在本文中引用：
Revised Report on the Algorithmic Language Scheme ([RnRS])
	http://www.scheme-reports.org/
	当前 [RnRS] 已出版多个版本，但引用时不涉及其具体差异。
Revised Report on the Kernel Programming Language ([RnRK])
	https://web.cs.wpi.edu/~jshutt/kernel.html
	Revised^-1 Report on the Kernel Programming Language ([Shu09])
		ftp://ftp.cs.wpi.edu/pub/techreports/pdf/05-07.pdf
	当前 [RnRK] 只有 n = -1 的版本。引用确切版本时，同 [Shu10] 中的用法，使用 [Shu09] 标记；但引用时一般同样不涉及其版本差异。
The Rust Reference ([Rust])
	https://doc.rust-lang.org/reference/index.html
Referential transparency, definiteness and unfoldability ([So90])
	http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf
Proper Tail Recursion and Space Efficiency ([Cl98])
	https://www.researchgate.net/profile/William_Clinger/publication/2728133_Proper_Tail_Recursion_and_Space_Efficiency/links/02e7e53624927461c8000000/Proper-Tail-Recursion-and-Space-Efficiency.pdf
其它文中局部使用的文献暂不在此列出。

@1.1.1 引用简写：
以下引用简写同 [Documentation::CommonRules @@1.1.1] 。
ISO C
ISO C++
ISO C++11
ISO C++14

@1.2 需求概述：
设计满足的需求描述参考 https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md 。
需求来源：
出发点：构建一个可用计算机实现的语言。
基本目的：在以标准 C++ 环境（ ISO C++ 定义的宿主实现(hosted implementation) ）的程序框架中嵌入配置和脚本操作。
扩展目的：渐进地向独立的计算机系统演进，探究能适用于各个领域并以计算机实现的通用目的语言(general-purpose language) 。
本文描述基于此出发点的 NPL(Name Protocoling Language) （一个替代的递归缩写是“NPL's not a Programming Language”，因其不仅适合作为 PL 的元语言特性）及其参考实现。
和大部分其它设计不同，为了确保一定程度的适应通用目的的性质，它们被设计整体首要考虑。这样的设计的语言是（自设计(by desing) 用于）满足通用目的的语言(general-purposed language) 。

@1.3 其它设计和实现参考：
NPL 是独立设计的语言，但它和 [RnRK](@1.1) 定义的 Kernel 有许多核心设计的相似之处，尽管设计的一些基本特征（如 @2.1.1.1 ）以及基本哲学(@1.4) 相当不同（参见 @2.2.3 ）。
NPL 的主要实现(@7) 的核心部分实质上支持了 Kernel 的形式模型(@2.1.1) —— vau 演算(vau calculi) 。具体的 NPL 语言在这些模型的基础上提供。
NPL 的命名(@2.1) 即体现了 vau 演算和传统 λ 演算(@4.5) 为模型的语言的核心差异：
强调表达式(@3.4.2) 求值(@4.1) 前后的不同，特别地，关注在语言中直接表达的名称(@2.3.2) 和求值(@4.1) 后指称的实体的不同(@2.3.2) 。
更进一步地，NPL 普遍地支持区分一等引用(@4.2.3) 和被引用的一等实体(@4.1) 并具有更精确的资源控制机制，这是与 Kernel 的主要设计上的差异。
关于 vau 演算的形式模型和其它相关内容，详见：
http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf ([Shu10])
关于 vau 演算的历史，详见 fexpr （另见 @7.3.6 ）：
https://en.wikipedia.org/wiki/Fexpr
关于一些其它支持 fexpr 特性的语言设计，参见：
PicoLisp ： https://software-lab.de/doc/faq.html#lambda
newLISP ： http://www.newlisp.org/downloads/newlisp_manual.html#define-macro
和 Kernel 以及本设计不同，这两个例子的设计使用动态作用域(@4.6.1.1.2) ；在主要的特性中存在一些关键的不同而在形式模型的适用性上有显著的区别。

@1.4 领域设计原则：
本节描述适用于满足通用目的的语言(@1.2) 的设计。
原则是关于设计和实现的哲学，同时作为一般规则约束设计和实现的工程阶段。

@1.4.1 本体论(ontology) ：
为使论述有效，约定本体论规则。
基本的本体论规则是约束逻辑系统构造的公理。

@1.4.1.1 正规性：
有效的陈述（如需求描述）应保证操作上可预期结果。
在此意义下，缺乏约束性的规则不可预期的风险是代价。
推论：规则应适当约定适用范围，以避免外延不清。

@1.4.1.2 存在性：
语义的存在体现本质。
仅仅应用语法规则，即限定为语法的文法(syntactic grammar) 的形式系统归纳的设计，不表示任何有效(@1.4.1.1) 的含义。

@1.4.1.3 名实问题：
名义概念的内涵和外延应被足够显式指定，避免指涉上的歧义，允许构造有效的陈述(@1.4.1.1) 。

@1.4.2 价值观：
价值观是关于价值判断的规则，其输出为二元的值，决定是否接受决策。
作为应对普遍需求场景的不同解决方案选型时的价值判断的抽象归纳，价值观被作为比较是否采用设计相关决策的全局依据。
以下陈述形式表达价值优先的选项，同时作为公理。

@1.4.2.1 变化的自由：
在明确需求的前提下，尽可能保证对现状按需进行改变的可行性和便利性。
适用于一般需求。
一般地，需求可能随着不可控的外部条件变化。假设已明确的需求不变只能适合相当有限的情形。积极应对变化能提供价值。
对计算机软件或其它可编程的实体：尽可能避免不必要地损失可修改性，便于保障按需引入或除去接口(@2.3.1.2) 及其实现的自由。

@1.4.2.2 避免不必要付出的代价：
尽可能消除对满足需求无意义的代价，减少影响需求实现的整体成本。
适用于一般需求中设计决策的比较。
对计算机软件或其它可编程的实体：不为不需要的特性付出代价。
Efficiency has been a major design goal for C++ from the beginning, also the principle of “zero overhead” for any feature that is not used in a program. It has been a guiding principle from the earliest days of C++ that “you don’t pay for what you don’t use”.
	-- ISO/IEC TR 18015

@1.4.2.3 最小接口原则：
在满足需求的前提下，尽可能使用符合倾向减小实现需求代价（如减小设计工作量等）的单一良基关系下具有极小元的接口设计。
这是一条模式规则，依赖具体情形何者符合良基关系的极小元这条非模式规则作为输入。
实际使用时，非模式规则可以直接指定为二元关系的子集，或者一种良序的度量（如“公开函数声明数”“模块数”）。
注意规则指定的基数是对实现需求有意义的代价，因此不涵盖 @1.4.2.2 。
在确定的范围内尽可能少地提供必须的接口，避免不必要的假设影响接口适应需求的能力，同时减少实现需求的各个阶段的复杂性。
适用于一般需求的实现，特别地，强调“通用”目的时。
对需要在计算机上实现的人工语言设计：设计语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。
Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.
	-- [RnRS] & [RnRK]
其它各个领域中的实质等价表述包括：
用于安全系统设计的最小特权原则(@1.4.4.2) ；
用于自然科学理论设计的奥卡姆剃刀(Occam’s Razor) 原理，避免不必要的假设引入诉诸无知(argument from ignorance) 谬误。
另见 [Documentation::CommonRules @@3.1.3] 。

@1.4.2.4 关注点分离原则(separation of concerns) ：
局部设计的内容应和需求的陈述或其它隐含的设计前提分别一一对应。
适用于一般需求的实现，特别是其中依赖认识论观点的过程。
这条规则利用需求和设计内容陈述中概念外延普遍蕴含的局域性(locality) ，提供给定代价下更多的可行性或求解给定问题时使用较小的代价，用于：
应对不可控复杂条件下使问题可解；
局部可复用现有解的子集。
此外，尽管并非总是必要，应用知识内容的简单假设、@1.4.2.3 和本原则可在认识论上导出还原论。

@1.4.3 形而上学(metaphysics) ：
根据作为需求的 @1.4.2 ，归纳适用于通用目的语言应有的构成及其性质的设计规则，包括三条价值判断实现公理：
设计应尽可能满足正确性(@1.4.3.1) ；
设计应尽可能满足简单性(@1.4.3.2) 。
设计的正确性应优先于简单性。
注意和 Worse is better 或 The MIT approach 不同，设计的性质并非完全并列。
具备这些性质的设计可视为由价值判断(@1.4.2) 蕴含，预设前提为真的设计方法论(@1.4.6) 的实现。

@1.4.3.1 正确性(correctness) ：
设计应正确地反映需求，不在需求的基础上新增作为实现细节以外的不确定性。
无法确保满足正确性要求时，不应继续设计。
正确性包含可行性(feasibility) 。
若无法满足正确性，则需求输入存在问题。
正确性不包含但应逻辑蕴含设计的一些其它性质。若无法实现，则具体性质的定义存在问题。
保持正确性作为设计评价的首要依据以使决策简单，同时能符合价值判断(@1.4.2) 。

@1.4.3.1.1 完整性(completeness) ：
正确性应蕴含完整性。
由 @1.4.3.1 的推论：设计应包含完整的需求响应。

@1.4.3.1.2 一致性(consistency) ：
正确性应蕴含一致性。
由 @1.4.3.1 的推论：设计应保证一致性。

@1.4.3.2 简单性(simplicity) ：
在满足正确性的前提下，接口设计应尽可能简单。
接口设计的简单性优先于实现的简单性。

@1.4.3.3 可修改性(modifiablity) ：
在满足需求的前提下，修改应尽可能少地有碍于其它的接口。
这是 @1.4.2.1 的推论。

@1.4.3.4 避免抽象泄漏(abstraction leak) ：
泄漏的抽象(leaky abstraction) 指抽象的底层复杂性没有被抽象合理地隐藏(@1.4.6.3) ，而在一定程度上构成了利用抽象时的不必要的依赖。
抽象泄漏的结果直接和避免不必要付出的代价(@1.4.2.2) 、关注点分离原则(@1.4.2.4) 和简单性(@1.4.3.2) 冲突。
同时，抽象的有效性被削弱，泄漏构成的不被预期的依赖难以满足正确性(@1.4.3.1) ；只要有避免抽象泄漏的方法，就不满足最小接口原则(@1.4.3.2) 。
因此，只要可能，避免抽象泄漏。

@1.4.3.5 关注资源限制：
为了可实现性，宿主(host) 系统对总的资源（典型地，运行程序需要的存储）有未指定(@2.3.2) 的上限。
除此之外，接口抽象不附加接口语义要求以外的限制。
这个原则同时利于满足正确性(@1.4.3.1) 和简单性(@1.4.3.2) 。而不遵循这个原则的设计在接口描述上违反 @1.4.2.3 。
在允许实现的前提下，附加具体特性上的使用限制（如 ISO C ）可放宽对实现的要求；但无原则地随意选取此处的限制不足以直接证明具体的限制的有效性，而依赖实际实现的情况才能判断，造成抽象泄漏(@1.4.3.4) 。
实例：PicoLisp 使用符合此原则的设计。

@1.4.3.6 开放性(openness) ：
除非另行指定，不假定实体不存在。
这个原则主要用于建模(modeling) 的依据。对一般的模型，这个原则称为开放世界假设(open-world assumption) 。
与之相对，封闭世界假设(closed-world assumption) 需要提前设置一个全集以保持合规。
封闭世界假设表面上可能简化实现，但在一般的模型中是不必要的，因为保持问题合规性的论域应已由清晰的需求描述规范，不应为此阻碍 @1.4.2.1 的实现。

@1.4.4 结构和依赖原则：

@1.4.4.1 接口设计和实现分离：
语言设计独立于语言实现(@2.3.2) 。
这是同时应用 @1.4.2.3 和 @1.4.2.4 的推论。
这种分离允许避免抽象泄露(abstraction leaking) 。
典型地，使用提供接口抽象层作为必要构造的架构方法，即分层设计。

@1.4.4.2 最小特权原则(principle of least privilege) ：
除非有必要，接口抽象不提供满足需求以外的其它信息和资源。
这是 @1.4.2.3 在限制适用领域前提下的等价表述之一，用于避免不必要的访问路径引入额外的安全(safety) 风险，更容易满足（针对恶意使用风险的）安全性(security) 和可信性保证相关的需求。
实质上提供例外的必要性之一是接口正确性：不附加不存在于需求以外的安全设计；根据 @1.4.3.3 ，这应是实现细节。

@1.4.4.3 最小依赖原则(principle of least dependencies) ：
除非有必要，接口实现仅使用必要的依赖。
这是 @1.4.2.3 的推论之一，其非模式规则的输入为：
已知必要的依赖较已知必要的依赖和不必要的依赖的并集要求较小的使用和维护成本。
这里的使用包括演绎抽象自身的推理(reasoning) 。依赖较少时，推理时需要搜索的解空间也越小。

@1.4.4.3.1 单一模块依赖倒置原则(dependence inversion principle) ：
这个原则在单一模块下包含以下含义：
抽象（的接口）不应该依赖（实现）细节；
（实现）细节应依赖抽象（的接口）。
这是 @1.4.4.3 应用在不同抽象的模块化设计中使用以下公设的推论：
抽象是细节包含的子集，依赖抽象的接口较依赖实现细节具有更少的依赖。

@1.4.4.4 可复用性(reusability) ：
高层抽象设计的实现应包括复用此设计的实现的设计。
这是 @1.4.2.3 的推论之一，其非模式规则的输入为以下公设：
一般地，高层抽象设计和复用此设计的实现较单一的高层设计的实现更复杂。
此前提条件由对需求工作量可行性分析中的度量验证总是成立。
推论：除非必要，不分离抽象设计的实现和复用此设计的实现的设计，避免复杂性。
全局意义上的不分离设计不违反 @1.4.2.4 。
典型实例：
语言是一种高层抽象设计，语言的库是一种复用语言的设计。
因此，语言实现应包括库设计。

@1.4.4.5 可组合性(composability) ：
组合是一种特定形式的涉及多个实体的复用，允许复用时不修改被复用的其它实体。
可组合原则：接口的设计应允许不同设计之间的组合满足这些设计响应以外的需求。
这是 @1.4.2.3 的推论之一，其非模式规则的输入为以下过程推断得到的引理：
公设：
一般地，在存在充足基础解决方案的情形下，组合现有解决方案的设计较重新给出不依赖这些解决方案的设计的解节约成本。
应用 @1.4.2.2 ，得到引理：
一般地，在存在充足基础解决方案和满足需求限制的情形下，组合现有解决方案的设计优于重新设计。
即提升可组合性可减少实现被复用(@1.4.4.4) 的设计的成本。

@1.4.5 接口设计性质和原则：

@1.4.5.1 统一性(uniformity) ：
接口的设计应尽可能避免特例。
这是 @1.4.2.3 的推论之一，以一致性(@1.4.3.1.2) 作为非模式规则输入。
无限制的特例要求指定更多的附加规则，而违反 @1.4.2.3 。
在语言设计上，这类似 [RnRK] 的设计原则 G1 ：
G1a 对象状态(object status) ：语言操作一等对象(@4.1)；
G1b 可扩展性(extensibility) ：用户定义的设施能重现内建特性的能力。
以上原则在 NPL 中略有变化。关于 G1a 的改变，详见 @4.2 。
整体上的 G1b 在和 @1.4.3.1 冲突时不被要求。
注意 G1b 仅表示用户使用语言的扩展，不表示语言自身的可扩展性（这通过满足需求的能力 @1.4.2.1 体现），因为语言规格(@2.3.1.2) 不依赖使用对象语言(@2.3.2) 表达。

@1.4.5.2 易用性(usability) ：
易预测性：设计应允许但难以偶然实现的危险操作。
同 [RnRK] 的设计原则 G3 。
危险的操作指引起较大代价的不预期或无法预期结果的操作。
这是 @1.4.2.1 和 @1.4.2.2 的推论，包含两方面：
避免危险操作的风险是 @1.4.1.1 和 @1.4.2.2 的推论；
不直接禁止危险的操作以满足 @1.4.2.1 的要求。
避免危险的操作在许多上下文中可减少程序中易错(error-prone) 的实现的风险。
结合用户的经验，这个规则的变体是之一是最小惊奇原则(principle of least astonishment) ，强调降低接口的学习和适应成本。

@1.4.5.3 最小惊讶原则(principle of least astonishment) ：
在保持合理性的前提下，若能评估目标用户的接受能力，避免违反其直觉的设计。
其中，合理性至少应蕴含正确性(@1.4.3.1) ，一般也蕴含简单性(@1.4.3.2) 和易用性(@1.4.5.2) 同时不违反其它原则（特别应注意尽量保持可复用性(@1.4.4.4) 和可组合性(@1.4.4.5) ）。
这个原则主要适用于人机交互接口的设计，但也适用于一般的 API 。
推论：约定优于配置(convention over configuration) ：约定接口的合理的默认行为(@2.3.2) ，而不是隐藏其行为而提供配置另行实现。

@1.4.6 方法论(methodology) ：
方法论是严格独立价值判断(@1.4.2) 的规则，是关于价值判断结果参数化的判断规则。
不同的价值判断的结果作为方法论输入，决定是否适用此方法。
其它方法详见以下各节。

@1.4.6.1 避免不成熟的优化：
Premature optimization is the root of all evil.
适用于一般需求。
适时收缩理论长度以照顾可操作性（注意断言一个优化过早自身可能就是一个过早的优化）；
主动适应需求变更（不同时明确全部的具体需求，只限定需求范围：能使用计算机实现部分语义的任务）。

@1.4.6.2 封装(encapsulation) ：
封装是接口设计的合理性准则。
以接口的预设风格的价值判断为输入，封装性要求接口满足以下多态性(polymorhism) ：
给定接口的替代接口，则替代接口应能代替原接口，当且仅当不引起非预期的可观察的差异。
在语言设计中，去除风格参数化的这条原则被作为 LSP(Liskov Substitution Principle) 。
参数化风格限定并非任意符合 LSP 的接口设计都符合封装性要求。这便于从不期望的设计中剔除不符合其它原则的设计。

@1.4.6.3 信息隐藏(information hiding) ：
保持不需要公开的信息不被公开，以使设计符合最小接口原则(@1.4.4.3) 并支持避免抽象泄漏(@1.4.3.4) 。
适用于接口及其实现。
信息隐藏以是否需要公开信息的价值判断（特别地，关于如何符合最小接口原则）的结果参数化。
封装(@1.4.6.2) 的接口通常有助于实现信息隐藏。直接限定避免接口规格具有过多的信息，是另一种直接的实现方式。

@1.4.6.4 模块化(modularity) ：
接口和实现的设计被划分为若干保持联系的组件，至少满足正确性(@1.4.3.1) 和可组合性(@1.4.4.5) ，并强调实现可复用性 (@1.4.3.1) 。
参数化的输入是需被评估模块化程度的结构设计（包括粒度(granularity) 和组成部分的依赖关系）相对给定需求的实现质量的价值判断。
模块化设计提供接口分组的单元称为模块(module) 。

@1.4.7 其它推论和比较：
从对正确性(@1.4.3.1) 的强调可知，较简单性(@1.4.3.2) 优先考虑通用性(generality) 。
这和 [RnRK] 中讨论的设计哲学虽然相当不同，但仍允许和 Kernel 具有相似的特性。
作为典型的 NPL 的一个派生实现(@2.3.2) ，NPLA1(@5) 具有以下和 Kernel 相似的核心设计：
相似的求值(@4.1) 算法（差异参见 @8.4 ）；
环境(@4.6.1.1) 可作为一等对象(@4.1) ；
支持 vau 抽象(@4.5.2.3) ，且使用词法作用域(@4.6.1.1.2) ；
强调表达式求值前后的不同（详见 @1.3 ）；
强调直接求值而非传统 LISP 方言的引用(@8.4) 。

@2 整体设计：

@2.1 基本原理、表达形式和抽象：
具体讨论设计策略另见需求描述文档。
和设计原则的讨论另见 @1.4 。对本节内容的描述的理解应符合 @1.4 的原则。

@2.1.1 模型：
可用计算机实现的语言首先是计算的模型(model of computation) ，它们对计算(computing) 进行建模。
与之相关地，为计算机系统建模作为计算机的模型(computational model) ，需对有限计算资源的现实进行适应。
这些模型可使用形式方法(formal method) 建立，即形式模型(formal model) 。
被计算机实现的语言应同时具有两方面的特征。
作为实用的语言，语言还应强调提供可编程性(programmability) 以允许用户利用；这样的语言称为编程语言(programming language) 。
Turing 机、无类型 λ 演算等早期计算模型不考虑有限计算资源限制。
因为以无限的计算资源为前提，这些模型无法被物理地完全实现，无法直接作为计算机实现的语言的模型。
同时，这些模型仅适合对计算建模，并没有强调允许可编程性的实现；扩充可编程设计而保持模型自身的主要性质相当困难。
因此，基于计算的模型适配编程语言的设计必然需要妥协：
对这些模型的裁剪和补充能提供若干编程语言的模型，但这无可避免地显著地复杂化模型自身，且不利用用户使用简单有效的规则实现通用目的上的可编程性。
事实上，使用严格形式化的模型描述编程语言的行为(@2.3.2) 较编程语言自身的发展更落后：
大部分编程语言并没有使用模型支持它们的设计；
现实的实用语言，特别地，包括所有主流的工业语言(industrial language) ，几乎都没有在语言规格(@2.3.1.2) 中给出完整的模型；
通常的实用语言只形式化基本的语法(syntax) 上的规则，无法指导用户精确理解程序的含义。
这些落后集中体现在的语义(semantics) 模型的缺失，使对编程语言语义的判断取决于规格说明中模型外规则的理解。
后验(postpone) 的语义模型可以使用不同形式语义方法(@2.2.3) 设计，但和语言规格差异的一些本应避免的附加工作，并且通常难以完整地作为标准规格的描述。
本设计尝试在语言的原生设计中应对这些问题以避免这些妥协带来的消极影响，同时取得比非模型方法更强的可用性。
这种可用性至少体现在语义的精确性可通过模型直接决定；仅为精确性，不需要另行补充模型设计（尽管现有模型可能仍然是不完全形式化的）。

@2.1.1.1 资源可用性基本约定：
在严格的资源限制要求下，模型不能隐藏预设的无限资源的前提。
因此，有必要做出基本的可用性(availability) 约定以允许表达：在抽象机(@2.6) 的配置中，任意通过元语言(metalanguage) 语法描述的资源总是可用的。
为避免对具体资源的总量和实现细节做出假设，除此之外，本设计只要求模型蕴含所有权语义（即便不严格形式化——注意作为元语言的描述模型使用的形式语言仍然可能是实现细节），详见 @4.2.2.3 。
具体计算机系统的实现中，保证基本可用的资源被直接映射到程序执行(execution) 的环境中。尽管和适配的软件环境相关，这最终由硬件实现物理地保证。

@2.1.2 适用领域：
为尽可能解决 @2.1.1 中的问题，优先以通用目的(@1.2) 而不是领域特定(domain-specific) 语言作为评估语言特性(feature) 设计的参考原则。
领域特定语言的特性应能合理地从支持通用目的的特性中派生(derive) ，且不影响实际的可用性。

@2.2 理论背景、工具和依据：
基本内容参见 [Documentation::CommonRules @@2.1] 。

@2.2.1 组织概念模型：
略。

@2.2.2 设计意义：
参见 [Documentation::Designation @@2.2] 。

@2.2.3 形式语义方法：
形式语义方法是建立语义模型的形式方法(@2.1.1) ，主要有公理语义(axiomatic semantics) 、指称语义(denotational semantic) 和操作语义(operational semantics) 。
操作语义可分为在抽象机(@2.6) 中指定具体规约(@4.1) 步骤状态的结构化操作语义(structural operational semantics) （小步(small-step) 语义），及仅指定规约的输入和输出的自然语义(natural semantics) （大步(big-step) 语义）。
非确定语义：经验语义，不需要使用自然语言解释的部分。
本文档不直接给出形式语义。语言规则(@2.3.1.2) 确定的经验语义可在一定条件下转写为上述形式语义方法表达的形式。

@2.2.4 构建原则：
基本内容参见 [Documentation::CommonRules @@2.2] 。
其它参见 [Documentation::Designation @@2.3] 。

@2.3 基本概念和约定：
本文档中非形式地使用和这个一些术语的在特定理论中严格定义具有逻辑上相容的含义的概念，不进一步解释，详见 @2.3.1.1 。
例如，在程序语言理论中，上下文(context) 指形式上可继续补充内容的构造；本文档中非形式地使用和这个含义相容的概念。
描述中可能涉及上下文相关的略称参见 @2.3.3 。

@2.3.1 通用约定：
关于“语言”补充的基本概念和约定，使用元语言语法 <相关范畴/上下文> 。
除非有其它说明，适用于任意上下文。

@2.3.1.1 [<自指><名词>] ：
实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。
语义(semantics) ：参见经验语义。
经验(experience) ：参见哲学或一般等价的经验语义。
范畴(category) ：参见范畴论。
态射(morphism) ：参见范畴论。
归纳(induction) ：一种态射，可操作性参见经验语义。
方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。
方法(method) ：方法学的一个子范畴；可操作性参见经验语义。
概念(concept) ：参见形式逻辑学。
上下文(context) ：一种概念范畴适用的态射；参见经验语义。

@2.3.1.2 [<非自指>] ：
形式(form) ：参见经验语义和数学。
<概念> 内涵：参见形式逻辑学。
<概念> 外延：参见形式逻辑学。
<概念> 定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。
集合(set) ：参见 NBG 集合论。
序列(sequence) ：有序集合。
类(class) ：参见 NBG 集合论和范畴论。
真类(proper class) ：参见 NBG 集合论和范畴论。
<动词> 抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。
<名词> 抽象(abstraction) ：<动词>抽象的结果。
<动词> 封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。
<名词> 封装(encapsulation) ：<动词>封装的结果。
接口(interface) ：一种封装，参见软件工程学。
实现(implementation) ：一种封装，参见软件工程学。
重用(reusing) ：参见经验语义和软件工程学。
不变性(invariance) ：满足某种等价关系（自反、传递、对称的二元关系）。
不变量(invariant) ：具有不变性的实体。参见数学和契约式程序设计。
状态(state) ：可以和其它实体关联的、可在某个上下文中保持变化或不变的实体。同一状态总是保持变化或保持不变。状态变化的含义参见经验语义、数学或另行指定。
可变状态(mutable state) ：在某个上下文中可能映射到若干其它状态的状态。
不可变状态(immutable state) ：不是可变状态的状态。
<动词> 派生(deriving) ：基于重用的操作。
<名词> 派生(derivation) ：<动词>派生的结果。
<语言> 接口(<language>interface) ：和表达语义有关的语言的可见的特征。
<语言> 实现(<language>implementation)：对语言表达语义的表达。
<语言> 人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为计算模型实现的语言接口。
<语言> 机器接口(machine interface) ：对机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。例如，对 C 预处理器而言，C 源代码中的空白符是机器接口，而对翻译器来说则不是。就源代码而言，机器接口总是人类接口的子集。
语言特性(language feature) ：作为功能提供的人类接口。
语言规则(language rule) ：约定可实现及应被实现的语言接口，可包含语言特性的表达。
语言规格(language specialization) ：语言规则的集合。
符合性(conformance) ：满足语言规格的实现性质。
要求(require) ：语言规格对实现的作为判断符合性的条件。

@2.3.2 领域约定：
适用于上下文 <NPL> 。
广义实体： <通用约定> 实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。
名称(name) ：一种特殊的广义实体，专用于指称另一个广义实体。
实体(entity) ：非名称的广义实体。
规则(rule) ：用于确定行为或其它规则（如语言规则(@2.3.1.2) ）的描述。
约束(constraint) ：可被形式表达，用于限制和明确行为的规则。不一定使用形式表达。
违反(violation) ：对约束指定的条件的不满足。
表示(representation) ：以一个符合某种形式的约束的实体指称另一个实体。
语言实现(language implementation) ：语言提供的接口的实现，是语言的表现形式，可以是具体语言实现或抽象语言实现之一。
具体语言实现(concreate language implementation) ：能最终完全表达为可预测的物理现象一一对应的表达可计算性的实现（如机器指令），一般应为程序。
抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。
派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。
实现环境(environment of implementation) ：对应特定语言实现的特定不变状态（对机器来说可以是配置项，对人来说不确定，所以一般忽略）的集合。
行为(behavior) ：语言实现的外部表现。基于可操作性考虑，一般仅约束机器实现。
翻译(traslation) ：不同语言之间的变换，可作为语言实现的形式。
解释(interpretation) ：通过直接执行(@2.1.1.1) 表现行为的具体语言实现的形式。
源语言(source language) ：翻译的输入的语言。
目标语言(destination language) ：翻译的输入的语言。
符号(symbol) ：语言规则允许的不使用其它对象表示的符合对象。
字母表(alphabet) ：符号在语言中的全集。
串(string) ：可能重复出现的符号的有限序列。
文法(grammar) ：描述任意的可形式化的语言规则。
语法(syntax)：以语言中的串作为基本元素，描述语言的字面(literal) 结构模式(pattern) 的语言规则，通常是文法的一部分。
语义(semantics)：非语法的考虑解释(interpretation) 或含义(meaning) 的规则、原理和过程，通常可被语法以外的文法描述并可约束含义的表达。
形式语言(formal language): 特定语言规则确定的串的全集，是语言规则对应的语法的外延（也可能作为其它语言规则对应的某种形式语义）。
实例(instance) ：具有代表性含义的集合的元素。
代码(code)：任意有限的语言的实例片段组成的语法范畴。
伪代码(pseudo code)：抽象语言实现的语言的代码。注意习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。
程序(program) ：具体语言实现接受的以代码表示的输入，或被变换后对应的输出。
计算复杂度(computational complexity) ：某个形式化计算模型中以有限的正整数作为模型决定的规模(metric) 作为参数的渐进(asymptotic) 性质确定的度量，一般包括描述步骤规模的时间(time) 和描述存储规模的空间(space) 复杂度。
复杂度(complexity) ：以程序的规模作为参数的关于程序的直接执行的计算复杂度，一般包括描述步骤规模的时间(time) 和描述存储规模的空间(space) 复杂度。
元语言(metalanguage) ：描述其它语言的语言。
对象语言(object language)：被元语言操作或实现的语言。
元编程(metaprograming) ：使用元语言编程。
反射(reflection) ：元语言和对象语言相同的元编程。
具现(reification) ：在对象语言中以数据模型作为关联实体以表示程序的语义。
诊断(diagnostics) ：明确的对特定预期或非预期执行的行为的响应的总和。
诊断消息(diagnostic message) ：用于和用户交互的表现诊断的告知及提示。
未定义的(undefined) ：可能导致违反约束但不保证具有诊断消息的。表示置于语言规则下的行为等不可预测。
未指定的(unspecified) ：在各个实现中可能存在的。不应假定不同实现具有完全一致的特性。
由实现定义的(implementation-defined) ：取决于各个具体语言实现的，要求有文档说明。
由派生实现定义的(derived-implementation-defined) ：取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。
未定义行为(undefined behavior) ：未定义的行为。
未指定行为(unspecified behavior) ：未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。
语言特性(language feature) ：语言提供的功能接口，可以是具体语言特性或抽象语言特性之一。
具体语言特性(concrete language feature) ：完全没有派生语言实现定义的语言特性。
抽象语言特性(abstract language feature) ：非具体语言特性的语言特性。
过时的(obsolesent) ：已确认因为存在更合适的选项而建议不继续使用的（接口/特性）。
废弃的(deprecated) ：过时的但因为兼容性等原因，暂时保留的、一般可提供替代的接口或特性。
外部环境(external environment) ：和程序及被翻译的程序没有交集的和实现环境无关的状态。

@2.3.3 略称：
仅在不致混淆时使用。
实现(implementation) ：语言实现。
环境(environment) ：实现环境。
派生实现(derived implementation) ：派生语言实现。

@2.4 NPL 实现模型：
NPL 是抽象的语言，没有具体语言实现(@2.3.2) ，但一些直接影响实现表现形式的规则被本节限定。
NPL 具体实现进行抽象解释(abstraction interpret) ，其目标不一定是程序(@2.3.2) 。
任一 NPL 派生实现的符合性(@2.3.1.2) 由文档指定的满足对实现的要求(@2.3.1.2) 的语言规则子集定义。
这类规则总是包含对应语言的语义的 NPL 公共子集(@4) ，且蕴含实现行为(@2.6) 的要求，如 @4.1.3 。

@2.4.1 实现的执行阶段(phase of execution) ：
一个 NPL 的完整实现应保证行为能符合以下的阶段（具体阶段不要求和实际实现中的一一对应，但应保证顺序一致）：
分析(analysis) 阶段：处理代码，取得适当的 IR（Intermediate Representation ，中间表示）；
代码生成(code generation) ：生成可被其它阶段执行的代码，称为目标代码；
运行：运行目标代码。
其中分析阶段是任意实现必要的，包含：
词法分析：必要时转换字符编码；转义并提取记号；
语法分析：语法检查（检验语法正确性(@2.5) ）并尝试匹配记号和语法规则中的语法元素(@3.4) ；
语义分析：语义检查（检验语义正确性(@2.5) ）并实现其它语义规则。
运行之前的阶段总称为翻译(translation) ，包含各个翻译阶段(phase of translation) 。
对有宿主语言(host language) 支持的嵌入实现(embedded implementation) 或目标不是程序的情况，代码生成及之后的阶段不是必须的。
宿主语言实现可提供作为对象语言(@2.3.2) 的 NPL 的本机(native) 实现。
嵌入实现的宿主语言可直接运行语义分析的结果（中间表示）。
在语义不变的前提下，允许实现一次或多次翻译部分代码产生部分中间结果并复用。
运行时(runtime) 程序实现运行阶段。
其它可能的阶段由派生实现定义，但应满足所有阶段具有确定的全序关系，且不改变上述指定的阶段的顺序。符合这些条件的附加阶段称为扩展阶段。

@2.4.2 并发实现(concurrent implementation) ：
一个实现中顺序执行以上执行阶段的控制流称为一个执行线程(thread of execution) ，简称线程(thread) 。
一个实现在整个执行过程中可以有一个或多个线程被执行。是否支持多线程执行（多线程翻译和/或多线程运行）由派生实现定义。

@2.4.3 阶段不变量约束：
若某些状态在某个执行阶段 k 被唯一确定为不可变状态，且在之后的状态下是不变量，则此状态称为满足 k 阶段不变量约束的。

@2.5 正确性：
正确性规则包含语法正确性和语义正确性。
当正确性规则被发现违反时，实现进入异常执行状态。
@2.5.1 以外的异常执行条件和状态由派生实现定义。
其它异常执行条件和状态以及异常执行的实现是否存在未定义行为(@2.3.2) 由派生实现定义。

@2.5.1 翻译时正确性规则：
翻译时的异常状态要求给出用于区分正常状态特定的行为(@2.3.2) ，包括诊断消息(@2.3.2) 和其它派生实现定义的实现行为(@2.6) 。
语法正确性规则是翻译时正确性规则。
部分形式上的正确性规则在翻译时确保。
翻译时确保的形式上正确的程序是合式的(well-formed) ；反之不合式(ill-formed) 。
合式的程序符合语法正确性的规则，以及翻译时确保的可诊断(diagnostable) 语义规则。
不合式的程序应在运行前终止，不被完整地翻译。

@2.5.2 错误(error) ：
错误是不满足预期的正确性或其它派生实现定义的不变性质时的特定诊断。
非正确性或不满足这些不变性的条件是错误条件(error condition) 。
满足错误条件时，实现可引起(signal) 错误。

@2.6 实现行为：
实现的行为由具有非特定存储的抽象机描述。
若语义规则明确可以行为被忽略，则被忽略之后的实现行为与之前等价。
允许派生实现定义附加的等价性。

@2.7 简单实现模型约定：

@2.7.1 嵌入宿主语言实现：
一个派生实现使用外部语言 L 简单实现模型 NPL-EMA ，若满足：
以 L 为宿主语言的嵌入实现，不包含扩展执行阶段(@2.4.1) ；
单一实现不支持多线程执行(@2.4.2) ，但允许多个实现同时在宿主中多线程执行。
宿主语言提供的实现环境称为宿主实现环境，简称宿主环境(host environment) 。

@3 基本文法：
本章约定基本的 NPL 文法(@2.3.2) 规则中，包括语法及对应的基础词法。对应的语义单独列为一章(@4) 。
多态文法规则：派生实现可完全不提供本章明确定义的词法和语法构造的支持，仅当提供同构的替代文法且符合语义规则。

@3.1 基本概念：
字符(character) ：组成语言代码的最小实体。
基本翻译单元(basic transation unit) ：任意连续字符的有限序列（可以是空序列）。
翻译单元(translation unit) ：基本翻译单元的集合，之间满足由派生实现定义的规则。

@3.2 字符集和字符串：
字符集(character set) ：对一个实现而言不变的字符的有限集合。
基本字符集(basic character set) ：实现环境必须支持的字符集。具体由派生实现定义。
字符串(character string) ：字符集上的序列。
其它同 ISO/IEC 14882:2011 对 character 和 character set 的有关定义。

@3.3 词法规则(lexical rules) ：
约定元语言语法 <x> 表示词法元素 x ，::= 表示定义，| 表示析取。
名称约定为在 NPL 中符合语法(@3.4) 约束的若干记号(@3.3.1) 的集合，一般可实现为可表达的字符串。

@3.3.1 基本词法构造：
<token> ::= <literal> | <$punctuator> | <$identifier>
词素(lexeme) ：代码中非空白符分隔的字符序列。
记号(token) ：词素的顶级分类。
属于记号的语法元素可以是以下的词法分类：
字面量(literal) ：一种记号，参见 @3.3.3 。
标点(punctuator) ：由派生实现定义的特定字符序列的集合，用于分隔其它记号，具有一定语义功能。
标识符(identifier) ：除字面量和标点以外的记号。
记号是可能附带附加词法分析信息的词素。词法分析(@2.4.1) 后得到的记号可以用词素映射到词法分类的有序对表示，但 NPL 不要求在此阶段保持分类也不限定表示的构造。
可以保证 ISO/IEC 14882:2011 的 identifier 的定义，或在上述标识符中插入字符 $ 构造得到的标识符属于 NPL 标识符。

@3.3.2 转义序列和字符序列：
<char-escape-content-seq> ::= <$single-escape-char> | <$escape-prefix-char><$escape-content-seq>
<char-seq> ::= <$literal-char> | \<char-escape-seq>

@3.3.3 字面量：
<literal-content> ::= <char-seq> | <literal-char-seq><literal-data>
<code-literal> ::= '<literal-content>'
<data-literal> ::= "<literal-content>"
<string-literal> ::= <code-literal> | <data-literal>
<literal> ::= <string-literal> | <$derived-impldef-literal>
代码字面量(code literal) ：以 ' 作为起始和结束字符的记号。
数据字面量(data literal) ：以 " 作为起始和结束字符的记号。
字符串字面量(string literal) ：代码字面量或数据字面量。
扩展字面量(extended literal) ：由派生实现定义的非代码字面量或数据字面量的记号。
字面量：代码字面量、数据字面量、字符串字面量或扩展字面量。

@3.3.4 词法分析规则：
输入翻译单元，输出记号序列。
输出规则（按优先顺序）：
反斜杠转义：连续两个反斜杠被替换为一个反斜杠；
引号转义：反斜杠之后紧接单引号或双引号时，反斜杠会被删除；
断行连接：反斜杠之后紧接换行符的双字符序列视为续行符，被删除使分隔的行组成逻辑行；
字面量：未被转义的单引号或双引号后进入字面量解析状态，无视以下规则，直接逐字节输出原始输入，直至遇到对应的另一个引号。
窄字符空白符替换：单字节空格、水平/垂直制表符、换行符被替换为单一空格；回车符会被忽略；
原始输出：其它字符序列逐字节输出。
不对空字符特殊处理。

@3.4 语法 ：
本节指定 NPL 作为对象语言(@2.3.2) 的语法(@2.3.2) 。
约定元语言(@2.3.2) 的语法 x 表示语法元素 x ，::= 表示定义，| 表示析取。
程序被作为语言实现(@2.3.2) 组成部分的语法分析(@2.4.1) 程序规约(@4.1) ，结果能确定其和一定的语法元素匹配。
规约时应进行语法规则的检查。

@3.4.1 基本语法构造概述：
基本语法单元是可递归构造的表达式，或派生实现指定的其它语法构造。
构成基本语法单元的规则参见 @3.3 。
合式的(@2.5.1) 基本翻译单元(@3.1) 应是一个或多个基本语法单元。

@3.4.2 表达式(expression) ：
<expression> ::= <atom-expression> | <composite-expression> | <list-expression>
表达式是受表达式语法约束的记号序列。
其中构成分别称为原子表达式(atom expression) 、复合表达式(composite expression) 和列表表达式(list expression) 。
构成表达式的表达式是前者的子表达式(subexpression) 。

@3.4.2.1 原子表达式：
<atom-expression> ::= <token>
原子表达式不能被表示为其它表达式的语法构成形式的复合。

@3.4.2.2 复合表达式：
<composite-expression> ::= token-expression | expression-token
符合表达式是原子表达式和表达式的复合，即语法意义上的直接并置连接(juxtaposition) ，不在被复合的表达式之间存在其它记号。
同一个表达式可能被按原子表达式出现的位置以不同的方式规约为复合表达式。允许的规约复合表达式的方式由派生实现定义。

@3.4.2.3 列表表达式：
<list-expression> ::= <left-list-bound> <expression> <right-list-bound>
<left-list-bound> ::= ( | <extended-left-list-bound>
<right-list-bound> ::= ) | <extended-right-list-bound>
列表表达式是使用 <left-list-bound> 和 <right-list-bound> 作为边界的表达式。
<left-list-bound> 和 <right-list-bound> 是不同的标点。
边界为 ( 和 ) 的表达式是基本列表表达式。其它可能的边界由派生实现定义，构成扩展列表表达式。

@3.4.3 语法形式(syntactic form) ：
语法形式是词法上满足特定形式(@2.3.1.2) 的语法构造。
除非派生实现另行指定，语法形式总是表达式。

@3.4.4 语句(statement) ：
以派生实现定义的标点结尾的表达式称为语句。
语句语法的分组(grouping) 规则以及是否隐式地作为列表表达式求值(@4.1) 由派生实现定义。

@3.4.5 简单文法约定：
一个派生实现使用简单文法 NPL-GA ，若满足：
翻译单元同基本翻译单元(@3.1) ；
只支持左原子表达式构成复合表达式(@3.4.2.2) ；
只支持基本列表表达式(@3.4.2.3) ；
标点为单个字符(@3.1) ；
不支持语句(@3.4.3) 。
NPL-GA 允许一些典型的分析器(parser) 简化设计作为实现。
在 @3.4.2 的形式文法仅作为语法规则，使用词法分析(@3.3) 的结果提供作为语法类别(syntactic category) 的符号串(@2.2) 作为输入的情况下，NPL-GA 支持 LL(1) 文法分析，即使用 NPL-GA 语法。
若延迟复合表达式(@3.4.2.2) 和列表表达式(@3.4.2.3) 中的选择到分析器外（之后可能由语义处理），检查语法的判定程序可进一步简化，仅判断记号“(”和“)”的匹配。
若词法分析处理直接对“(”和“)”和进行记号化(tokenize) 标记，则 NPL-GA 分析器不需要支持其它判定。这样的分析器实现的 NPL-GA 子集等效 LL(0) 文法。但由于 NPL-GA 不限定语法元素具体数量，等效 LL(0) 分析器当且仅当输入的串终止时接受输入，因此是平凡的(trivial) ，通常不具有实际意义，因为：
形式上这里只有算法步骤的多少的差异，而几乎所有实现的语言都不把它作为可观察行为(@4.1.3) ；
即便需要统计串的长度，也应可以在之前（词法分析）计算，使用语法分析完成这个任务在此是低效的。
反之，在分析 NPL-GA 语法前扩展其它语法预处理(preprocessing) 规则可以支持更多的文法扩展。这样的文法扩展可接受扩展的非 NPL-GA 文法，但仍允许保持语法分析器的实现使用 NPL-GA 语法。

@4 语义：
NPL 的语义规则(@2.3.2) 构成演绎系统(deductive system) ，通过对翻译单元(@3.1) 中的表达式(@3.4.2) 的求值(@4.1) 表达。
除非派生实现另行指定，仅使用表达式指定对象语言的语义。
基本语义规则要求：
所有不需要诊断消息(@2.3.2) 的规则由派生实现定义；
本章内的规则应不产生未定义行为(@2.3.2) 。
NPL 允许程序具有语义等价的未指定未指定行为(@2.3.2)。派生实现可能通过约定和限制其具体选项的选取以指定更具体的实现行为(@2.6) 。

@4.1 基本概念：
区域(region) ：和特定位置代码关联的有限实体集合。
范围(range) ：一个连续区间。此处“连续”的概念由派生实现定义，默认参照数学的形式定义。
声明(declaration) ：引入单一名称的表达式。
声明区域(declarative region) ：对某一个声明及其引入的名称，通过声明区域规则(@4.3.1) 决定的区域，可由词法分析实现(@5.3.1) 确定的关于这个名称有效的代码片段的最大位置范围。
有效名称(valid name) ：可以唯一确定指称的实体的名称。
有效命名实体(valid named entity) ：有效名称指称的实体。
名称隐藏(name hiding) ：若同一个名称在同一个位置属于超过一个声明区域，则应能通过名称隐藏规则(@4.3.2) 确定唯一有效的声明以指定有效名称和对应的有效命名实体，此时有效名称隐藏其它声明区域声明的名称，有效命名实体隐藏可以使用被隐藏名称指称的实体。
作用域(scope) ：声明区域的子集，满足其中指定的名称是有效名称。
生存期(lifetime) ：逻辑上关于可用性的连续区间的抽象，是一个闭集。
对象(object) ：表示可被逻辑上表达为连续存储的状态的集合且能明确生存期开始和终止的实体。
变量(variable) ：通过声明显式引入或通过演绎系统规则隐式引入的以名称指称的实体。
绑定(binding) ：引入变量的操作或结果，其中后者是变量的名称和引入的被变量表示的实体构成的有序对。
约束(bound) ：被绑定的。
常量(constant) ：满足某种不变量的约束以和不可变状态关联的实体。具体由派生实现定义。注意不和变量对立（表示不可变状态的变量可能是常量）。
值(value) ：表达式关联的不可变状态。
修改(modification) ：使状态(@2.3.1.2) 改变的操作。
副作用(side effect) ：对表达式的值以外的表示的改变。
幂等性(idempotence) ：重复后即不改变状态的操作性质。
项(term) ：特定的演绎系统(deductive system) 特别是项重写系统(term rewriting system) 中处理的对象，是带有基本递归构造的元素，可对应语法中的表达式。
子项(subterm) ：具有递归形式构造的文法描述的参与构成项的项。
约束变量(bound variable) ：子项中出现的被约束的变量。
自由变量(free variable) ：子项中出现的非约束变量。
组合子(combinator) ：不是变量也不含相对任何项的自由变量的子项。
转换(conversion) ：根据基于特定等价性（假设）前提的两个项之间的自反的演绎。
规约(reduction) ：两个项之间的、实例(@2.3.2) 是某个转换的子集的满足反自反的演绎。
计算作用(computational effect) ：可被某个形式化计算模型描述的行为。
作用(effect) ：语言支持的一定上下文内的表达式规约的结果的计算作用，包括计算得到的值、产生的副作用以及其它可由区域和变化的状态二元组描述的实体。
求值结果(evaluation result) ：作用的子集，是求值得到的用于替换被求值的表达式的表达式或其它由派生实现定义的实体。不和其它结果混淆时，简称结果(result) 。
抽象求值(abstract evaluation) ：对表达式的不取得作用的规约。
具体求值(concrete evaluation) ：对表达式的取得作用的规约。
求值(evaluation) ：抽象求值或具体求值。
控制状态(control state) ：实现中决定求值的状态。
控制作用(control effect) ：引起控制状态改变的作用。在 NPL 中，控制作用是在对象或派生实现定义的实体上引起改变的副作用。
外部表示(external representation) ：具有特定形式的用于和外部环境(@2.3.2) 交互的表示(@2.3.2) 。
内部表示(internal representation) ：非外部表示的表示(@2.3.2) 。
等价关系(equivalence relationship) ：自反的(reflexive) 、对称的(symentric) 和传递的(transitive) 的二元关系。
相等关系(equality relationship) ：定义在值的集合上的等价关系。
一等实体(first-class entity) ：语言表达的中允许足够操作的子集（使用的判定准则和 [RnRK] Appendix B 的 first-class object 的约定一致）的实体。
同一性(identity) ：在一等实体上的一种等价关系，允许实体具有标识不相等特定的属性（如占据存储）。
一等对象(first-class object) ：可确定同一性的一等实体。
在实现执行的上下文，生存期概念兼容 IEC 2382 的 lifetime 定义：
portion of the execution duration during which a language construct exists

@4.1.1 表示：
表示用于表现演绎实例、具体实现及其中一部分实体（如某个值）的状态。
注意变量不一定是可变状态的表示。
外部表示和内部表示是相对的。不同外部环境可以有不同的外部表示，这些外部表示相对其它外部环境而言可以不是外部表示。
文法(@3) 约定基准的表示作为翻译(@2.3.2) 的输入。这种表示是翻译所在外部环境的外部表示，称为源代码(source code) ；翻译结果为对象语言代码，简称对象代码(object code) ，可以是另外的外部表示。
其它外部表示和内部表示的外延由派生实现定义。

@4.1.2 演绎规则：
指定转换的演绎规则是转换规则。
指定规约的演绎规则是规约规则。
两两可转换的对象的传递闭包构成等价类，称为可转换等价类。除非另行指定，只讨论具有单一可转换等价类的转换规则的（抽象）重写系统。
对象之间的转换保持某种等价关系的等价变换(transformation) 。对象之间的规约是其中的子集，即以存在等价关系的一个对象替代另一个对象的有向转换。
若两个对象具有规约到相同结果的变换，这两个对象可连接的(joinable) 。
若任意两个对象等价蕴含对象可连接，则此重写系统具有 Church-Rosser 属性(Church-Rosser property) 。
若可从任意一个对象规约到的任意两个对象可连接，则重写系统具有汇聚性(confluence) 。
若可从任意一个对象的一步规约到的任意两个对象可连接，则重写系统具有局部汇聚性(local confluence) ，或称为弱汇聚性(weak confluence) 。
若可从一个对象规约到的任意两个对象可连接，则此对象具有汇聚性。
若可从一个对象的一步规约到的任意两个对象可连接，则此对象具有局部汇聚性，或称为弱汇聚性。
规约中可包括实现环境(@2.3.2) 的交互。
若规约用于求值，汇聚性限定为：满足任意以此规则变换前和变换后的项被分别规约时，两者的作用相等。

@4.1.3 状态和行为：
状态不变由实现定义的等价关系(@2.3.1.2) 决定。
除非派生实现另行指定，约定：
实现行为(@2.6) 总是可使用状态进行描述；
存在副作用为可观察(observable) 行为的必要条件；
在实现外部访问某个状态的操作（输入/输出操作）是副作用。
若存在状态等价性以外描述的行为描述，由派生实现指定。
可观察行为如有其它外延，由派生实现指定；否则存在副作用是存在可观察行为的充分条件。
实现应满足实现行为(@2.6) 和语义蕴含的可观察行为等价；不严格要求按抽象机(@2.6) 实现操作语义。

@4.1.4 等价谓词(equivalence predicate) ：
等价关系(@4.1) 划分等价类(equivalence class) 。
等价谓词是判断等价关系的函数，描述一些重要的等价类划分的基本操作，在避免依赖良序(well-ordering) 和良基(well-founded) 的理论中满足 @1.4.4.3 （尽管判断本身依赖序关系）。
语言提供等价谓词判断两个项之间是否满足等价关系，满足判断等价关系的需要。
类似一般的值的集合上可能存在的相等关系，作用于实体的值的等价谓词（若存在）定义实体的相等关系。
决定相等关系的谓词是相等谓词，可判断实体和实体的值相等(equal) 。
一些情况部分值的集合不满足数学意义上的等价（如浮点数的 NaN ），但在此忽略这种可被单独扩展的情况。
以下不同准则的操作是相等关系的实例（参见 [EGAL](http://web.cecs.pdx.edu/~black/publications/egal.pdf) ）：
抽象相等(abstract equality) ；
引用(@4.2.3) 相等(reference equality) ；
EGAL 。
语言中应允许共存多个等价谓词。具体等价谓词的设计可由派生实现及语言的用户提供。
一般地，设计等价谓词需注意避免一些现实的使用困难，如 https://www.craigstuntz.com/posts/2020-03-09-equality-is-hard.html 。

@4.1.4.1 实体的同一性：
同一性(@4.1) 是实体上的等价关系(@4.1) 的一个实例。
同一性决定任意两个实体可在语言中不依赖具体操作的行为被直接区分，即满足 Leibneiz 法则(Leibneiz's law) 。
基于这个性质，可在实体上定义和 [So90] 相容的更强的（不依赖语言设计中不存在副作用(@4.1.4) 的）引用透明性(referential transparency) 。
同一性决定的等价类之间的实体相同，即其整体和任意的属性(property) 在任意上下文中等价。
相同的实体在语言中不需要被区分，可直接替换而不影响程序的语义和行为。后者蕴含可观察行为等价(@4.1.3) 。
在语言规则中，实体的同一性体现在以下隐含的默认规则：
不同上下文的实体默认相互独立而不保证能被视为相同（在任意上下文中等价）；
通过语言构造引入的超过一个实体，默认为不相同的实体；
除非另行指定，表示具有同一性的实体的语言构造和其它实体不被要求共享（详见 @4.2.3.4 ）指称相同的具有同一性的实体。
关于语言在一等实体上提供的同一性的具体判断依据，和具体语言支持的特性相关，参见 @4.2.1 。

@4.1.4.2 实体的不可变性(immutability) ：
通过特定的等价关系可定义具体的不可变状态(@2.3.1.2) 的集合。
这些集合可用于定义以这些状态为值的实体的不可变性，进而定义不保持可变性的改变(mutation) 操作和具体的其中可能影响可观察行为(@4.1.3) 的修改(@4.1) 操作。
通过限定不同的修改操作，定义不同的可修改性(modifiability) 和对立的不可修改性(nonmodifiability) 。
通过明确不可修改性拒绝支持修改操作（例如通过通过实体的类型检查(@4.6.2.3) 拒绝特定的修改操作），或通过不提供修改操作（例如关于 ISO C++ 的非类且非数组类型的纯右值，尽管要求非纯右值可被视为是一种类型检查），语义规则保证实体不被修改操作改变状态。
（不依赖和影响实体同一性(@4.1) 的）同一个实体上的修改操作是改变操作。只有具有可变状态(@2.3.1.2) 的实体可能支持这些操作。
一般地，一个实体不一定保证可区分是否具有不可变性以及具有何种不可变性（也蕴含一般不可区分可修改性），因为不可变性依赖实体的表示(@2.3.2) 进行约定。
基于等价关系而不是预设具体表示之间的相等定义可变性，避免抽象的目的（如封装性(@1.4.6.2) ）依赖特定相等关系(@4.1.4) 的实现细节(@1.4.3.4) ，支持开放世界假设(@1.4.3.6) 。
这种设计的一类典型反例是在预设排除副作用的纯的(@4.4.2) 的设计为基础进行扩展定义变化操作，包括：
默认使用不可变数据结构，并在此基础上扩展出可变的数据结构（如 [Rust] ）；
默认支持保证排除副作用的纯求值(@4.4.2) ，仅在有限的上下文中通过特定构造模拟支持非纯求值（如 Haskell 等纯函数式语言）。
一般地，这类策略对通用目的语言(@1.2) 是过度设计，因为这实质上要求所有不存在变化操作的实体操作都完全排除副作用，不支持指定不同类别或层次保留不同变化操作并划分不同等价类的可能性，而限制表达的能力或增加实现相同抽象的复杂性。
支持不同等价的不可变性的一个用例是，有序的数据结构中的键需要保持的（通过序关系定义的）等价关系和键的可修改性是两种不同的等价关系。作为它的一个具体的反例，C++ 标准库要求关联容器的键具有 const 修饰，没有区分两种等价性，导致无法修改等价的键（除非具有 mutable 数据成员），而引起一些不必要的复杂。

@4.1.5 数据结构：
实体之间可能允许具有集合论意义上的包含关系。被包含的实体称为子实体(subentity) 。
子实体可以是作为数据结构的一部分。这种数据结构可以是一般的图(graph) 。
数据结构也可在对象语言中通过实体包含关系以外的途径定义。例如，限定包含关系构成的图中的所有权关系(@4.2.2.3) 附加限制，详见 @4.2.4 。

@4.1.6 作用使用原则：
不同副作用(@4.1.4) 对行为(@2.3.2) 的影响可能依赖作用之间的顺序。
为保持可组合性(@1.4.4.5) ，副作用仅在必要时引入，且通常需明确区分是否依赖副作用以避免非预期的行为。

@4.2 一等实体设计原理：
基于统一性(@1.4.5.1) ，语言操作一等实体。（根据 @4.2.1 ，@1.4.5.1 中的规则 G1a 是此规则的推论。）
一等实体的一等(first-class) 性质体现在语言支持的操作限制足够小，使之实例的全集可以涵盖任意求值上下文(@4.4.7) 中。（一个反例是 ISO C 的数组类型的值无法作为函数的形式参数。）

@4.2.1 一等实体和一等对象：
一等实体可以有两类：只关心对象的值的，和同时关心作为对象的其它属性(@4.1.4.1) 的一等对象。
其中，后者允许更多的操作，且允许作为前者使用，反之无法直接保证：一等对象总是一等实体，一等实体不保证可作为一等对象使用。
逻辑上，一等实体可以关联其它对象（作为一等对象时关联可以是存储）。关联的对象的（表达式相关的）值是一等实体关联的值，可对应一等对象存储值。关联的值或存储的值是一等实体或一等对象的属性。
除非派生实现指定，NPL 的一等实体都是一等对象。

@4.2.1.1 一等对象的同一性：
一等对象通过保证具有同一性(@4.1) 强调不相同的对象总是存在至少一种总是不相同(@4.1.4.1) 的属性。
语言规则选取其中一种属性作为名义(nominal) 同一性属性。
一等对象具有名义同一性，定义为可比较名义同一性属性相等(@4.1.4) ；名义同一性的相等即名义同一性属性相等。
名义同一性在名义上标识相同的对象，区分不相同的对象，即便后者可能仍然在行为上完全符合同一性的要求。
由语言特性而非用户程序提供表达同一性的支持是必要的，这体现在通过在通用目的语言(@1.2) 中省略同一性的表达再由实现或用户程序引入的做法一般是不可行的：
由 Rice 定理，非平凡(non-trivial) 的程序语义性质无法被可计算地实现，而确定程序中任意对象的同一性蕴含判定“和特定程序行为一致”这种非平凡语义性质，无法被通过证明程序行为的等价(@4.1.4.1) 任意地引入，因此若无法确定用户程序不需要任意的同一性（这是一种平凡情形），指定“不需要引入同一性”总是只能在特定的程序上由语言设计者或用户具体地决定；
作为通用目的语言若需要描述能适应语言自身实现问题的特性，总是依赖具体语言的逻辑上的直谓(predicative) 的规则（如资源抽象），除非语言规则是空集（这是一种平凡情形），这不可能完全由用户程序提供。
形式上，一等对象是名义同一性属性和它作为一等实体的关联的对象作为非对象（无视同一性）的其它属性集合（如存储的值）的二元组。
语言的设计中显式区分两者的支持而非只直接支持一等对象仍然是必要的，主要原因是：
一等实体的具体表现形式通常是实现细节而要求不被依赖，为了支持前者不被显式表达，满足 @1.4.2.4 ；
一等实体的普遍支持允许以统一(@1.4.5.1) 的方式抽象可变状态(@4.1.3) ，且扩展使便于满足 @1.4.2.1 。
为简化设计，NPL 约定以下默认规则：
除非另行指定，名义同一性属性指定为对象在抽象机(@2.6) 实现的操作语义下的存储位置；对象占据存储位置起始的若干存储；存储位置的表示(@2.3.2) 未指定；派生实现可指定具体的表示。
在语言规则中，一等对象满足 @4.1.4.1 的默认规则。

@4.2.1.2 可变状态和普遍性：
一等实体的普遍支持体现在：
在一般的一等实体上引入可变状态，实质上提供了一等副作用(first-class side effect) ，而不把可修改性(@4.1.4.2) 限于特定的数据结构（如求值环境(@4.6.1.1) ）；
允许以一致的方式和实现的外部环境(@2.3.2) 进行互操作，特别地，允许物理上提供状态抽象的设备实体的状态直接映射为一等对象。
普遍的一等实体支持使一等实体的访问不依赖非一等的实体(@4.2.3.5) 。

@4.2.1.3 Kernel 中的一等对象：
尽管没有显式指出一等实体和一等对象的区别，在 [RnRK] 中的一等对象和此处的一等实体在目的上一致。因为 Kernel 不直接支持区分对象同一性，一等实体退化为一等对象。
并不需要修改一等对象的判定准则(@4.1) 限定为后者并使前者依赖后者的定义，因为作为抽象，前者通常并非是后者的操作上进行限制得到（正相反，一般是通过补充约定假设得到，如 @4.1 的定义）。
类似的一个例子是不可修改对象(nonmodifiable object) 可以但不必要是对应的可修改对象(modifiable object) 的子类型。
作为 @1.4.5.1 的实例，一等实体避免特殊规则，和 [RnRK] 设计原则 G1a 一致。
除非另行指定，本节中的以下描述提供允许派生实现提供保证或假设的机制，并非要求。派生实现可附加规则改变此处对一等对象的保证或性质。

@4.2.2 同一性关联扩展性质：
一等对象之间总是能准确地判断同一性(@4.1.4.1) ：仅当能证明不改变可观察行为(@4.1.3) 时，两个一等对象的同一性可能未指定。
通过一等对象关联同一性，允许语言提供依赖同一性差异的特性。
注意同一性在这个意义上不是对象自身确定的性质（而是对象和解释对象表示的可能由外部提供的实现的共同确保的性质），不是应被隐藏的内部实现，因此 [EGAL] 中有关自我诊断(autognosis) 的结论不适用；而代理(proxy) 仍然可通过语言提供适当的隐藏同一性的手段可靠地实现。

@4.2.2.1 一等状态：
这里的限制集中体现在允许一等对象映射到状态(@4.1.3) 即一等状态(first-class state) 的支持上。
为支持一等状态，有必要支持判断两个对象的同一性，确保修改(@4.1) 某个对象的操作不会关联到任意其它对象，以允许特定对象关联特定的一等状态。
注意并非所有一等对象都需要支持一等状态；否则几乎总是会付出本不必要的代价(@1.4.2.2) 也难以避免违反易用性(@1.4.5.2) ；因此有必要区分一等状态的对象和非一等状态的对象。
这种区分实质上更普遍地对具体的计算操作也存在意义，自然地引入了值类别(value category) ；最简单的设计如区分左值(lvalue) 和右值(rvalue) 分别关联是否需要支持一等状态的对象。
为允许一等状态和外部环境的互操作，不能总是假定只有一类总是可被程序局部预知的修改操作(@4.1.4.2)（典型地，定义为“设置被引用对象(@4.2.3)”操作，如 [RnRK] 3.1 ）影响状态，而应允许和特定对象关联的求值时的不透明的副作用（一个实例是 ISO C 和 ISO C++ 的 volatile 类型对象）。
若不考虑互操作，则一等对象用有限的不同等价谓词(@4.1.4) 即能提供区分同一性的操作；否则，等价谓词的设计即便保持正交，也需区分不同的一等对象对各种副作用的不同支持情况。

@4.2.2.2 一等作用：
语言可指定特定的求值自动创建对象。
典型地，按值传递(@4.4.4.5) 时，被传递后的对象和实际参数(@4.5.3) 表示的对象具有不同的同一性，即按值传递时创建了新的对象。
基于此规则可在传递时附加不同的作用(@4.1) ，即实现可随一等对象传递的一等作用(first-class effect) 。
这里的一等作用可包括用于维护对象的不变性(@2.3.1.1) 的副作用，作为契约式编程(contract-based programming) 的基础实现方式。
这种不变性可包括对象的生存期。通过限制特定表达式求值的作用域(@4.1) 内销毁对象以确保对象生存期有限，即基于作用域的对象管理(scope-based object management) 。
基于作用域的对象管理可直接对应有限资源的普遍性质，使一等对象作为资源的抽象，确保资源的创建和销毁的副作用符合资源操作的语义，同时避免隐式的泄漏。这种惯用法(idiom) 在 C++ 中称为 RAII(resource aquisition is initialization) 。
配合一等状态(@4.2.2.1) ，对象语言中的一等对象允许直接表示超过程序运行时自身的生存期的状态。这允许不在程序运行时持久储存的数据能直接被一等对象进行操作，而不需要依赖外部系统的约定并减少冗余操作（例如，从外部持久的“文件”上打开“流”以及其上的持久化操作），更符合简单性(@1.4.3.2) 。

@4.2.2.3 所有权(ownership) 抽象：
基本规则参见 [Documentaion::CommonRules @@2.3.4] 。
配合一等作用(@4.2.2.2) ，实体的所有权自然地适用对抽象为对象的资源进行约束。
NPL 的设计避免要求对象语言隐含单一的根(root) 所有者作为其它资源的所有者，以适应抽象不同系统的需要，并满足 @1.4.2.1 ：
当不需要这样的所有者时，保持设计的简单性(@1.4.3.2) ，同时满足 @1.4.2.2 和 @1.4.2.3 ；
当需要这样的所有者时，仍然允许实现或派生实现引入。
注意规约(@4.1) 允许蕴含非一等对象的所有者用于提供规约时不在对象语言中可抽象为一等对象访问的资源，这样的所有者不需要是全局的；若实现为在不同规约实例乃至全局共享的资源，也不应在对象语言被依赖。
单一的全局所有者违反 @1.4.4.3 ，且不支持不清楚所有者状态时对特定对象之间进行所有权的局部推理(local reasoning) 。
为满足 @1.4.2.1 ，当需要表达局部所有权关系时，使用单一的全局所有者使用户无法直接在对象内嵌(embedding) 这种关系而需另行编码所有权信息，这存在以下问题：
使整体设计直接违反 @1.4.2.2 ；
要求局部所有权以和全局默认机制的不一致的方式表达，造成接口抽象泄漏(@1.4.3.4)（这首先来放弃局域性(@1.4.2.4) 和需求的冲突）。
此外，即便使用时不要求区分对象的局部所有权关系，全局的分配释放机制也比局部的机制有更大的实现复杂性和约束。为实现对内部有限的资源的有效管理，局部所有权在实现中仍是必要的。
在使用全局所有者如全局的垃圾回收(GC, garbage collection) 的实现中，这种必要性被隐藏在全局所有者内部实现，语言的整体设计不会更简单。
使用全局所有者的资源管理假定启发式(heuristic) 策略以节约现实中无法接受的非预期性开销。这仍无法保证总是对不同的场景同样有效，以至于存在以下问题：
设计至少违反 @1.4.2.1 和 @1.4.3.2 之一；
在不引入支持用户配置策略的扩充设计时，违反 @1.4.2.1 总是无法避免的；
若引入其它设计支持用户配置策略，@1.4.3.2 的违反难以避免，且实际基本上没有被避免；
即便能通过扩充设计避免 @1.4.3.2 ，也不能使设计违反 @1.4.2.2 ；
不论是否引入扩充设计，都会使资源管理的一般开销更难以估计，而使设计整体的可用性评估更困难，容易使用户决策和 @1.4.2.2 冲突。

@4.2.3 引用(reference) ：
尽管满足 [RnRK] Appendix B 的准则(criteria)，和 [RnRK] 及 Java 等语言要求的设计不同，NPL 的一等对象即对象自身，不要求区分引用和被引用对象(referent) 的普遍概念。
注意有引用的语言设计中不能排除被引用对象，否则无法确定对象的值以表达计算；相反，不对引用而直接对值操作仍然能实现一些足够有意义的程序。
因此，若存在引用，无法忽略非引用（即便非引用不能在对象语言被直接使用）；引用可以由非引用的对象添加语义规则派生。
要求语言操作的一等对象总是关联到引用的设计实质上使对象语言的一等对象都是引用。但这不表示引用是自然的一等实体，因为引用的作用仅是操作被引用对象，无法把引用自身作为一等对象进行操作。
反之，通过使引用和被引用对象同为一等对象(@4.2.1) ，NPL 支持一等引用(first-class reference) 。
特定的操作可能预期非引用，或总是隐含通过引用访问被引用对象，这不改变引用被作为一等对象使用的普遍支持。
一等引用的相等关系(@4.1.4) 定义被引用对象的名义同一性相等(@4.2.1) 。这允许相等的引用上推理引用透明性(@4.1.4.1) 。
一等对象的使用仍然可以通过要求引用访问(access) 以避免在任意上下文中需要不同的对象副本。但这并不应排除其它形式的一等对象操作。
考虑此设计决策时关注的有以下几点依据。

@4.2.3.1 设计复杂性问题：
要求一等对象都是引用的设计无法回避几个基本的设计问题：
同时引入引用和被引入对象与仅要求（可能被引用的）对象相比，仅作为某个基本语言子集的设计上即显然更复杂，违反简单性原则(@1.4.3.2) ；
在形式模型(@2.1.1) 意义上，这种设计不支持不提供引用但仍能表达上述足够有意义的计算的子集，这违反最小接口原则(@1.4.2.3) 。

@4.2.3.2 可扩展问题：
在形式模型(@2.1.1) 以外，使用以基本语言子集扩展特性得到派生语言的方式，也无法避免不在对象语言中使用非引用的设计满足通用可编程需求，而产生其它复杂性及可行性问题。
特别地，这导致难以在基础语言的基础上复用和扩充语义规则派生其它语言。
考虑设计和实现整体，要求一等对象都是引用，在简单性(@1.4.3.2) 上是一个过早的优化(@1.4.6.1) ，它限制了一些整体较简单的实用的试图把和同一性(@4.1) 关联的性质附加到对象上的设计。
使用这种关联性质的扩展参见 @4.2.2 的讨论。另见 @4.2.3.5 中的例子。

@4.2.3.3 对象语义问题：
单一类型的普遍引用存在替代被引用的一等对象，容易和一等对象设计的语义冲突。
和不要求仅通过引用而直接提供一等对象的设计相比，消除这些冲突的设计普遍更复杂且难以裁剪，违反简单性原则(@1.4.3.2) 和最小接口原则(@1.4.2.3) 。
而除了放弃要求一等对象都是引用以外的减小设计复杂性的方式，即便只作为核心语言（待扩充特性的基本语言子集），也会显著减小实现普遍需求的抽象（如资源所有权语义(@4.2.2.3) ）的表达能力。
仅对设计被扩充的核心语言而言，放弃一等对象都是引用，允许被引用对象作为一等对象（即便不普遍）而非作为扩充规则的修补仍然更合适。

@4.2.3.3.1 一般的对象属性(@4.1.4.1) ：
非一等的对象抽象实质上利用的仅仅是对“对象”的普遍预期操作的一个较小的子集，显著削弱了一等对象描述（不一定和对象的值直接关联的）附加状态的抽象能力：
仅通过引用访问的一等对象无法被预期是否具有存储以及基于存储的属性如大小(size) ；对生存期和所有权的确定也直接在形式上（而不只是实现上）依赖附加在对象以外的元数据(metadata) ，而无法利用蕴含在被访问的对象内部的状态。
这意味一旦需要这些附加属性时，提供的额外的操作依赖附加的定义。
这同时要求设计中假定普遍存在的作为间接抽象的引用和这些附加定义（直至扩充到被引用对象满足一等对象具有的操作），使语言的设计更复杂。
即使总是使用对象的引用间接访问这些属性，也需要依赖对象自身。
因此若设计不提供这些接口，实现仍然需要负担开销。尽管不提供接口可能容易优化实现，激进的优化和扩展语言特性很大程度上是矛盾的。

@4.2.3.3.2 对一等状态(@4.2.2.1) 的支持：
在具有引用的情况下，区分不同的副作用的实质由被引用对象引起，而并非引用的性质；要求一等对象都是引用并不简化派生实现添加不同一等状态的支持，反而引入了无法回避的复杂性。
单一类型的引用和以上最简单的值类别(@4.2.2.1) 的设计兼容，只要把引用关联到左值，非引用关联到右值即可；但这种设计和要求一等对象都是引用矛盾，因为后者使这里的右值不再是一等对象。
若特定的对象访问操作都通过引用进行，这些操作中需要的状态可直接使用引用提供；这是一种保守的设计优化，不保证可替代任意的对象属性(@2.3.3.3) 及基于这些性质的其它操作。

@4.2.3.3.3 对所有权(@4.2.2.3) 的支持：
实体的所有权无法通过单一类型的引用直接被区分。
引入非全局的所有权不依赖一等对象都是引用的设计。
与直接使用带有所有权的对象的设计比较，通过引用保持对象的所有权引入不必要的复杂性。若保证引用确定所有者，则：
需要单一的全局所有者(@4.2.2.3) ，或；
引用总是需要带有指示所有者的元数据（例如，在对象的引用的内部实现总是隐含对对象的所有者的引用），一般情形这无法由实现或者用户总是保证等效地移除，违反 @1.4.2.2 。
因为存在以上的已知问题，一般的引用不保证对象的所有权。
需保证所有权以实现资源管理等目的的特定的引用可在实现内部提供及由派生实现定义的特定数据结构引入，以支持 @1.4.2.1 。

@4.2.3.4 共享引用问题：
共享引用指在不同位置中（即作为不同一等对象的）的引用可能引用同一个被引用对象。
合理的共享引用可以节约实现占用的资源，提供更好的性能。但共享引用的实现仍可能有附加的开销，因此并不能保证使用共享引用一定能提供更好的性能。通常这种情形至少包括一些典型的对资源独占一次使用（具有独占所有权(unique ownership) ）的情况。
更重要地，并非任意引用的共享都不改变程序的语义和行为，不合理的使用可能造成非预期的作用。
任意地引入共享引用而使用户不便预测其作用破坏易用性（参见 @4.2.3.4.1 ）。
区分是否需要表达共享的情形一般不能由语言实现预知。和使用全局所有者的问题(@4.2.2.3) 类似，使对象默认共享的设计若需避免违反 @1.4.2.2 ，在此违反 @1.4.3.2 。
默认共享引用可能是隐式的，即语言的实现不通过程序代码中的显式标注的操作而引入共享的引用，且往往无法保证通过一等对象上的操作避免被引用的对象被其它一等对象引用——无法使用对象语言的操作排除共享引用（即便是新创建的对象也没有保证，尽管实现上不必要）。
一些语言的设计指定或隐含的规则在程序代码操作的一等对象上普遍地引入隐式共享的引用，如：
[RnRK] 中的引用和被引用对象明确地分离，且 $define! 和 set-car! 等改变操作(@4.1.4.2) 要求设置对象引用的其它对象为特定的操作数确定的被引用对象，无法排除被设置的引用被共享；这实质要求所有可能包含其它引用的可被改变的对象中的引用都需要能构成隐式的共享。
[RnRS] 明确指出特定的空对象的唯一性（即便因为不保证具有位置(location) ，不一定保证以位置决定的名义同一性(@4.2.1) ），蕴含这些对象上总是可构造或超过一个引用必须构造隐式的共享引用；其它变量引用(variable reference) 未指定排除隐式的共享。
在要求一等对象都是引用的设计中，一般地，只有不要求名义同一性(@4.2.1) 的非对象的实体才能安全地共享引用，但在非对象实体上的类似引用的机制并没有保证通过一等引用提供为语言特性；
其它情形下，允许引用之间的隐式的共享使不相同的对象(@4.2.1) 可能共享状态而破坏同一性的行为保证(@4.1.4.1) ：程序无法可靠地避免共享状态导致的可观察行为的影响（如 @4.2.3.5 中的操作），此时共享状态的改变非预期地影响其它对象而不具有一致性(@1.4.3.1.2) 。
为了排除破坏同一性和易用性的问题，语言的设计需要限制引起问题的操作的可用性（例如，[RnRK] 和 [RnRS] 不提供使用一等引用的变化操作以保证变化能通过程序源代码中有限的语法上下文被推理），但这样的策略限制设计的通用性(@1.4.7) 。
因为共享引用的影响的普遍性，不提供可避免隐式共享引用的设计的造成的缺陷也是普遍的。
由于显式的引用可以由用户控制在局部使用，更容易推理其影响，可避免类似的缺陷。

@4.2.3.4.1 易用性(@1.4.5.2) 问题：
任意地引入共享引用而使用户不便预测其作用破坏易用性(@1.4.5.2) 。
特别地，这和具有副作用的非确定性(non-deterministic) 编程冲突。
典型的多线程并发执行若需对象上的副作用，需要保护和排除不必要的共享，确保独占所有权以避免竞争条件(race condition) 。也有其它的一些类似的容易被忽略的场景，如：
http://okmij.org/ftp/continuations/map-story.html
另见 @4.2.3.5.3 。

@4.2.3.4.2 对象语言语义问题：
在未证明共享引用一定节约开销时，隐式的共享对象语言程序违反 @1.4.2.2 ，或者在实现需要明确对资源使用的约束时，对进一步的程序变换带来开销（如需要别名分析保证安全），进而鼓励用户代码违反 @1.4.2.3 。
隐式的共享添加伪依赖(pseudo dependency) 减小可程序中操作共享对象的可并行部分，也会由于对共享同步操作的要求而限制并发程序的设计。

@4.2.3.4.3 普遍的设计限制：
除非在语言规则中添加复杂的约束（如通过类型系统）以证明特定上下文可避免共享引用，无法避免引用引入不必要的别名(aliasing) 。若公开这样的性质作为接口约束，违反 @1.4.2.3 。
隐式的共享使涉及修改(@4.1) 的操作的特性更难设计，参见 @4.2.3.5.3 。

@4.2.3.4.4 普遍的实现限制：
隐式的共享会隐藏一些语言不可访问的全局属性，使实现在提供语言特性之前先行受到限制，而影响可移植性。
隐式的共享要求运行时具有维护共享资源的机制。由于物理上资源并不能自然地共享，无法避免维护共享状态的运行时机制，如全局 GC(@4.2.2.3) 。
按 @4.2.2.3 ，这样的机制不被公开为 NPL 的设计。
若派生实现提供这样的机制的公开接口，则削弱实现对隐式的共享对实现带来的可用性，且用户利用这样的设计合理地消除开销仍然是普遍困难的。
维护共享状态的运行时机制依赖隐式的资源分配，以维护被引用对象和引用以外的全局状态。这样的分配机制难以具有可移植性，或者公用的可移植机制并不能满足隐式共享的引用的语义而必须有附加的开销，在一定程度上违反 @1.4.2.2 。
依赖全局状态的实现通常无法简单地通过程序逻辑的推理消除运行时的状态依赖或把运行时拆分为不同的系统。这使实现通常无法直接部署在分布式系统上而阻碍 @1.4.2.1 。
特别地，指令集架构(ISA, instruction-set architecture) 以地址空间(address space) 这样典型的形式提供的存储空间资源的元素之间通常是不可共享的；ISA 的实现共享的资源（如 cache ）并不为解决共享问题而设计，也不在 ISA 显式提供而基本不可能被利用加速隐式共享引用的实现。
现实的语言实现通常也符合这里的判断。典型地，允许普遍地通过引用提供隐式的共享行为的语言（如 Scheme ）使用不支持隐式的共享引用的语言（如 C ）实现，因为前者需要后者实现运行时；反之则几乎不存在实例，因为去除运行时的共享而模拟总是不共享的（可变的）对象是不必要和低效的。
使资源到修改(@4.1) 操作之后延迟分配使系统的失败风险被集中，但同时引入更多不确定性。添加不同的使用范型(paradigm) 和场景往往使对系统性能和可靠性的评估都更困难。
现有的如 COW（ copy-on-write ，写时复制）启用隐式资源共享的策略，都会要求运行时机制的更大的计算开销并增加系统复杂性。在硬件支持机制（如地址翻译）的辅助下，加速特定被指定总是进行的任务可使系统整体性能提升，但这不保证能适合作为通用的计算策略。
考虑到脱离硬件支持的情况下，一般的引用访问总是需被实现为额外的（间接）操作，这种缺陷也不能被实现直接避免。
即便在设计以下引入等价引用的兼容层可能提升实现被复用的可能性，不需要通过引用表达的属性仍然存在，减小复杂性需要保留冗余的间接操作而损害性能等实现质量。

@4.2.3.4.5 语言的演化问题：
允许实现按需引入特定而非普遍的引用是更符合一般需求的决策。
在已具有隐式的共享作为普遍的默认特性的设计的语言中，引入保证不共享的机制（如所谓的值类型(value type) ）难以复用现有的特性，而需要大量并行的冗余设计。如 Java 添加值类型要求大量改动 JVM 添加无法被先前的语言实现机制表达的 inline class ：
http://cr.openjdk.java.net/~dlsmith/lw2/latest/

@4.2.3.5 可变对象问题：
仅使用引用操作一等对象在涉及对象修改(@4.1) 的存在一些问题。
一般地，和对象改变操作(@4.1.4.2) 对应的作用(@4.1) 及其类似的副作用(@4.1) 也和修改对象有类似的问题。

@4.2.3.5.1 可变对象操作限制：
在使用普遍引用的设计中，实体的可修改性(@4.1.4.2) 可能以被引用对象的可变性提供：通过允许改变对象中包含的引用指定对象可变，而体现可修改性。
因为引用不能替代被引用对象，即不能避免不包含引用的实体，这样的设计并不涵盖这些的一等对象可修改性。
Scheme 通过 SRFI-17 在受限的上下文引入可分辨同一性的一等对象(@4.2.1) 。相对一般的一等对象，这种设计违反简单性(@1.4.3.2) 和统一性(@1.4.5.1) 原则。
使用这样的操作要求可变对象是已知环境绑定的变量，而事实上无法脱离求值环境(@4.6.1.1) 。因依赖引入变量绑定的具体的环境，若需进行可变对象的互操作，需要隐含环境作为操作数。在没有依赖变量绑定（而仅要求可变对象自身）时，这种不必要的依赖违反了 @1.4.2.2 。
实际使用时，这表示无法简便有效地表达“在多个已知不同的一等对象中选择值满足特定属性的对象进行改变”这样的操作，如在 C++ 中可实现的如下操作：
bool f(int);
int x = 1, y = 2;
++(f(x) ? x : y);
这样的操作中，若不同对象具有不同的值，无法共享被选择的不同对象；反之，表达这样的操作反而需要复制对象。引入附加的绑定来变通时，这种局部操作的意图是明确的，并不因此更易预测(@1.4.5.2) 。这样的抽象性上的损失并不能保证换取相应的其它优势。
依赖这种可变操作的限制可能简化语义模型，如 CEKS 抽象机（参见 https://legacy.cs.indiana.edu/ftp/techreports/TR202.pdf ）。
但是这类模型中依赖的全局存储引入了其它的问题，参见 @4.2.2.3 。

@4.2.3.5.2 对象分类的复杂性：
限制一部分只包含引用的实体具有可变性，即便是只在基本的数据结构上应用，也容易导致对象分类的复杂化而使设计违反简单性。因为区分可变和不可变对象而需要更多的特设的操作，也一定程度上违反统一性。
例如，Racket 区分可变和不可变的基本数据结构（从 https://blog.racket-lang.org/2007/11/getting-rid-of-set-car-and-set-cdr.html ），修改操作不能通用。除非用户明确需要，这样要求选取的类型是否不变（特别是没有引入区分同一性的一等实体支持时）是过早的优化(@1.4.6.1) ，同时违反 @1.4.2.1 和 @1.4.2.3 。
注意，改变操作的冲突可以是未定义的(@2.3.2) 。避免冲突不是语言设计选取不变数据结构的合理理由（相对地，选择避免冲突的数据结构是用户的合理理由）。提前放弃未定义的选项，要求任意无法具有实际意义的操作冲突具有一致的行为(@2.6) 也是设计上的过早优化。

@4.2.3.5.3 共享改变：
仅允许这样的可变性也不允许被引用的对象通过不同引用可共享改变。
共享改变通常需要使用可变的包含引用的容器对象（称为箱(box) ）以至实质上的装箱(boxing) 和拆箱(unboxing) 操作，如 SRFI-111 。
这有以下问题：
这同样违反了简单性；
这使基于等价关系定义不同的修改(@4.1.4.2) 更困难且难以实现统一性(@1.4.5.1)（例如，需要更多的特设的基本修改操作(@4.1.4.2) ，或者如 SRFI-17 这样的为修改操作特设的上下文），乃至缺乏实际意义；
若支持 SRFI-111 的自动装箱(autoboxing) （实际包含自动拆箱(autounboxing) 和幂等(@4.1) 的拆箱操作），则进一步违反简单性，也更难以实现统一性。
基于 [RnRK] 的封装类型(encapsulation type) 可实现装箱，但装箱实际上依赖的是共享的引用，并非封装类型自身的名义类型(@4.6.2.1) 特性，不符合 @1.4.2.4 。并且，在扩展针对个别对象的属性（如不可变性(@4.1.4.2) ）时它仍存在一些不容易扩展的较复杂的问题，如：
https://groups.google.com/forum/?fromgroups#!topic/klisp/pLz-uqJ0WfE 。
使用 [RnRK] 的设计而在此之后引入一等引用（而不仅是一等被引用的对象）可能是对语言特性的实现的复杂的改动，但直接消除隐式的共享(@4.2.3.4) 而使用一等引用的设计并不需要这样的复杂性。
封装类型作为装箱以外仍有意义。封装类型仍可用于实现箱，但这只是实现细节，更一般的情形两者是无关的——这也符合 @1.4.2.3 和 @1.4.2.4 的要求。

@4.2.3.5.4 退化的间接改变：
退化的箱(@4.2.3.5.3) 可能不共享改变。这样的箱和一等引用没有实质区别。
例如，表达为 Box<T> 、Reference<T> 或 Array<T> 这样的被装箱类型 T 的参数化类型，在这个意义上等价。
但是，依赖共享改变的特性在这样的设计中仍然是奇异的和非必要的，尽管这样的类型在某些过程调用(@4.5.3.1) 缺乏引用的语言中被作为替代引用传递(@4.4.4.5) 参数的变通（如 Java ）。
直接支持一等引用而不是其它类型使用户可自行扩展其它类型，在不依赖隐式共享的引用和封装类型(@4.2.3.5.3) 时仍符合可扩展性(@1.4.5.1) 。
一等引用外的其它类型在这个意义上仅因为共享的引用而具有可变性，这是实现细节而不应被依赖。它们应具有其它的特定的含义，以避免违反 @1.4.2.3 、@1.4.2.4 和 @1.4.3.2 ，并允许实现支持 @1.4.2.2 。
例如，[RnRK] 中的 pair 因为 set-car! 等操作相当于这里的可改变的箱类型。在不保证共享改变的引用也不引入一等引用时，改变不会被扩散。

@4.2.3.6 非必要性和其它限制：
对语言设计中的一些关键规则，要求使用引用同时保留非引用的形式访问对象并非必要，因为满足以上准则实际上仅关心对象（类似作为表达式）直接关联的值，而非其它属性。
这也体现是否仅允许通过引用访问对象应是实现细节，而不影响一等对象的判定。
依赖一等对象都是引用保证普遍的间接抽象能提供一部分实现的便利（如 TCO(@5.2.6.4) 可以直接移除活动记录帧(@4.5.3.4) ），但并非没有可忽略的代价（如要求全局 GC(@4.2.2.3) 引入非确定性）和替代实现方法。
关于 TCO 的实现方式，另见 @7.3 。

@4.2.3.7 其它替代：
不依赖普遍引用的设计仍允许特定一等对象以引用形式在对象语言中直接访问。
对象语言仍可引入普遍的、独立于被引用对象的引用实体，供用户使用。
这种引用可能是非一等的，例如 ISO C++ 的引用类型；也可能是一等对象，如 ISO C 的指针（不需要使用指针算术）。
这些引用不需要具有隐含的普遍引用的限制。对象作为实体，其不可变性(@4.1.4.2) 的描述不依赖关联的引用是否存在，尽管实现仍可能通过判断只使用限定为不可变（如 const 限定符）的这些引用进行访问的情形以假定或证明对象是否可变。

@4.2.4 自引用(self-referencing) 数据结构和循环引用(cyclic reference) ：
特定的数据结构在逻辑上要求内部具有相互指涉的引用，即自引用。
自引用可实现为一等对象集合内的循环引用，即允许对象属于有限次迭代访问被引用对象的操作的传递闭包（非空的链(chain) ，称为引用对象链）的构造。
NPL 的设计不保证支持这种方式实现自引用以避免一些固有缺陷。即便派生语言允许提供扩展支持，但本节讨论的原理仍然适用。
避免自引用的构造使实体构成的数据结构由一般的图(@4.1.5) 退化为（可共享节点的）树形数据结构，即 DAG（Directed Acyclic Graph ，有向无环图）。
这样的设计在实现上避免外部所有者（如全局 GC(@4.2.2.3) ）。
避免一般的循环引用的普遍理由是非直谓性(impredicativity) 并非是抽象上必要的普遍特性。一般的循环引用在抽象上即应通过特殊进行归纳，这并非泄漏抽象(@1.4.3.4) 。
反之，需求决定的抽象上不必要的情形下，假定循环引用的存在反而妨碍抽象的构造，可能避免某些有用的普遍性质（例如，保证程序可终止；另见强规范化性质(@4.4.3) ），而违反 @1.4.3.2 、@1.4.5.1 和 @1.4.5.2 ，并引起若干具体设计问题(@4.2.4.2) 。

@4.2.4.1 循环引用和所有权：
循环引用支持和一等对象引用(@4.2.3) 的一些性质密切相关，特别地，隐含所有权(@4.2.2.3) 的假定。
数据结构的实现蕴含对资源（如存储空间）的使用，其中必然存在不被外部所有的资源，表示为内部的资源对象。
这包含宿主语言对象对具有所有权的对象的情形，如宿主语言对象的子对象。后者统称为内部对象(internal object) 。
为维护数据结构的边界，满足最小依赖原则(@1.4.4.3) ，数据结构作为宿主语言对象，其中的内部对象应具有以下性质：
数据结构对内部对象具有整体所有权。
推论：数据结构不引用自身。
注意，以上性质是逻辑上的普遍要求。具体的一些语言中，可能因为通过只通过外部所有者代理的方式的访问而无法在实现上保证，但这种逻辑关系仍应存在。
不具有所有权的对象不是内部对象。

@4.2.4.2 通过任意对象支持循环引用的问题：
若直接通过对象之间的引用支持循环引用，且不附加不由用户程序控制的数据结构外部的所有者，有以下问题：
首先，在设计上，这和资源释放算法([Documentation::CommonRules @@2.3.6.5.1]) ）要求所有权正规化([Documentation::CommonRules @@2.3.6.5.1]) ）矛盾。
由于没有外部所有者，必须存在明确的所有权的下界。这要求内部对象的引用至少需要区分两种引用（典型情况即区分是否可确定存在对其它对象具有所有权的引用）。
因此，除所有内部对象之间不具有所有权而直接被表示数据结构接口的单一对象所有外，内部引用对象链中的对象不能都对其它内部对象具有平等的（单一种类的）所有权。
否则，这种对内部实现的限制是一种资源管理机制的抽象泄漏。
其次，在实现上，相对不具有循环引用的情形，有更大的且难以避免的时间和空间开销。
此外，无论是否附加外部所有者，都需要引入更多的处理循环的专用(ad-hoc) 规则。
以上问题体现在不使用循环引用的场合下，一般对象上的循环引用同时违反避免不必要付出的代价(@1.4.2.2) 、最小接口原则(@1.4.2.3) 和关注点分离原则(@1.4.2.4) ，也不利简单性(@1.4.3.2) 。
这些问题的根本原因是所有权没有被足够早地显式区分。更进一步地，不附加外部所有者的普遍的循环引用要求不能直接区分，否则可通过定义某种规则从中判断出不循环的(acyclic) 的引用链的子集而不构成循环引用（实际上若能保证复杂度(@2.3.2) 上限，这也是消除循环引用的主要方式）。
因此，除非允许语言隐含不由用户程序指定的所有者，保留循环引用无法解决这些问题；甚至即便允许这样的所有者，也无法彻底解决实现开销的问题（而需要更多地依赖语言实现系统外部的假定减缓这些开销），仍然一定程度上不符合以上提及的所有原则的要求。

@4.2.4.3 自引用数据结构相关的一般实现：
没有理由表明通过任意对象支持循环引用是自引用(self-referencing) 数据结构的唯一实现方式，不论使用自引用数据结构的普遍程度。
自引用数据结构可通过在更高的抽象层次上编码，转换为由用户（而不是语言实现）指定明确的外部所有者的形式消除上述所有问题，同时对外部保证同等的功能正确性(@1.4.3.1) 。
典型地，在不支持循环引用的对象构造中保存无所有权的一等实体引用其它实体，构造出不蕴含所有权的仅以特定对象构成的循环引用，而在外部引入对象作为所有这些构成引用的对象的所有者。这也是 C 和 C++ 等语言惯用的实现图(graph) 的数据结构的合理方式。
此外，无限数据结构不一定需要自引用数据结构表示。并且，即使使用自引用数据结构，也只适合直接表示其中的具有周期性的无限结构。使用生成序列替代无限数据结构的直接表示则没有周期性要求和限制。

@4.2.5 其它普遍性质：
更一般地，基于和 [RnRK] 中讨论类似的其它实用性理由，定义一等对象的准则和设计决策还应满足以下几点：
第一，应使一等对象的定义和基于状态存储的对象的概念定义一致，即一等对象是对象。
第二，应允许类型(@4.6.2) 在语言中被抽象为一等对象。
一等对象准则内不依赖类型的概念（而可依赖值域(value domain) ）以避免概念定义的循环依赖。

@4.2.6 实体类型：
NPL 不要求预设的实体及对象类型的设计，因此不要求用户使用语言体现整体上的可扩展性(@1.4.5.1) 。这允许由派生实现指定类型的外延而满足 @1.4.2.1 。
另见 @4.6.2 。
除不必涉及引用(@4.2.3) 外，[RnRK] 中定义的封装的(encapsulated) 类型的概念及类型封装性（ [RnRK] 原则 G4 ）仍然适用，且一般仍然需要满足；差异是派生实现因为扩展不满足的情形也不影响此实现的一致性(@2.4) （尽管使用扩展的程序可能不可移植）。
表达式中的对象的类型和值类别(@4.2.2.1) 应分别讨论，因为两者正交：两者的确定(typing) 和检查(typechecking) 机制都相互独立。

@4.2.7 例子：
存在一些判定准则不符合这些要求，如 [RnRK] 中引用的 [Gu91] ：
“类型”未经定义直接出现在规则中，不满足 @4.2.5 最后一点；
显式地放弃了生存期的抽象，不满足上述 @4.2.3 第一点要求的对象一般属性的抽象能力。

@4.3 名称规则：
名称(@2.3.2) 和能标识特定含义、符合名称词法约束(@3.3) 的表达式(@3.4.2) 一一对应。
具体的外延由派生实现定义。
表示名称的表达式不同于名称，但在无歧义时，语言中可直接以名称代指表达式和对应的词法元素。

@4.3.1 声明区域(@4.1) 约定：
对引入名称 n 的声明 D ，对应的声明区域始于紧接 n 的位置，终于满足以下条件的记号“)”（若存在）或翻译单元末尾（不存在满足条件的记号“)”）：
记号“)”和与之匹配的记号“(”构成的表达式包含 D ；
此记号之前不存在满足上一个条件的其它的记号“)”。

@4.3.2 可见(visible) 名称：
名称隐藏规则：若声明 D 是表达式 E 的子集，且不存在 D 的子集声明同一个名称，则 D 声明了有效名称，隐藏了 E 中其它同名的名称。
在声明区域(@4.1) 中，没有被隐藏的名称是可见(visible) 的。有效名称实质蕴含可见名称。

@4.3.3 名称解析(name resoultion) ：
名称解析是通过名称确定名称指定的实体的操作。
名称解析包括名称验证(name verification) 和名称查找(name lookup) 。
不保证名称解析总是成功。
名称验证确定可见名称(@4.3.2) 的基础上确定名称是否有效。
名称查找是从已知有效名称确定唯一指称的实体的过程，仅在名称验证成功后进行。
不同名称经过名称查找的结果可能等效。等效的有效名称视为同一的，规则由派生实现定义。
除非另行指定，成功的名称解析没有影响可观察行为(@4.1.3) 的副作用(@4.1) 。
以上约定以外的具体规则以及失败的行为由派生实现定义（另见 @4.6.1.1.2 ）。

@4.3.4 命名空间(namespace) ：
命名空间是实体(@2.3.2) 。命名空间可以由名称指称。
是否实现命名空间为程序中可由用户指定可变的实体及求值环境(@4.6.1.1) ，由派生实现定义。

@4.3.4.1 指称(denotation) ：
总是没有名称指称的命名空间是匿名命名空间(anonymous namespace) 。
没有有效名称指称的命名空间是未命名命名空间(unnamed namespace) 。
注意匿名命名空间和未命名命名空间不同。前者可能是一个系统的默认约定，一般整体唯一存在（如全局(global) 命名空间）；后者只是对某些接口隐藏，可以有多个。
NPL 定义一个抽象的匿名命名空间，称为根命名空间。未命名命名空间的支持由派生实现定义。
NPL 约定一个在实现中的有效名称总是指称一个命名空间。有效名称指称的命名空间的同一性和有效名称的同一性(@4.3.3) 对应。

@4.3.4.2 成员(member) ：
除了用于指称的名称外，一个命名空间可以和若干其它名称关联。
通过派生实现定义的对命名空间的操作可以取得的名称是这个命名空间的成员。
若无歧义，命名空间的成员指称的实体也称为这个命名空间的成员。
命名空间直接包含成员，称为直接成员。
除了根命名空间和其它派生实现定义外，命名空间可以作为另一个命名空间的成员，此时命名空间内的成员（若存在）是包含其的命名空间的间接成员。
命名空间对成员的直接包含和间接包含总称为包含，是反自反的、反对称的、传递的二元关系。

@4.3.4.3 简单名称(simple name) 和限定名称(qualified name) ：
命名空间的直接成员(@4.3.4.2) 的标识符在这个命名空间中是有效名称，称为简单名称。
命名空间及其成员按包含关系依次枚举标识符组成的序列是一个名称，称为在这个命名空间中的限定名称。
根命名空间的限定名称称为全限定名称(fully qualified name) 。
限定名称的语法（如标识符之间的分隔符等）由派生实现定义。

@4.4 求值和规约规则：
基于基本语义规则要求(@4) 和基本概念(@4.1) ，对象语言的操作语义(@2.2.3) 可通过关于规约(@4.1) 的重写规则(rewriting) 中的步骤(step) 指定。
这样的重写规则称为规约规则。
描述 NPL 对象语言的操作语义也可被视为特定的对象语言，其规约可以视为求值。但除非另行指定，以下表达式仅指对象语言的表达式，其求值仅指关于对象语言中表达式的求值，而非一般的规约。
一个规约可以描述表达式的求值(@4.1) 。直接表达一个表达式求值的规约是一个求值规约。
描述操作语义或实现可使用的求值规约以外的规约称为管理(administrative) 规约。
管理规约可以是求值规约的一部分，或者和求值规约的步骤没有交集。
系统的规约规则即表达式的求值规约规则和管理规约规则的并集。
抽象求值(@4.1) 中不在对象语言求值结果(@4.1) 中可表达的中间规约是管理规约实现。
求值的基本操作以满足特定规则的替换(substituion) 规则或其组合表示。
除非另行指定，以下讨论的排除求值副作用的重写系统具有汇聚性(@4.1.2) 。
这保证求值满足以下基本规则：
值替换规则：表达式的值的计算通过已知的子表达式的值替换决定。
除非派生实现另行指定，子表达式的值仅由求值得到，此时递归蕴含规则(@4.4.4.1) 中的求值依赖规则是这个规则的推论。

@4.4.1 顺序(order) ：
先序(sequenced before) 关系是两个规约之间存在的一种偏序关系(partial order) ，对实现中规约之间的顺序提供约束。
后序(sequenced after) 是先序的逆关系。
非决定性有序(indeterminately sequenced) 是先序或后序的并集。
无序(unsequenced) 是非决定性有序在求值二元关系全集上的补集。
非决定性规约规则：除非派生实现另行指定，递归蕴含规则(@4.4.4.1) 约定外的任意表达式的求值之间无序。
非决定性规约规则允许在语言中表达并发实现(@2.4.2) 。
规约规则的顺序直接适用于求值，其顺序为求值顺序(evaluation order) 。

@4.4.2 求值性质：
两个具体求值等价，当且仅当两者的作用相等。
两个求值等价，当且仅当作为具体求值时等价，或其中每个求值的变换实质蕴含另一个。
没有副作用的求值是纯的(pure) （仅有值的计算或抽象求值）。
值为被求值的表达式自身的具体求值或不包含变换为存在不等价求值的表达式的抽象求值为恒等(identity) 求值。
恒等的纯求值是空求值(empty evaluation) 。
作用是空集的表达式求值是空作用求值(null effect evaluation) 。推论：空作用求值是空求值。
语法形式(@3.4.3) 固定且求值总是空求值的表达式是空表达式(empty expression) ，这仅由派生实现可选提供。

@4.4.3 范式(normal form) ：
规范化形式(normalized form)，或简称范式(normal form) ，是由派生实现定义的表示(@2.3.2) ，被一组规约(@4.1) 规则确定，满足：
通过有限的规约步骤后得到；
按规约规则，规范形式上不存在不和空求值等价(@4.4.2) 的进一步规约。
在具有 Church-Rosser 属性的重写系统(@4.1.2) 中，一个对象若具有范式则唯一。
表达式在得到规范形式后规约终止，且蕴含求值终止。
得到范式的规约步骤称为规范化(normalization) 。
若表达式规约总是能得到规范形式（求值总是能在有限规约步骤后终止），则具有强规范化(strong normalization) 性质。
实现应避免引起无法保证强规范化性质的操作（如直接无条件的递归规约调用）。
除非派生实现另行指定，不保证强规范化性质。
保证得到范式的规约是规范化规约。
具体求值得到的范式若可作为表达式，其求值结果(@4.1) 和被求值的项等价，即仅允许恒等求值(@4.4.2) 而仍是范式；这样的项称为自求值项(self-evaluating term) 。
重复求值直至取得自求值项的求值结果是最终求值结果(final evaluation result) 。

@4.4.3.1 其它规范化中间表示：
第一个子表达式（头表达式）是范式的表达式是 HNF（Head Normal Form ，头范式）。
头表达式是可直接求值为范式的表达式是 WHNF（Weak HNF，弱头范式）。
约定求值到 WHNF 提供保证强规范化性质的一般手段，可用于非严格求值(@4.4.4.5) 。
WHNF 的头表达式是操作符(operator) ，存在对应 HNF 的头表达式的最终求值结果(final evaluation result) ，详见 @4.5.3.2 。
WHNF 中除了操作符以外的子表达式是操作数(operand) 。
操作数以具有限定顺序或不限定顺序的数据结构表示，典型代表分别是操作数列表(operand list) 和操作数树(operand tree) 。
操作数树是有限的树形数据结构的 DAG(@4.2.4) （和 Kernel 类似），其具体构造和表示由派生实现定义。

@4.4.4 组合求值：
表达式和子表达式之间的求值需满足一定约束。

@4.4.4.1 递归蕴含规则：
除非派生实现另行指定，表达式和子表达式之间的求值满足以下递归蕴含规则：
求值依赖规则：表达式被求值实质蕴含子表达式(@3.4.2) 被求值。
顺序依赖规则：子表达式求值先序(@4.4.1) 所在的表达式求值。
平凡求值规则：指定一个表达式是平凡求值(@4.4.2) 实质蕴含其子表达式的求值被指定为平凡求值。

@4.4.4.2 严格性(strictness) ：
若表达式的任意子表达式的求值总是非空求值(@4.4.2) 且先序表达式求值，则这个表达式的求值是严格的(strict) ；反之，求值是非严格的(non-strict) 。
推论：严格求值满足顺序依赖规则。
非严格求值在规约时可保留未产生作用（通常即未被求值）的部分子表达式，允许实现根据先序的求值作用确定的选择性求值，即包括未指定是否作为空求值(@4.4.2) 的子表达式求值，如分支判断或短路求值。
例如：ISO C++ 的条件表达式存在可能未被求值的操作数(@4.4.3.1) ，属于非严格求值； ++ 表达式不作为完全表达式(full expression) 时，副作用可超出此表达式的求值（不满足顺序依赖规则），也是非严格求值。
表达式经过严格性分析(strictness analysis) 确定是否严格求值，通过严格性分析器(strictness analyzer) 在语义分析(@2.4.1) 时实现。
中间值(thunk) 是保留不直接实现具体求值的部分子表达式的特定的数据结构。
例如，通过保留中间值待延迟求值，可实现子表达式值的按需传递(@4.4.4.5) 。

@4.4.4.3 顺序求值：
明确的词法顺序可为同一个表达式的若干子表达式提供一致的有序求值策略：从左到右或从右到左。为一致性，不需要考虑其它特定顺序作为一般规则。
递归文法表示的表达式和子表达式之间存在相对内外顺序：子表达式在表达式的内部。此求值顺序可对应表达式树的遍历顺序。

@4.4.4.4 替换策略：
对应项的规约规则的表达式的重写规则由派生实现定义，基本的可选项包括：
名称替换：保证替换前后项对应的名称不变；
实体替换：保证替换前后项关联的实体不变；
值替换：保证替换前后项关联的表达式的值满足实现定义的相等关系。
引用替换：保证替换前后项关联的表达式的值以实现定义的方式引用同一实体。

@4.4.4.5 求值策略：
组合严格、顺序求值和替换策略可得到不同性质的求值策略。
除非派生实现约定，表达式求值策略可以随具体语法形式(@3.4.3) 不同而不同。
典型性质组合如下：
严格求值：
应用序(applicative order) ：以最左最内(leftmost innermost) 优先的顺序求值。
顺序仅在操作数是有序数据结构(@4.4.3.1) 时有意义；不考虑操作数内部构造时，仅表示操作数作为子表达式总是被求值，和严格求值等价。
按值传递(pass by value) ：使用值替换的严格求值。
按引用传递(pass by reference) ：使用引用替换的严格求值。
共享对象传递(pass by shared object) ：使用的共享机制以及对象和值或引用的关系由派生实现定义。
部分求值(partial evaluation) ：允许求值分为多个阶段(phase) 。
非严格求值：
正规序(normal order) ：以最左最外(leftmost outmost) 优先的顺序求值。
按名传递(pass by name) ：使用名称替换且保持作为名称的表达式最后被替换的求值。
按需传递(pass by need) ：按名传递但允许合并作用相同的表达式。
非决定性求值(@4.4.1) ：
完全归约(full reduction) ：替换不受到作用之间的依赖的限制。
按预期传递(pass by future) ：并发的按名传递，在需要使用参数的值时同步。
乐观求值(optimistic evaluation) ：部分子表达式在未指定时机部分求值的按需求值，若超出约定时限则放弃并回退到按需求值。

@4.4.6 可选求值规则：
应满足的本节上述约定的最小求值规则和语义外的具体求值的规则和语义由派生实现定义。
派生实现的求值可满足以下节指定语义，此时应满足其中约定的规则。

@4.4.7 上下文相关求值：
在被求值的表达式以外，对应的规约规则在实现此规约的元语言(@2.3.2) 中可能是上下文相关的，这种附加依赖的上下文为求值上下文(evaluation context) 。
求值上下文被作为元语言实现对象求值规则时的输入，可指定项所在的位置等不被被规约的项必然蕴含的附加信息。
由派生实现定义的特定求值上下文称为尾上下文(tail context) 。以尾上下文求值可提供附加的保证。
元语言中，一般的求值上下文 C 形式化为具有占位符 [] 和可选前缀 v 及可选后缀 e 的递归组合的串：
C ::= [] | Ce | vC
其中 e 是被求值表达式，v 是作为范式(@4.4.3) 的值。
通过附加适当的求值规则保证对象语言中的表达式总是可唯一地被分解为这种表示，抽象的求值上下文可直接实现对象语言的求值。但语义描述和实现的基准都以抽象机(@2.6) 替代，因为：
抽象机语义允许不依赖源程序的表示和构造（如特定的表达式的文法）；
这种分解一般要求遍历对象语言的源程序而难以具有较好的可实现性质，如复杂度(@2.3.2) ；
为满足良好的可实现性质，需描述实现中可能具有的离散状态与只和其中个别状态关联的局部的求值规则时，这种分解通常会渐进演化为某种抽象机的表示。

@4.5 λ 完备语义和对应语法：
作为通用语言，求值规则表达的系统可具有和无类型 λ 演算(untyped lambda calculus) 对应的形式和计算能力。
基于此语义的派生实现应允许以下几种互不相交的表达式集合：
名称表达式(name expression) ；
匿名函数(anonymous function) ；
函数应用(function application) 。
具体含义见以下各节。
注意 λ 演算可保证以上除函数应用外求值的强规范化，但此处不要求，参见 @4.4.3 。

@4.5.1 名称表达式 ：
名称表达式是表示变量的 λ 项。
原子表达式(@3.4.2.1) 的由派生实现定义的非空子集是名称表达式。其它作为名称表达式的表达式语法形式(@3.4.3) 由派生实现定义。
名称表达式不被进一步规约；其求值是值替换规则(@4.4) 的平凡形式。

@4.5.2 函数(function) ：
函数是一种参与特定规约规则的实体，也可以指求值为函数对象的表达式。
一般地，函数表达式在 WHNF 下作为操作符(@4.4.3.1) 被求值，其最终求值结果(@4.4.3) 为函数实体，或函数对象（若函数在语言中允许作为对象）。
NPL 中，作为一等对象(@4.1) 的函数表达式的最终求值结果(@4.4.3) 是合并子(@4.5.3.2) 。
一个函数表达式是以下两种表达式之一：
保持等价地(@4.4.2) 求值到其它函数表达式上的名称表达式，称为具名函数(named function) 表达式，简称具名函数；
满足本节以下规则的由派生实现定义的匿名函数(anonymous function expression) 表达式，简称匿名函数。
函数应确定替换重写规则被替换的目标(@4.4.4.4) （称为函数体(function body) ）。
匿名函数可以捕获(capture) 若干变量，并在函数体引入这些变量。
匿名函数可以显式指定（绑定(bind) ）若干变量使之成为约束变量(@4.1) ，称为函数的形式参数(formal parameter, parameter) 。
使用词法作用域(@4.6.1.1.2) 时，若匿名函数所在作用域(@4.1) 的存在同名的名称，则被捕获的名称隐藏(@4.1) 。形式参数隐藏被捕获的变量名。
派生实现的语义规则应满足和 λ 演算语义(@4.5) 的 α-转换(alpha-conversion) 规则不矛盾。注意 vau 演算(@1.3) 在没有限定环境(@4.6.1.1) 时不考虑一般意义上的自由变量(@4.1) 。
除非派生实现另行指定，函数不需要被进一步规约，此时其求值是值替换规则(@4.4) 的平凡形式。
除非另行指定，作为项的函数应具有符合类型构造器(type constructor) * → * 结果的类型(@4.6.2) ，如为简单类型 λ 演算(STLC, simply-typed lambda calculus) 兼容的函数类型实例。

@4.5.2.1 过程(procedure) ：
过程是操作符具现(@2.3.2) 的实体，决定特定的可提供求值的作用（包括决定求值结果）的计算。
函数表达式的最终求值结果(@4.4.3) 由过程实体的计算结果决定，以派生实现定义的方式关联。
过程中和过程外的计算的组合满足因果性(causality) ：
以求值描述的过程中的计算整体非后序(@4.4.1) 于引起过程中计算的外部环境的计算；
以求值描述的过程中的任意计算非后序(@4.4.1) 于对应计算结果的值的计算，即值的计算结果是决定值的计算的依赖(dependency) 。
主调函数(caller function) 等调用者(caller) 或其它引起过程中的计算的实体进入(enter) 过程，转移控制(control) 到过程中的计算。
过程可以返回(return) 控制(control) ，指定之后的计算。
引起控制转变的计算可以通过切换指定当前计算之后的计算的续延(continuation) 。
具体实现中的过程按计算的顺序约束和默认返回控制的方式，可能有不同的形式：
例程(routine) 的求值不交叉(interleave) ，即例程中的计算和之外的计算非决定性有序(@4.4.1) ；
作为不同的例程，不考虑被保存续延时，子例程(subroutine) 在返回一次后不重新进入，协程(coroutine) 则可能引起多次返回；
一般的续延支持返回多次并可能支持和调用者并发的计算。
过程可能同时使用这些形式的一种或多种，使用的具体形式由提供过程的派生实现指定。
注意过程不一定具有可被对象语言(@2.3.2) 直接表达的一等(first-class) 函数而在元语言(@2.3.2) 中可能是，如无界续延(undelimited continuation) ，因为其不符合函数的类型要求(@4.5.2) 。

@4.5.2.2 λ 抽象(lambda abstraction) ：
λ 抽象是典型的操作符，是 λ 演算中的基本构成之一。
λ 抽象创建的过程是应用合并子(@4.5.3.2) 。

@4.5.2.3 vau 抽象(vau abstraction) ：
Vau 抽象是 vau 演算中的基本构成之一。
Vau 抽象创建的过程是操作合并子(@4.5.3.2) 。
使用 vau 抽象可实现 λ 抽象，如 Kernel 提供的 $vau 操作合并子(@4.5.3.2) 。

@4.5.3 函数合并(function combination) ：
形如 E1 E2... 的复合表达式(@3.4.2.2) E ，当且仅当 E1 是函数时，E 是函数合并表达式，简称函数合并。
子项(@4.1) E1 是操作符(@4.4.3.1) ，总是被求值；
子项列表 E2... 是操作数(@4.4.3.1) ，在 E 被求值时以操作数决定的值等效替换(substitute) 函数的形式参数。
替换形式参数的值是实际参数(actual argument, argument) 。
函数合并的求值是替换规则(@4.4) 的非平凡形式。
若替换操作数 E2... 可被求值，函数合并 E 是函数应用表达式，简称函数应用。
若操作符是 λ 抽象，E2... 视为一个整体，则函数应用替换规则对应 λ 演算的 β-规约(beta-reduction) 规则。
其它函数合并使用的替换规则由派生实现指定。
派生实现应指定函数合并规约(@4.1) 的结果是规范形式(@4.5.2)，它对应的值是函数合并的求值结果(@4.1) ，称为函数值。
函数应用中，替换形式参数(@4.5.2) 为实际参数(@4.5.2) 的过程蕴含对实际参数的值的计算的依赖，即参数的值的计算先序(@4.4.1) 函数应用的求值；但其它求值顺序没有保证。

@4.5.3.1 函数调用(call) ：
求值函数合并引起函数被调用。
若被调用的函数存在形式参数，函数调用首先包含操作数替换以特定规则绑定(@4.5.2) 的形式参数(@4.5.2) 。
实现在函数合并的求值中应提供函数调用的支持。
函数调用确定副作用的边界：保证参数表达式在函数应用被求值之前被求值。
在控制返回(@4.5.2.1) 主调函数(@4.5.2.1) 时，函数调用内部确定的函数值最终替换被求值的函数调用(@4.5.3.1) ，即为返回值(return value) 。
典型实现的函数指称过程(@4.5.2.1) ，函数调用为过程调用(procedure call) 。
若一个函数的调用仍待返回，则该函数调用是活动的(active) 。
一般地，被调用的函数及函数调用的作用的等价性通常不能被确定。一个重要的子类是不能确定具体表示的合并子的情形(@4.4.3.1) ，参见 @4.5.3.2 。其它函数一般也有类似限制。

@4.5.3.2 合并子(combiner) ：
除非另行指定，NPL 假定函数合并满足以下典型情形，即函数合并的操作符(@4.4.3.1) 一般求值为以下类型的合并子(@4.4.3.1) 之一：
对操作数(@4.4.3.1) 直接操作（而不要求对操作数求值）的合并子是操作合并子(operative combiner) ，简称操作子(operative) ；
合并子的函数应用（依赖对操作数进行至少一次求值）是合并子应用(combiner application) 。
合并子应用使用应用序(@4.4.4.5) 。
被应用的合并子是应用合并子(applicative combiner) ，简称应用子(applicative) ；
由派生实现定义的扩展合并子(extended combiner) 。
应用子总是由底层(underlying) 对应的合并子通过一元的包装(wrap) 操作得到；其逆操作为解包装(unwrap) 。
解包装结果不是扩展合并子的合并子称为真合并子(proper combiner) 。
除非另行捕获续延，合并子被调用时以当前续延(current continuation) 返回(@4.5.3.1) 且仅返回一次。
合并子上可以定义若干等价关系，这些等价关系蕴含关于函数应用替换的基本形式：
若对任意上下文，替换一个应用中的合并子为另一个不改变函数应用替换的结果，则这两个合并子等价（对应 λ 演算的 β-规约等价）。
由于程序可能引入未知具体表示的合并子（如从其它模块链接），以上等价可能无法判定，不要求实现提供。
派生实现可按需定义较弱的等价谓词(@4.1.4) ，保证其判定结果蕴含上述等价关系的结果。

@4.5.3.3 续延调用(continuation call) ：
符合函数类型要求(@4.5.2) 的续延(@4.5.3.2) 可作为函数以直接作为合并子(@4.5.3.2) 构成函数合并(@4.5.3) 以外的方式进行函数调用，称为续延调用。
续延调用隐含在函数应用(@4.5.3.2) 中。续延调用的其它的具体形式由派生实现定义。

@4.5.3.4 活动记录(activation record) ：
活动的(@4.5.3.1) 合并子分配的对象称为活动记录。
函数调用时以活动记录引用涉及的变量。每个调用的活动记录中可保存多个变量。活动记录可能因此持有状态，即便不一定可被函数调用外的操作直接修改。
嵌套的函数调用具有多次分配的活动记录。为强调其中的对应关系，每一个调用关联其中的一个帧(frame) 。
在确定一次分配的一个活动记录对应一次函数调用的实现中，一个活动记录和一个活动记录的帧同义。
活动记录的集合可能构成特定的数据结构。例如限制只支持嵌套的子例程调用（而不支持一般的续延调用(@4.5.3.4) ）时，具有后入先出(LIFO, last-in-first-out) 的栈的结构。

@4.5.4 λ 求值策略：
在变量(@4.5.1) 绑定值后，兼容 λ 演算规约语义的表达式的具体求值(@4.1) 根据是否传递操作数对使用按需传递(@4.4.4.5) 的求值策略的情形分为三类：
（完全）惰性求值(lazy evaluation) 、部分惰性求值和热情求值(eager evaluation) 。
其中，惰性求值总是使用按需传递，热情求值总是不使用按需传递，部分惰性求值不总是使用或不适用按需传递。
在保证不存在非纯求值(@4.4.2) 时这些求值的作用(@4.1) 没有实质差异。存在非纯求值时，使用的 λ 求值策略由派生实现定义。
非严格求值(@4.4.4.5) 严格蕴含惰性求值。两者经常但不总是一致，例如，实现可能并行地热情求值，并舍弃部分结果以实现非严格求值。
热情求值蕴含严格求值(@4.4.4.5) 。两者也经常但不总是一致，例如，实现可能使用应用序严格求值。但因为非严格的热情求值缺乏性能等可局部优化的实用动机，这种不一致的情况通常不作为附加的语言特性提供（而仅为简化实现默认作为全局策略使用）。
由于实现可能确定特定表达式的作用对约定必须保持的程序行为(@4.1.3) 没有影响而可能省略求值，按抽象机(@2.6) 语义的严格求值在实际实现中通常是不必要的。
惰性求值可通过中间值延迟求值(@4.4.4.2) 实现。

@4.6 表达式关联实体：

@4.6.1 上下文(context) ：
上下文是表达式关联的状态的特定集合（注意不是 @2.3.1.1 约定的自指概念）。
一个上下文是显式的(explicit) ，当且仅当它可以通过名称表达式(@4.5.1) 访问。
一个上下文是隐式的(implicit) ，当且仅当它不是显式的。
确定上下文的状态或对可变上下文的修改称为对上下文的访问(access) 。
过程实体(@4.5.2) 决定函数表达式(@4.5.2) 关联的上下文。
本节以外其它具体规则由派生实现定义。

@4.6.1.1 求值环境(evaluation environment) ：
求值环境是在求值(@4.1) 时可访问的隐式上下文，是由变量的绑定(@4.1) 构成的集合。
按绑定的定义，求值环境即变量的名称和通过声明引入的被变量表示的实体构成的映射。
不和实现环境(@2.3.2) 相混淆的情况下，简称（变量或绑定所在的）环境(environment) 。

@4.6.1.1.1 实现环境提供的求值环境：
实现环境可能在实现以外提供附加的求值环境(@4.6.1.1) 作为任务通信的机制，如环境变量。
除非派生实现另行指定，语言支持的求值环境和这些机制蕴含的求值环境的交集为空。语言可以库的形式提供 API 另行支持。

@4.6.1.1.2 函数和函数应用的求值环境：
在典型的对象语言中 λ 抽象(@4.5.2.2) 中指定的替换构造具有局部作用域(local scoping) ，其中可访问 λ 抽象外部词法意义上包含的(enclosing) 的求值环境的变量，对应求值环境为局部环境(local environment) 。
在基于词法作用域(lexical scoping) 的对象语言中，引入 λ 抽象对应的语言构造支持捕获引入函数时所在的作用域的环境，称为静态环境(static environment) 。
相对地，动态作用域(dynamic scoping) 根据求值时的状态指定指称。
Vau 抽象(@4.5.2.3) 进一步支持在局部环境中提供访问函数应用(@4.5.3) 时的求值环境，即动态环境(dynamic environment) 的机制。
除非另行指定，按词法闭包(lexical closure) 规则捕获，即只根据词法作用域确定捕获的指称；若需要支持依赖求值状态动态确定指称时，使用派生实现提供的对求值环境(@4.6.1.1) 的操作，而不依赖动态作用域。
除非另行指定，NPL 只存在一种作用域，即所有作用域都使用相同的名称解析(@4.3.3) 和捕获规则。

@4.6.1.2 互操作上下文(interoperation context) ：
用于互操作的和求值(@4.1) 关联的隐式上下文是互操作上下文。
典型的实例为由 ISA 约定的通用架构寄存器的状态，可能需要在函数调用(@4.5.3.1) 或任务切换过程中保存和重置。
除非派生实现另行指定，语言不提供访问互操作上下文的公开接口。

@4.6.2 类型(type) ：
上下文中和表达式直接关联或间接关联的元素，满足某个执行阶段的不变量约束(@2.4.3) 。
和表达式直接关联的类型满足起始阶段不变量约束，称为静态类型(static type) 。
和表达式的值(@4.1) 关联的类型满足运行阶段(@2.4.1) 的不变量约束，称为动态类型(dynamic type) 。
其它可能存在类型或实现执行阶段的扩展由派生实现定义。
NPL 对象类型和存储的值的类型之间的关联未指定。
称为类型的具体实体和之间的关联由派生实现的类型系统(type system) 规则指定。
默认类型系统不附加约束，所有表达式或关联的项都没有指定类型(untyped) ，为退化的平凡类型系统(trivial type system) 或单一类型系统(unityped system) ，实质上是动态类型。
对类型系统的分类中，类型也指确定类型的过程称为类型机制(typing) 。

@4.6.2.1 名义类型(nominal typing) 和结构化类型(structrual typing) ：
通过显式指定标识（如名称）的方式定义类型的方法是名义类型，否则是结构化类型。
名义类型之间没有隐含的等价关系。结构化类型之间的等价关系由实现定义。

@4.6.2.2 类型标注(type annotation) ：
根据是否需要特定的文法元素指定和项关联的类型即类型标注，对确定类型的机制可进行分类。
类型系统可使用显式类型(explicit typing) ，即要求类型标注。
不使用类型标注确定的类型是隐式类型(implicit typing) 。
在引入实体（特别地，如变量(@4.1) ）时指定实体的显式类型标注称为清单类型(manifest typing) 。
不使用清单类型而使隐式引入的实体（如值(@4.1) ）关联具体类型的机制称为潜在类型(latent typing) 。
清单类型是显式类型的实例；除此之外，显式类型还包括铸型(casting) ，即显式指定表达式求值的结果应具有的类型。
潜在类型是隐式类型的实例；除此之外，隐式类型还包括类型推断(type interferece) ，即通过隐含的上下文信息判断表达式关联的类型。
若类型机制可保证在某个执行阶段(@2.4.1) 内有确定强规范性质(@4.4.3) （即保证终止）的算法确定类型，则类型机制在该阶段是静态类型(static typing) 。
在静态类型之后阶段确定的类型机制是动态类型(dynamic typing) 。
除非另行指定，静态类型的阶段是翻译时阶段；动态类型的阶段是翻译时之后，即运行时(@2.4.1) 。
语言可能个别指定引入这些类型相关的规则，在保持逻辑相容的前提下可混合使用。

@4.6.2.3 类型检查(typechecking) ：
类型检查解答程序是否满足类型规则的判定性问题。
使用语义分析或运行时(@2.4.1) 的类型检查分别为静态类型检查和动态类型检查。
静态类型检查规则是可诊断语义规则(@2.5.1) 。
语言可能个别指定引入类型检查相关的规则，在保持逻辑相容的前提下可混合使用。
注意静态类型检查和静态类型(@4.6.2.2) 以及动态类型检查和动态类型(@4.6.2.2) 的区别。类型检查和类型机制是不同的规则，不必然包含蕴含关系。

@4.7 程序的控制执行条件(execution condition) ：
和 @4.5.2.1 类似，程序的控制状态(@4.1) 决定求值使用的续延。
更一般地，规约规则指定语言的实现决定程序行为时使用的（对程序不保证可见的）续延，这种在实现中对应的控制状态称为控制执行条件。
和控制状态不同，控制执行条件描述语言提供的不同控制机制的分类，而不被作为语言可编程的特性提供。
除非另行指定，默认规约规则决定满足执行条件是正常(normal) 的。
改变程序的正常的控制要求存在控制作用(@4.1) ，此时，控制执行条件是非正常(abnormal) 的。
具有规约语义的语言总是支持正常控制条件。NPL 中，非正常的控制条件的支持是可选的。

@4.7.1 异常(exception) ：
由派生实现定义的非正常的控制条件是异常(exceptional) 条件。
异常是通过抛出(throw) 实体（称为异常实体）同时表达满足异常条件的控制作用的语言构造。
语言的实现或用户通过特定操作（如求值一个表达式）指定程序满足异常条件，使程序的控制进入异常执行状态(@2.5) ，允许程序具有正常条件下可分辨不同行为。
程序通过捕获(catch) 并处理(handle) 被抛出的实体，程序可满足不同的恢复正常执行的条件。
进入 @2.5.1 的异常执行状态时，由语言实现的值的异常执行机制指定其行为。
和 @2.5.1 不同的其它异常执行状态的异常条件，包括所有运行时(@2.4.1) 异常条件，和直接引起异常的用户操作。
这些异常条件的具体行为和正常条件下的不同由派生实现指定的运行时状态或直接引起异常（改变程序的控制）或语言构造的语义决定。此时，由实现定义是否使用和以上异常执行机制相同的实现。
派生语言实现可指定以下规则：
符合以上约定的判断改变（进入和退出）异常执行状态的执行机制；
包括抛出和捕获的语言构造和其它可选的引起改变异常条件的上下文。
若派生实现不指定以上要求的执行机制和上下文，则不支持异常。
除非派生实现另行指定，异常的控制作用总是同步(synchrnozed) 的，即：
在初始化异常实体时，保证存在与异常条件关联且可确定单一的执行线程(@2.4.2) 的状态作为引起控制状态改变即引发异常的来源；
异常条件的满足不依赖未和引发异常状态同步的程序中的其它的执行状态（包括其它未同步的线程的状态）；
确认满足异常条件和进入异常执行状态之间，上述执行线程内程序仅在引发异常的线程上的程序允许存在计算作用（这保证不被引起可观察行为改变的其它线程的操作中断）。
除非派生实现另行指定，未捕获的异常总是确定性地(deterministically) 持续引发异常的执行线程中引起控制的转移：
若捕获操作有效的上下文，控制转移捕获构造处理对应异常的异常处理器(exception handler) ；
否则，若在活动函数调用中，则单向地从当前活动(@4.5.3.4) 的函数向其主调函数(@4.5.2.1) 转移控制，使后者活动；
否则，若没有找到剩余的活动函数调用，则程序异常终止。
除非派生实现另行指定，上述转移活动函数若成功（包括异常在活动的主调函数嵌套的特定语言构造中被捕获），先前不再活动的活动记录中的资源在控制成功转移后应立即被释放。
典型的设计中，求值规则使的正常状态的函数调用要求的活动记录分配和释放满足 FIFO（Last-In First-Out ，后入先出）的顺序，构成了栈(stack) ，活动记录是栈帧(stack frame) 。
除非派生实现另行指定，活动函数的转移释放资源，应保证按和创建被其所有的实体的顺序的相反顺序可观察行为一致的形式释放。这种释放活动记录占用资源的机制称为栈展开(stack unwinding) 。

@5 派生语言设计和实现：
当前维护的派生语言为 NPLA ，是 NPL 的抽象语言实现，约定以下附加规则。
NPLA 的参考实现 NPLA1 是具体语言实现，约定特定于当前参考实现的附加规则和实现。
NPLA1 解释实现参见 @7 ，作为对象语言的规格说明参见 @8 。

@5.1 整体设计概述：
作为原型设计，NPLA 重视可扩展性。

@5.1.1 NPLA 领域语义支持：
位(bit) ：表示二进制存储的最小单位，具有 0 和 1 两种状态。
字节(byte) ：基本字符集(@3.2) 中一个字符需要的最少的存储空间，是若干位的有序集合。
八元组(octet) ： 8 个位的有序集合。

@5.1.2 实现支持策略：
NPLA 实现支持可扩展的 API ，作为解释器(interpreter) 的实现基础。
解释器的程序执以对语法分析(@5.3.2) 结果的规约实现，可对应语言或（适合改进执行性能的）某种等价变体的小步语义(@2.2.3) 。
在此基础上，可允许派生实现优化性能，如嵌入编译。
NPLA API 公开解释器的状态，可支持和宿主语言的互操作(@2.4.1) 。
虽然 NPLA 没有给出形式语义(@2.2.3) ，但 NPLA 实现中包含的 API 部分地提供和形式语义方法对应的支持：
通过回调对应依赖宿主语言(@5.2) 实现作为描述的指称语义；
在回调内对项和上下文进行操作，对应小步语义；
在回调内复用其它接口，对应大步语义。
NPLA 可支持非固定的规约规则集合，以 API 的形式体现，详见 @6.5 ；另见 @5.5 。
具体实现的编码风格导引参见 [Documentation::CommonRules @@5] 。

@5.2 NPLA 约定：
使用宿主语言(@2.4.1) 为 ISO C++11 （及其之后的向前兼容的版本）的简单实现模型 NPL-EMA(@2.7.1) 。
使用可选的语法预处理和 NPL-GA 语法(@3.4.4) 。
默认使用隐式类型而非显式类型(@4.6.2.2) 。
默认使用潜在类型(@4.6.2.2) ：值(@4.1) 具有类型；不指定动态类型以外的类型。
显式类型（如清单类型）(@4.6.2.3) 的机制可由派生实现指定可选地引入。除非派生实现另行指定，引入的静态类型应同动态类型。
使用和宿主语言相容的动态类型检查(@4.6.2.3) 。除非派生实现另行指定及类型映射(@5.2.3) 的需要，使用的类型检查规则和宿主语言一致。
宿主语言对象的值描述状态且宿主语言要求的对 volatile 左值的操作也属于可观察行为(@4.1.3) 。
名称仅被实现为和字符串(@3.2) 的值的一个真子集一一对应的表示（参见 @5.2.3 和 @5.6.1 ）。
代码字面量(@3.3.3) 解释为名称。
数据字面量(@3.3.3) 等价字符串字面量(@3.3.3) 。
扩展字面量(@3.3.3) 包括以 '#' 、'+' 、'-' 起始的但不全是 '+' 或 '-' 组成的长度大于 1 的标识符或十进制数字字符起始的标识符构成的字面量。
规范形式(@4.4.3) 是特定类型的 C++ 对象。
名称解析失败(@4.3.3) 可被忽略而不终止(@4.4.3) 实现演绎；
保证名称表达式求值的强规范化(@4.4.3)。
不要求提供命名空间(@4.3.4) 实现的可变实体。
一字节占用的位和宿主环境(@2.7.1) 一致（至少占用 8 个二进制位）。
存在不保证先求值的子表达式(@3.4.2) 的形式是特殊形式(special form) 。
不保证求值都是纯求值；非特殊形式使用热情求值；其它情形使用热情求值或惰性求值(@4.5.4) 由具体特殊形式约定。
对象语言的函数(@4.5.2) 默认为过程(@4.5.2.1) 。过程默认实现为子例程(@4.5.2.1) 。过程指定的计算结果和函数表达式最终返回结果的关联(@4.5.2.1) 是过程调用(@4.5.3.1) 结果的一一映射。
除非另行指定，实现函数(@4.5.2) 的宿主数据结构生存期要求默认同宿主语言；循环引用(@4.2.4) 可能行为未定义（另见 @5.2.4.4） 。
除非另行指定，按值传递(@4.4.4.5) 支持复制初始化(@5.5.2) 对象的一等作用(@4.2.2.2) 。这和宿主语言的对应语义也保持兼容。
派生实现使用的项不满足特定的表示(@5.8.5.4) 。

@5.2.1 本机实现(@2.4.1) 和互操作(interoperation) ：
NPLA 的宿主语言应能提供 NPLA 及派生实现的本机实现。
NPLA 的派生实现提供特定的和宿主语言的互操作支持。
本机实现可以具有 C++ 的实现兼容的二进制接口的函数提供，这些函数称为本机函数(native function) 。
本机实现可直接支持本机函数在实现中被调用。若被支持，具体接口由派生实现指定。
本机函数作为函数的实现，其调用的求值可具有和非本机的函数一致的作用(@4.1) ，但不需要具有可被对象语言表达的函数体(@4.5.2) 。
为确保函数求值的作用可能保持一致，本机函数应符合和本机函数调用时使用的规约一致的方式使用，即至少符合以下规约调用约定(calling convention) ：
被调用时的子项被作为以 WHNF(@4.4.3.1) 形式表示的被调用的表达式使用；
调用后具有项被重写为必要的值以表示函数调用的返回值(@4.5.3.1) 。
本机函数的返回值应能表达任意的非本机函数调用的返回值，即通过求值函数调用(@4.5.3.1) 中函数体(@4.5.2) 的非本机函数的求值结果(@4.1) 。

@5.2.2 NPLA 未定义行为(@2.3.2) ：
NPLA 规则不排除未定义行为。其中，宿主语言的未定义行为是非特定体系结构或其它 ISO C++ 意义上不可预测或不可移植的行为。
部分 NPLA 未定义行为会在实现中被检查以预防（尽可能避免）宿主语言的未定义行为，但这种检查不保证完全覆盖所有引起未定义行为的条件，不应预期其行为可移植。
除非派生实现另行指定，NPLA 约定仅有具有以下情形的程序引起未定义行为：
互操作(@5.2.1) 时引起的宿主语言的未定义行为；
本机实现(@5.2.1) 不支持资源分配而引起宿主语言的未定义行为（如宿主语言函数调用的自动对象无法被分配）；
违反资源所有权语义(@4.2.2.3) 约束的操作，包括但不限于：
	违反内存安全(@5.2.4.3) 的操作；
	除非另行指定，构造任意的循环引用。

@5.2.2.1 常规宿主资源分配要求：
一般地，本机实现要求资源分配失败时，引起（可能派生）std::bad_alloc 或另行指定的宿主异常而非宿主语言的未定义行为；但因为宿主语言缺乏保证，可能并非所有宿主语言实现都能保证实现这项特性。
实际的实现中非极端条件下（如宿主调用栈接近不可用）通常可支持实现这些行为。
宿主语言实现支持时，具有可预期的失败（而 NPLA 或宿主语言的非未定义行为）的 NPLA 实现的要求称为常规宿主资源分配要求。

@5.2.3 类型映射(type mapping) ：
类型映射指定对象语言和宿主语言之间的实体类型(@4.2.6) 之间的关系，是前者中的类型到后者中的类型的映射。
作为类型映射目标的宿主语言类型称为宿主类型(hosted type) 。
对象语言中的值被对象语言的实体类型表示蕴含它被映射的宿主类型表示，反之亦然。
类型映射可以是非空的多对一、一对多或一一映射。
若类型映射是一一映射，其类型等价性同宿主语言的语义规则；否则，由类型的语义规则约定。
类型系统(@4.6.2) 是开放(@1.4.3.6) 的，可能提供不被对象语言支持的宿主语言类型和值，如中间值(@5.6) 。
因需提供与作为宿主语言的 C++ 的互操作性支持，所以明确约定实现中部分实体类型对应的 C++ 类型：
用于条件判断的单一值的宿主类型是 bool 。
字符串(@3.2) 及和字符串的子集一一对应的词素(@5.2) 的宿主类型都是 string 类型(@5.3.1) 。
推论：字符串和词素可直接比较相等性或排序。
其它宿主类型所在的命名空间由实现(@5.4.1) 约定。具体宿主类型参见以下各节和对象语言类型对应的描述。
宿主类型在对应的 C++ API 中可能以类型别名的形式引入。
另见 @4.2.6 。

@5.2.4 存储和对象模型：
NPLA 使用统一的模型对存储和对象进行抽象，并提供若干保证。
对象语言的存储被视为资源进行管理，称为存储资源(memory resource) 。

@5.2.4.1 基本模型：
因需提供宿主语言(@5.2) 互操作性支持，除不支持静态(static) 存储和没有提供支持的存储操作外，NPLA 的基础存储模型和对象模型和 ISO C++11 相同。
当前不支持的存储操作包括分配函数(allocation function) 取得的存储和线程局部(thread-local) 存储。
NPLA 还允许类似对象具有未指定的存储或不需要存储的实体，以使一等实体(@4.2) 可涵盖宿主语言在功能上等价的非对象类型（如 C++ 的引用）。这些实体若被支持，其存储实现和互操作接口由派生实现定义。
保证存储性质的差异不被依赖时，一等实体可按一等对象相同的方式实现。
在此情况下对象都是固定(pinned) 的，即对象在存储期(storage duration) 内具有宿主语言意义上的确定不变的地址。派生实现可约定扩展作为例外。
和宿主语言类似，对象的生存期是存储期的子集。创建对象基于已确保可访问的存储；销毁对象结束后释放存储。
基于宿主操作等意义，作为一等对象相同方式传递的一等实体都在此都视为一等对象；仅当不依赖一等对象的性质时，实现以非一等对象的方式实现一等实体的操作。

@5.2.4.2 求值和对象所有权：
被求值的表达式的内部表示即项(@5.5) 或环境(@5.4.3) 中的对象具有 NPLA 对象的所有权。
所有权可被前者独占的 NPLA 对象是临时对象(temporary object) 。关于引入临时对象，参见 @5.5.5 。
和宿主语言类似，NPLA 临时对象的存储未指定。对名义上被项所有的临时对象，必要时实现可分配内部存储转移项（包括在环境中分配），以满足附加要求（如 @5.2.5 ）。
和宿主语言类似，对象的所有权随可随对象被转移，且被转移对象后的项具有有效但未指定(valid but unspecified) 的状态，参见 @5.5.2.3 和 @5.5.3 。
环境对绑定具有的所有权是独占的。绑定对其中的对象可具有独占或共享的所有权。因此，环境可对绑定中的对象具有独占或共享的所有权。
求值结果(@4.1) 可包含一等对象(@4.1) ，称为结果对象(result object) 。结果对象和 ISO C++17（由提案 [WG21 P0135R1] 引入）中的概念对应。
函数调用(@4.5.3.1) 时以活动记录(@4.5.3.4) 保持被引用对象(@4.2.3) 的所有权。活动记录及其帧的具体结构、维护方式和生存期由派生实现定义。
除非另行指定，NPLA 只有一种作用域(@4.6.1.1.2) 。
因为宿主语言函数调用实现（典型地，调用栈(call stack) 及其中的栈帧）不提供可移植的互操作性，除非另行指定，NPLA 的活动记录设计不需要保证直接对应关系。
环境对象共享所有权，按值传递环境不引起其中所有的对象被复制。

@5.2.4.3 内存安全(memory safety) ：
（非并发）内存安全是存储资源避免特定类型不可预测错误使用的性质。
基本的内存安全保证蕴含非并发访问时不引起未定义行为。这至少满足：
对存储的访问总是在提供存储的对象的存储期内，除非有其它另行指定的机制（如宿主环境的互操作）保证存储的访问不违反其它语义规则；
宿主环境中不访问未被初始化的值。
派生实现可能扩展内存安全，提供语言规则避免非预期的内存访问错误，提供安全 (security)保证，如保密性(secrecy) 和完整性(integrity) （另见 https://arxiv.org/abs/1705.07354 ）。
除非另行指定，派生实现不提供扩展的内存安全保证。
NPLA 不对数据竞争避免(data race avoidence) 提供保证。
用户代码应注意避免违反内存安全的访问，包括非并发的，以及并发访问的内存冲突。

@5.2.4.3.1 非内存安全操作：
非内存安全操作是不保证内存安全的操作，在对象语言中即可能引起违反内存安全。
这些操作违反内存安全时，引起 NPLA 未定义行为(@5.2.2) ，且可能未被实现检查而同时引起宿主语言的未定义行为(@5.2.2) 。
NPLA 当前未被实现检查(@5.2) 的操作包括：
未关联锚对象引用计数的 NPL::TermReference(@5.6.3) 初始化；
非内存安全提升操作(@6.6.5) 。
对象语言中的非内存安全特性可能直接调用这些操作。NPLA 外依赖此类操作的其它操作也具有类似的性质。

@5.2.4.3.2 NPLA 对象语言内存安全保证：
NPLA 中，确定地引入具有非内存安全操作(@5.2.4.3.1) 的对象的操作应仅只包括引入特定的间接值(@5.7.2) 或其它派生实现指定类型的值的操作：
调用引入不保证内存安全的间接值的 NPLA API(@6.6.5) ；
调用 NPLA 中其它取 YSLib::ValueNode 存储值的间接值的 API 。
排除非内存安全操作以及非内存安全的本机实现(@5.2.1) ，NPLA 实现的对象语言提供基本内存安全保证。

@5.2.4.3.3 NPLA 内存安全保证：
满足 @5.2.4.3.2 同时排除引起宿主语言未定义行为的非内存安全的操作（如超出生存期的对象访问），NPLA 实现提供基本内存安全保证。

@5.2.4.4 内存泄漏(memory leak) ：
资源泄漏(resource leak) 是不能预期地（决定性地）访问之前被分配的资源的情形。
内存泄漏(memory leak) 是存储资源的泄漏。
强内存泄漏状态是指存在存储无法通过任何途径访问的状态。若存在存储不被任意对象或其它另行指定的代替对象的实体（如宿主环境）所有权的传递闭包包含，即所有权依赖不可达(unreachable) ，则存在强内存泄漏。
弱内存泄漏是除了强内存泄漏以外的内存泄漏，和具体预期相关。
一般意义下，[Cl98] 中定义的任一空间复杂度类都可以作为形式的预期。因为内存作为存储资源被空间复杂度类度量，满足某个空间复杂度类的无空间泄漏(space leak) 蕴含对应的无内存泄漏。
弱内存泄漏的预期的可实现性和实现细节相关，因此 NPLA 不指定具体预期。

@5.2.4.4.1 资源回收策略：
单一作用域(@5.2.4.2) 内的资源回收策略有删除(deletion) 和保留(retention) 的策略（详见 [Cl98] ）。
NPLA 不限定具体使用的回收策略，但应支持释放一等对象时副作用(@4.2.2.1) 且不放弃确定性(@4.2.3.6) 。
为简化语义规则同时避免限制特定的可用资源（如系统中剩余的内存）的变化被派生实现抽象为副作用，除非派生实现指定，不对内存使用保留策略，不使内存超出对象生存期(@4.1) 。
NPLA 要求完全避免强内存泄漏，但不要求实现 GC(@4.2.3.4.4) 。
不依赖 GC 同时允许不依赖释放可能具有的副作用顺序的存储资源和其它资源共享更普遍的所有权抽象资源所有权语义(@4.2.2.3) 上的操作，以更好地满足资源管理操作的可复用性(@1.4.4.4) 和作用使用原则(@4.1.6) 的要求。
由于 GC 通常基于具有特定操作的单一资源所有权的所有者的对象池的这一实现特例，不依赖共享所有者的 GC 一般也更容易满足 @1.4.5.1 、@1.4.2.3 和 @1.4.2.4 。
多个对象构成的系统中，仅存在平等的所有权(@4.2.2.3) 时的循环引用造成强内存泄漏：
除非即从循环引用的对象中区分出具有不同类所有权的对象子集实现所有权正规化，总是存在无法被释放资源的对象(@4.2.4.2) 。
基于非预期的循环引用不可避免地造成实现开销而违反 @1.4.2.2（即使这种开销可能并不总是可观察），NPLA 不要求实现 GC 和对一般对象区分强弱引用等机制避免循环引用(@5.2) 。

@5.2.4.4.2 安全性：
内存泄漏是和内存安全(@5.2.4.3) 不同的另一类非预期的问题，表明语言设计、实现或程序存在缺陷。
注意即便不违反内存安全保证，涉及弱化空间复杂度类预期的内存泄漏仍可引起安全问题。
内存泄漏和违反内存安全同属违反特定的存储访问不变量的错误条件(error condition) ，但因为不论在语言还是程序的设计和实现中，避免的机制相当不同，在此被区分对待。
存在其它语言使用类似的区分内存泄漏和非内存安全(@5.2.4.3.1) 的设计，如 [Rust]（详见 https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html ）。

@5.2.4.5 自动存储管理：
和 C++ 的自动变量类似，函数调用结束、控制退出函数体(@4.5.2) 的作用域（对应 C++ 的函数体最外层块作用域）后，被变量独占所有权的资源被释放。
资源回收策略(@5.2.4.4.1) 允许存储资源和宿主语言对象之间的明确对应，且允许以环境持有所有作用域内的所有资源。
使用自动变量释放的机制，自动存储管理的基本设计可不依赖 GC(@5.2.4.4) ，也不需显式对资源进行释放。
把右值(@5.5.1) 的值传递视为传递独占的引用，这类似 newLISP 的 ORO(One Reference Only) ： http://www.newlisp.org/MemoryManagement.html 。

@5.2.5 生存期附加约定：
和宿主语言不同，NPLA 子表达式的求值顺序可被不同的函数（特别允许显式指定对特定操作数(@4.4.3.1) 求值的操作子(@4.5.3.2) ）中的求值调整，不需要特别约定。
NPLA 不存在宿主意义上的完全表达式(@4.4.4.2) ，但在按宿主语言规则判断生存期时，使用本机实现(@5.2.1) 的函数合并(@4.5.3.2) 视同宿主语言的完全表达式，其本机函数调用不引起函数内创建的对象的生存期被延长。
临时对象的生存期(@5.2.4.1) 同时约束隐含的隐式宿主函数调用（如复制构造）。
为保证求值表达式取得的临时对象(@5.2.4.2) 的内存安全(@5.2.4.3) ，函数合并同时满足以下规则：
操作符(@4.4.3.1) 和未被求值的操作数的直接或间接子表达式关联的对象以及求值操作数的子表达式引入的临时对象的生存期结束的作用应不后序(@4.4.1) 于活动调用(@4.5.3.1) 结束。
这同时确保引入临时对象时，其生存期不会任意地被延长（超过函数合并表达式的求值）。
具体操作可在以上约束下指定被求值的操作数可能引入的临时对象的生存期。
生存期起始和结束的顺序被确定(determined) 时，和对应所在的表达求值之间的先序(@4.4.1) 关系同构；
否则，其顺序满足非决定性有序(@4.4.1) 关系。

@5.2.6 尾上下文约定：
尾上下文(@4.4.7) 在 NPLA 中可满足一些附加的性质。

@5.2.6.1 真尾规约(proper tail reduction) ：
尾上下文涉及的存储在特定情况下满足调用消耗的空间有上界（即空间复杂度 O(1) ）。
满足这种情况下的规约称为真尾规约。

@5.2.6.2 尾调用(tail call) 和 PTC（proper tail call ，真尾调用）：
在尾上下文规约的调用(@4.5.3.1) 是尾调用。
以真尾规约(@5.2.6.1) 的实现尾调用允许具有不限定数量的(unbounded) 活动调用(@4.5.3.1) ，称为 PTC 。
PTC 占用活动记录(@4.5.3.4) 满足真尾规约的上界的要求。
当宿主语言提供函数调用支持 PTC 时，可直接使用宿主语言的 PTC 调用，否则，需要使用其它替代实现机制确保 PTC 。
注意非对象语言的调用的上下文中，若被调用时间接使用，也仍需要保证 PTC 。
PTC 确保仅有一个活动(@4.5.3.1) 的调用。不满足 PTC 的情形下，语言没有提供用户访问非活动记录帧(@4.5.3.4) 资源的手段，因此可以认为是资源泄漏。但为简化语义规则，NPLA 不要求避免相关的弱内存泄漏(5.2.2.2) 。
NPL 不保证一般对象存在引用(@4.2.3) ，NPLA 也不添加保证活动记录的帧(@4.5.3.4) 中保存引用，销毁活动记录的帧可能影响环境中的变量生存期而改变语义；因此 NPLA 不保证 PTC 支持，实现一般的 PTC 依赖派生实现定义的附加规则。
为满足 PTC ，在 @5.2.5 的基础上，尾上下文内的可以确定(@5.2.5) 并调整对象生存期结束时机：
作为临时对象(@5.2.4.2) 的合并子及其参数可以延长生存期至多到尾上下文结束；
被证明不再需要之后引用的对象，或未被绑定到活动记录上的项中的对象，可以缩短生存期；
被延长生存期的对象生存期起始和结束的相对顺序保持不变；
被缩短生存期的不同对象生存期结束的相对顺序保持不变。
推论：被缩短生存期和延长生存期的对象的生存期结束的相对顺序保持不变。这由没有被调整生存期的对象与被调整生存期对象之间的生存期结束的顺序关系(@5.2.6) 的传递性保证。
延长临时对象生存期和宿主语言中允许扩展非完全表达式内的临时对象的效果类似，但条件不同。
注意，理论上 PTC 不要求延长生存期，仅要求特定情形下缩短生存期，且其它情形被释放的对象生存期不延长到尾上下文外；延长生存期是 @5.2.5 的推论。

@5.2.6.3 PTR（proper tail recursion ，真尾递归）：
PTC 的活动记录性质也在一般的递归规约时体现，被称为 PTR 。
和 PTC 不同，PTR 要求的递归规约不一定是对象语言中的调用，以 PTR 描述时仅强调递归，不考虑尾上下文的适用性。
通过特定的保持语义等价的变换，对象语言可要求尾上下文作用于函数调用以外的上下文中（例如非函数合并表达式(@4.5.3) 的语法上下文）使用真尾规约实现。
除非派生实现另行指定，NPLA 对象语言不指定使函数调用以外的上下文作为尾上下文的要求；函数调用以外的尾上下文规约的仅可能用于实现的元语言中的管理规约(@4.4) ；非管理规约的真尾规约都用于尾调用。
此时，PTR 等价被递归调用的 PTC 。但由于支持 PTC 在非递归规约情形时也影响语言实现的一般构造，所以描述要求时一般不以 PTR 代替 PTC 或真尾规约。
关于 PTR 在 Scheme 为基础的形式模型，参见 [Cl98] 。
PTR 的一个更激进的实现优化方式是 evlis tail recursion ，参见以下文献和参考资料：
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.8567&rep=rep1&type=pdf
[Cl98]
https://www.akalin.com/evlis-tail-recursion

@5.2.6.4 TCO（Tail Call Optimization ，尾调用优化）：
TCO 是在以尾上下文规约时，允许减少修改规约状态的优化。
一般地，TCO 可重新排列规约过程中的被语义允许调整的副作用和其它不影响可观察行为的状态(@4.1.3) 的调用，减小空间开销。
TCO 的这种性质可以在宿主语言不支持 PTC(@5.2.6.2) 时用于实现对象语言的 PTC(@5.2.6.4.1) 。
关于 TCO 和 PTC 的差异，另见 https://groups.google.com/d/msg/comp.lang.lisp/AezzhxTliME/2Zsq7HUn_ssJ 。

@5.2.6.4.1 宿主语言中立：
C++ 不要求实现支持 PTC ，也不保证支持 TCO 。因此，对象语言的 PTC 要求显式的 TCO 实现。
为可移植地支持 TCO ，NPLA 不依赖宿主语言中不可移植地互操作的活动记录（通常是体系结构相关的栈）。
注意尾调用可避免尾上下文中非嵌套调用安全的情形的宿主语言实现的未定义行为(@5.2.7) ，但不保证非尾上下文中具有类似的性质。

@5.2.6.4.2 策略实现概述：
TCO 包括以下形式：
静态 TCO ：实现时替换宿主语言中不保证满足 PTC 的构造为满足 PTC 的构造；
动态 TCO ：运行时调整直接或间接表示对象语言构造的数据结构和状态，使状态占用的空间复杂度满足 PTC 要求。
静态 TCO 也适合非对象语言的调用的上下文(@5.2.6.2) 。
不依赖宿主语言特性的静态 TCO 包括以下形式：
替换宿主语言实现中的不保证满足 PTC 的递归调用为满足 PTC 的结构（如循环结构），包括直接编码和自动的变换(transformation) ，称为宿主(host) TCO ；
替换不满足 PTC 的对象语言原语为满足 PTC 的表达形式，称为目标(target) TCO 。
不依赖宿主语言特性的动态 TCO 包括以下形式：
通过合并不同活动调用(@4.5.3.1) 中活动记录占用的冗余状态，减少宿主语言的活动调用同时占用的总空间，称为 TCM（Tail Call Merging ，尾调用合并）；
引入具有便于操作控制作用(@4.1) 的构造，同时作为一些其它优化的基础，以消除部分活动记录状态的分配，称为 TCE（Tail Call Elimination ，尾调用消除）。
TCM 一般只减小尾调用(@5.2.6) 需要占用的活动记录，而 TCE 可能直接替换控制结构，同时减小运行操作需要的时间开销。但 TCE 变换自身可能需要额外开销且实现较复杂。因此，当前 NPLA 只支持 TCM 方式的 TCO 。
因为只使用 TCM ，相对没有 TCO 的基线版本，无法保证具有可预期的时间性能提升；相反，引入 TCM 可因为增加运行时存储分配和缓存局域性等原因降低性能（但一般实现应不影响复杂度类而只降低可接受的常数）。
TCM 引入的构造通常基于对象语言的内部变换。静态 TCO 使用的对宿主语言的自动变换和这种内部变换可基于相同的策略，如通过对程序全局变换得到的 CPS(@5.4.4) 或 ANF(Adminstrative Norm Form) ）的中间表示(@2.4.1) 。
当尾上下文规约涉及的存储（主要是活动记录(@4.5.3.4) ）被一并消除时，调用消耗的空间复杂度有静态上界，满足 PTC(@5.2.6.2) 。

@5.2.7 嵌套调用安全：
宿主语言的 API 提供嵌套调用安全，当且仅当若非调用没有宿主语言无法分配资源的未定义行为(@5.2.2) ，则同时避免嵌套调用深度过大时引起这样的未定义行为。
嵌套调用安全应包括支持 @5.2.6.4.1 不保证的情形。
嵌套调用安全允许不限制嵌套深度的可靠的调用，如递归调用。
宿主语言实现在宿主语言的尾上下文可能支持宿主 TCO(@5.2.6.4.2) 而使递归调用满足嵌套调用安全，但这并不是语言提供的保证，不应在可移植的实现中依赖。
非嵌套调用安全的情形在过程嵌套调用深度过大时，可因为宿主语言的存储资源消耗导致的宿主语言实现的未定义行为，典型地包括实现中的栈溢出(stack overflow) 。

@5.3 NPLA 实现架构：
NPLA 实现为对数据结构的管道-过滤器(pipe-filter) 架构模式的处理框架。每个处理节点实现一个或若干个阶段(@2.4.1) 。
这里的数据结构是语言实现的 IR(@2.4.1) 或通过代码生成(@2.4.1) 得到的代码。在 NPLA 实现中后者是可选的。
本节指定首先经过两个前端(frontend) ，之后的处理见 @5.4 。
本章下文中，除 @5.3 和 @5.4 在 C++ 命名空间 NPL 中引入的类型名称和如下列出的使用 C++ 命名空间 YSLib 的名称外，其余 C++ 名称使用 C++ 限定名称以避免混淆：
shared_ptr
observer_ptr
weak_ptr
本章下文中，项目的模块命名空间([ProjectRules @@3.2]) 名称若为 NPL 模块，省略 NPL 前缀；其它 YSLib 模块需使用限定名称；非 YSLib 模块还需指定库的来源。
本章下文中，使用 namespace 关键字指定 C++ 命名空间。

@5.3.1 词法分析：
参见 @3.3.4 和参考实现模块 Lexical 。
Lexical 模块在 namespace NPL 通过别名声明引入 YSLib::string 类型和 YSLib::string_view 类型。
Lexical 模块的词法分析器支持分析表示 S 表达式的文本流，但源语言中不包含点(dot) 记号，且支持同宿主语言相同的断行连接和转义字符。和宿主语言不同，不支持的转义前的 \ 不需要被重复，且不支持字符串字面量的直接并置连接。
词法分析的结果是记号的序列，以记号列表类型 TokenList 表示。
Lexical 模块提供类型别名和以下类型：
LexemeList ：词素列表。
词素列表中的元素是在词法分析阶段中表示记号(@3.3.1) 的短字符串。虽然逻辑上并不依赖，但为便于实现，提供分配器(@5.7.1) 支持。
SourceLocation ：源代码位置。
词法分析提供以下元函数访问词法解析器中的类型：
MemberParseResult
ParserClassOf
ParseResultOf
GParserResult
词法分析提供以下类实现或作为词法解析器：
BufferedByteParserBase
ByteParser
DelimitedByteParser
其中，DelimitedByteParser 保留更多的中间结果。

@5.3.2 语法分析：
参考实现模块 SContext ，提供源代码的文本流或其词法分析结果(@5.3.1) 转换到分析结果的转换接口。
分析结果是结构化的递归数据结构，称为分析树(parse tree) 。除非派生实现另行指定，分析树中的节点应同构 NPL 语法(@3.4) 的非终结符(non-terminal) 文法元素。
语法分析通过调用词法分析转换源代码为 TokenList 类型(@5.3.1) 表示的记号列表结果，并在此之上递归解析取得记号序列对应的语法对象(syntax object) ，然后从语法对象构造分析树。
除包含构造分析树的必要信息，语法对象还可能包含来自源代码的附加元数据，如分析结果对应的源代码位置信息。当前 SContext 的语法对象不包含这些附加的元数据，因此和分析树同构。
分析树包含源代码中语法规则（包括 @3.4 和派生实现定义的其它扩展）关注的所有语法信息，也被称为具体语法树(concrete syntax tree) 。
与之相对，以 AST（Abstract Syntax Tree ，抽象语法树）作为保存分析结果的 IR 排除了之后的阶段中不需要的信息。
因为 SContext 输入的形式是和 Lexical 模块(@5.3.1) 兼容的 S 表达式，分析树和 AST 同构，不需要保持冗余信息。因此 SContext 只一种提供同时表示分析树和 AST 的数据结构。派生实现可根据扩展语法规则的需要定义不同的分析树。
对语法分析的递归操作应在分配资源失败应满足常规宿主资源分配要求(@5.2.2.1) 。
使用 AST 作为 FOAS（First-Order Abstract Syntax）不需要保留优先级等冗余信息。
派生实现可能检查更多语法规则。
SContext 模块在 namespace NPL 通过别名声明引入若干 YSLib 类型名称，包括（但不限于）：
ValueObject 、ValueNode 、observer_ptr 和 LoggedEvent 。
关于这些类型，另见 [Documentation::YSLib @@3.16] 和 [Documentation::YSLib @@3.2] 。
语法分析提供 TermNode 类型(@5.4.2) 作为表示分析树（根据以上讨论，同时也是语法对象和后续使用的 AST ）的输出类型，及其相关操作。
以下类型和 TermNode 关联：
TNCIter
TNIter
TermByteAllocator
SContext 模块的其它 API，详见以下小节和 @6.2.1 。

@5.3.2.1 NPL 源代码分析会话(session) ：
语法分析提供类 Session 表示分析处理一个翻译单元(@3.1) 的 NPL 源代码的会话。
会话利用词法分析器提取源代码中可被分析的信息，并提供使用指定词法解析器(@5.3.1) 取解析结果的 API 。
若不指定词法解析器，默认使用的词法解析器是 ByteParser(@5.3.1) 。

@5.3.2.2 命名空间 NPL::SContext ：
命名空间 NPL::SContext 提供转换节点相关数据和遍历节点的 API 。
以下命名空间 NPL::SContext 中的 API 提供词素相关的转换：
函数模板和函数 ToLexeme
仿函数 LexemeTokenizer
以下命名空间 NPL::SContext 中的 API 递归遍历参数指定的记号范围以转换其中的结构化数据为表示的语法树：
函数模板 Validate
函数模板 Reduce
函数和函数模板 Analyze

@5.4 NPLA 公共语言实现数据结构：
本节到 @5.8 节之间的内容外其它 NPLA 实现使用的接口详见模块 NPLA 和以下章节(@6) 。
本节中的 API 都位于模块 NPLA ，详见 @6 。
另见 @5.9.3 。

@5.4.1 类型映射(@5.2.3) 实现：
类型映射使用的 C++ 类型在 namespace NPL 中声明，从 namespace YSLib 引入。
一些类型如 string 、ValueNode 和 ValueObject 在词法分析(@5.3.1) 和语法分析(@5.3.2) API 中引入，被以下章节的实现使用，成为实际的映射目标。
以下章节 @5.4.2 和 @5.6 提供的节点或中间值(@4.4.4.2) 类型(thunk type) 是类型映射的目标(@5.4.1) 。

@5.4.2 IR 节点数据结构：
NPLA 实现使用节点(node) 数据结构表示实现使用的 IR 中间表示递归的构造，如 SContext 产生的 AST 的节点和语义分析使用的项。
这样的节点类型为 TermNode ，也用于表示单一的树（如整个 AST(@5.3.2) ）。
NPLA 实现语义规则时对 TermNode 进行处理，包括节点上的规约(@4.1) ，即树规约(tree reduction) 。TermNode 对象在树规约中表示被规约项(reduced term) 。
树规约的输入和各个规约步骤的结果中，变量不需要直接被表示，规约允许和输入 AST 中一致的未求值的名称，参见 @5.6.1 ；同时，允许在同一个树中包含经不同过程转换的结果，不需要显式区分阶段(@2.4.1) 。
因为绑定(@4.1) 在外部表示，树规约不需要使用 HOAS（Higher-Order Abstract Syntax ，高阶抽象语法）。接受表达式到表达式的映射附加处理可通过派生实现约定对象语言中特定类型的对象实现，不要求被编码在规约的结果中。
名称和作用域通过求值环境(@4.6.1.1) 维护，其数据结构参见 @5.4.3 。
TermNode 中保存子节点的容器。当作为被规约项时，TermNode 的子节点对象是子项(@4.1) 的表示(@2.3.2) 。
TermNode 的 Value 数据成员称为值数据成员(value data member) ，是 ValueObject 类型的对象。用于表示对象语言（ NPLA 实现）中表达式或对象储存的值，或者包装的中间值(@4.4.4.2) 。
TermNode 对子节点和值数据成员具有直接的独占所有权。
作为子节点的容器，TermNode 子节点的迭代器、指针和引用保持稳定，即移除子节点时不无效化(invalidate) 其它项的迭代器、指针和引用。
TermNode 子节点的稳定性也支持项被转移时（如维护临时对象的内部存储(@5.2.4.2) ）不需要附加操作维护已在其它位置被引用的子项有效性。
针对 TermNode 的一些操作如移除第一个子节点的 RemoveHead 一般使用 ADL 方式调用。
树规约可按需添加或删除 TermNode 的子节点。具体添加或删除的时机未指定，取决于具体的规约算法。
除非派生实现另行指定，删除值数据成员和删除子节点的作用非决定性有序(@4.4.1) 。
除最后的代码生成（若需要），规约时每个子表达式的树的结构总是在此表达式的根节点保持不变（被删除前保证表达式总是对应一颗树），且源于语法分析的节点名称不会被修改。
TermNode 中存储的值可引用其它节点共享部分数据形成 DAG(@4.2.4) 。当前节点不直接被共享，值数据成员可能共享数据。
因为节点可能被共享，在被引用节点的意义上的规约为图规约(tree reduction) ，但这不属于一般的规约规则。
注意实现应避免形成非 DAG 的共享，以保证不出现资源的所有权(@4.2.2.3) 的冲突。
使用 TermNode 进行处理时，若子节点的分配器(@5.7.1) 和所在的项的分配器不相等，则涉及子节点容器的交换操作（包括 swap 及 TermNode::SwapContent ）的行为未定义。
除非另行指定，NPLA 及其派生实现的使用 TermNode 的 API 隐含上述关于分配器相等性的前置条件。

@5.4.2.1 项节点结构分类：
节点容器的内容被视为子节点按迭代顺序确定的有限的序列，即真列表(proper list) 。
真列表不包含环(cycle) 。其它形式的列表，如 Scheme 和 Kernel 中可能有环的非真列表(improper list) 不被支持。
按内容的结构，项节点具有如下互斥的基本分类（使用 TermNode 的 empty() 判断）：
枝节点(branch node) 或非叶节点，即具有子节点的节点，表示非空列表或同时具有子节点和叶节点的非正规(@5.4.2.1) 的非列表；
叶节点(leaf node) ，即不具有子节点的节点，表示空列表或不具有子节点的正规的(@5.4.2.1) 非列表。
按表示的内容，项节点可进一步使用其它谓词判断其分类：
列表节点(list node) 是值数据成员(@5.4.2) 为空的节点；
空节点(empty node) 同时是叶节点和列表节点；
分支列表节点(extended list node) 同时是枝节点和列表节点；
扩展列表节点(extended list node) 是枝节点或列表节点。
注意扩展的列表节点可能同时具有子节点和非空的值数据成员。
进一步地，节点可按子节点数（使用 TermNode 的 size() 结果判断）按需进行扩展分类。
列表节点对应对象语言的列表类型。作为列表节点的 TermNode 是对象语言中列表类型的宿主类型(@5.2.3) 。
考虑 TermNode 的值数据成员是否为空及其实际持有对象的动态类型等，具体实现 API 可约定使用不同的具体结构分类。
因为次级分类不一定是互斥的，所以可能需要约定对节点的操作顺序以确保结果一致，作为被规约项时典型地可能有以下几种情形：
先判断是否为枝节点，再判断是否为符合预期类型的非空叶节点，分派不同的操作；
根据项表示的值(@4.1) 考虑子节点及值数据成员（关于规约后的一般表示，参见 @5.8.5 ）。

@5.4.2.2 项的标签(tag) ：
枚举 TermTagIndices 和枚举 TermTags 作为索引和对应的掩码提供项使用的标签作为元数据。
每个项中附加 TermTags 的标签数据供用户程序使用。
TermTags 中的枚举项表示的标签主要有：
Unqualified ：非限定对象。默认值。
Unique ：唯一引用。
Nonmodifying ：不可修改。
Temporary ：临时对象。
默认值外仅用于 NPLA 项引用（参见 @5.6.3 和 @5.6.3.1 ）和派生实现。
在 TermTagIndices 中的枚举项带有 Index 后缀，和这些枚举项一一对应。
项的标签指定通过和标签关联的值访问的对象假定允许具有的性质。除非派生实现另行指定，违反这些假定不引起 NPLA 未定义行为(@5.2.2) 。
唯一引用允许通过通过具有唯一引用的项或项引用(@5.6.3) 访问关联的对象，对象可被假定不被其它引用而仅通过这个途径访问，即便实际存在其它途径的引用时可能引起不同的行为；在假定的基础上程序具有何种可能的行为是未指定的。
唯一引用允许实现做出类似 ISO C 约定的 restrict 关键字允许的假定，但程序违反假定的约束时不引起未定义行为。
类似地，和宿主语言不同，违反不可修改标签引入的假定不引起未定义行为。

@5.4.3 环境数据结构：
求值环境(@4.6.1.1) 以 Environment(@6.9.1) 类相关的类型表示，其中包含变量名称到表示被绑定对象(bound object) 的映射，称为名称绑定映射(name binding map) ，对被绑定对象具有所有权。
TermNode 对象在名称绑定映射中表示被绑定对象。
在对象语言的环境以表示环境的引用（而不是环境对象自身的）一等对象(@4.2.1) 表示，称为环境引用。
环境引用共享环境对象的所有权。
根据所有权(@4.2.2.3) 管理机制的不同，环境引用包括环境强引用(strong reference) 和环境弱引用(weak reference) 。
引入环境弱引用作为一般的引用机制，且仅在必要时使用环境强引用，以避免过于容易引入循环引用引起强内存泄漏(@5.2.4.4.1) ，符合 @1.4.5.2 。
传递环境引用不直接复制环境对象。另见 @4.2.3 。
Environment 支持定制名称解析(@4.3.3) 和名称解析的重定向，其中包含以下相关的定制状态：
重定向算法；
名称解析算法；
可在运行时确定宿主类型(@5.2.3) 的父环境引用（用于重定向算法的实现)。
默认的名称解析算法首先在名称绑定映射中查找局部变量的绑定(@4.1) ；若失败，调用重定向算法进行重定向，从父环境引用中取目标环境代替环境后代替环境继续使用其中的名称解析算法查找，直至没有可重定向的目标。
默认的重定向算法依次检查重定向目标的宿主值(@5.5) 类型。
对象语言中的环境引用类型的宿主类型是非递归的重定向目标类型。
不同宿主值类型具有不同的所有权。作为一等对象的环境引用的一般表达式值中，应根据是否需要具有所有权区分使用这些宿主类型的环境引用。
和 Kernel 类似，默认的重定向算法默认使用 DFS（Depth-First Search ，深度优先搜索）遍历目标。
相关 API 参见 @6.9 。

@5.4.4 上下文数据结构：
上下文(@4.6.1) 使用 ContextNode 类表示。
ContextNode 对象保存上下文相关的公共状态，具体 API 详见 @6.9.2 。
上下文的公共状态包括当前处理的环境，称为环境记录(environment record) 。
环境记录指定了活动记录中当前的处理的帧(@4.5.3.4) ，指定对象语言中对应当前处理的帧的当前环境(current environment) 。
上下文对环境具有共享所有权(@5.2.4) ，通过环境对象的引用可以取指向它的引用(@6.9.1) 。
上下文支持设置对应规约迭代(@5.8.3) 中对应的规约动作(action) ，保存特定的当前动作(current action) 和若干后继的定界动作(delimited actions) 组成当前动作序列(current action sequence) 。
其中，当前动作和后继的动作分别表示元语言中处理当前和后继的求值上下文中的操作。
当前动作作为宿主语言的函数对象被调用，激活(activate) 其中的规约操作，其中可覆盖当前动作为后继的动作。
以循环实现重写(@4.1.2) 时，有效的当前动作可用于作为保持重写循环的条件。当不存在有效的当前动作时，规约在完成已激活的规约操作后终止。
以抽象机描述操作语义(@2.2.3) 时，定界动在尾上下文外提供剩余的动作，作为一个序列，称为尾部动作(trailing actions) ，是当前动作的后继动作。另见 http://www.brics.dk/RS/03/41/BRICS-RS-03-41.pdf 。
当前动作起始的当前动作序列表示语言实现中（不作为一等对象(@4.1) 的）未被捕获的当前续延(@4.5.2.1) 。
动作和尾部动作整体构成求值上下文(@4.4.7) 的实现。后者在元语言中提供操作，又称为元上下文(meta-context) 。另见 http://www.brics.dk/RS/05/16/BRICS-RS-05-16.pdf 。
当前动作可作为尾上下文(@4.4.7) 的实现，称为尾动作(tail action) 。
配合重写循环提供基于尾动作的循环 API 可实现 CPS(contiuation passing style) 风格的异步调用。相关 API 参见 @6.9 。

@5.5 表达式和求值：
表达式由作为被规约项的 TermNode 表示(@5.4.2) 。
TermNode(@5.4.2) 的子节点表示的子项(@5.4.2) 通常作为子表达式(@3.4.2) 的实现。
此外，值可以是具有 TermNode 子项的列表(list) 数据结构，详见 @5.8.5 。
NPLA 表达式或其求值得到的值以若干个 TermNode 、TermNode 子项或值数据成员(@5.4.2) 表示；其中被求值的表达式应总能使用一个 TermNode 对象表示，称为被求值项。
求值结果(@4.1) 也用 TermNode 表示，以支持树规约(@5.4.2) 中直接基于项的替换操作实现求值。
在规约时，上下文(@4.6.1) 指定当前被求值项，确定当前被规约的 TermNode 。
表示值的 TermNode 是宿主语言对象具有的特定动态类型(@4.6.2) 的值是宿主值(hosted value) ，具有不固定的宿主类型(@5.2.3) 。
宿主值可包括值数据成员和子节点中的各个值数据成员中所有被擦除类型存储的对象，即宿主对象(hosted object) 。
典型情况下，值数据成员对应单一的宿主值。
除非另行指定，类型映射(@5.2.3) 的值是单一的宿主值。
NPLA 表达式求值取得的范式(@4.4.3) 总是其表示（一个 TermNode 对象）中的子项或值数据成员之一，详见 @5.8.5.2 。
TermNode 可能不直接表示表达式，如表示某些中间值(@5.6) 的情形。除非中间值也作为一等对象的表示(@4.1) ，NPLA 的范式不会使用这些形式表示。
用于表示表达式的项称为表达式项(expression term) 。表达式项经规约取得求值结果(@4.1) 。
作为 @4 的扩展，作用于非表达式项上的规约规则不是求值规则。

@5.5.1 值类别(@4.2.2.1) ：
和 ISO C++17 （由提案 [WG21 P0135R1] 引入的特性）类似，表达式项(@5.5) 及在表达式求值的规约中得到的项具有以下值类别之一：
泛左值(glvalue) ：求值用于决定被表示的对象的同一性(@4.1) 的项；
纯右值(prvalue) ：求值不用于决定对象同一性（而仅用于初始化(@5.5.2) 临时对象(@5.2.4.2) 或计算对象中存储的值）的项。
一个项可能被标记为消亡值(xvalue) 或附加其它元数据（如通过间接的引用(@4.2.3.3.1) ），以提供基于不同的所有权的行为。
左值(lvalue) 是除了消亡值外的泛左值。
右值(rvalue) 是消亡值或纯右值。
求值涉及项的值类别仅在必要时约定。
表达式的值类别同表示表达式的项的值类别。
作为名称表达式(@4.5.1) 明确引用直接存储在环境中的对象及其包含的（数据成员）子对象的项都是左值。
右值一般存储在环境以外的项上；必要时，实现可能存储右值在特定的环境中。
值类别根据是否只关心表达式关联的（对象的或非对象的）值，在需要对象时提供区分两类一等对象(@4.2) 的机制，同时避免在仅需要表达式关联的值时引入不必要的其它对象。
另见 @4.2.3 。

@5.5.1.1 类型系统和表示：
值类别在 NPLA 中被作为一种内建的类型系统，参见 @4.2.6 。
但在类型的值的内部表示上，值类别和特定的类型相关：
当前 NPLA 支持的左值都是项引用(@5.6.3) ，这同时表示引用值(@5.6.3) 。
另见 @5.6.3 和 @5.8.5 。

@5.5.1.2 设计原理：
按已有的规则，NPLA 约定求值至少需要支持以下的重要的性质：
第一，允许表达式直接表示一等实体而不论它是否是一等对象(@4.1)（即便按 @4.2.1 ，默认不会出现这种情形，派生实现仍然可能改变）；
第二，使用支持按引用传递的策略(@4.4.4.5) ，允许通过表达式构造引用不同对象的引用类型的值且被作为一等对象(@4.2) 传递。
一般地，这表示引入值类别的差异是必要的。因为，若假设平凡(trivial) 情形下，值类别可退化到都是泛左值或都是纯右值的情形。
若只存在泛左值，则任意的求值都决定一个对象；由于存在和一等对象无关的实体，无法满足第一条性质。
若只存在纯右值，则无法区分不同的对象，形式上无法构造出可用的引用类型的值满足第二条性质。
此外，NPLA 同时约定：
第三，求值满足递归蕴含规则(@4.4.4.1) ；
第四，允许对象的操作保持资源局域性，满足一等对象不依赖引用的抽象(@4.2.3) 同时允许按需区分是否依赖引用的两类一等对象；
第五，避免需要假设存在外部具有被引用对象(@4.2.3) 的所有权的所有者(@5.2.4.4) 。
第三条性质保证表达式的作用(@4.1) 是可组合的并允许求值表达为树规约(@5.4.2) ，还保证能总是通过子表达式的值类别决定表达式的值类别。因为被求值的表达式是有限的，判定过程是总是能终止，即便求值不满足强规范化性质(@4.4.3) 。
第四条性质要求提供泛左值总是能作为纯右值使用的机制和通过纯右值引入对象的机制，详见值类别转换(@5.5.4) 。
第五条性质要求在表达式之外不存在地位相同的对象的存储资源(@5.2.4) 的所有者，限定了被决定同一性的对象的外延；存储由环境提供(@5.2.4) ，其中不需要保存对象的引用。

@5.5.2 初始化：
部分创建对象的表达式引入对象的初始化(initialization) 。
初始化包括被绑定对象(@5.4.3) 的初始化和作为函数值的返回值(@4.5.3.1) 对象的初始化。
决定初始化这些对象的作用(@4.1) 的表达式是初始化的初值符(initializer) 。初值符的求值可能有副作用，其求值结果指定特定被初始化的对象的初始值(initial value) 。
初始化被绑定对象可能以修改操作(@4.1.4.2) 的形式体现，此时修改绑定具有副作用。若这样的副作用存在，每个被初始化的值后序(@4.4.1) 于对应初始的计算。
和宿主语言不同，初始化不是独立的依赖特定语法上下文的概念，但此处语义上的作用类似，一般可蕴含宿主对象的初始化。

@5.5.2.1 复制初始化和直接初始化：
和宿主语言类似，初始化包括直接初始化(direct initialization) 和复制初始化(copy initialization) 。
函数可能接受引用值(@5.6.3) 参数和返回值，是对函数的形式参数或函数值的复制初始化；其它初始化是直接初始化。
复制初始化形式参数和函数值时，函数参数或返回值作为初值符。

@5.5.2.2 函数参数和函数值传递(@4.4.4.5) ：
部分函数可保证被初始化的值和初值符(@5.5.2) 的值及元数据（如 @5.6.3.1 ）一致。
类似宿主语言的完美转发(perfect forwarding) ，这样的参数或返回值的初始化的求值称为转发(forwarding) 。
转发也包括只部分保留上述部分元数据的情形。
在允许保留元数据不变的上下文，转发在本机实现(@5.2.1) 中可直接通过转移项实现。
相对地，完美转发也保持引入这些初始化的表达式（通常是被求值取得函数值的函数表达式）时，其求值结果（函数值）的值类别(@5.5.1) 和初值符保持一致。

@5.5.2.3 对象的复制和转移：
类似宿主语言中的类类型的值，可使用初值符为参数进行复制或转移操作以复制初始化对象。（其它情形另见 @5.5.5.3 。）
类似 ISO C++11 起选择类的转移构造函数代替复制构造函数，可使用转移操作时，不对项进行复制，因此不要求值数据成员保存的宿主对象可复制（而避免抛出 ystdex::invalid_construction 等实现相关的异常）。
和 ISO C++11 起不同，上述可使用转移操作的条件和语法上下文无关：引起选择转移操作的条件由对初值符的谓词而非类似宿主语言的构造函数判断（详见 @5.5.4.1 ）。
同宿主语言，对象的复制和转移不改变被转移后的类型(@4.6.2) 。

@5.5.3 项的转移：
求值可引起包含宿主对象的被规约项(@5.4.2) 被整体转移，而避免其中包含的对象的初始化在对象语言中具有可见的作用，包括：
以 TermNode 对象的形式使其子项和值数据成员被转移（转移后的项具有有效但未指定的状态(@5.2.4.2) 但不可在对象语言中被访问）；
以未指定的其它实现相关的方式使 TermNode 成为其它节点的子项（不存在转移后的项）。
项的转移引起对象的析构性转移(destructive move) ：对象在转移后被销毁，其生存期结束。
和对象的转移不同，因为被转移的对象的生存期结束，项的转移不保证被转移后的项中的对象的类型不改变。
除了不初始化新的对象和使被转移项中对象的类型改变，项的转移在对象语言中效果可能类似宿主对象的转移。
项的转移保证不无效化(@5.4.2) 子项，也不转移或复制值数据成员(@5.4.2) 所有的宿主对象。

@5.5.3.1 宿主对象转移消除：
一般地，当对象需要被转移且没有约定转移后要求类型不变(@5.5.2.3) 时，项的转移(@5.5.3) 可代替对象的转移(@5.5.2.3) ，避免初始化新的宿主对象。
项的转移也类似 YSLib::ValueObject 自身的转移，其实现（当前通过 ValueObject 内部的 ystdex::any 的转移构造函数）保证直接转移对象而不保证转移构造所有的值。
若需调用宿主对象的转移构造函数，需明确避免宿主对象转移消除的上下文中进行操作。派生实现可提供这些操作。

@5.5.4 值类别转换：
和宿主语言类似，具有特定值类别的表达式可转换为不同值类别的表达式：
除非另行指定，泛左值总是允许作为纯右值使用，称为左值到右值转换(lvalue-to-rvalue conversion) ；
从纯右值初始化(@5.5.2) 可被对象语言作为一等对象(@4.1) 使用的临时对象并用消亡值表示，称为临时对象实质化转换(temporary materialization conversion) 。
左值到右值转换没有副作用(@4.2.2.1) 。临时对象实质化转换没有副作用，当且仅当其中初始化临时对象时没有副作用。
临时对象实质化转换中，纯右值被实质化(materialized) 。
在求值子表达式时，按表达式具有的语义，必要时（如按 @5.5.1.1 判断上下文的值类别）进行值类别转换。
为支持引用值(@5.6.3) 作为一等对象，NPLA 在左值到右值转换的基础上提供更精细的引用值提升转换，即以下转换操作：
若操作数是引用值，则结果是操作数引用的被引用对象；
否则，结果是操作数。
根据引用值的性质，易知左值到右值转换的规约是引用值转换的规约的传递闭包，即：
若操作数是已被折叠的引用值，则引用值提升转换等价左值到右值转换；
否则，有限次的引用值提升转换等价左值到右值转换。

@5.5.4.1 设计原理：
值类别和左值到右值转换在一些上下文的行为类似箱和自动拆箱(@4.2.3.5.3) ，不利于维护简单性(@1.4.3.2) ：
特别地，和宿主语言不同，函数不包含充分的信息（参数类型）推断是否接受左值操作数，因此在不提供针对函数的重载(overloading) 一般机制的前提下，本机实现(@5.2.1) 不能预知输入的操作数是否是左值，通常需分别支持左值和右值的操作数；
即便提供重载，仍然较单一的值类别更复杂。
但 NPLA 的设计中，值类别转换已被通过正确(@1.4.3) 反映需求的存储和对象模型(@5.2.4) 的设计隐含在项的内部性质中，因此不是可选的。
由正确性的优先规则(@1.4.3) ，完整性(@1.4.3.1.1) 应先于简单性被满足。
而考虑统一性(@1.4.5.1) ，对存储和对象模型的设计，用户自行的实现仍要求这些设施（尽管更困难）。

@5.5.4.2 返回值转换(return value conversion) ：
返回值转换是一次引用值提升转换和可选的临时对象实质化转换的复合。
返回值转换(return value conversion) 用于在对象语言中确定函数调用的返回值(@5.2.1) 可包含函数体(@4.5.2) 的求值结果到返回值的转换。
返回值转换的应用参见 @7.1.4.2 。

@5.5.5 临时对象的引入：
和宿主语言的临时对象的使用方式类似，NPLA 的临时对象在特定的上下文中被引入。
为简化规约和互操作机制的设计，和 ISO C++17 不同，临时对象仅在转换为消亡值(@5.5.1) 时的临时对象实质化转换(@5.5.4) 引入，而不包括延迟初始化或异常对象的创建。
临时对象实质化转换引入临时对象的规则和 ISO C++17 不同：
不论表达式是否作为子表达式使其值被使用（未使用的情形对应 ISO C++ 中的 discarded-value expression ），都允许存在临时对象；
要求复制消除(copy elision) 而避免特定对象的初始化(@5.5.2) ，参见 @5.5.5.3 。

@5.5.5.1 实质化转换上下文：
可要求临时对象实质化转换的上下文包括：
使用纯右值初始化按引用绑定的变量（如函数的引用类型的形式参数(@4.5.2) ）；
求值函数调用以初始化返回值对象。
其中，按引用绑定的变量被可选地支持；若被支持，引入引用值的形式参数的具体形式由派生实现指定。
一般地，按引用绑定的变量在活动调用(@4.5.3.1) 关联的环境分配临时对象(@5.2.4.2) 。此时，对象被调用表达式的项独占所有权，同时被绑定的环境独占资源所有权。

@5.5.5.2 返回值转换上下文：
返回值转换(@5.5.4.2) 可引入实质化的临时对象，其中可能转移求值的中间结果（条件参见 @5.6.3.4 ）；否则，对象被复制。
此处被转移对象符合 @5.2.4.2 的临时对象的定义，但除非另行指定，被转移的对象不在对象语言中可被访问。
此处的转移引起宿主对象转移消除(@5.5.3.1) 。
仅在对象被复制且复制具有副作用时，返回值转换具有等价复制的副作用。

@5.5.5.3 复制消除：
和 ISO C++17 类似，NPLA 要求特定上下文中的复制消除，排除复制或转移操作且保证被消除操作的源和目的对象的同一性(@4.2.1.1) 。
和 ISO C++17 不同，NPLA 的复制消除限于临时对象的消除，但不限制对象的类型（特定的 C++ 类类型），且除以下约定外的所有表达式求值的上下文对复制消除相同（例如，不区分求值结果是否被作为返回值(@4.5.3.1) 或求值是否为常量表达式）。
复制消除仅在以下转换上下文中被要求，即直接使用转换的源表达式中被求值项指称的对象(@5.7.3) 作为实质化的对象而不初始化新的临时对象：
实质化转换上下文(@5.5.5.1) ；
引起对象转移的返回值转换上下文(@5.5.5.2) 。
非本机实现(@5.2.1) 函数函数体内指定的返回值不属于上述的确定返回值的上下文，但也不要求被复制消除。这和 ISO C++17 要求 return 语句中的特定的表达式被消除不同，而不需要依赖特定上下文的语法性质。
实现仍可能根据当前环境(@5.4.4) 来判断是否在允许消除对象复制的上下文中（当前未实现），而进行复制消除。
在完成实质化转换前的不完整的求值规约(@4.4) 中的临时对象在逻辑上不需要作为一等对象(@4.1) 存在，但纯右值作为对象表示中的子项，随纯右值在宿主语言中作为对象存在，以允许互操作。
复制消除不在被初始化对象以外引入新的项。若被消除的对象来自不同的项，则复制消除为宿主对象转移消除(@5.5.3.1) 。这包括所有对象转移的返回值转换上下文的情形(@5.5.5.2) 。
在使用纯右值初始化引用值时，延长源表达式的项指称的对象(@5.7.3) 的生存期(@5.2.5) 。这和初始化非引用值类似，但实现需区分是否初始化的是延长生存期的临时对象，以确保之后能区分是否按引用绑定。

@5.5.6 表达式的类型：
NPLA 的类型系统(@4.6.2) 使用隐式类型(@4.6.2.2) ；和 Scheme 及 Kernel 类似，默认使用潜在类型，保证表达式的值具有类型(@5.2) 。
NPLA 表达式的类型约定为表达式求值结果(@4.1) 的类型。
空求值(@4.4.2) 的求值结果要求未求值的合式的(@2.5.1) 表达式应具有和语法分析(@5.3.2) 的输出兼容的类型，参见 @5.4.2.1 和 @5.6.1 。
注意表达式的类型和 [R7RS] 的 expression type 无关，后者是语法形式(@3.4.3) 的约定；因为存在合并子(@4.5.3.2) 作为一等对象(@4.1) 的类型，不需要这种约定。
实现对特定的上下文的表达式可使用类型推断(@4.6.2.2) 。由此确定的类型类似宿主语言的表达式的类型。
和 Scheme 和 Kernel 不同而类似宿主语言，表达式具有值类别(@5.5.1) 。
值类别的指派是类型系统的一部分(@5.5.1.1) 。但除非另行指定，类似宿主语言，值类别和表达式的类型正交，以简化操作涉及类型的指定。
和宿主语言不同，语言机制不限制值类别和其它类型的判断操作和结果(@4.1) 被作为一等对象(@4.2.5) ，尽管不一定直接提供。

@5.6 NPLA 中间值：
中间值(@4.4.4.2) 可在 TermNode 的值数据成员(@5.4.2) 中存储。
和具体求值(@4.1) 的求值结果(@4.1) 及其它情形存储的对象不同，中间值可能参与特定的规约作为求值的中间步骤的表示。
为允许区分中间值和被映射的其它值，约定中间值具有特定的类型。但以中间值引入的类型，其值仍可能作为求值结果。后者实质被对象语言作为一等对象(@4.1) ，称为一等中间值(first-class thunk) 。
中间值类型不是其它 NPLA 外类型的别名，但考虑由其它类型转换或构造。
其中：
记号值(@5.6.1) 构成的项可表示未求值的表达式。
记号值和项引用(@5.6.3) 可作为某些对象语言的表达式的表示。
NPLA 扩展中间值(extended thunk) 是其它由派生实现定义的其它中间值。

@5.6.1 记号值(token value) ：
NPL::TokenValue 类型的值表示记号(@3.3.1) ，可使用 string 类型的值构造，记号值类型。
由 @5.2.3 ，记号值对应的词素(@3.3.1) 作为名称，宿主类型为 string 。记号值对应的词素的宿主值和构造记号的 string 类型的值相等。
记号值和词素在逻辑上非空，但因为外部表示(@4.1) 未指定(@4.1.1) ，不保证在 API 中取得的这些类型对应非空串，因此除特定的内部实现外不省略空串检查。
和字符串值不同，记号值求值的结果不会继续是记号值，以避免不经意的递归求值或无法和宿主语言字符串值区分的情形出现。
但在 API 层次上，记号值的求值不排除无限循环或递归，不保证对应的项作为表达式时具有强规范化性质(@4.4.3)。实现需注意保证作为名称表达式时满足强规范化要求(@5.2) 。
表示一个未被求值的非字面量(@3.3.3) 记号的记号值称为符号(symbol) 。符号可构成名称表达式(@4.5.1) ，也可作为一等中间值。
符号的宿主类型(@5.2.3) 是 NPL::TokenValue 。
和 Kernel 类似，NPL 设计强调区分程序是否被求值的差异。符号是引入和表示为自求值项(@4.4.3) 的其它表达式的关键数据类型。
符号可能有外部表示。以未求值的记号值作为符号是其和外部表示关联的设计。由于外部表示未指定，这种关联是有限的。记号值蕴含了词素和符号的映射关系，即源代码文本；其余关系（包括源代码支持的文本编码）由派生实现指定。
记号值的相等性由等价于其对应的词素的相等性。
记号值可出现在词法分析(@5.3.1) 阶段，由单独的规约过程(@5.8.3) 通过调用 NPL::TokenizeTerm(@6.4.3) 转换词素或直接初始化分析的中间结果得到。
记号值相关 API 参见 @6.4.2.1 。

@5.6.2 环境引用：
NPL::EnvironmentReference 引用环境对象，封装 weak_ptr<Environment> 和锚对象(anchor object) 指针表示可能具有共享所有权的环境弱引用(@5.4.3) 。
环境对象的弱引用使用 weak_ptr<Environment> 确定。
因为 weak_ptr<Environment> 不提供可靠的弱引用计数，引用锚对象附加的引用计数用于确定弱引用的数量，详见 @6.9.2 。
默认构造的 NPL::EnvironmentReference 具有空的 weak_ptr<Environment> 值，是空的引用。
非空的 NPL::EnvironmentReference 是对象语言的环境弱引用的宿主值。

@5.6.3 项引用和引用项：
NPL::TermReference 储存在项的值数据成员中引用一个项，用于在必要时引入可被引用的一个项而不在 TermNode 中直接储存这个项的值。
对实现作为一等对象(@4.1) 的列表(@5.5) 的引用(@4.2.3) ，支持引用整个项的中间值是必要的；但 NPL::TermReference 也支持引用非列表项。
在对象语言中，引用值(reference value) 即作为引用的值在特定上下文中不提供和其它一等对象(@4.2.1) 相同的操作。
这主要体现为引用值被按值传递和按引用传递时(@4.4.4.5) 具有和其它一等对象不同的语义。差异和 ISO C++ 的引用类似。
值数据成员为项引用对象的项是引用项(reference term) 。
引用值可使用以下方式表示：
引用项；
使用 TermTags::Temporary 标签(@5.4.2.2) 标记的非引用项。
NPL::TermReference 和所在的项中可能包含的子对象是引用值的宿主值(@5.5) 类型。
其中，子项只被 @5.6.3.5 的情形使用。
子对象引用使用的这种形式的表示通常因为需要更多的操作比其它引用值的类似操作低效，但这种表示可避免依赖宿主语言中的本机对象内部表示（如成员布局）的依赖。一般地，在 C++ 的意义上不存在能满足语义的更有效的可移植表示，所以这种表示在和宿主语言的互操作上是必须的。
NPL::TermReference 通过是否使用引用值初始化决定对象语言中的左值引用(lvalue reference) 和右值引用(rvalue reference) 。
引用值是否作为左值(@5.5.1.1) 使用取决于上下文。除非另行指定，引用值都是左值。其中，在要求右值的上下文发生左值到右值转换(@5.5.4) 。
引用值应引用在存储期(@5.2.4) 内的对象。否则，引用值是悬空引用(dangling reference) 。注意访问悬空引用不满足内存安全(@5.2.4.3) 。
对 NPL::TermReference 相关操作详见 @6.4.4 ；可能使用 NPL::TermReference 访问项的操作详见 @6.4.5 。

@5.6.3.1 项引用的元数据(@4.2.3.3.1) ：
NPL::TermReference 包含一些附加的只通过引用形式访问对象的元数据作为优化设计(@4.2.3.3.2) ，包括标签(@5.4.2.2) 和关联的环境。
部分元数据在初始化时决定。
NPL::TermReference 初始化时，初始化保存标签(@5.4.2.2) 。
NPL::TermReference 通过 NPL::EnvironmentReference(@5.6.2) 可选地指定关联的环境。
当关联的环境不存在时，不提供对引入的对象内存安全(@5.2.4.3) 的检查(@5.2)。
引用值关联的环境是可靠的，当且仅当关联的环境是被引用对象的所有者。
不保证可靠的关联环境的引用值是不安全引用值(unsafe reference value) 。除非另行指定，仅有不存在关联环境的引用值是不安全引用值。
（另见 @5.4.3 和 @5.2.4.3.1 。）

@5.6.3.2 引用折叠(reference collapse) ：
和 ISO C++ 类似，引用值在 NPLA 中默认不被继续引用，使用引用初始化引用会引用到被引用对象(@4.2.3) 上，即引用折叠。
内部表示可支持间接的引用。和 ISO C++ 不同，NPLA 不限制派生实现利用未折叠的引用值，但 NPLA 的其它接口不和其与其它值区分。这允许在对象语言中实现一等引用(@4.2.3) 。
未折叠的引用值被折叠时，用于初始化的被引用对象可能仍然是未折叠的引用值。
完全折叠的引用值得被引用对象不是引用值。除非另行指定，以下的引用值指已完全折叠的引用值。

@5.6.3.3 引用值的消除：
引用值可被消除，即被其关联的被引用对象替代。修改引用值为关联的被引用对象消除引用值；折叠引用值消除被折叠的引用值。
未折叠的引用值消除引用值结果仍是引用值。配合引用折叠，消除已折叠的引用值确保结果总是右值(@5.5.1) 。

@5.6.3.4 可转移条件：
根据项是否具有特定元数据的引用值可判断使用复制代替对象转移的条件(@5.5.2.3) 。
可转移条件的判断基于表示表达式的值的项。可转移项(movable term) 通过以下方式确定：
若项是非引用项，总是可转移的；
否则，若项引用具有的标签(@5.6.3.1) 决定它是被引用对象的唯一引用且非不可修改(@5.4.2.2) ，项是可转移的。
一般地，决定可转移条件有两类：
由一般表达式的值确定可转移：判断表示表达式的值是可转移项使之能作为非引用值的返回值（用例如 @7.1.4.2 ）；
由被转发(@5.5.2.2) 表达式的值确定可转移：除上述条件外，表示绑定临时对象的引用值（具有临时对象标签(@5.4.2.2) ）的项蕴含被引用对象(@4.2.3) ，也是可转移的（用例如 @8.8 ）。

@5.6.3.5 子对象引用(subobject reference) ：
特定的引用值是子对象引用，通过一个引用值和它的子对象构造，引用被对象所有的一等对象。
子对象引用的表示详见 @5.8.5.4 。
子对象引用使用的这种形式的表示通常因为需要更多的操作比其它引用值的类似操作低效，但这种表示可避免依赖宿主语言中的本机对象内部表示（如成员布局）的依赖。
一般地，在 C++ 的意义上不存在能满足语义要求且总是更简单高效的可移植表示，所以这种表示在和宿主语言的互操作上是必须的。

@5.7 资源管理：
NPLA 的实现约定统一的资源管理语义，并以此支持存储和对象模型(@5.2.4) 。
除非另行指定（如明确资源被共享使用），NPLA API 提供类型的对象按值传递(@4.4.4.5) 传递资源所有权（复制或转移资源）。
违反 NPLA 资源管理要求可引起宿主语言的未定义行为并违反 NPLA 内存安全保证(@5.2.4.3.3) 。
基本的资源所有权约束由宿主语言的规则蕴含。部分数据结构可有更进一步的上下文相关的约定，如 TermNode 对象在作为被归约项(@5.4.2) 和被绑定对象(@5.4.3) 时具有不同的规则（参见 @5.7.3 ）。
NPLA 还引入称为间接值(indirect value) 的对象管理特定的资源，参见 @5.7.2 。

@5.7.1 分配器(allocator) ：
分配器分配资源，用于提供供实现指定的宿主语言的存储资源的来源。这和对象语言的存储资源(@5.2.4) 管理机制类似，但不保证对应。分配器隐含被映射的类型中，不显式出现在对象语言中。
NPLA 中的分配器具有可和 TermNode::allocator_type 互相隐式转换的类型，接受 YSLib::pmr::memory_resource 类型的存储资源。
这些分配器通常来自 TermNode(@5.4.2) 、ContextNode(@5.4.4) 的存储资源以及 Environment::BindingMap(@6.9) 的分配器，用于这些类型和 NPL::EnvironmentList(@6.9.1) 以及其它被运行时使用相同存储资源管理的项中的对象的初始化。
NPLA 和派生实现的本机实现(@5.2.1) 应保证分配器的使用符合以下小节的约定。

@5.7.1.1 相等性要求：
预期来自等价存储资源的分配器应相等，以避免分配器不相等的容器交换操作引起行为未定义（如 TermNode 交换，参见 @5.4.2 ）。
由 C++ 分配器要求，分配一个宿主语言对象时使用的分配器和其它特定分配器之间的相等性此宿主语言对象的生存期中确定不变。
以下关于 TermNode 的分配器相等性是 API 隐含的：
TermNode::Container 满足 C++ 标准库容器的 allocator-aware 要求，容器和作为容器元素的子节点使用的分配器相等；
TermNode::get_allocator 决定 TermNode 的分配器等价于 TermNode 中的节点容器的分配器。
以下情形的分配器在实现中应保证相等：
由同一个 ContextNode 对象决定的分配器在 ContextNode 生存期内应相等（且通常使用这些分配器的对象的生存期是此生存期的子集）；
若分配器来自超过一个宿主语言对象，这些对象提供的分配器应相等。
一般地，以下关于 TermNode 的分配器之间不保证相等性：
TermNode 对象和它的值数据成员(@5.4.2) 的分配器；
TermNode 的值数据成员和其中持有的对象可能具有的分配器。

@5.7.1.2 分配器来源：
宿主语言对象的分配器可通过从存储资源初始化或由其它对象使用的分配器复制初始化取得。
部分类型（如 ContextNode ）的对象初始化可接受存储资源参数。提供实际参数作为存储资源的用户代码应适当维护被引用的存储，确保这些对象的生存期是存储资源的生存期的子集，以避免引用已释放的存储而引起宿主语言的未定义行为(@5.2.2) 。
NPLA 使用的多态分配器可保证分配器和初始化分配器的存储资源的对应。但若已存在（满足操作的接口语义需要的）可用的分配器，取分配器的副本而不是使用存储资源初始化新的分配器。
由 C++ 分配器要求，使用相等的分配器效果一致，但除非另行指定或以下所有途径都不支持取得能兼容被分配的对象的分配器，若需要分配器（以满足 @5.7.1.1 或提供优化实现等），仍按以下规则（自上而下优先）约定确定用于复制初始化的分配器的来源：
引起表示对象语言的值的 TermNode 对象创建时，若分配器（根据接口语义）依赖操作中的一个或若干个已知分配器相等的、表示对象语言值（如对象语言中函数的参数）的 TermNode 对象，后者中的任一个 TermNode 对象提供分配器；
引起 TermNode 对象创建时，若对象被一个或多个 TermNode 对象共同所有（如节点的值被值数据成员所有），TermNode 的分配器以表示关联所有者的 TermNode 类型的值提供；
引起 Environment 对象创建时，需要的分配器由关联的 Environment::BindingMap 的分配器提供；
引起满足 allocator-aware 的容器要求的对象（支持迭代器和所有权）的元素的创建时，由被添加目标对象的分配器提供；
其它情形的分配器对象由 ContextNode 的存储资源提供。

@5.7.1.3 取分配器的方式：
提供分配器的对象可能若干种隐式（如转移构造）或显式（如 TermNode::get_allocator 调用）方式决定被使用的分配器。
满足上述预期的分配器相等性能决定同一来源的不同方式取得的分配器相等时，取分配器使用的方式未指定，如：
一个表示对象语言的值的 TermNode 对象提供分配器时，可直接取其分配器或子节点（若存在）的分配器。
否则，一般不能通用，如：
引起 TermNode 对象创建时，被初始化的值数据成员不能通过某个未知分配器来源也不具有相等性保证的被 ValueObject 值持有的对象取得。

@5.7.2 值所有权：
TermNode 对构成值的表示的子节点和值数据成员(@5.4.2) 具有所有权。和 @5.4.2 不同，非直接的所有权可能不是独占的。
TermNode 表示对象语言中一等对象的所有权规则符合 @5.2.4 ，且作为被归约项时，符合 @5.7.3 或派生实现指定的其它规则的所有权约束。
值对宿主对象(@5.5) 的所有权的机制由值数据成员（具有 ValueObject 类型）相关的 API 提供。
默认使用的 ValueObject 使用值的持有者 YSLib::ValueHolder ，直接作为对象的表示，同时具有对象的所有权。
使用其它持有者或约定特定的中间值(@5.6) 实现间接值允许和所有权分离的其它形式的表示，提供和非间接值不同的对象所有权和附加操作。
间接值具有访问被引用对象(@4.2.3) 的 API ，并确保允许复制或转移引用的对象以恢复对应的非间接值。
间接值可用于代替非间接值，避免求值时改变环境(@5.4.3) 所有的非临时对象(@5.2.4.2) 的所有权。
间接值可实现和 C++ 引用类型表达式类似的行为。
NPLA 提供引入间接值的 API ，参见 @6.6.2 。
实现通过值数据成员以外的机制也可隐含固定（不通过用户代码修改定制）的所有权关系，如上下文(@5.4.4) 和环境(@5.4.3) 。
所有权机制和中间值(@5.6) 正交：具有间接值的对象可能作为中间值，也可能不作为中间值。
引用一个项可能有多种方式，不具有所有权。关于引用相关的值的所有权，参见以下小节。

@5.7.2.1 引用值：
使用 NPL::TermReference(@5.6.3) 作为间接值引用一个项。

@5.7.2.2 引用持有者：
使用持有者 YSLib::RefHolder 的实例可实现间接值。
被间接引用的值的类型和 TermNode 的值数据成员(@5.4.2) 取得的类型一致，可直接替换非间接引用的对象。
引用持有者一般并不能替代引用值(@5.7.2.1) ，因为持有者仅影响存储来源和所有权，不区分类型，也无法要求用户代码使用明确的引用操作。
一般引用的持有者的项仅作为上述明确的引用操作的结果，作为中间结果继续以和非间接值一致的方式被规约（使用 NPL::LiftTermRef(@6.6.2) ）。

@5.7.3 被规约项(@5.4.2) 所有权：
具有值类别的被规约项若指称对象，对应的对象是这个项的项对象(term object) 。项对象是求值结果(@4.1) 或求值的中间结果对应的对象。
项对象可能不直接由项自身表示，即可以通过项引用其它途径引入的对象。
基于 @5.7.2 ，为保证内存安全，避免临时对象被引用，仅在泛左值(@5.5.1) 中允许引入被可能引用的间接值。
推论：泛左值的项对象不是临时对象，被环境所有。
通常纯右值作为其它项的子项而被独占所有权，求值时可能通过临时对象实质化转换(@5.5.4) 标识创建的临时对象(@5.5.5) 。
作为 @5.2.4 的实现，临时对象以项自身作为表示(@5.5) ，被纯右值所有，也间接被其它项所有。
特定情况下纯右值可能被环境所有，但应只通过复制等方式访问其值而不依赖所有权关系（如仅复制记号值(@5.7.4.2) ）。

@5.7.4 间接值使用规则：
在特定的适当情形（详见以下小节）下复制或转移间接值引用的对象以保证满足生存期要求(@5.7.3) ，维护内存安全。
不能满足上述适当情形条件的若不明确引起错误，则行为未定义。
间接值生存期规则：被规约对象中间接值的生存期总是不超过被引用的环境中的对象，以保证内存安全。
不满足间接值生存期规则的情形，除非提供派生实现定义的其它保证，不保证内存安全。
以含间接值的项替代不含间接值的项称为引入间接值。
包含间接值的项可被不含引用值的项替代，称为消除。
如需直接替换项表示的值，需消除间接值。否则，没有必要提前对项进行操作以提前移除间接值。
关于被求值的被规约项中的对象的所有权，另见 @5.7.3 。
派生实现可基于本节约定其它规则。

@5.7.4.1 引用值(@5.6.3) 作为间接值：
由于左值(@5.5.1) 的项对象被环境所有(@5.7.3) ，在项上的求值需要其它项对象作为中间值。
这种中间值通过间接引用左值以确保左值标识的对象可作为一等对象(@4.1) 使用，也是一种间接值，即引用值(@5.6.3) ，是引用(@4.2.3) 的实例。
NPL::TermReference(@5.6.3) 类型作为左值的引用的内部表示。
这类似 ISO C++ 的对象类型的左值引用和右值引用的差异。消亡值(@5.5.1) 使用内部的 TermTags::Unique 标签(@5.4.2.2) 标记。
基于引用的左值到右值转换(@5.5.4) 可通过 NPL::ReferenceTerm(@6.4.4) 实现。
和宿主语言的涉及成员访问的表达式类似，直接使用标识符进行名称查找(@4.3.3) 得到的表达式是左值或消亡值。在此环境总是被视为左值，所以结果由环境中的对象类型确定：当且仅当对象是左值时，结果是左值引用；否则是右值引用。
和宿主语言类似，右值引用类型的表达式可作为左值使用。
一般地，并非所有对象需要引用，详见 @4.2.3 。
引用值在必要时被消除(@5.6.4.3) ，以被进一步求值。

@5.7.4.2 其它间接值：
规约实现在特定情形的求值中使用 NPL::LiftTermRef 等(@6.6.2) 引入基于引用持有者(@5.7.2.2) 的间接值避免求值时改变泛左值(@5.5.1) 标识的非临时对象的所有权。
否则，引入的间接值引用环境所有的对象。
应注意存储环境以外的间接值时，不超出持有对象的存储期，避免未定义行为(@5.2.4) 。当前实现不对此附加检查。
注意不求值而仅替换项时，使用 NPL::LiftOther 或 NPL::LiftTerm(@6.6.1) ，这不引入间接值。
除构造间接值的例程(@6.6) ，当前不直接引入引用持有者。如需要引入间接值，使用引用值(@5.6.3) 而不是其它间接值，以统一处理无法直接持有的列表项和非列表项的引用。

@5.7.4.3 间接值的消除：
访问间接值涉及维护内存安全保证(@5.2.4.3) 时，可能需要提升项(@6.6) 以移除允许非内存安全(@5.2.4.3.1) 访问的间接值。
引用值作为间接值可被消除(@5.6.3.3) 。
用于按值传递参数时，一般使用 NPL::LiftTerm(@6.6.2) 和确保创建值副本的 NPL::SetContentWith(@6.2.1) 实现；前者取非引用类型的右值(@5.5.1) ，后者提升间接值确保结果不是中间值。
用于按值传递返回值时(@4.5.3.1) ，除显式分别对是否为引用值的情形进行处理，可使用 NPL::LiftToReturn(@6.6.3)（其中也使用以上方式实现），实现临时对象实质化转换(@5.5.4) ，详见 @5.7.4.4 。

@5.7.4.4 返回值转换(@5.5.4.2) ：
作为提升项的使用用例(@5.7.4.3) ，在返回值转换上下文(@5.5.5.2) 中确定函数返回值的实质化转换上下文(@5.5.5.1) 的部分操作消除引用值(@5.6.3.3) ，即返回值转换。
这可约束作为间接值的引用值不逃逸(escape)（即使用被引用对象的值时不超出指向对象的生存期），而保证只考虑项的值数据成员(@5.4.2) 可能是引用值时的内存安全。
返回值转换不保证未折叠的引用值在消除引用值后的结果不逃逸。为确保内存安全，程序仍需要保证被引用的对象的间接引用的对象生存期结束后，不能访问间接引用的对象。
除非证明不需要临时对象（当前未实现），返回值转换中初始化临时对象作为返回值的项对象(@5.7.3) 。
是否需要返回值转换由实质化转换上下文中的被调用的函数而非上下文是否需要使用右值决定，无关被转换的表达式是否是左值，因此返回值转换不是左值到右值转换(@5.5.4) 。
不论是否存在返回值转换，返回值的项对象来自返回的右值关联的临时对象实质化转换(@5.5.5) 。这可能在 NPL::LiftToReturn 或之前的求值规约的调用中蕴含。

@5.7.5 被归约项稳定性：
基于 TermNode 的性质，未被规约修改的项的子项的迭代器、指针和引用保持稳定(@5.4.2) 。
被规约的项在取得求值结果(@5.8.1) 前不被删除，以避免项的迭代器、指针和引用失效。
结合 @4.2.4.1 得到推论：被规约的项在取得求值结果起可被非内部对象(@4.2.4.1) 引用。
由 @5.2.4.1 ，项中的值数据成员(@5.4.2) 表示的宿主对象(@5.5) 保持固定。
子项的稳定性保证只要被规约的整个项不被作为对象被引用，直接转移被规约的项仍保持子项中的宿主对象保持固定。

@5.7.5.1 规约操作资源：
规约时保持决定当前规约操作的状态的资源的独占所有权([Documentation::CommonRules @@2.3.4.6]) 的项应具有足够长的生存期，以避免调用时引起未定义行为。
实现 WHNF(@4.4.3.1) 时，第一个子项对此资源具有独占所有权。
在无法预知子项是否需要被进一步使用而不会在被调用前另行存储包含这些资源的项时，实现使用的操作应避免删除这里的子项（对实现 WHNF 而言即第一个子项），以免无法使用其中的状态。

@5.7.5.2 临时对象资源：
表示临时对象的项的子项的迭代器、指针和引用应保持稳定 ，以支持子项被绑定到对象语言中的引用值(@5.6.3) 。
表示临时对象的项自身不需被绑定到引用值，不保证稳定，可被直接存储为 TermNode（而不需要保存为指针等间接值）。
对临时对象分配资源可能转移表示临时对象的项，但不影响其子项的稳定性。

@5.7.6 项修改限制：
若规约需调整项的结构以便使用特定 API ，可使用 TermNode& 作为参数的规约函数(@5.8.6)（另见 @6.5.3 ）；
如不可行，一般需转移到新创建的项上进行调用，以免改变现有的项导致无法使用项独占所有权的资源（如 @5.7.5.1 的状态）。
单独转移可能具有宿主类型对象的子项会违反固定对象的约定(@5.7.5) ，因此除非确保子项不被引用，不单独转移或销毁可能带有宿主对象(@5.5) 的子项（包括引起子项对象被销毁的删除操作）。
若规约内部确定符合内存安全(@5.2.4.3) 或派生实现指定的假定满足的条件（至少应满足 @5.7 中的资源管理要求），子项可被转移或销毁。这些操作包括：
被规约项取得自求值结果起，在非内部对象引用此项前被整体转移的操作；
NPLA 指定删除或其它可能转移或销毁子项的操作；
派生实现指定的其它要求假定或可证明安全的操作。
其它情形应避免这类操作。特别地，一般应避免在被处理的 TermNode 上直接调用 RemoveHead(@5.4.2) 。

@5.8 规约约定：
NPLA 规约 API(@6.5) 约定默认使用 TermNode 和 ContextNode 类型的引用作为参数类型，分别表示被规约项(@5.4.2) 和使用的上下文(@4.6.1) 。
其中其它变体参见 @6.5.3 。
NPLA 约定列表表达式(@3.4.2.3) 子项作为被规约项需进行递归的树规约(@5.4.2) 。

@5.8.1 规约结果：
规约过程返回描述一次规约调用操作结束后的状态的结果，包括以下几种情形：
部分规约(partial reduction) ：需要继续进行规约。表示不是完整的求值规约，也可以仅是管理规约(@4.4) 。一般仅用于异步规约(@5.8.7) 。
中立规约(neutral reduction) ：规约成功终止(@4.4.3) ，且未指定是否需要保留子项。
纯值规约：规约成功终止，且不需要保留子项。
非纯值规约：规约成功终止，且需要保留子项。
重规约：所在的列表表达式需要以相同的参数重新调用进行进一步规约，而需要跳过当前被规约项（一个 TermNode 对象）的剩余的规约动作(@5.4.4) 。
取得重规约外的规约结果时，被规约项表示求值结果(@4.1) 。关于使用规约实现表达式求值，另见 @5.5 。
纯值规约的求值结果总是由值数据成员(@5.4.2) 决定。
非纯值规约为纯列表规约，当且仅当求值结果仅由子项决定而不需要访问值数据成员。
除不指定要求保留子项，中立规约和非纯值规约的作用相同，仅影响 @5.8.3 中的处理。
若被规约的项已符合保留子项的要求，中立规约可以通过判断当前项是否已保留子项而分别指定为非纯值规约或纯值规约代替，但这带来不必要的项访问，不利于性能；因此本设计直接在规约结果中提供。
除非实现逻辑需要或另行指定，规约结果默认为纯值规约。因为通常求值结果的子项来自被规约项的子项，和表示规约后的项经常并没有关联而应被清除，默认规约结果设计为纯值规约便于处理这种常见情形。
规约结果作为规约实现的状态，设计原理如下：
基于实现的可扩展性、可复用性、复杂性和性能，判断规约终止的谓词（范式判断(@5.8.4.1) 谓词）不一定适合在单独的规约过程中指定。
引入可指定规约不终止的显式的重规约状态代替范式判断谓词应对这些问题，允许项在最终取得范式前附加可变状态，并优化范式判断(@5.8.4.1) 。
区分规约终止的不同情形能在一定程度上复用已有的列表节点(@5.4.2.1) ，避免规约时节点或其它数据结构的一些冗余创建。

@5.8.2 子项规约：
由树规约的性质(@5.4.2) ，可假定规约不改变参数外部的项的有效性，不需要外部项的存在性及结构进行额外的检查以确保继续满足相关前置条件（如子项被规约后所在的项总是继续为枝节点(@5.4.2.1) ）。

@5.8.2.1 子项的清理(cleanup) ：
纯值规约要求清理(cleanup) 操作，即移除不被需要(@5.8.1) 的子项。
清理时子项所有的对象被销毁，可具有副作用(@4.1) 。
子项的清理属于 @5.7.6 中约定的删除子项的操作。

@5.8.3 规约迭代：
对项的一次规约可分解为若干个对这个项的分步规约的有序的迭代过程，每个过程称为一个遍(pass) ；另见 @6.8 。
一次规约中有且仅有最后一遍规约迭代终止(@5.8.1) ；重规约(@5.8.1) 或通过抛出异常退出的迭代是一遍非终止的迭代。
一次不异常退出的规约按规约结果总是对应部分规约以外的规约结果(@5.8.1) 之一。

@5.8.3.1 规约迭代结果：
一次规约取得一个规约结果。
规约结果被用于在每次规约后维护被规约项的表示(@5.8.5) 。
若无法利用规约结果，在不需要保留项时，可能需要其它的显式的清理(@5.8.2.1) 操作。

@5.8.3.2 规约结果合并：
为避免保存规约结果的不必要开销，每一遍的规约结果不被提供给其它遍共享地访问。
不同遍的规约结果可能不同。项的一次规约的结果由被调用的一个或多个遍的结果顺序地迭代决定：
未经遍调用迭代的规约结果为中立规约（参见 @5.8.3.3 ）；
之后每一遍返回后，逐一合并(combined) 之前遍决定的规约结果和新的遍的结果，作为新一轮迭代后的规约结果。
（注意此处的合并操作不同于函数合并(@4.5.3) 。）
项的一次规约的结果为规约迭代的最后一遍合并后得到的结果。
迭代处理不同遍的规约结果仍有开销，但即便作为纯软件实现，通常仍远小于直接保存每个遍规约结果的开销。这也允许减少一次规约中不同遍之间的重复的维护操作(@5.8.5.2) 。

@5.8.3.3 规约结果覆盖：
一次规约中，某一轮被迭代处理的遍的规约结果可能和处理结果相同，即覆盖当前处理的规约结果。
规约成功终止的规约结果不被不表示规约成功终止的规约结果覆盖，以满足范式的语义(@5.8.4) 。
规约成功终止的不同规约结果可能支持互相覆盖。
由于规约结果作用不同，不同规约覆盖不一定被同等地支持。（这同时避免需要过多的不同的规约结果表示不同的覆盖操作。）
覆盖行为不应影响单一遍的规约结果的语义正确性。对子项的影响明确不同的规约不能互相替换。
例如，中立规约实现处理为纯值规约或非纯值规约是未指定的。但中立规约明确不清理子项，一般不能用纯值规约代替，不论纯值规约是否按以下规则覆盖其它规约结果。而为避免实现细节，中立规约也不能用非纯值规约替换。
当前规约结果覆盖使用以下对称覆盖设计：
未被规约的初始状态假定为中立规约，不影响子项并允许被之后的规约结果覆盖。
规约成功终止时，明确指定纯值规约或非纯值规约的规约结果在合并过程中可覆盖其它规约结果。
一般地，一个项上的规约成功终止时已决定是否需要保留子项，通常不需要覆盖非默认规约结果。
所以相对地，被确定为非纯值规约的情形不严格需要支持被下一轮规约结果覆盖为纯值规约。若仍要求不保留项，则需其它的显式的清理操作(@5.8.3.1) 。
和纯值规约类似而和非纯值规约不同，中立规约不覆盖其它规约成功终止的规约结果，不影响子项是否需要被清理。

@5.8.3.4 迭代规约结果的合并算法：
根据以上讨论中的要求，可确定规约结果的合并算法。
成功终止(@5.8.1) 的遍规约迭代结果的合并符合以下规则：
若被迭代的新一轮的遍的指定可覆盖其它结果的规约结果(@5.8.3.3) ，则指定合并的规约结果为此规约结果；
否则，新一轮合并的规约结果为之前的遍合并的规约结果。
一般的序列规约结果合并符合以下规则：
若之前的遍合并的规约结果指定规约成功终止，则使用以上关于成功终止的规约结果的合并规则决定新一轮合并后的规约结果；
否则，新一轮合并的规约结果同之前的遍合并的结果。
注意和非纯值规约(@5.8.1) 不同，中立规约(@5.8.1) 不会影响保留的规约结果。

@5.8.4 规约范式：
被规约项可能通过规约得到范式(@4.4.3) 。

@5.8.4.1 范式判断：
基于范式的定义，终止的(@5.8.1) 规约迭代应对 TermNode 参数进行规范化(@4.4.3) 以得到范式。
NPLA 提供以下等价的方式判断规约迭代后是否在 TermNode 得到范式：
除非另行指定，可直接使用 NPL::CheckReducible(@6.5.2) 以规约结果(@5.8.1) 决定是否为可继续规约的非范式；
通过检查节点结构的谓词确定是否为枝节点(@5.4.2.1) 等作为范式判断谓词进行判断；
其它派生实现指定的范式的判断方式。
以上等价性由特定的 NPLA 规则（如 @5.8.5.1 ）和规约实现机制保证。
因为只检查规约结果的值而不访问项，使用 NPL::CheckReducible 代替范式判断谓词(@5.8.1) 一般能优化性能。
基于上述等价性保证，上述等价方式中的范式判断谓词可蕴含 NPL::CheckReducible 的结果，必要时也可用范式判断谓词代替规约结果，详见 @5.8.5.2 。

@5.8.4.2 规范化规约(@4.4.3) 约定：
除非另行指定(@5.8.5.2) ，一次终止的规约迭代中若存在规范化规约，其发生的次数和时机未指定；一般在最后一遍(@5.8.3) 或之前存在一次即可。
注意规范化规约可能有引起可观察行为(@4.1.3) 变化的副作用(@4.1) ，实现应保证规约行为可被预期。

@5.8.5 正规(regular) 表示：
结合 @5.5 ，被求值的项的正规表示和规约结果有如下关系：
纯值规约由被规约的项的值数据成员(@5.4.2) 直接保存规约得到的值；
纯列表规约由被规约的项的子项决定规约得到的值。
满足上述约定的表示(@5.5) 是正规表示。其它表示是非正规(irregular) 表示。
平凡(trivial) 非正规表示保证可被（此次规约中剩余的操作）安全忽略而不改变规约的语义。
项通过求值取得平凡非正规以外的表示是得到范式的必要非充分条件；为取得范式，可能需要继续进行规范化规约(@4.4.3) 。
正规表示的值数据成员(@5.4.2) 称为正规值(regular value) 。
不论是否正规表示，项应该可复制和转移且不影响其中值的有效性。这蕴含非正规表示中不能依赖特定对象的同一性（如值数据成员直接引用子项）。

@5.8.5.1 规约表示基本性质：
除非另行指定（参见 @5.8.5.4 ），NPLA 实现应保证规约过程中出现的表示满足以下基本性质：
任一遍规约中，非正规表示应是平凡(trivial) 的。
规约表示基本性质允许在已知 TermNode 得到范式时通过直接判断项的节点结构(@5.4.2.1) 是否存在子项代替推断此次规约中之前的规约结果。
在对象语言输入可保证不存在非正规表示的前提下，这样的设计满足原则 @1.4.1.1 和 @1.4.2.2 。
若不能保证不引入非正规表示，实现可通过正规化操作(@5.8.5.2) 约束规约后的项，以确保接口行为满足上述规约语义的保证。

@5.8.5.2 正规化(regularization) 操作：
一次规约后，被规约的项中的值数据成员或子项仍然可保留其它状态而非范式；对表示求值的情况，也不是正规表示(@5.8.5) 。
因为规范化规约可能存在副作用(@5.8.4.2)，NPLA 约定求值得到正规表示的规范化规约在抽象机(@2.6) 的意义上总是被进行，称为正规化操作。
纯值规约(@5.8.1) 的正规化操作对子项进行清理(@5.8.2.1) 。由纯值规约的语义，被清理的子项不应影响项作为求值结果的表示。若应清理的子项存在，则清理前为平凡(trivial) 的非正规表示。
若需避免子项的生存期扩展到所在的项，需确保对平凡非正规表示总是存在可预期的清理操作。
纯值规约中存在的清理和修改值数据成员的作用仍非决定性有序(@5.4.2) ，因此一个项中的清理可能先序(@4.4.1) 最终确定作为值的表示的对值数据成员的修改操作。
因为子项的删除时机未指定(@5.4.2) ，不假定 NPLA 实现的规约清理求值后的节点，即清理由派生的具体规约实现指定。
一般在一个表达式取得求值结果(@5.8.1) 前，清理纯值规约要求排除的子项。
纯列表规约的规范化标记值数据成员为特定的值，可以是默认构造的空值或派生实现定义的表达式项(@5.5) 内的值数据成员外的记号值(@5.6.1) 。
除 @5.8.5.4 指定的情形（通过先行判断值数据成员而排除）外，当前未从非纯值规约结果中区分纯列表规约，因此不对纯列表规约进行操作。
注意正规化操作和之前的清理操作可能会影响项的生存期；另见 @5.7.5.1 。
对同一个规约结果的正规化操作是幂等(@4.1) 的，超过一次的连续正规化操作无其它作用。

@5.8.5.3 正规表示分类：
基于规约表示基本性质(@5.8.5.1) ，除非另行指定（参见 @5.8.5.4 ），不需要单独判断正规表示。
基于正规化操作规则(@5.8.5.2) ，通过以下逻辑对作为表示(@5.5) 的 TermNode 分类：
具有非空子项的 TermNode 表示非空列表(@5.4.2.1) ；
空节点表示空列表(@5.4.2.1) ；
其它项当值数据成员不是特定的值时，表示非列表表达式的值。
值数据成员为特定的值（如没有约定在对象语言中可表示的中间值(@5.6) ）的没有子项的 TermNode 不是任何表达式的表示。
注意值数据成员为 TermNode 类型的节点不表示列表节点。

@5.8.5.4 非平凡(non-trivial) 非正规表示：
基于非纯列表规约的非纯值规约，允许存在子项和值数据成员都有意义的非平凡非正规表示。
这样的表示要求先通过值数据成员进行判断，以排除为列表项。
NPLA 使用的子对象引用的非正规表示应符合以下约定：
只存在以下和派生实现另行指定的特定有限种类的非平凡非正规表示受支持；否则，行为未定义。
当前实现只支持以下情形：
子对象引用(@5.6.3.5) ：值数据成员持有 NPL::TermReference 类型的值，保留某个子项的引用。
子对象引用的项的子项数应为 1 ，该子项持有 shared_ptr 的实例的非空值且其指向的对象和值数据成员持有的 NPL::TermReference 值的 get() 结果应引用同一个项对象。

@5.8.6 规约函数：
接受 TermNode 和其它参数进行规约的 API 主要以宿主语言的函数（子例程）的形式提供，称为规约函数。
规约函数以被规约的项作为第一形式参数。
规约函数可能返回规约结果(@5.8.1) 。
规约函数可以调用其它规约函数实现。
注意因为可直接忽略被调用的规约函数的返回值并指定其它值，规约函数的实现的分类不一定具有组合性。

@5.8.7 异步规约(asynchronized reduction) ：
直接式(direct style) 的语言实现利用宿主语言的函数调用实现图规约(@5.4.2) ，满足规约函数(@5.8.6) 的调用包含子项的规约，即同步规约(synchronized reduction) 。
非同步规约称为异步规约。异步规约允许在宿主语言中分离部分规约(@5.8.1) 的不同部分的实现，使之公开为一等对象表示控制状态(@4.1) 及被调度。
NPLA 支持同步规约和异步规约中立的接口设计。具体异步规约在派生实现使用。
NPLA 实现支持异步规约，以避免 C++ 本机(@2.4.1) 资源限制下不限定数量(@5.2.6.2) 调用深度时可能引起的宿主语言的未定义行为(@5.2.2) 。
若资源分配失败，应满足常规宿主资源分配要求(@5.2.2.1) 。

@5.8.7.1 异步规约动作(@5.4.4) ：
NPLA 中，这通过以规约动作(@5.4.4) 作为 CPS(@5.4.4) 的被跳板(trampoline) 执行的中间值(@4.4.4.2) 例程的机制实现。此时，当前动作(@5.4.4) 是尾动作(@5.4.4) 。
跳板例程设置的规约操作将被异步调用(@5.4.4) ，即当前动作设置为异步动作，在跳板中被循环调用。上下文的重写循环(@5.4.4) 提供一个跳板调用当前动作(@5.4.4) 。
这种方式支持嵌套调用安全(@5.2.7) 。其它方式实现可能具有更好的性能，但存在限制而不被使用，如：
依赖不可移植的宿主语言扩展及实现假定，
对对象语言源代码中使用的语言构造（特别是影响控制流的合并子(@4.5.3.2) ）进行限制，使用单独的阶段进行抽象求值(@4.1) 。（这允许使用静态 TCO (@5.2.6.4.2) 所需的变换。）

@5.8.7.2 异步规约操作流程：
调用当前动作(@5.4.4) 引导若干操作（可包括后继的动作对当前动作的更新）组成一个异步操作序列实现对一个项的规约，这和对应的同步操作的树规约(@5.4.2) 保证 CPS 等价：
除以下约定不支持的宿主行为关联的副作用，规约对应求值的副作用顺序满足可观察行为(@4.1.3) 等价（一般因为无法预测内容，需完全一致）；
组成异步序列的动作（即作用在单一项上的操作）的作用的顺序仍然满足顺序依赖规则(@4.4.4.1) ，但不指定其它的顺序；保持可观察行为等价时，子项不需要使用严格满足树规约的实现。
使用异步序列进行规约即异步规约，实现一个支持 TCO 的规约的一般流程如下：
明确下一步会在规约函数返回规约结果(@6.5.1) 后被异步调用的操作；
通过直接访问或使用 ContextNode::SetupTail 等 API(@6.9.2) 设置上下文中的当前动作(@5.4.4) 为此操作。
下一步设置的当前动作为下一动作(next action) 。

@5.8.7.3 和同步规约的对应关系：
因为不再通过宿主的活动记录保留同步操作对应的项，当明确异步动作及对应的项时，规约函数返回的规约结果(@6.5.1) 和对应同步操作不再具有一一对应关系；上述外层循环的循环条件仅考虑当前动作的有效性，具体同 ContextNode::Rewrite(@6.9.2) 的约定。
当前动作对应单一项的到当前被求值项(@5.5) 的有界续延(delimited continuation) 。后继动作是这个边界外的被定界的续延。
实现过程调用(@4.5.3.1) 时，设置子项的当前动作前保存当前动作，和同步操作时保存活动记录帧(@4.5.3.4) 等价。保存当前动作的方式（具体调用的 API ）由调用方的实现指定。
异步规约所在的重写循环(@5.8.7.1) 中，每个动作返回的规约状态的含义不变；除被规约的项（若保持副作用顺序，也包括每个子项）上最后一步外，使用当前动作实现一个项内非最终步骤的异步操作，都为部分规约(@5.8.1) ，规约函数返回值应为 ReductionStatus::Partial 。
因为不记录规约的具体项，求值遍(@7.3.1.2) 中的动作序列在需要重规约时无法判断是否保留剩余的规约动作(@5.8.1) 。
是否继续需要剩余规约动作，由规约函数自行判断：
异步规约的实现通过重规约指定跳过剩余的规约动作；
上下文把规约动作的返回值保存在上下文的最后一次规约状态中；
由剩余的规约动作中访问上下文检查状态，根据最后一次规约状态判断是否继续异步添加或忽略（跳过）当前被规约项上的规约迭代(@5.8.3) 中剩余的后续的规约动作。
使用当前动作实现等效的规约时，应注意保存和恢复当前动作，以保持已有规约操作的连续性。
例如，调用 ContextNode::Switch(@6.9.2) 替换当前动作，返回被替换的当前动作可在当前动作后再次设置。
不指定当前动作的 ContextNode::Switch 也可用于清空当前动作以满足扩展当前动作操作的前置条件。
分离的当前动作可用于实现捕获(@5.8.7.4) 定界续延（如控制操作符(@4.4.3.1) shift ）。被捕获的续延在适当的条件下可重新组合到动作中以实现控制流的切换（如 reset 控制操作符）。
实现可使用扩展当前动作操作(@6.9.4) 配合这些调用组合当前动作。保存当前动作可在被保存的当前动作前添加其它操作。因为当前动作表示的续延有界，也可在当前被求值项之后添加操作。

@5.8.7.4 续延捕获(capture) ：
续延捕获把当前续延具现(reify) 为对象语言中可操作的对象。
由于宿主语言不支持作为一等对象的续延，捕获续延需在异步动作的边界保存当前续延对应的状态。
一般地，当前异步动作可以是一般的可调用对象，设置组合的动作后不保证可以拆分，也没有限制异步动作的组合必须显式地保留外部可见的边界（保存到活动记录），因此边界需在当前动作外部。
考虑到性能开销和对象语言的基于规约实现表达式求值，约定仅在表达式边界允许保存续延状态。

@5.8.7.5 异步规约中立(neutrality) ：
一些实现对是否存在异步规约中立(neutral) ，即不依赖引起可观察行为改变的上下文操作的存在都可使用。
这种依赖具有传递性：当底层实现依赖的都支持异步规约或对异步规约中立，此 API 实现支持异步规约。
所有间接依赖的 API 也都不涉及可观察行为改变的上下文操作的情形称为严格中立。
注意因为可能实现为同步或异步操作，非严格中立上下文的行为仍然可能改变（然而不应被用户代码依赖）。公开的规约不能是返回 ReductionStatus::Partial 的部分规约(@5.8.7.3) 。
NPLA 的 API 中，依赖可能包括通过回调等方式引入。仅在完全确定不涉及引入这些依赖时，操作被视为异步规约中立的。

@5.9 派生实现和应用实例：
除 NPLA 公共实现和派生实现 NPLA1 外，NPLA API 还具有一些其它应用实例。

@5.9.1 NPLA1 约定：
NPLA1 仅使用宿主语言的类型和值作为状态。
类型等价性基于类型映射(@5.2.3) 及其实现(@5.4.1) ，由 C++ 的语义规则定义。
值等价性由宿主实现的 == 表达式的结果定义。
除非另行指定，所有类型的外部表示都是同宿主类型的空字符结尾的字符串（ C++ NTCTS ）。

@5.9.1.1 附加规则：
当前仅支持标识符(@3.3.1) 作为名称。
含有“$$”的名称保留给宿主交互使用；含有“__”的名称保留给 NPLA1 实现。
在 NPLA 规则(@5.2) 的基础上，具有以下情形的程序引起未定义行为：
显式使用保留给实现的标识符。

@5.9.2 NPLA1 应用实例：
NPLA1 当前加入特定的序列化和反序列化作为配置文件，参见 NPL::Configuration 。
NPLA1 的上述配置文件加入特定的匹配和初始化机制作为 YSLib::UI::Loader([Documenatation::YSLib @@5.9.9]) 在运行时读取用户界面布局和配置的脚本。
NPLA1 用于 MIME 类型和文件名映射([Documentation::YSLib @@4.5.3]) 的实现，上述配置文件对应的外部配置格式。
注意这些应用不直接使用 NPLA1 的语义，其中使用的 TermNode 类型中名称直接表示上下文(@4.6.1) 中的实体名称。
计划使用完整的实现(@7) 取代这些应用的底层，使用 NPLA1 作为对象语言或作为附加的代码生成遍重新实现这些应用，但具体路线图未定。
关于当前提供的应用，另见 @7.12 和 @9 。

@5.9.3 NPLA 其它实现应用实例：
NPL::SXML 命名空间提供的 API 部分支持以 NPLA 分析 SXML 及构造 NPLA 表示的节点并转换为 XML 输出。
NPL 自定义分析器被用于 NPL::Dependency 模块中的函数 NPL::DecomposeMakefileDepList 实现解析 GCC 输出的兼容 GNU make 包含依赖字符串。

@5.9.4 实现兼容性：
除非在此另行指定，YSLib 中的 NPL 实现保持兼容。
影响向前兼容的变更：
b449 增加对多个未命名节点（叶节点或第一个子节点未能解析为名称的分支节点）作为非名称子节点时的反序列化支持。多个值会被以 $ 前缀接序号（从 0 起始）命名。之前的版本中读取的节点名称为空串，值被覆盖为第一个节点值。

@6 NPLA 公共语言实现接口：
部分实现的功能由公共 API 的形式提供，以便派生实现复用。
用于 @5.9.2 和 @5.9.3 等部分不直接用于 NPLA 解释实现的 API 可能在本节中被略过。
一些 API 仅列出名称，其具体描述详见接口文档（通过源代码注释生成）。

@6.1 安全保证：
除以下例外，NPLA 实现及对应可能由用户提供的替换的实现应支持嵌套调用安全(@5.2.7) ：
直接递归遍历节点的操作如 NPL::SetContentWith(@6.2.1) 和 NPL::TokenizeTerm(@6.4.3) ；
因为直接或间接调用上述遍历节点实现的操作，详见 @6.6.6 。

@6.2 节点(node) 操作：
NPLA 提供类似 YSLib::ValueNode 的 TermNode 类(@5.4.2) 和 ContextNode 类(@5.4.4) 的作为规约的公共实现基础。
ContextNode 作为上下文的实现，其中包含的部分数据成员是环境(@4.6.1.1) 的实现。
当前实现中，环境中的绑定(@5.4.3) 是平坦的映射，未依赖节点的递归性质；但是其中的被绑定对象(@5.4.3) 使用 TermNode ，也适用以下操作。

@6.2.1 项节点访问：
模块 SContext 提供访问项节点的 API 。
其中，判断项节点基本分类(@5.4.2.1) 的谓词包括：
NPL::IsBranch
NPL::IsBranchedList
NPL::IsEmpty
NPL::IsExtendedList
NPL::IsLeaf
NPL::IsList
这些谓词分别判断枝节点、分支列表节点、空节点、扩展列表节点、叶节点和列表节点。
TermNode 在类定义外提供关于节点内容的辅助 API 简化操作：
NPL::AsTermNode
NPL::SetContentWith
其余 API 主要包括：
NPL::TraverseSubnodes 遍历访问参数的子节点。兼容 TermNode 和 ValueNode ，主要用于语法变换。
NPL::AssertBranch 断言项是枝节点。
NPL::AssertPtr 访问值数据成员(@5.4.2) 中持有对象的指针。重载兼容 TermNode 和 ValueNode 。
通常仅在不涉及语义（仅涉及语法，或更基本的底层操作实现）时使用其访问项中非列表类型(@5.4.2.1) 的值。
涉及语义时，使用 @6.4.3 、@6.4.4 或 @6.4.5 的 NPLA 代替。这些接口提供了确切的项结构检查以符合正规化表示的相关假设(@5.8.5.2) 。

@6.2.2 非规约节点操作：
部分 API 用于不经过规约过程的变换，为纯语法操作。
SXML(@5.9.3) 依赖这些 API 。
其它操作包括向输出流打印节点的文本表示等。

@6.3 异常处理：
NPL::NPLException 是 NPL 实现的异常基类。
其它 NPL 异常都从此类直接或间接派生，包括：
NPL::TypeError
NPL::ValueCategoryMismatch
NPL::ListTypeError 列表类型(@5.4.2.1) 错误。
NPL::ListReductionFailure
NPL::InvalidSyntax
NPL::ParameterMismatch
NPL::ArityMismatch
NPL::BadIdentifier
NPL::InvalidReference
除 @6.2.2 外，NPLA 实现可能抛出这些异常或派生实现定义的派生这些类的其它异常。
NPLA 实现可能抛出标准库异常。
一般地，不通过对象语言构造（而仅通过互操作或实现缺陷）引起的异常，不使用 NPL 异常基类。

@6.4 上下文无关非节点处理 API ：
NPLA 实现提供不依赖一般项规约逻辑(@5.8) 的公共 TermNode 操作 API 。
以下 API 处理和 TermNode 或其中的成员数据类型相关但和 ContextNode 无关的数据。

@6.4.1 记号类别支持：
NPL::LexemeCategory 表示 NPLA 支持的词素(@5.6.1) 类别。
NPL::CategorizeBasicLexeme 和 NPL::CategorizeLexeme 对词素分类。两者的区别在于是否把扩展字面量视为符号(@5.6.1) 。
NPL::IsNPLAExtendedLiteralPrefix 判断字符是否为 @5.2 约定的扩展字面量前缀。
NPL::IsNPLASymbol

@6.4.2 规约相关类型别名：

@6.4.2.1 记号值：
基本概念参见 @5.6.1 。
调用 NPL::TermToNamePtr(@6.4.3) 访问具有记号值的名称节点对应的字符串。

@6.4.2.2 锚对象(@5.6.3) 指针：
NPL::AnchorPtr 是锚对象的指针的类型，是不确定类型的 shared_ptr 实例。
相关 API 详见 @6.9.2 。

@6.4.3 项访问操作：
NPLA 提供访问若干访问 TermNode 的便利接口。
NPL::TermToNamePtr
NPL::TermToString
NPL::TermToStringWithReferenceMark
NPL::TermToTags
NPL::ThrowListTypeErrorForInvalidType
NPL::TokenizeTerm
NPL::TryAccessLeaf
NPL::TryAccessTerm

@6.4.4 项引用操作：
NPL::TermReference(@5.6.3) 包括若干成员，其中主要有以下 API ：
IsMovable
GetEnvironmentReference
对 NPL::TermReference 的相关操作包括以下 API ：
NPL::Collapse
NPL::PrepareCollapse
NPL::ReferenceTerm

@6.4.5 项引用访问操作：
类型 NPL::ResolvedNPL::TermReferencePtr 表示解析项后作为访问参数的项引用指针。
函数 NPL::ResolveToNPL::TermReferencePtr 转换项引用指针为项引用的访问参数指针。
函数和函数模板 NPL::IsMovable 判断解析后的项是否指示可转移项(@5.6.3.4) 。
若被判断的参数是 NPL::TermReference(@5.6.3) 值，则同 NPL::TermReference::IsMovable(@6.4.4) 。
否则，被判断的参数是指向指向项的指针（支持包括项引用指针和项引用的访问参数指针）。
考虑到项可能是 NPL::TermReference 的访问项的相关操作包括以下 API ：
NPL::TryAccessReferencedLeaf 是 NPL::TryAccessTerm 和 NPL::ReferenceTerm 的复合。
NPL::IsReferenceTerm
NPL::IsBoundLValueTerm
NPL::IsUncollapsedTerm
NPL::IsUniqueTerm
NPL::ResolveTerm 解析并间接引用处理可能是引用值(@5.6.3) 的项，其中尝试解析使用 NPL::TryAccessLeaf 。
NPL::CheckRegular 指定函数访问检查项后的指定类型正规值(@5.8.5) ，即按模板参数指定的类型访问解析后的正规值。
NPL::AccessRegular
NPL::ResolveRegular

@6.4.6 项引用函数对象：
除以上 API ，NPLA 还提供以下关于 @6.4.4 的便利接口：
类 NPL::ReferenceTermOp
类 NPL::ComposeReferencedTermOp

@6.5 规约 API ：
基本概念和约定参见 @5.8 。
部分规约 API 以函数（如 @6.5.3 ）的形式提供，其中：
ContextNode 可被递归地作为子项规约的参数，因此可以不使用其它参数。
其它兼容实现可能使用其它参数。

@6.5.1 规约结果类型：
规约函数(@5.8.6) 的返回类型可以是规约结果(@5.8.1) ，以枚举 NPL::ReductionStatus 表示，其枚举项的值具有含义：
ReductionStatus::Partial 指定部分规约；
ReductionStatus::Neutral 指定中立规约；
ReductionStatus::Clean 指定纯值规约；
ReductionStatus::Retained 指定非纯值规约；
ReductionStatus::Regular 指定已取得正规表示(@5.8.5) 的规约（当前实现的枚举值的数值同指定非纯值规约）；
ReductionStatus::Retrying 指定重规约。
已取得正规表示的规约未指定公开的规约结果覆盖行为(@5.8.3.3) ，可以实现为中立规约、纯值规约或非纯值规约；当前实现同非纯值规约会覆盖默认的纯值规约，避免不必要的清理(@5.8.2.1) 而有利于性能。

@6.5.2 规约迭代：
基本概念参见 @5.8.3 和 @5.8.4 。
规约检查 API ：
函数 NPL::CheckReducible 检查参数指定的规约结果是否可继续规约，详见 @5.8.4.1 。
函数模板 NPL::CheckedReduceWith 循环规约直至不满足 NPL::CheckReducible 的判断结果。
正规表示(@5.8.5) API ：
函数 NPL::RegularizeTerm 按规约结果正规化(@5.8.5.2) 项。

@6.5.3 规约函数(@5.8.6) 形式约定：
规约函数(@5.8.6) 包括以下形式：
第一参数为被规约的项，类型为 TermNode& ；
或者，第一参数是和 TermNode& 对应的容器的以下至少之一：
	有效的 TermNode::Container& 值或 TermNode::Container 对象上的连续序列的迭代器范围之一；
	可作为值数据成员(@5.4.2) 的有效的 ValueObject& 值。
替代 TermNode& 的参数的形式允许不构造完整的 TermNode 而允许更好的性能，但仅在保证不要求直接使用 TermNode （如取得 O(1) 的 size() 或调用遍(@7.3.1) ）时适用。
规约函数的返回类型是 ReductionStatus(@6.5.1) 或 void 。
返回 void 的规约函数在规约结果(@5.8.1) 的语义上同总是返回 ReductionStatus::Clean 。

@6.5.3.1 直接和间接规约函数：
一些规约函数被设计可直接用于作为 EvaluationPass(@7.3.1.2) 遍的处理器(@6.8.1) ，称为直接规约函数。
其余规约函数是间接规约函数。
间接规约函数可能直接或间接调用直接规约函数。
规约函数对表示被规约的项以及上下文（若存在）或其上述对应形式的形式参数的使用应符合 NPLA 实现的规约迭代默认的约定(@5.8) 。
构成直接规约函数类型的一个必要非充分条件是：
第一参数的类型是 TermNode& ，且当第二参数存在时，其类型可隐式转换为 ContextNode& 。

@6.5.3.2 名称约定：
以下规约函数的名称以 Reduce 起始：
直接规约函数(@6.5.3.1) ；
起始两个形式参数符合直接规约函数要求，且可能直接或间接调用其它直接规约函数的间接规约函数。
不调用其它直接规约函数的间接规约函数的名称以 Evaluate 起始。
其余规约函数的名称不以 Reduce 或 Evaluate 起始。
注意不同实现中的命名空间可能不同，在此不作限制。

@6.5.3.3 主规约函数：
NPLA 的派生实现可提供对一般的规约(@4.1) 的实现以蕴含对象语言表达式的求值规则。
NPL 的表达式的语法是递归表示的，因此包括对列表表达式子项的递归规约。使用单一规约函数实现的这种规约一般即树规约(@5.4.2) 。
规约实现作用在对象语言表达式上通用的求值算法(evaluaton algorithm) ，符合规约性质(@5.5) 。
主规约函数是提供这种单一规约函数实现的直接规约函数(@6.5.3.1) 。
间接值(@5.7.2) 对主规约函数透明，不被直接处理。
推论：主规约函数实现的求值算法中，被求值的表达式不发生值类别转换(@5.5.4) 。这简化实现的复杂性，并允许派生实现单独处理需要间接值（如引用值）的情形，并在其它情形避免不需要的开销。

@6.6 提升项：
对项的提升(lifting) 指一类对项的替换变换，使用项进行一定的变换后取代其它项或其一部分，并满足下述提升条件。
决定替换变换是提升的条件为：被提升的项是提升后的项的一个直接或间接子项，以树表示项则为叶节点取代枝节点。
这可以视为消去 λ 抽象的 lambda 提升（详见 https://en.wikipedia.org/wiki/Lambda_lifting ）的一般化，但此处和 λ 抽象没有直接关联。
被提升的项往往被转移，因此一般地，需要可修改。
提升时对抽象的值表示进行操作实现基本的语义功能，可能进行检查，包括为满足接口行为的语义检查和实现为预防宿主语言的未定义行为的附加检查(@5.2) 。
提升项对象通过变换操作取作为项的值数据成员(@5.4.2) 。在此基础上有递归版本。
提升项可引入或消除(@5.7.4) 间接值(@5.7.2) 。
提升项通过被引用的对象替换作为项的值数据成员的引用值而消除引用值(@5.6.3.3) 。提升项的求值结果(@5.8.1) 是消除引用值的结果。
提升操作辅助对项的操作，可用于实现规约函数，包括以下各节中描述的 API 。其中：
名称前缀为 Lift 的函数是一元提升操作，具有一个 TermNode& 参数和其它可选的参数，提升第一参数指定的项，提升后的项保存在第一参数指定的项；
名称前缀为 Move 的函数是二元提升操作，具有两个 TermNode& 参数和其它可选的参数，要求参数指定的两个项不相同，提升第二参数指定的项，提升后的项保存在第一参数指定的项。

@6.6.1 基本提升操作：
基本提升操作包括直接转移赋值及以下 API ：
成员函数 YSLib::ValueObject::MakeIndirect 取记号值或持有其它类型的值的引用的间接值(@5.7.2.2) 。
成员函数 YSLib::ValueObject::MakeMoveCopy 转移或复制对象以消除间接值。
函数 NPL::LiftOther
函数 NPL::LiftTerm
函数 NPL::LiftOtherOrCopy
函数 NPL::LiftTermOrCopy
函数 NPL::LiftTermValueOrCopy

@6.6.2 可能引入间接值(@5.7.3) 的提升操作：
以下值操作可能引入间接值：
函数 NPL::LiftCollapsed
函数 NPL::MoveCollapsed
函数 NPL::LiftTermRef 提升项引用：提升项的内容为参数指定的项或值的引用值(@5.6.3) 。
引用值通过参数指定的值对象(@5.4.2) 上创建得到。
函数 NPL::LiftToReference 提升项对象为引用。
若项对象表示引用值则提升项，否则对 ValueObject 进行基于所有权的生存期检查并取引用这个项的引用值。
运行时进行的检查类似于强制 C++ 的一元 & 对表达式值类别（另见 @4.2.3 ）的要求但更严格（尽管仍然不能保证避免未定义行为），避免临时对象(@5.2.4.2) 被保存为引用值。

@6.6.3 消除中间值的提升操作：
函数 NPL::LiftMoved
函数 NPL::LiftMovedOther
函数 NPL::LiftToReturn
函数 NPL::MoveRValueToReturn
函数 NPL::MoveRValueToForward
函数 NPL::LiftSubtermsToReturn
本节的函数作用在被规约项时，对引用值的操作实现临时对象实质化转换(@5.5.4) 所在的求值规约的最后部分的操作，一般在尾上下文(@4.4.7) 中进行处理。
为消除中间值需要进行复制消除(@5.5.5.3) ，其中使用不同的可转移条件(@5.6.3.4) 决定使用转移而非复制。
当前实现在转移项时使用的宿主转移操作总是使用宿主对象的转移（基于 NPL::SetContentWith(@6.2.1) ）而不是 TermNode 的转移。
另见 @5.7.4.3 。

@6.6.4 辅助提升操作：
函数 NPL::LiftFirst 和 NPL::LiftLast 提升第一个和最后一个子项。

@6.6.5 非内存安全(@5.2.4.3.1) 的提升操作：
以上操作中，不保证引入的对象内存安全(@5.2.4.3) 且不提供检查(@5.2) 的操作有：
NPL::LiftTermRef ：通过 YSLib::ValueObject::MakeIndirect 引入间接值。
NPL::LiftToReference ：非内存安全的项引用操作(@5.2.4.3.1) 。

@6.6.6 不支持嵌套调用安全(@5.2.7) 的提升操作：
以上操作中，作为例外，当前（因为直接或间接调用 NPL::SetContentWith(@6.2.1) 遍历节点）不支持嵌套调用安全的函数包括：
NPL::LiftTermValueOrCopy(@6.6.1) ；
NPL::LiftTermRef(@6.6.2) ；
@6.6.3 的操作。

@6.7 辅助函数：
可作为规约函数(@6.5.3) 的不依赖上下文的 API 的辅助函数称为辅助规约函数，能处理一般情形的项，不存在作为断言的要求项非空的前置条件。

@6.7.1 简单规约操作：
NPLA 提供只依赖项既有结构的项简单规约操作。这些操作是直接规约函数(@6.5.3.1) 。
函数 NPL::ReduceBranchToList 要求参数是枝节点(@5.4.2.1) ；移除第一个子项，剩余项作为列表的元素，并返回 ReductionStatus::Retained(@6.5.1) 。
函数 NPL::ReduceBranchToListValue 要求参数是枝节点；移除第一个子项，剩余项作为列表的元素，调用 NPL::LiftSubtermsToReturn(@6.6.2) 提升子项的值，并返回 ReductionStatus::Retained(@6.5.1) 。
这保证最外的第一级引用被提升，不影响被引用项自身包含的引用。
函数 NPL::ReduceForLiftedResult
函数 NPL::ReduceHeadEmptyList
函数 NPL::ReduceToList
函数 NPL::ReduceToListValue

@6.7.2 间接辅助规约操作：
以下辅助规约函数转移参数实现规约：
函数 NPL::ReduceToReference
函数 NPL::ReduceToReferenceAt
函数 NPL::ReduceToValue

@6.8 遍迭代 API ：
NPLA 实现提供支持可调用的遍(@5.8.3) 的集合作为一次规约迭代的基础可配置的边界。
部分遍以 ContextNode(@6.9) 的引用作为参数。声明时，ContextNode 不需要是完整类型。

@6.8.1 遍处理器(handler) ：
每一遍规约迭代(@5.8.3) 实现为一个事件处理器(handler) 。这允许运行时修改求值执行的不同逻辑以取得较大的灵活性和可扩展性。
类似 std::function ，遍处理器持有目标对象(target object) 并具有其所有权。

@6.8.2 遍合并：
函数 NPL::IsOverridableReductionResult 判断参数指定的规约结果在合并中是否可被覆盖(@5.8.3.3) 。
函数 NPL::CombineReductionResult 和 NPL::CombineSequenceReductionResult 提供 @5.8.3.1 的成功终止和一般规约结果的合并操作。

@6.9 环境和上下文处理：
类 ContextNode 表示上下文(@5.4.4) 。
类 Environment 表示环境(@5.4.3)。
只使用其中包含的环境时，可使用 ContextNode(@6.9.2) 和 Environment(@6.9.1) 的 API 访问环境的数据。
需要上下文时，一般使用现有上下文，可能替换和重置状态；或通过现有上下文和环境创建新的上下文。

@6.9.1 环境相关类型：
NPL::EnvironmentList 为 vector<ValueObject> 的别名，表示一个环境列表，作为父环境时可用于递归重定向。
Environment 是环境类，提供父环境以及基本的名称解析(@4.3.3) 等操作的接口。其中的操作可被针对特定的环境对象重新设置。
变量名称到表示被绑定对象的映射(@5.4.3) 由其中保存的数据成员 Environment::Bindings 对象（类型为 BindingMap(@6.9.1) ）表示。
类 Environment 的成员函数 Define 、Redefine 和 Remove 修改上下文中的值。
使用 shared_ptr<Environment> 类型的环境强引用(@5.4.3) 引用环境对象以支持环境对象共享所有权(@5.2.4.2) 。
因为支持直接从对象中创建 shared_ptr<Environment> 类型的值，环境类应使用和强引用兼容的分配方式创建，以支持相关引用类型(@5.4.3) 。
使用环境弱引用(@5.4.3) 主要用于避免所有权(@4.2.2.3) 关系构成循环引用(@5.2) 。
当前支持循环引用检查的上下文有：
DefaultResolve（见以下描述）重定向父环境；
以引用的环境作为动态环境创建 vau 抽象(@7.11.5) 且创建的对象不对环境有所有权。
因为循环引用是对象语言的未定行为，检查循环引用失败抛出 std::bad_weak_ptr 而非 NPL 异常(@6.3) 。
环境访问相关的 API 可使用 shared_ptr<Environment> 或空的环境引用值(@5.6.2) 指定不存在环境对象。
使用可能具有这些值的代码需要对空值进行检查。因为这些空值不出现在对象语言，一般通过 ThrowForInvalidValue（见以下描述）抛出 std::invalid_argument 而非 NPL 异常(@6.3) 。
NPL::EnvironmentReference(@5.6.2) 表示环境弱引用。
NPL::EnvironmentSwitcher 类型用于切换上下文(@6.9.2) 中的当前环境(@5.4.4) 。
类 Environment 中，指定变量绑定的映射类型为 Environment::BindingMap 。
Environment 包含以下相关的数据成员：
Parent ：作为可在运行时确定类型的父环境引用，用于重定向算法的实现。
Environment::DefaultRedirect 依次检查重定向目标的宿主值(@5.5) 类型为如下之一：
NPL::EnvironmentList(@6.9.1) ；
shared_ptr<Environment> ；
NPL::EnvironmentReference 。
派生实现可提供其它宿主类型(@5.2.3) ，如 observer_ptr<Environment> ，用于内部实现而不要求所有使用环境的操作支持。
除 shared_ptr<Environment> 的 use_count 的结果外，环境的引用计数具体值是实现细节，不保证具有明确含义的稳定的结果。
类 Environment 还包含其它一些维护内部状态和绑定(@4.1) 的 API 。
成员函数 IsOrphan 判断是否为孤立的环境，即锚对象(@5.6.3) 未被外部引用。
成员函数 GetAnchorPtr 取锚对象指针(@6.4.2.2) 。
成员函数 GetAnchorCount
成员函数 GetMapRef 取名称绑定映射(@5.4.3) 引用。
成员函数模板 AddValue
成员函数模板 Bind
静态成员函数 CheckParent
静态成员函数 Deduplicate
成员函数 Define 和 DefineChecked 添加定义。后者在定义已存在时抛出异常。
成员函数 LookupName 在绑定集合中查找（一般作为局部变量的）标识符指定的名称，实现名称查找(@4.3.3) 。输入字符串指定（假定名称验证已通过的）名称。
成员函数 Remove 和 RemoveChecked 以字符串为标识符在指定上下文移除定义。后者在定义不存在时抛出异常。
成员函数 Replace 和 ReplaceChecked 以字符串为标识符在指定上下文的名称查找结果中替换定义。后者在定义不存在时抛出异常。
成员函数 ThrowForInvalidType
成员函数 ThrowForInvalidValue
友元函数 swap 交换环境对象的绑定、算法和锚对象指针。

@6.9.2 上下文 API ：
类型 NPL::Reducer 是以上下文引用作为参数的应的规约动作(@5.4.4) 类型，用于抽象一遍规约的动作(@5.4.4) 。
类 ContextNode 提供其它一些上下文 API 。
数据成员 Resolve ：名称解析算法。
数据成员 Current 即当前动作(@5.4.4) ，是类型为 NPL::Reducer 的一遍规约，一般不直接访问，可被作为尾动作(@5.4.4) 。
数据成员 Delimited 即后继动作(@5.4.4) ，是 NPL::Reducer 的容器。不同的动作被容器内不同的元素表示。
数据成员 LastStatus 保存最后一次规约状态。
Current 和 LastStatus 共同表示当前续延。
成员函数 GetBindingsRef 取环境记录(@5.4.4) 中的名称绑定映射(@5.4.3) 引用。
成员函数 GetRecordRef
成员函数 GetMemoryResourceRef 取存储资源(@5.7.1) 引用。
成员函数 ApplyTail
静态成员函数 DefaultResolve
成员函数 Pop 和 Push 维护动作的迁移，在 Current 和 Delimited 之间转移动作。
成员函数 Rewrite 以 Current 为条件的循环调用 ApplyTail ，作为跳板(@5.8.7.1) 实现一般规约重写。因为先设置当前动作，所以也有 Current 为空的前置条件。
成员函数模板 SetupTail 设置 Current 。前置条件是 Current 为空以避免重复设置覆盖当前动作的原始状态。
成员函数 Switch
成员函数 SwitchEnvironment 和 SwitchEnvironmentUnchecked 切换环境，即设置参数指定的环境并返回之前的环境。两者接受 shared_ptr<Environment> 的参数，区别为对空参数抛出异常或引起未定义行为。环境切换便于实现续延或过程调用(@4.5.3.1) 。
切换环境时，旧的环境若没有被引用，则被释放。由于环境具有对象的所有权(@5.2.4.2) ，内部绑定的对象作为自动变量也被一并释放(@5.2.4.5) 。
成员函数 ShareRecord 和 WeakenRecord 取环境的引用。
部分 API 使用的参数类似规约函数(@6.5.3) 。
这些函数的参数可能在内部实现被预先绑定，调用时对应的实际参数被忽略：如 TermNode& 类型的形式参数被绑定，内部使用绑定时确定的项而不是实际参数指定的任意的项。
因为绑定参数引入附加的函数调用，一般仅在有必要时使用。

@6.9.3 环境、绑定访问和解析操作：
基于环境的名称解析(@4.3.3) 操作可选地处理保留名称(reserved name) 并查找名称(@4.3.3) 。
解析环境只支持要求作为一等对象(@4.1) 的环境引用(@5.4.3) 。
以下解析名称的部分 API 可能折叠引用(@5.6.3) 。
函数模板 NPL::EmplaceLeaf
类 NPL::EnvironmentSwitcher
函数 NPL::ResolveName
函数 NPL::ResolveIdentifier
函数 NPL::ResolveEnvironment

@6.9.4 合并动作和扩展当前动作的操作：
以下 API 集中实现基于当前动作的复合中继操作，用于异步规约(@5.8.7.1) ：
类模板 NPL::ComposedAction 表示组合的两个动作。被组合的动作销毁时保持和初始化相反的顺序。确定的顺序允许保证异常安全。
函数模板 NPL::ComposeActions 组合参数指定的两个动作。
当第一个动作为 NPL::Reducer(@6.9.2) 类型的空值时，此动作被忽略。不检查第二个动作是否为空。
函数模板 NPL::ComposeSwitched 和 NPL::ComposeSwitchedUnchecked 组合规约动作和上下文中的当前动作。
其中，后者要求上下文中已经设置非空的当前动作，否则行为未定义。
函数模板 NPL::RelayNext 和 NPL::RelayNextUnchecked 通过设置上下文文中的当前动作异步地规约后继动作：在后继动作起始设置当前动作。
其中，后者要求上下文中已经设置非空的当前动作，否则行为未定义。
函数模板 NPL::RelaySwitched 规约当前动作作为后继动作，在后继动作起始设置当前动作。通过判断 ContextNode::Current 非空，调用 NPL::RelaySwitchedUnchecked 或 ContextNode::SetupTail 指定动作。
NPL::RelaySwitched 及 NPL::RelayNext 以当前动作或特定派生实现定义的其它动作调用时候，可支持 TCO(@5.2.6.4) 。
函数 NPL::MoveAction 转移动作到当前动作及定界动作。通过判断 ContextNode::Current 非空，调用 ContextNode::Push 或 ContextNode::SetupTail 。

@6.9.4.1 关于上下文中的当前动作的一般建议：
使用上下文中的动作时，避免直接使用 ContextNode::Current(@6.9.2) 或调用 ContextNode::Switch(@6.9.2) 的操作，以避免遗漏是否为空的前置条件检查。
除以上原因外，为提前资源分配并减少不必要的切换操作的开销，优先使用以下组合（尽管被替换的操作组合的其它作用通常等价）：
使用 NPL::RelayNext 和 NPL::ComposeSwitched 替换嵌套的 NPL::RelaySwitched 和 ContextNode::Switch ；
使用 NPL::RelayNext 和 NPL::ComposeSwitchedUnchecked 替换嵌套的 NPL::RelaySwitchedUnchecked 和 ContextNode::Switch 。

@7 NPLA1 解释实现：
NPLA1 解释实现是 NPLA 给定的 AST(@5.3.2) 作为输入的解释器(@5.1) 。
和 NPLA 类似，NPLA1 的实现也注重可扩展性。在限制修改语言规则的前提下，部分实现可被语义等价地使用更高性能的简化实现替代。
命名空间 NPL::A1 提供了特定于 NPLA1 的 API 。以下命名空间 A1 指 NPL::A1 。
命名空间 A1::Forms 提供了 NPLA1 的语法形式(@3.4.3) 对应的功能的实现(@7.10) 。
以下限定名称中，无歧义的嵌套限定命名空间使用非嵌套类型名称（即 Forms 指 A1::Forms ）。
除此以外，本章以 @5.3 约定的限定名称的方式使用 API 中出现的 C++ 名称和项目模块命名空间。

@7.1 NPLA1 一般约定：
在 NPLA 的一般约定(@5.2) 外，本节概述不通过具体 API 指定的一般特性。
关于内存安全和临时对象的基本规则，参见 @5.2.4 。
关于所有权和生存期，基本规则参见 @5.7 ；其中关于求值对应的 API ，参见 @7.5.4 。

@7.1.1 对象语言约定：
扩展字面量同 NPLA(@5.2) ，其中至少包括 #t 、#f 和数值的处理。前两者的对象语言和宿主值(@5.5) 类型为 bool ，后者的类型由派生实现指定。
引入过程(@4.5.2.1) 的具体形式参见 @7.11.5 ，也可约定通过特定的本机函数(@5.2.1) 等其它方式提供。

@7.1.2 项的结构：
项的结构（如项的分类(@5.4.2.1) 或子项数）和检查密切相关(@7.5.1.3) 。
遍的处理可能改变项的结构。应注意避免遍的处理器实现因此被改变自身或对此具有所有权的对象生存期导致未定义行为。
特定的项可具有非默认值的标签(@5.4.2.2) 。当前仅使用 TermTags::Temporary(@5.4.2.2) ，包含以下互不影响的情形：
在特定的被规约项(@5.4.2) 的管理规约(@4.4) 中，标记函数调用右值(@7.5.4.1) ；
在被绑定对象(@5.4.3) 或由被绑定对象通过调用 A1::EvaluateIdentifier(@7.5.4) 得到的被规约项中，标记绑定临时对象(@7.6.2.2) 。
其它标签当前作为项的成员不直接被使用，这包括：
被绑定对象中，不使用其它标签；
在表示求值结果(@4.1) 的被规约项中，不直接使用其它标签，对应宿主语言的限定符在纯右值(@5.5.1) 忽略。
除非派生实现另行指定，NPLA1 实现可假定已知纯右值的项中不存在以上不直接被使用的标签：
本机实现(@5.2.1) 选择复制或转移（参见 @5.5.2.3 和 @5.5.3）时，不需要判断表示纯右值的项的标签是否包含 TermTags::Nonmodifying(@5.4.2.2) 以避免修改。
NPLA1 本机实现初始化引用项时，仍应使用其中的标签初始化，以避免依赖具体标签的逻辑。以不表示求值结果的被规约项（如被绑定对象）的初始化可在标签中排除作为求值结果时未被使用的标签值如 TermTags::Temporary 。
以上限制不包含标签的单独使用（如 A1::BindParameter(@7.6.6) ）。

@7.1.3 NPLA1 间接值使用规则：
基本规则参见 @5.7.4 。
除非另行指定，不在求值引入右值引用(@5.7.4.1) 。
特别地，A1::EvaluateIdentifier(@7.5.4) 保证对应表达式求值的结果是左值引用。这使之实现求值符号(@5.2) 时的结果是左值(@5.5.1) 而不立即引入左值到右值转换(@5.5.4) 及复制对象，和宿主语言的行为类似。
作为替代，可通过 NPLA API（如 NPL::IsBoundLValueTerm(@6.4.5) ）间接判断绑定的对象的是否为右值引用。
引入绑定的 API(@7.6.6) 可引入引用值(@5.6.3) 。已有的引用值的引用总是左值引用，否则是右值引用。

@7.1.4 NPLA1 规约内存安全保证(@5.2.4.3) 机制：
在 @5.7 的基础上，NPLA1 规约附加以下约定以维护内存安全。

@7.1.4.1 修改限制：
部分关于间接值的操作依赖非内存安全操作(@5.2.4.3.1) ，其实现应满足一定限制以保证对外部调用者保证内存安全。
绑定操作(@7.6.2) 的 API 在实现内直接通过复制或转移立即使用可能创建的间接值而在复制或转移未失败时保证内存安全（仅当不按值传递(@4.4.4.5) 绑定的对象不保证内存安全）。
规约过程中可能使用 NPLA 项提升 API(@6.6) 。其中，消除中间值的操作(@6.6.3) 被用于实现内存安全的操作。

@7.1.4.2 过程返回值：
NPLA1 的部分过程抽象隐含返回值转换(@5.7.4.4) 。这可使返回值引用的对象不逃逸。
其它不隐含返回值转换的操作由用户代码避免非内存安全操作。

@7.1.4.3 非内存安全项：
引用持有者(@5.7.2.2) 仅存在有限的求值中间过程中，调用引入间接值 NPLA API(@5.2.4.3.2) 在 NPLA1 实现中可能仍能保证内存安全。
NPLA1 不直接调用非内存安全的提升操作(@6.6.5) 。派生实现可调用这些函数处理引用持有者（如 @5.7.4.3 ）。
其它 NPLA1 非内存安全操作(@5.2.4.3.1) 包括实现中调用的明确取无所有权引用的 API ，参见 @7.10.1 关于间接值的约定以及 @7.10 中具体函数的描述。
NPLA1 对后者的使用补充基于项引用(@5.6.3) 和环境的引用计数(@6.9.2) 的检查机制（如 @7.11.5 ）以在非内存安全的操作中避免引起宿主语言的未定义行为(@5.2.2) ，即便已引起 NPLA 和对象语言的未定义行为(@5.2.4.3.1) 。

@7.2 NPLA1 中间值：
NPLA1 扩展了 NPLA 的中间值(@5.6) 机制。
NPLA1 规约使用 @5.6 约定的类型影响求值状态。
除这些中间值和以下节引入的中间值外，不引入其它中间值。

@7.2.1 处理器(@6.8.1) ：
直接在值数据成员(@5.4.2) 储存的符合函数类型要求(@4.5.2) 的扩展中间值(@5.6) 是处理器，用于实现规约中的特定操作。
处理器可作为对象语言中的一等对象(@4.1) 的宿主类型(@5.2.3)。
处理器的调用是遍处理的规约过程中处理的。处理器类型不一定是在宿主语言中的函数。
使用基于 ContextNode 类型作为输入的事件处理器（ YSLib::GHEvent 的实例）作为中间值形式的处理器，可以组合不同的操作，用于实现规约(@6.5) 。
NPLA1 提供以下处理器类型的 NPLA 扩展中间值(@5.6) ：
A1::ContextHandler 以 TermNode(@5.4.2) 和 ContextNode(@5.4.4) 作为输入，实现一般的上下文处理，可作为 A1::EvaluationPasses(@7.3.1.2) 的事件处理器。
A1::LiteralHandler 以不可修改的 ContextNode 作为输入，用于和当前被规约的特定项无关的事件，典型地用于处理字面量引起特定的事件。
使用 NPL::EmplaceLeaf<A1::ContextHandler> 和 NPL::EmplaceLeaf<A1::LiteralHandler> 可设置环境或 ContextNode 的环境中的绑定的指定名称对应的处理器。参见 @6.9.3 。
关于 A1::ContextHandler 和遍处理、规约过程的关联和宿主类型，详见 @7.5.1 。
A1::LiteralHandler 可用于对特定单一记号(@5.6.1) 而不是记号组合作为输入时的处理，可配合交互式界面使用，参见 @7.7 。

@7.2.1.1 使用约束：
规约实现需满足 @5.7.5 。
在 @5.7.5.1 决定操作状态的资源包含当前使用的遍处理器中的目标对象(@6.8.1) 。
规约前被规约项的第一个子项具有遍处理器的所有权，也对目标对象具有所有权。
假定满足 @5.7.6 的要求而允许删除子项的情形包括：
主规约函数(@6.5.3.3) 和 @7.10 支持的本机函数(@5.2.1) 的实现可假定被在调用处理器前会转移子项的处理器调用；
通过处理 WHNF 的调用遍处理器的 A1::ReduceCombined(@7.5.4.1) 在调用处理器前会转移子项，可保证调用时生存期不会因为直接清理第一个子项而结束，因此处理器可清理第一个子项。

@7.2.2 节点记号：
NPLA1 实现使用 A1::ValueToken 枚举类型表示用于特殊标记的扩展中间值(@5.6) 。
当前被保留未直接在规约例程(@7.3) 中使用。
A1::ValueToken::Null 用于作为规约(@7.3) 过程中值数据成员(@5.4.2) 的占位符，适合值数据成员(@5.4.2) 逻辑上为空但不符合其它要求（如需要保留节点但稍后规约中被移除）时的场合，当前实现对 NPLA1 实现都是透明的；
A1::ValueToken::Unspecified 用于表示未指定的值，是一等中间值(@5.6.1) 。
语言规格(@2.3.1.2) 可能使用未指定值，但实现的 API （如 A1::Forms(@7.10) ）会明确指定使用这个值（如设置这个值作为对象语言中函数的返回值），用户代码仍然不应依赖此处使用的具体值。
注意当前 A1::Reduce 规约时不对空节点（表示空列表）和 A1::ValueToken 类型的值进行操作。

@7.2.3 NPLA1 续延(@4.5.2.1) ：
续延是依赖上下文状态(@7.3.3) 的一等中间值(@5.6.1) ，参见 @7.3.2 。

@7.3 规约实现：
NPLA1 在 NPL::A1 中提供不同粒度的规约和求值实现 API 。
由于实现 NPLA 的宿主语言不支持 TCO(@5.2.6.4.1) ，在实现时显式使用尾调用(@5.2.6) 形式才能支持空间复杂度和规约调用的嵌套深度无关；详见 @7.9 。
命名空间 A1 中的规约函数（参见 @7.3.4 和 @7.3.6 ）要求 ContextNode& 类型的参数引用的对象是 NPLA1 上下文状态或 public 继承的派生类，否则行为未定义。

@7.3.1 遍类型：
基于 YSLib 事件（ YSLib::GEvent 的实例），NPLA1 提供若干的遍类型。
基于 NPLA 公共实现，NPLA1 使用上下文提供的可配置的公共遍(@7.3.3) ，其 API 详见 @7.3.3 。

@7.3.1.1 遍合并器(pass combiner) ：
忽略部分规约(@5.8.1) 的多个遍的调用结果被实现为遍合并器 A1::PassesCombiner 定义的逻辑合并。合并时使用的判断条件参见 @6.8.2 。
遍合并器依次调用事件处理器，合并调用的结果为表示是否需要重规约(@5.8.1) 的值。当发现调用的结果对应遍的规约结果需要重规约时，调用停止。
遍合并器被 YSLib::GEvent 的模板参数依赖，可简化不使用异步规约(@5.8.7.1) 的同步实现。

@7.3.1.2 合并遍：
A1::GPasses 是用于作为可合并结果的遍的泛型类型。从事件处理器合并的结果被作为调用结果。
基于 A1::GPasses ，NPLA 提供处理不同的种类的合并结果的遍：
A1::TermPasses ：项合并遍，处理一般项的合并。项合并遍只使用项作为输入。
A1::EvaluationPasses ：求值合并遍，简称求值遍(evaluation pass) ，处理一般求值的合并。求值使用项和上下文作为输入。
A1::LiteralPasses ：字面量合并遍，处理已知为字面量的项的求值。
字面量遍的处理器应翻译可接受的字面量，返回结果为 ReductionStatus::Clean ；
否则，返回 ReductionStatus::Retrying 。
后者包括标识符是符号(@5.6.1) 的情形。
当前字面量不支持列表项，返回 ReductionStatus::Retained 同 ReductionStatus::Clean ，但可能在未来改变。
当前字面量遍不支持异步规约(@7.8)，返回 ReductionStatus::Partial 同 ReductionStatus::Retrying ，但可能在未来改变。

@7.3.1.3 非合并遍：
直接基于 YSLib::GEvent ，NPLA 还提供以下不合并结果的遍：
NPL::GuardPasses ：作用域守卫遍，处理固定出口逻辑的遍，对应作用域守卫类型 NPL::Guard 。
最后一个作用域守卫的值被作为调用的结果。

@7.3.1.4 遍规约约定：
A1::Reduce(@7.3.4) 满足迭代顺序(@7.3.5) 提供的保证优先检查子节点数，列表遍仅用于子节点数大于 1 的非叶节点(@5.4.2.1) 求值。
这个特性允许在对象语言的对应确定被求值的子项的表达式外添加匹配的括号而不改变语义，且在列表遍中可简化子项求值（如 @7.5.4 直接使用 ReduceCombined(@7.5.4.1) 而不需检查节点数量是否大于 1 ）。
一般列表遍不依赖以上假设，可能对叶节点或具有一个节点的平凡列表节点对应的表达式求值。因此列表遍不是枝节点(@5.4.2.1) 遍。
遍的调用不一定需要维护共享状态，也因此一般多个遍被调用时不保证求值的强异常安全；其它情形仍然遵守一般约定([Documentation::YFramework @@3.2]) 。
除 A1::ReduceCombined(@7.5.4.1) ，NPLA1 规约实现不保证进行正规化操作(@5.8.5.2) ：
在正规化操作不保证存在时，实现列表遍的用户代码需注意清理(@5.8.2.1) 不需要的子项。
关于规约函数的约定，参见 @6.5.3 。

@7.3.2 NPLA1 续延：
类 A1::Continuation 表示 NPLA1 的一等续延，即作为一等对象(@4.1) 的续延。
一等续延依赖 NPLA1 上下文状态(@7.3.3) 。
一等续延当前未完全在对象语言中被支持。

@7.3.3 NPLA1 上下文状态：
类 A1::ContextState 是 ContextNode 的 public 派生类，其对象表示 NPLA1 上下文状态，包含 NPLA 上下文的状态(@5.4.4) 。
NPLA1 上下文状态提供以下的供迭代的公共遍：
守卫遍(guard pass) ，类型是一个 GuardPasses(@7.3.1.3) ，用于提供调试回调等。
叶遍(leaf pass) ，类型是一个 EvaluationPasses(@7.3.1.2) ，用于实现叶节点(@5.4.2.1) 对应表达式的求值。
列表遍(list pass) ，类型是一个 EvaluationPasses ，用于实现列表节点对应表达式的求值。
字面量遍(literal pass) ，类型是附加 string_view 参数的 EvaluationPasses ，用于在叶遍的处理器内部调用，处理不同类型的扩展字面量(@5.2) 。
尽管 NPLA 已约定字面量的词法构成(@5.2) ，仍使用字面量遍而不是固定的扩展字面量处理逻辑以便派生实现决定具体字面量的关于不同字面量和不同语义的处理方式，同时能保证实现逻辑的局域性。
A1::ContextState 提供以下公开 API ：
数据成员 EvaluateLeaf 、EvaluateList 、EvaluateLiteral 和 Guard 是上下文提供的公共遍，分别为叶遍、列表遍和守卫遍。
数据成员 ReduceOnce
成员函数 RewriteGuarded 和 ContextNode::Rewrite 类似，但首先调用成员 Guard 动作。
成员函数 Access 通过指定的 ContextNode 对象中访问对应的 ContextState 引用。
成员函数 GetNextTermRef 取下一求值项的引用。
成员函数 SetNextTermRef 设置下一求值项的引用。若下一求值项的指针为空，抛出 NPL::NPLException(@6.3) 异常。
成员函数 ClearNextTerm 清除下一求值项的指针。
类 A1::ContextState 包含以下静态成员函数作为默认算法实现：
DefaultReduceOnce

@7.3.4 NPLA1 主规约函数：
NPLA1 规约以 A1::Reduce 和 A1::ReduceOnce 作为主规约函数(@6.5.3.3) 的参考实现，返回类型为描述一次规约调用操作结束后的状态的 ReductionStatus(@6.5.1) 。
A1::ReduceOnce 转发操作到 ContextState::ReduceOnce 的处理器调用，后者提供默认实现为 ContextState::DefaultReduceOnce(@7.3.3) 。
A1::Reduce 是 A1::ReduceOnce 的包装，最终调用后者以支持异步规约(@7.8) 。
A1::ReduceOnce 的规约对列表和非列表分别进行处理，实现求值算法(@6.5.3.3) ，要求单一子项的项规约为其子项，而其它列表或非列表项的规约操作由遍(@7.3.1) 提供。其中，列表被先匹配。
A1::ReduceOnce 和辅助规约函数(@6.7) 类似，能处理一般的项，没有前置条件。参数中 TermNode(@5.4.2) 表示的表达式语法意义(@3.4.2) 上非空，但没有实现限制（即不附加检查）。
A1::ReduceOnce 循环调用遍(@7.3.1) 进行必要的重规约，即迭代规约；通过 NPL::CheckReducible(@6.5.2) 判断是否需要重规约。
A1::ReduceOnce 的实现中不直接指定需要重规约；所有 ReductionStatus::Retrying 都来自遍(@7.3.1) 的调用。
名称表达式的求值不进行进一步规约(@4.5.1) ，这由具体遍(@7.3.1) 的实现保证。关于记号，另见 @5.6.1 。
使用设置遍的 API(@7.3.1) 修改 ContextNode 中的具体遍以使用不同的规约规则。
基于 A1::Reduce 包装的辅助规约例程参见 @7.3.6 。
NPLA1 主规约函数依赖 NPLA1 上下文状态(@7.3.3) 。

@7.3.5 迭代顺序：
A1::Reduce 定义节点次级结构分类(@5.4.2.1) 指定的规约迭代顺序被作为默认规约迭代顺序。
具体的分类和适用范围详见源代码文档。

@7.3.6 NPLA1 辅助规约函数：
类似 NPLA(@6.7) ，NPLA1 提供若干辅助规约函数，可直接作为规约函数实现遍规约。
和 @6.7.1 不同，这些辅助规约函数通过 ContextNode& 参数表明依赖上下文的状态(@5.4.4) ，且进一步依赖 NPLA1 上下文状态(@7.3.3) 。
A1::ReduceAgain 明确指定作为尾上下文(@4.4.7) 的再次规约。
若使用异步实现，按 @5.8.7.3 实现。
A1::ReduceAgainLifted 先提升项(@6.6.1) ，再调用 ReduceAgain 规约。
A1::ReduceArguments 从第二个子项起逐项规约。
A1::ReduceArguments 允许单一子项表示没有参数的情形，即便这不会通过 A1::Reduce(@7.3.4) 得到（因为子节点数为 1 时不调用列表遍），也可简化某些实现如 @7.11.5 。
A1::ReduceChildren 规约子项。
A1::ReduceFirst 对可能存在的第一个子项进行规约。
若第一个子项规约结果(@5.8.1) 可被作为列表遍(@7.3.3) 的事件处理器，整个项可继续规约。能进行此规约的形式称为 fexpr ，其中 f 表示 first 。
在某些其它语言中，符合类似求值规则的构造也称为 fexpr ，但语源不尽相同。
可组合使用 fexpr 的求值以及其它显式对 fexpr 子表达式的求值实现非严格求值(@4.4.4.5) 。
因为避免判断未指定子表达式是否需要规约（实现即非确定性求值(@4.4.4.5) ），A1::ReduceFirst 一般具有较小的解释开销。
A1::ReduceOrdered 顺序规约余下的子项，使用最后一个子项的值。
在 @5.2.5 的基础上，子项的求值被严格先序关系约定。
A1::ReduceTail 移除第一个子项并规约余下的项。

@7.3.7 其它辅助函数：
A1::SetupTraceDepth 设置跟踪深度节点，主要用于调试。

@7.4 NPLA1 节点处理 API ：
NPLA1 提供了对节点作为树形数据结构和整体处理的处理 API 。

@7.4.1 直接节点操作：
以下 API 主要用于兼容历史实现。
A1::InsertChild 插入 NPLA1 子节点。
A1::TransformNode 变换 NPLA1 节点 S 表达式抽象语法树为 NPLA1 语义结构。
通过 ValueNode 变换实现解释，参数指定映射例程，结果为变换的序列语义结构。
复合表达式中的经过节点到字符串的映射例程被解释为序列语义结构的名称，余下的项一一映射为子节点。
A1::LoadNode 加载 NPLA1 翻译单元。

@7.4.2 中缀变换：
NPLA1 提供符合特定谓词指定的过滤条件的中缀分隔项替换为特定名称表达式(@4.5.1) 指定的前缀操作形式的列表。
这些中缀变换作为预处理操作，可识别和接受 NPL-GA 语法外的记号，即转换扩展的 NPL-GA 文法输入为严格的 NPL-GA 语法(@3.4.4) 要求的源语言。
这些操作以函数对象类型 SeparatorTransformer 提供。
其中，函数成员 operator() 直接提供核心变换算法。
变换包含递归和非递归变换。
变换结果可被进一步规约。

@7.5 遍处理：
除主规约函数(@7.3.4) 和辅助规约函数(@7.3.1) 外，NPLA1 还提供若干 API 作为和特定节点内容相关的具有特定功能的遍(@7.3.1) 的事件处理器。
详细功能参见源代码文档。

@7.5.1 上下文处理器(context handler)：
基于 A1::ContextHandler(@7.2.1) ，NPLA1 提供了包含特定公共（检查或其它功能）逻辑的节点处理器包装其它事件处理器。
类模板 A1::WrappedContextHandler 是适配可选返回类型的包装模板。
当处理器返回类型为 void 时，可默认指定返回值为 ReductionStatus::Clean(@6.5.1) 。
注意上下文处理器不只适用于特定的规约实现如 A1::Reduce(@7.3.4) 。

@7.5.1.1 宿主类型：
A1::ContextHandler 是合并子(@4.5.3.2) 的宿主类型(@5.2.3) 。
迭代时，求值遍(@7.3.1.2) 可选使用基于 A1::ContextHandler 的处理器作为 A1::EvaluationPasses 事件处理器：
类 A1::FormContextHandler ：一般形式上下文处理器，表示不保证对操作数严格求值的合并子。
初始化 A1::FormContextHandler 提供包装数(wrapping count) ，决定调用合并子时对操作数求值的次数。
包装数在初始化后由数据成员 FormContextHandler::Wrapping 保存。这是一个 size_t 类型的值，存在上限。
相对（单独分配的应用子的存储的）直接实现，这减少构造应用子时需要的分配。
其数据成员 Handler 为被包装的处理器，类型为 A1::ContextHandler 。
Handler 是合并子的底层合并子(@4.5.3.2) ，可被嵌套地多次初始化。嵌套初始化操作实现合并子的包装(@4.5.3.2) 。
其数据成员 Wrapping 是一个 size_t 类型的值，指定调用合并子时对参数求值的次数。
操作子(@4.5.3.2) 以具有 0 值的 Wrapping 的 A1::ContextHandler 对象表示。
应用子(@4.5.3.2) 以具有非 0 值的 Wrapping 的 A1::ContextHandler 对象表示。

@7.5.1.2 处理器调用：
A1::FormContextHandler::operator() 依次进行以下操作：
按 Wrapping 的次数指定调用合并子参数求值，每次调用 A1::ReduceArguments 求值每一个子项（函数参数）；
若 Check 数据成员非空则调用 Check 进行检查，失败时抛出异常；
调用被包装的处理器 Handler 数据成员。
除此之外，附加操作参见 @7.5.1.3 。
注意直接在处理器中调用规约实现可导致无限递归；另见 @4.4.3 。

@7.5.1.3 前置条件检查和异常处理：
A1::FormContextHandler::operator() 调用时，按包装数(@7.5.1.1) 判断是否需要调用（被包装的处理器 Handler 数据成员）。
若需要调用，调用被包装的处理器 Handler 数据成员，并处理部分异常；
否则，调用 A1::ReduceArguments(@7.3.6) 规约参数项并以减少包装数 1 的上下文处理器中的调用作为后继调用。
Handler 调用至少可断言项满足 IsBranchedList ，但这在 A1::FormContextHandler::operator() 没有检查。
NPLA1 实现中，作为被调用的处理器（如 @7.3.6 和 @7.10 中的 API ）中可能存在对参数数量的检查。这类检查中已对枝节点类别进行检查，即不需要指定 NPL::IsBranchedList 作为前置条件。

@7.5.1.4 比较操作：
包装模板和上下文处理器提供重载操作符 == 以支持比较谓词(@7.11.1) 。
比较是必要的；否则，实例化 GHEvent 的操作可能导致无限递归调用。
当前没有直接提供 != 和其它比较操作。

@7.5.1.5 规约结果选择：
设计上下文处理器时选择 ReductionStatus(@6.5.1) 一般使用以下策略：
若为部分规约，使用 ReductionStatus::Partial ；
否则，若需重规约，使用 ReductionStatus::Retrying ；
否则，若需在求值结果(@5.8.1) 中保留列表，使用 ReductionStatus::Retained ；
否则，若能确保求值结果由值数据成员(@5.4.2) 决定且已经过正规化(@5.8.5.2) ，使用 ReductionStatus::Retained 而避免冗余的清理(@5.8.5.2) 操作。
否则，使用 ReductionStatus::Clean 。

@7.5.2 助手 API ：
NPLA1 提供枚举 WrappingKind 标识初始化 A1::FormContextHandler 需要的包装数(@7.5.1.1) 。
基于 NPL::EmplaceLeaf(@6.9.3) ，NPLA1 提供注册处理器事件的助手函数模板，无需显式嵌套构造 A1::ContextHandler 和其它处理器(@7.5.1.1) 类型：
A1::RegisterHandler
A1::RegisterForm
A1::RegisterStrict
助手函数的模板传入被包装的处理器和检查例程。

@7.5.3 项检查和辅助 API ：
A1::FetchArgumentN

@7.5.4 项求值 API ：
NPLA1 提供规约处理器若干 API 实现基于节点的表达式求值。被求值的标识符项构成对象语言中的名称表达式(@4.5.1) 。
包括以下函数：
A1::DefaultEvaluateLeaf
A1::EvaluateIdentifier
A1::EvaluateLeafToken 对作为叶节点记号的项求值，其中会判断字面量并按需调用字面量合并遍(@7.3.1.2) 或 A1::EvaluateIdentifier 。
A1::ReduceCombined 规约作为上下文列表的枝节点，详见 @7.5.4.1 。
A1::ReduceCombinedBranch
A1::ReduceCombinedReferent
A1::ReduceLeafToken 规约叶节点记号，提取名称并调用 A1::EvaluateLeafToken 求值对应项。
记号值类型(@5.6.1) 预期已在必要时被处理(@5.7.4.2) ，以上 API 没有区分得到的求值结果(@5.8.1) 是否可以是总是被复制的非临时对象的值。

@7.5.4.1 规约合并项：
函数 A1::ReduceCombined 对枝节点以已规约的第一个子项为上下文处理器(@7.5.1) 并返回调用结果，以节约严格性分析(@4.4.4.2) 开销；并根据处理器返回的规约结果进行正规化操作。
通过节点的值数据成员(@5.4.2) 是否持有 A1::ContextHandler 类型的值或引用到 A1::ContextHandler 的值上的 NPL::TermReference 的值确定是否为上下文处理器。
若存在 A1::ContextHandler 对象的子对象引用(@5.6.3.5) ，先变换子对象引用。这些子对象引用应符合 @5.8.5.4 约定的表示，否则断言检查失败。
以上变换中，若子对象引用持有的值不具有 A1::ContextHandler 类型，则抛出异常。
之后，设置或清空被规约项的 TermTags::Temporary(@5.4.2.2) 位分别表示函数右值和函数左值。被调用的处理器必要时可利用这个标签位作为提示进行优化。
因为被规约项总是非引用项(@5.6.3) ，和 @7.1.2 的其它用法（由 A1::EvaluateIdentifier(@7.5.4) 保证求值结果是引用项）不冲突。（同时，尽管只在管理规约(@4.4) 而不在对象语言的表达式中出现，这仍符合引用值(@5.6.3) 的语义；这实际上是复用 TermTags::Temporary 的主要理由。）
若存在调用，且不是（表示左值的）引用的情形，则先从第一个子项转移 A1::ContextHandler 对象，以维护生存期。
规约结果最终通过调用 NPL::RegularizeTerm(@6.5.2) 按纯值规约正规化(@5.8.5.2) 。
调用上下文传递时不清理(@5.8.2.1) 参数，即处理器中的第一个子项是已被清理的项，可被实现使用。
当调用返回 ReductionStatus::Clean 时，在返回结果前清理(@5.8.5.2) 子项（另见 @7.3.1 ）。
当调用返回 ReductionStatus::Retained 时，在返回结果前设置值为 A1::ValueToken::Null(@7.2.2) 以标记空参数列表。
当枝节点的第一个子项不是上下文处理器时失败，抛出 NPL::ListReductionFailure 异常(@6.3) 。
失败包含子项是列表的情形，此时不抛出 NPL::ListTypeError(@6.3) 。这也避免提示错误时，直接和具体的上下文处理器的具体宿主类型（当前为 A1::ContextHandler ）耦合。
对叶节点直接返回 ReductionStatus::Clean ，无其它作用。
配合 A1::FormContextHandler 在第一个子项上提供中间值(@5.6) ，得到的项为 WHNF(@4.4.3.1) ； A1::ReduceCombined 实现 WHNF 的求值。
调用合并子时，合并子和操作数中的临时对象被延长生存期(@5.2.6.2) ，但在尾上下文之前结束。
按 @5.2.4.2 ，实现可选择不同的内部存储保存这些临时对象，具体策略和是否支持异步规约(@7.8) 相关，详见 @7.8.3 ；另见 @7.13.2 。
函数 A1::ReduceCombinedBranch 同 A1::ReduceCombined ，但断言项符合 IsBranch 。
函数 A1::ReduceCombinedReferent 同 ReduceCombined ，但使用第三参数指定的值。
规约合并项不判断处理器内部的操作，以同时支持宿主语言的本机实现和对象语言(@7.11.5) 引入的合并子。
派生实现可在必要时使用特定的处理器缓存实现以提升对应的处理器调用性能。

@7.6 公共规约操作：
部分操作和 NPLA1 的规约的内部实现（特别是非本机函数实现的求值以及函数调用）相关。
使用这些操作实现对象语言对应操作的 API 详见 A1::Forms(@7.10)（以下简作 Forms ）。
部分公用的操作规则也在本节中约定。

@7.6.1 求值规约操作：
基于 NPLA 合并动作(@6.9.4) ，NPLA1 提供动作合并规约操作：
类型 A1::EnvironmentGuard
函数 A1::RelayForEval 直接求值(@4.1) 规约：规约并传递求值的结果。
函数 A1::RelayForCall 函数调用规约（ β 规约(@4.5.3) ）：规约并传递词法闭包规则(@4.6.1.1.2) 下求值的结果。
使用合并动作 API ，可定义依赖这些合并动作的求值规约操作，附加相同的约束。
为确保嵌套函数调用时允许引用绑定到非直接主调函数的临时对象形式参数，已被匹配作为绑定目标的项所在的不表示操作数的项（参见 @7.6.2 ）可能被转移以保证其子项生存期足够长。
按 @5.7.5.2 ，此时被作为绑定目标的子项不需被修改（因此自动符合 @5.7.6 的要求）。
间接调用 A1::RelayForEval 或 A1::RelayForCall 的操作是求值规约操作。
间接调用 A1::RelayForEval 的求值规约操作包括：
Forms::Eval(@7.11.4.1)
Forms::EvalRef(@7.11.4.1)
Forms::EvalString(@7.11.4.1)
Forms::EvalStringRef(@7.11.4.1)
Forms::Apply(@7.11.9)
间接调用 A1::RelayForCall 的求值规约操作包括通过过程抽象(@7.11.5) 中的函数引入合并子的调用。
求值规约操作附带绑定操作匹配被绑定的操作数树。
求值规约操作中可能具有提升操作(@7.1.4) 。
忽略提升操作可允许对象语言的函数调用返回(@4.5.3.1) 引用值(@5.6.3) 。

@7.6.1.1 求值规约提升项：
关于提升项的基本用例，参见 @5.7.4.3 。
部分求值规约操作使用同返回值转换(@5.7.4.4) 效果相同的方式实现消除引用值(@6.6) ：
A1::RelayForCall 和 A1::RelayForEval(@7.6.1) 间接依赖 NPL::LiftToReturn(@6.6.3) 。
对间接值的相关使用和检查另见 @7.5.5 。
引用值外的其它间接值(@5.7.4.2) 对应复制或转移间接值参见 @7.10.1 。
关于具体操作，另见 @7.10 中的保证，如 @7.11.5 。

@7.6.2 绑定操作：
绑定操作决定符号或具有符号的数据结构与项的对应关系，并初始化被绑定对象(@5.4.3) 而引入变量(@4.1) 。
作为函数语法的扩展，前者和后者分别是绑定操作使用形式参数(@4.5.2) 和操作数(@4.4.3.1) 。
作为 TermNode ，操作数(@4.4.3.1) 的表示具有树的构造，即操作数树(@4.4.3.1) ，它可以具有子项。
匹配的形式参数和操作数树对应也可具有树的构造，即形式参数树(formal parameter tree) 。
绑定操作初始化的变量的名称和值分别由形式参数树和操作数树决定。
绑定操作匹配待绑定的形式参数和操作数或它们的子项。
成功的匹配决定形式参数对应的操作数或其子项，作为其实际参数(@4.5.3) 。这种对应关系是单射但不一定是满射，即匹配成功后，每个参数总存在对应的操作数或其子项，而操作数和子项允许不对应形式参数而被忽略。
NPLA 操作数树的叶节点为符号(@5.6.1) 或其引用值(@5.6.3) 。
被绑定的项的操作数是待匹配的项的子项（而不会是此项自身，满足 @6.5.3 ）。
被绑定的参数可以作为函数的形式参数(@4.5.2) ，也可以其它初始化变量的语法构造的基础。
和 Kernel 类似，形式参数树是 DAG ，但通过真列表(@5.4.2.1) 的性质蕴含而不需要另行限制。形式参数树中的节点在匹配时被视为右值。
和 Kernel 不同，操作数树同时支持作为引用的左值(@5.5.1) 和非引用的右值(@5.5.1) ，在实现上需要解析引用（类似 @6.4.3 的部分操作）。
绑定操作的 API 详见绑定支持(@7.6.6) 。
绑定操作符合以下小节的绑定规则。其它具体行为参见对应 API (@7.6.6) 的详细描述。

@7.6.2.1 绑定初始化：
类似宿主语言，绑定的对象节点的值和子节点元素被复制初始化。
绑定时不对形式参数对应的函数参数进行修改，所以不对形式参数除访问引用值外的间接处理。
若形式参数可能由求值得到，需在匹配前另行处理。

@7.6.2.2 绑定临时对象标签：
绑定临时对象时设置对象上的 TermTags::Temporary 标签(@5.4.2.2) ，以实现区分通过引用绑定延长生存期的临时对象和非引用绑定的对象(@5.5.5.3) 。
一般地，表达式中的纯右值（非引用值）被绑定为临时对象，被绑定的对象在初始化后具有 TermTags::Temporary 。
这对应宿主语言中的转发引用(forwarding reference) 参数中的情形：
若模板参数 P 对应转发引用函数参数 P&& ，其中 P 是右值引用类型，保留从实际参数推断但不是实际参数类型的信息；
没有绑定临时对象标签的对象则同一般的非引用类型的对象类型参数（非转发引用）。
A1::EvaluateIdentifier(@7.5.4) 保证被绑定的对象名称解析的引用标签不包含 TermTags::Unique(@5.4.2.2) ，但不清除绑定临时对象引入的 TermTags::Temporary 。
这允许 TermTags::Temporary 在作为返回值的名称表达式中直接被跨过程传递（若不经过返回值转换(@5.7.4.4) 或其它操作）。
被传递标签类似宿主语言的 std::forward 的模板参数中指定转发引用参数类型（因为宿主语言的引用折叠，此处 P 和 P&& 一致）。
跨过程传递实质上并不被宿主语言支持（因为 P 表示的静态类型信息不在函数外可用），因此一般仅限为了实现类似宿主语言的根据值类别和类型转发参数的转发上下文(forwarding context) 中使用。
使用引用标记字符(@7.6.2.4) 可保留来自引用值实际参数的绑定临时对象标签。

@7.6.2.3 绑定匹配：
数据结构和匹配算法类似 Kernel 中用于 $define! 和 $vau 等操作子(@4.5.3.2) 的机制，但有以下不同（另见 @8.6.4 ）：
#ignore 按符号处理（但作用一致）；
不支持 cons 对(pair) 的中缀 . ，但支持形式参数树中的列表最后以带前缀 . 的符号（省略(ellipsis) ）匹配多个列表项的参数（其它一些不支持 cons 对的语言，如 ECMAScript 2019 的 rest 参数的语义效果与此类似；列表外的 . 起始的词素(@5.6.1) 当前视为普通的符号，但此行为可能会在未来改变）；
不提供转义，若符号去除可选的 . 后为空则忽略绑定；
对参数子项的符号中可选的 . 起始以及之后可选的前缀作为标记字符(sigil) 作为引用标记进行处理；
若参数子项按引用传递(@4.4.4.5) 则间接访问并绑定被引用项内容；
只支持真列表(@5.4.2.1) ，且不检查（因为 API 已经保证只支持真列表）；
不检查重复符号：操作数树中出现重复的符号时，只有其中某个未指定的绑定生效，其它绑定被覆盖。
和 Kernel 不同，绑定匹配对特定模式的形式参数进行不同的处理，参见 @7.6.2.4 。

@7.6.2.4 引用标记字符：
应用在形式参数树叶节点的前缀 % 、& 或 @ 为标记字符表示名称绑定的可按需引入引用，称为引用标记字符。
没有标记字符时，指示绑定的默认行为。
标记字符引起的绑定的差异为：
没有标记字符则对操作数按值绑定，实际参数值传递给对应的形式参数，若为 NPL::TermReference 则发生左值到右值转换(@5.7.4.1) ；
有标记字符 % 或 & 按引用推断规则直接绑定或转发操作数（当操作数为引用时；属于引用折叠(@5.6.3.2) ）；
有标记字符 @ 则绑定操作数的引用，不论操作数的类型和值类别（不进行引用折叠）。
使用引用推断规则绑定引用时，操作数按引用传递(@4.4.4.5) 给形式参数(@7.6.2.3) ；否则，操作数按值传递(@4.4.4.5) 给形式参数。
合并使用或不使用引用标记字符的情形，单一参数对象的绑定初始化包含以下过程：
	若没有绑定标记字符 @ ，则：
		若操作数为可转移的(@5.6.3.4) 对象的引用值，则：
			有标记字符时，使用引用推断规则，绑定变量为通过操作数直接初始化的引用值。
			没有标记字符时，绑定变量为操作数复制初始化的值。
			被绑定对象（引用值）的标签由操作数的（引用值）的标签决定：
				当有标记字符 & 时，被绑定对象（引用值）中包含绑定临时对象标签(@7.6.2.2) ，当且仅当引用值的标签包含 TermTags::Unique 。
				否则，被绑定对象的标签和引用值的标签相同。
		否则，若操作数标签(@7.6.2.5) 指定可修改的唯一值或有标记字符 % 时的唯一值，操作数是可转移的非引用值，被绑定的对象是临时对象。
		否则，当有标记字符 & 时，被绑定对象是操作数的引用值。
		否则，被绑定对象是复制自操作数的值。
	否则，被绑定的是操作数的引用：
		绑定操作数的引用时，要求引用的是列表中的项，否则抛出 NPL::InvalidReference(@6.3) 异常。
		被绑定的对象应是不唯一的值（直接绑定操作数右值以外的值），被绑定对象是操作数的引用值。
若绑定操作数的引用时，实际被引用的是临时对象，则行为未定义。（不和宿主语言一样延长右值的生存期。）
绑定的默认行为对引用值特殊处理，是为了满足 G1b ，而不是像某些语言（如 ISO C 和 [Rust] ）仅通过内建的机制提供特定左值上下文(lvalue context) 。
绑定的默认行为不使用析构性转移(@5.5.3) 的操作（类似 [Rust] 的设计），原因是考虑到绑定的副作用影响操作数（即便因为对象被销毁而不一定是修改操作）和破坏幂等性(@4.1) （特别是指定过程调用的形式参数时，参见 @7.11.5 ）违反易预测性原则(@1.4.5.2) 。
当前暂时不支持修改被绑定操作数。使用标记字符而修改操作数的绑定可能在未来支持。
具有引用标记字符的形式参数支持引入引用值并支持绑定引入临时对象的实际参数(@5.5.5) 。
绑定临时对象时可能设置被绑定对象上的 TermTags::Temporary 标签(@7.6.2.2) 。

@7.6.2.5 递归绑定：
递归的绑定匹配(@7.6.2.3) 对应递归的绑定，即可能绑定子项。
绑定算法应确定和当前处理的项对应的标签(@5.4.2.2) ，称为操作数标签(operand tags) 。
操作数标签和被引用标记字符结合决定是否按引用传递(@4.4.4.5) 初始化，并判断绑定初始化(@7.6.2.1) 时是否允许转移。
绑定开始时，操作数应为纯右值，当前实现中，其标签应为默认值（参见 @7.1.2 的约定）。此时以 TermTags::Temporary 作为初始操作数标签，以指定操作数可被唯一使用。
绑定的子项可以是引用项(@5.6.3) 。
绑定子项时，子项由现有的操作数标签按初始的操作数标签值和本节中以下约定的子项继承规则决定：
非引用项的子项标签和所在的项的标签相同。
否则，此时绑定的对象是被引用对象，处理子项时的操作数标签以操作数子项表示的引用值的标签(@5.6.3.1) 为基础，由先前处理子项所在的项的操作数标签按以下引用项继承约束限定：
若子项是引用项，则子项的操作数标签不包含 TermTags::Temporary ；
子项的操作数标签是否包含 TermTags::Unique 标签应和所在的项的操作数标签中是否包含 TermTags::Unique 一致；
若所在的项的操作数标签包含 TermTags::Nonmodifying ，子项的操作数标签应包含 TermTags::Nonmodifying 标签。
对引用项的 TermTags::Nonmodifying 标签的绑定规则和宿主语言中的非 mutable 类数据成员访问操作符决定 const 限定符的规则类似。
绑定 TermTags::Temporary 标签可影响参数转发(@7.6.2.2) 。若需按类似宿主的成员表达式的值类别而不是成员是否为非左值引用进行转发，需确保被转发的值不是带有 TermTags::Temporary 的引用值。
操作数标签中的 TermTags::Unique 由所在的项单独决定，而 TermTags::Temporary 仅在递归绑定时所在的所有列表项都是非引用值时包含。
子项标签继承规则保证使用 & 或 % 标记字符(@7.6.2.4) 时，值类别的决定规则和宿主语言的成员操作符类似：
列表左值中的元素总是被绑定为左值；
列表右值的元素按元素是否为引用被绑定左值或消亡值。
使用对象语言，若需判断列表左值中的元素是否为引用值，可直接绑定列表为引用并按需转换为消亡值再递归绑定列表元素。

@7.6.6 绑定支持 API ：
绑定支持 API 包括引入绑定的 API ，通过引入新的绑定(@4.1) 修改求值环境(@4.6.1.1) 。
用于辅助引入绑定的 API 包括：
函数模板 A1::CheckSymbol 检查记号值是符合匹配条件的符号。
函数模板 A1::CheckParameterLeafToken 检查记号值是符合匹配条件的参数符号。
实现引入绑定的绑定操作(@7.6.2) 的 API 包括：
函数 A1::MatchParameter 匹配操作数树(@7.6.2) 。
函数 A1::BindParameter 匹配并绑定操作数到参数上。
为允许调用宿主对象的转移构造函数，绑定操作(@7.6.2) 仅在特定的上下文中使用复制消除(@5.5.5.3) 。（实际上，初始化引用之外的参数创建也不是 ISO C++17 约定要求消除复制的上下文。）
对实际参数，检查尾部参数是否为省略(@7.6.2.3) 后，匹配前判断是否为 TermNode 以支持引用(@5.7.4.3) 。
一般地，对操作数树的递归操作应在分配资源失败时，引起（可能派生）std::bad_alloc 的宿主异常而非宿主语言的未定义行为(@5.2.2) 。
为支持嵌套调用安全的约定(@6) ，实现应避免无法预测嵌套深度的递归调用，但实现内调用的重定向操作以尾调用形式进行递归调用，类似使用跳板的异步规约动作(@5.8.7.1) 。
引入绑定的规则参见 @7.6.2 。
另见 @7.11.4.3 和 @7.11.5 。

@7.7 REPL API ：
NPLA1 提供 API 通过解释器的各个子模块组装 REPL(read-eval-print loop) 的交互式界面。
A1::SetupDefaultInterpretation 初始化默认解释，包括一般事件处理例程。
默认解释初始化的处理器(@7.2.1) 应符合 @7.2.1.1 的约定。若参数的处理器不符合约定，可能不满足 @5.7.5.1 并可能引起未定义行为。
别名模板 A1::GParsedValue 提供词法解析器(@5.3.1) 的解析结果类型中的元素类型。
别名模板 A1::GTokenizer 提供标记器，即和解析器的解析结果类型中的元素类型为参数的转换为 TermNode 的例程。对应解析器类型提供以下实例：
A1::Tokenizer
A1::SourcedTokenizer
以下 API 辅助 REPL 诊断：
函数 A1::QuerySourceInformation
函数 A1::QueryContinuationName
类 A1::REPLContext 可直接作为 REPL 原型。
A1::REPLContext 以 ContextNode::EvaluateList(@6.9.2) 为第二参数调用 A1::SetupDefaultInterpretation 初始化，之后默认解释配置 ContextNode 具有以下能在 A1::ReduceOnce(@7.3.4) 运行的规约算法：
若项是具有一个子项的列表节点，则规约为这个子项；
若项是具有多个子项的列表节点，依次调用 NPL::ReduceHeadEmptyList(@6.7.1) 、A1::ReduceFirst(@7.3.6) 和 A1::ReduceCombined(@7.5.4.1) 规约列表项；
否则调用 A1::ReduceLeafToken(@7.5.4) 规约叶节点。
REPL 对象内部保存求值表达式一次预处理的处理器作为数据成员。这在 @7.7.1 的算法前生效，不处理子表达式。
函数模板 A1::TryLoadSource 从上下文尝试加载代码。

@7.7.1 NPLA1 规范(canonical) 求值算法：
A1::REPLContext 配置的主规约函数具有的求值算法(@7.3.6) 称为 NPLA1 规范求值算法。
NPLA1 规范求值算法和 [RnRK] 中定义的 Kernel 求值算法（以及 [Shu10] 中定义的 vau 演算(@1.3) ）类似，差异为：
规约函数类型签名决定输入的表示被求值项(@5.5) 的数据结构 TermNode 是真列表(@5.4.2.1) 而不是有序对，但作为真列表子集功能实质等价；
先匹配列表值（但对符合正规表示(@5.8.5) 的输入没有实质差异），由 A1::ReduceOnce(@7.3.6) 决定；
要求一个子项的列表总是使用其列表元素求值，由 A1::ReduceOnce 决定。
最后一个差异是实质性的，它决定求值列表表达式和其中的子表达式求值总是等价。
为支持没有操作数的函数应用，需约定其它表达式表达求值为函数合并的应用表达式(@4.5.3) ：
当复合表达式的第一个子项为空列表“()”时，求值为一个函数合并(@4.5.3) ，这通过 NPL::ReduceHeadEmptyList(@6.7.1) 实现。对没有操作数的情形，这是唯一被直接支持函数应用的语法；否则，求值的作用同移除第一个子项 () 后的剩余形式。
和 RnRS Scheme 不同而类似 Kernel ，空列表 () 作为表达式在求值时按自求值项(@4.4.3) 规约，而不是没有函数的空过程调用。（在前者构造空列表需要 '() 。）
关于 () 的求值规则避免这种简洁有用的语法导致语法错误(syntax error) 。而和 Kernel 不同的函数合并求值规则使这个设计和函数求值字面上没有直接的关联，避免了 Kernel 中为什么 () 不是词法上类似的如 (f x) 这样的表达式的特例的问题。
注意以 () 作为前缀并不要求要求特定函数的子类型而可能破坏子类型封装性的假设。关于区分函数类型的替代设计的一个例子，参见 https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable#comment-422279775 。
由 @7.1.3 和 A1::REPLContext 配置的求值遍，NPLA1 规范求值算法不对引用值(@5.6.3) 特别处理。
因此，引用值在此作为一等对象(@4.1) ，作为表达式时不发生左值到右值转换(@5.5.4) 。符号(@5.6.1) 作为名称表达式(@4.5.1) ，求值为左值(@5.5.1) 。
这允结果保留(@7.10.1) 被求值表达式中的引用值，同时避免实现需要分别检查列表和作为符号求值结果的引用值类型的开销。
求值符号的实现参见 A1::EvaluateIdentifier(@7.5.4) 。

@7.8 异步(@5.8.7.1) 规约支持：
基本概念参见 @5.8.7 。
在 NPLA1 API 中同时提供对应的完全非异步规约的实现，不满足 TCO 要求(@5.2.6.4) ，仅供参考。
以下讨论的由上下文(@5.4.4) 支持的 NPLA API 使用方式和 NPLA1 相关。其它非 NPLA1 的派生实现可使用其它方式或选择不支持。

@7.8.1 和同步规约实现兼容性：
和同步实现的对应关系参见 @5.8.7.3 。
在当前被求值项(@5.5) 之后添加的操作可包括调用 A1::ReduceCombined(@7.5.4.1) 的清理操作。
和 NPL::CheckedReduceWith(@6.5.2) 单独判断规约结果保持循环条件不同，清理操作对应的异步规约由默认不清除当前动作即保持循环条件的 NPL::RelayNextActions 自行设置函数对象实现，当前不公开 API 。
这种实现允许通常没有进行 TCO 且不访问当前动作或不暴露当前动作状态改变的同步实现兼容子项规约为异步操作的实现（但反之一般不成立），即异步调用安全(asynchronous call safety) 。
允许这种兼容性有利于迁移 API 的实现至异步操作的实现，也允许支持按需启用 TCO 以平衡时间和空间开销及优化性能（但当前不考虑支持）。

@7.8.2 异步规约 API 支持：
部分 NPLA1 API 提供同步和异步的不同实现。一些 API 明确支持异步规约。

@7.8.2.1 异步规约基本支持：
A1::Reduce 当前实现依赖 ContextState::RewriteGuarded(@7.3.3) ，总是使用异步规约。
以下 NPLA1 API 可保存当前动作支持和实现异步规约：
A1::FormContextHandler::operator()
A1::ReduceChildren
A1::ReduceChildrenOrdered
A1::ReduceCombined
A1::ReduceOnce
A1::ReduceOrdered
A1::RelayForEval
A1::RelayForCall
以下 NPLA1 API 对异步规约中立而支持异步规约：
A1::ReduceArguments
A1::ReduceFirst
A1::ReduceTail
以下 NPLA1 API 覆盖当前动作支持和实现异步规约：
A1::ReduceAgain
以 A1::Reduce 起始的规约函数调用这个函数设置上下文中的当前动作(@5.4.4) 支持异步规约相关操作。
和同步规约不同，异步的重规约(@7.3.4) 不由求值遍(@7.3.1.2) 根据规约状态处理。调用异步重规约的代码需插入 A1::ReduceOnce(@7.3.4) 作为起始动作引导重规约。
规约状态 ReductionStatus::Retrying(@6.5.1) 在 A1::ReduceOnce 的实现中被用于判断是否跳过当前求值的子表达式支持重规约。
在每个表达式求值时，每个求值遍(@7.3.1.2) 的中间结果保存在 ContextNode::LastStatus(@6.9.2) 中，其中非 ReductionStatus::Partial(@6.5.1) 的结果被通过调用 CombineSequenceReductionResult 合并。
在表达式求值规约中，A1::Reduce 对 ContextNode::LastStatus(@6.9.2) 置为 ReductionStatus::Retrying(@6.5.1) ；之后再在求值后判断是否需要重规约。因为后续的求值是尾调用，可支持 TCO(@7.9) ；另见 @7.9.6 。
之后在判断应跳过上下文当前处理的表达式的剩余求值或没有剩余的求值遍时，求值完毕，再次置空。
A1::ReduceAgain 在必要时确保后续异步动作返回 ReductionStatus::Retrying ，直接支持异步重规约。
其它仅对表达式内的规约操作可直接返回规约状态而不设置上下文中的状态。

@7.8.2.2 异步规约派生支持：
以下 NPLA1 API（可能包含直接或间接调用 @7.8.2.1 中异步规约中立外的 API ）依赖当前动作支持和实现异步规约：
包含规约作为子表达式的子项的规约函数；
Forms 下 API 引入的 vau 处理器的 operator() 。

@7.8.2.3 当前动作前置条件：
为减小不必要的判断和重复维护当前动作开销，NPLA1 API 中只有特定规约函数(@6.5.3) 及其调用的 API 支持保存当前动作。
这些 API 包括 @7.8.2.1 和 @7.8.2.2 中明确支持异步规约的 API 。其中保存当前动作时，要求当前动作非空。
此外，A1::ReduceAgain 直接覆盖当前动作。
其它 NPLA1 API 对异步规约中立，不直接访问当前动作。
非 NPLA1 API 若支持异步规约，可能以关联的上下文中的当前动作为空作为前置条件以允许直接调用 ContextNode::SetupTail(@6.9.2) 等设置当前动作。
对具有前置条件的 API ，调用者应按需在其他操作前保存当前动作以维护符合预期的作用顺序。

@7.8.3 临时对象管理：
规约时，对象语言的函数右值和操作数右值需要被保存以避免引起宿主语言的未定义行为(@5.2.2) 。
特别地，对象语言语法意义上的嵌套函数调用应能引用外层对象（例如，通过绑定引用参数(@7.6.2.4) ）而不引起宿主语言的未定义行为(@5.2.2) 。
A1::ReduceCombined 在同步规约时通过宿主语言的规则自然地实现此要求，转移子项(@7.2.1.1) 时只需以宿主语言的自动对象作为新建的项。
而异步规约时，需要另行单独保存函数临时对象和操作数临时对象。这通过使临时对象保存在动作中实现。
排除本机函数(@5.2.1) ，合并子中的求值都通过 A1::RelayForEval（直接求值）或 A1::RelayForCall（合并子调用）实现，转移子项保存临时对象不晚于 A1::RelayForCall(@7.6.1) 的调用。
宿主语言直接实现的本机函数通常仍使用同步规约以避免转移子项等操作的复杂性；若使用异步规约，也需要保证子项的生存期以满足上述要求。
实现需自行决定是否使用内部存储保存临时对象以及需要保存临时对象的内部存储的位置。若需支持异步规约，不能使用宿主语言的自动对象。
一般地，因为 TermTags::Temporary(@5.4.2.2) 允许原地标记被绑定的临时对象而非引用其它存储(@5.5.5.3) ，不需要对被绑定的操作数临时对象特别处理。
当前不提供 API 辅助实现本机函数中的临时对象维护。
按 @5.7.6 ，本机实现可对表示临时对象的子项分别转移，但转移前不应有非内部对象(@4.2.4.1) 引用被转移的子项。

@7.9 TCO 支持：
因为要求对宿主语言中立(@5.2.6.4.1) ，基于 CPS 调用(@5.4.4) 的上下文 API 实现异步规约(@7.8) ，带有上下文状态的前置条件(@6.9.2) 。
这样的实现方式性能相对直接使用体系结构相关的方式较低，但仍可被接受。
这样实现的 TCO 同时允许可移植地在对象语言中实现某些引入控制作用(@4.1) 的一等实体(@4.1) （如续延(@4.5.2.1) ）。
当前未支持宿主栈展开(stack unwinding) 的互操作。
C++ 异常调用重写循环(@5.4.4) 内资源对象的析构函数顺序是未指定的。但是，对 C++ API 异常安全保证的要求(@7.3.1.4) 仍然不变。
在 NPLA1 API 中同时提供对应的异步规约但不使用 TCO 的实现，不满足本节要求，仅供参考。
以下指定当前对 TCO 的有限支持。没有明确指出的情形不保证支持 TCO 。

@7.9.1 TCO 支持实现 PTC(@5.2.6.2) ：
TCO 应支持实现 PTC 。
要支持 PTC ，需保证 O(1) 的空间复杂度（通常需要分配大于 O(1) 的活动记录帧(@4.5.3.4) 资源），此外需要确保宿主语言的活动记录不会在运行时耗尽。
后者通过经验方法验证确保，因此实现符合复杂度要求即可。
NPLA1 实现支持的 TCO 包括以下形式：
直接在实现中变换宿主语言的递归调用为循环可实现宿主 TCO(@5.2.6.4.2) ；
基于异步规约 API(@7.8.2) ，使用重写规则（直接通过现有 API 支持的即重规约(@7.3.4) ）代替直接使用宿主语言的递归形式可实现目标 TCO(@5.2.6.4.2) ；
动态 TCO(@5.2.6.4.2) ，具体机制详见 @7.9.3.2 。
NPLA 除个别例外(@6.1) 均支持宿主 TCO(@6) ，不需要其它形式的静态 TCO(@5.2.6.4.2) 。
在此基础上，NPLA1 通过允许和动态 TCO 互操作的异步重规约的方式支持目标 TCO ，详见 @7.9.6 ；但当前 NPLA1 部分 API 不保证支持宿主 TCO ，这可能在以后完善。
NPLA1 支持的动态 TCO 按实现策略即 TCM(@5.2.6.4.2) 。
综上，使用 NPLA1 的 PTC 有三类实现策略：
通过直接重写宿主语言的实现（使用循环代替部分递归）提供宿主 TCO ；
通过 TCO 动作(@7.9.3) 提供动态 TCO ；
基于异步重规约和 TCO 的互操作(@7.9.6) 提供目标 TCO 。

@7.9.2 整体设计约束：
TCO 要求尾上下文的续延(@4.5.2.1) 保持等效。考虑到计算资源的限制，排除构造相同的外部的求值环境(@4.6.1.1.2) 的实现方式，这蕴含同一性。
NPLA 的 TCO 基于异步规约(@7.8) ，基本方式是尾调用合并(@7.9) 。TCO 动作是支持了尾调用合并的动作。
考虑到当前动作预期直接构成当前续延(@6.9.2) ，对 NPLA1 ，这需要限制尾动作(@5.4.4) 的下一动作(@5.8.7.2) 不是 TCO 动作。

@7.9.3 TCO 动作设计：
TCO 动作支持动态 TCO (@7.9.1) 。
TCO 动作具有特定的非公开类型。为简化实现，减小判断开销，当前是单一的非公开的类型。

@7.9.3.1 TCO 操作序列：
TCO 动作可包含多项操作，典型地用于支持函数应用替换(@4.5.3) 或求值函数(@7.9.10) 的实现，包括如下序列：
保存当前的环境并更新环境(@7.9.3.3) ；
分配活动调用关联(@5.2.4.2) 的临时对象(@5.2.5) ；
可选地提升项（变换函数应用替换的结果为非引用；当前具体实现在 A1::RelayForEval 或 A1::RelayForCall(@7.6.1) 内部提供）；
可选地请求异步重规约(@7.9.6) ；
异步规约被替换或求值的项。
对应的不支持 TCO 的异步实现中，每个操作都可以是一个动作。
为减少判断 TCO 动作的复杂性，这些操作被合并到 TCO 动作内，TCO 动作的类型保持唯一。

@7.9.3.2 操作压缩：
上述操作中的一些是幂等的(@4.1) 。这些操作一一对应 TCO 动作内部的某个状态，表示是否存在此操作。
当检查到 TCO 动作而需要继续补充上述操作时，不创建新的动作或分配其它资源，而修改当前 TCO 动作的状态表示启用对应的操作，在规约调用动作时生效。
因为不同幂等的操作分配的资源不冲突，操作可以按类别归类，满足同类幂等操作的相对顺序不变即可。
连续出现的幂等操作不受递归嵌套深度的影响。若操作序列(@7.9.3.1) 最后一项以外的操作都是幂等的，则可支持不受限制递归尾调用，即实现了 PTC 。
由于语义规则限制，不在任意情形下避免非幂等的操作而保证 PTC （这些操作随着嵌套深度的增加随之需要分配存储）：
捕获动态环境（通过 vau 抽象(@4.5.2.3) 的创建(@7.11.5) ）时，所在的环境记录(@5.4.4) 作为帧(@4.5.3.4) 占据的存储不保证有上界；
包含非平凡析构(trivially destructible) 对象的帧的存储是否支持 PTC 未指定（另见 @7.13.2 中关于生存期的实现注记）。

@7.9.3.2.1 非幂等操作：
非幂等的操作和生存期相关，包括：
设置环境时，确保被设置环境的父环境(@5.4.3) 的生存期；
分配临时对象(@5.2.4.2) 时，确保临时对象最终能被及时释放。
这些操作可能有多个实例，因为以下几个原因而无法合并：
存储模型和对象模型(@5.2.4) 要求生存期开始和结束的顺序；
对象模型相关的语义规则没有允许合并不同的对象；
需提供宿主语言(@5.2) 互操作性支持，一般无法证明实现这些合并不影响可观察行为。
但注意调整语义规则或通过区分出非平凡析构等方式证明可观察行为不变后，减少父环境被隐藏的变量而完全实现 PTC 是可能的。
基于语义规则的许可，实现应支持部分非幂等操作的被合并，以支持 PTC ：
若设置前的环境是被设置的环境的直接或间接父环境，其中可能影响可观察行为的变量都被新的环境隐藏，可确定父环境不再使用且不影响可观察行为，则仍然合并操作，并释放该父环境的资源。
NPLA 规则 @5.2.6 允许可合并临时对象分配的非幂等操作实现 PTC ，即若存在已在 TCO 动作中分配的相等（以宿主环境(@2.7.1) 约定，参见 @7.13.2）的临时对象，则不再分配。

@7.9.3.2.2 非幂等操作合并约束：
同一个 TCO 动作内，以下尾调用合并的效果仍然有效：
相同类别的不同实例的操作仍然被尾调用合并集中；
非幂等操作和幂等操作之间的顺序被调整；
两类非幂等操作之间的顺序被调整，不再交错。
最后一项变换是被允许的，因为尾上下文内环境的生存期被子表达式内的调用（如 @7.11.5 的实现）约束；而临时对象生存期在尾上下文中可以延长到整个 TCO 操作结束(@5.2.6) 。

@7.9.3.3 状态维护：
和操作序列(@7.9.3.1) 对应，规约调用动作时影响状态。
在最后一项操作前，状态需要被维护，保证被语义和非 TCO 的实现语义的差异不违反语义规则。
求值退出尾上下文时，需恢复原始的求值环境（正常退出或异常退出），或显式设置被保存的环境（通过修改当前动作返回，可实现续延返回）。
退出尾上下文时恢复原始的环境由尾环境(tail environment) ，即在 TCO 操作前设置的环境即提供。
因需支持异常退出和显式设置当前动作，使用守卫(guard) 的形式实现。
若退出时尾环境不是保存的环境，表明并非尾上下文求值，则直接设置尾环境为空。
NPLA 的 TCO 实现较一般实现（直接设置及恢复下一环境）更复杂。原因除为支持有界续延公开当前动作为单一对象外，主要来自尾动作支持的操作需要适应 API 的设计和语言特性的要求：
不在规约函数中传递环境参数，避免在不切换环境的操作中频繁传递环境的开销，同时需维护作为一等对象的环境自身的生存期，因此需要在切换环境时进行附加的操作；
存储模型和对象模型支持临时对象(@5.2.4.2) ，需要非幂等的操作(@7.9.3.2) 维护临时对象的生存期；
不要求支持 GC(@5.2.4.4) ，而一等函数的结果默认需要维护内存安全(@5.2.4.3) ，因此需要提升项；
规约函数支持返回规约结果(@6.5.1) ，需要附加的操作进行维护（为减小开销仅表达式求值状态）。
注意其它一般实现若要保证内存安全，仍然可能需 GC 对环境的维护提供支持（如设置 GC 根对象，避免环境记录(@5.4.4) 被回收）。
当前 TCO 设计的资源管理机制参见 @7.9.4 。

@7.9.4 TCO 相关的资源管理：
TCO 动作持有尾上下文的活动记录帧(@4.5.3.4) ，包括环境和被规约表达式中的右值对应的临时对象。
操作压缩(@7.9.3.2) 和以下资源管理的操作在 A1::RelayForCall 和 A1::RelayForEval(@7.6.1) 的调用中实现。
关于临时对象，参见 @7.9.5 。

@7.9.4.1 帧记录(frame record) ：
帧记录是保存无法被操作压缩安全释放的活动记录保存的对象和中间状态。
操作压缩结束后的数据结构被保存在帧记录构成的列表中，称为帧记录列表(frame record list) 。
帧记录列表添加的操作在操作压缩以及资源回收后(@7.9.4.2) 进行。
因为互动记录帧的资源以环境引用(@5.4.3) 的形式管理，帧之间的引用影响引用计数。
帧记录中的环境总是具有环境强引用(@5.4.3) 以确保直接可用且避免资源回收(@7.9.4.2) 发生时机的非确定性。

@7.9.4.2 资源回收：
除非证明移除活动记录帧不影响对象语言的语义，活动记录帧不是操作压缩的可合并的目标。
因为帧记录具有环境强引用，不通过其它操作引起的引用计数改变而释放，回收帧记录引用的资源是显式的操作。这需要同时避免循环引用。
在切换环境的操作（如过程调用(@7.11.5.4) ）时，无法合并的帧在当前 TCO 动作中分配并储存。
紧接储存帧的操作之前，对现有的活动记录进行压缩，以确保新的帧后不再形成冗余。PTC 要求存储的帧不无限增长，依赖此处活动记录被成功压缩。
压缩活动记录会对现有储存的帧中的环境和父环境进行遍历，以环境为单位回收不再被引用的环境对象和对应帧中的其它资源。
环境对象及其关联的锚对象(@6.9.2) 的引用计数为是否引用提供依据：
环境自身以 shared_ptr 确定强引用计数；
锚对象确定其弱引用计数。
被从 TCO 对象中移除的环境对象是没有 NPL::TermReference 引用其锚对象的对象。当强引用计数为 1 时，压缩后最终会被清除而释放，持有的对应资源被回收。
这一过程在局部上类似基于引用计数的 GC(@5.2.4.4) 机制。

@7.9.5 临时对象管理：
关于临时对象和资源管理的一般机制，参见 @7.8.3 和 @7.9.4 。
TCO 异步规约对临时对象的管理基本策略同 @7.8.3 ，但因为操作压缩(@7.9.3.2) 具有更多的变化和限制，所以实现较复杂。
和非 TCO 异步规约的实现相比，临时对象不仅因为引用绑定子项需保证子项的生存期足够长(@7.6.1) 的原因，还可因为操作压缩的需要，而可被转移。后者的情形应符合 @5.7.6 中取得求值结果后不被引用的项修改限制条件。

@7.9.5.1 非本机函数临时对象：
在 @7.8.3 的基础上，操作压缩保存函数临时对象时，尝试进行去重(deduplication) ：比较函数是否相同，以在资源回收(@7.9.4.2) 前即尽可能接近 PTC 的要求。资源回收不处理函数临时对象。
未能被操作压缩去重的函数临时对象应被保存到帧记录列表(@7.9.4.1) 中，以确保满足和 @7.8.3 中相同的要求。

@7.9.5.2 非本机操作数临时对象：
资源回收支持处理操作数临时对象。资源回收以环境为单位，因此操作数临时对象应绑定到由 TCO 对象持有的临时环境对象上以便回收时引用。
由于操作数临时对象作为实际参数在环境中绑定后是固定(@5.2.4.1) 的，这要求保存操作数临时对象提前到 A1::RelayForCall(@7.6.1) 的调用之前。
这里的临时对象分配由过程抽象(@7.11.5) 引入的合并子的处理器在参数绑定(@7.11.5.3) 前进行。
对应地，合并子使用的 A1::BindParameter(@7.6.6) 的绑定实现会利用已经储存在 TCO 动作中的临时对象以确定绑定到引用时需要的锚对象(@6.9.2) 。
未能被资源回收释放的环境应被保存到帧记录列表(@7.9.4.1) 中，以确保保存操作数临时对象的环境不会过早地在过程抽象(@7.11.5) 恢复环境时被销毁。

@7.9.5.3 本机临时对象：
因为没有公开 API ，当前不支持外部的本机函数(@7.8.3) 实现访问 TCO 动作实现以上的类似操作。
不使用 A1::RelayForCall 和 A1::RelayForEval 调用的本机函数若需支持 TCO ，应使用 TCM(@5.2.6.4.2) 以外的替代 TCO 实现方式。
本机函数的实现和以上的普遍机制略有不同，和需要被保存的临时对象相关。
一般地，本机函数对应的合并子由宿主函数决定，并不保存状态。这使遍处理器的目标对象(@7.2.1.1) 不需要被本机函数调用时持续保留，即不需要保留对应本机函数临时对象。
以下本机临时对象仅讨论操作数临时对象。
若临时对象不需要保留被求值，则可在求值之后移除临时对象。否则，需保存临时对象。这在支持 TCO 本机函数的实现中可通过以下方式实现。
向 TCO 动作添加临时对象使之被 TCO 动作所有。此时，转移临时对象对应的子项(@7.8.3) 。
转移子项的操作在逻辑上 TCO 动作之前的动作中分别进行，每次处理至少一个临时对象对应的子项。
这种尾上下文中关于临时对象的 PTC 实现方式称为尾重写(tail rewriting) 。
尾重写可能保留第一个临时对象的生存期到最后，但之前的临时对象顺序或按不确定的顺序销毁。
因为当前操作的语义不要求这种顺序，当前不需要使用这种方式实现 TCO 本机函数。

@7.9.6 异步重规约(@7.8.2.1) 的 TCO 互操作：
主规约函数（通过调用跳板(@5.8.7.1) ）保证调用的异步的重规约可以支持 PTC(@5.2.6) 。
异步重规约不是 TCO ，实现直接操作上下文(@5.4.4) 中的状态，不需要依赖 TCO 动作(@7.9.3) 。
异步重规约和 TCO 不直接兼容。不维护 TCO 动作的异步重规约可导致之后紧随的 TCO 动作无法进行操作压缩(@7.9.3.2) 而无法支持 PTC 。
同时，当前一般异步重规约的设计不直接支持 PTC ，以避免上下文中的专用的异步规约状态过于复杂。
使特定异步重规约操作感知 TCO 动作，允许和 TCO 操作序列 @7.9.3.1 中的操作兼容且非决定性有序(@4.4.1) 地组合以支持 PTC 。
通过静态地决定使用异步重规约和 TCO 互操作，这种组合实现目标 TCO(@8.1) 。
当前异步重规约的 TCO 互操作由 A1::ReduceAgain(@7.3.6) 实现。另见 @7.9.7 。

@7.9.7 动作内联(inlining) ：
特定的异步规约实现可能要求引入的操作总是尾动作(@5.4.4)，否则行为未定义。
这允许直接使用同步动作代替异步动作调用，即动作内联。
动作内联可减少操作 ContextNode::Current(@6.9.2) 的开销。
注意这项要求具有传递性，即在宿主语言中直接或间接同步调用的操作也应满足要求的条件。
因此，除非能确保不限制接口语义，当前 NPLA1 不使用这样的实现方式。
派生实现应明确指定影响接口语义的动作内联的使用。

@7.10 语法形式支持：
模块 NPL::NPLA1Forms 提供的命名空间 A1::Forms 的 API 专用于实现语法形式对应的功能而不是 NPLA1 的一般机制。
一部分操作是基本的(primitive) 。其余操作是派生的(derived) ，可在通过组合这些操作实现。
派生操作的功能对 NPLA1 实现并非严格地必要，但适合使用宿主语言实现，被 NPLA1 代码间接地调用。
因性能等原因，一些基本派生操作在此直接提供 API 。
这些 API 可能使用重规约(@5.8.1) ，或假定使用默认解释(@7.7) 的合并遍(@7.3.1.2) 等价的实现。
推论：和默认解释不同的合并遍是否在这些 API 的实现中被调用是未指定的。
以上差异可能造成在修改合并遍（如 A1::SetupDefaultInterpretation(@7.7) 的遍参数）时，只使用对象语言的派生实现和使用这些 API 的本机实现(@5.2.1) 的行为可能不同。
作为典型例子，Forms::Apply(@7.11.9) 等操作在需调用上下文处理器(@7.5.1) 时不需要保证和 A1::ReduceCombined(@7.5.4.1) 无关的列表遍(@7.3.3) 的处理器的调用。
实现应保证以上差异不影响满足对象语言关于特定操作的语义要求。
以上下文处理器调用的操作应满足上下文需要的状态：
在进入调用前已使用 A1::ReduceCombined 确保存在 TCO 动作(@7.9.3) ，以允许尾上下文(@4.4.3) 求值。
基本派生操作包括 Forms::First(@7.11.3) 等针对特定类型的操作。关于不同类型的其它综合操作参见 @7.11.9 。
这些 API 不被 A1::Forms 以外的 API 及实现依赖，且符合本节的以下约定。
除非另行指定，这些形式不是特殊形式(@5.2) ，一般作为按值传递(@4.4.4.5) 的函数(@4.5.2) ；其中的值对象(@5.4.1) 表示引用时，传递引用(@4.4.4.5) ；表示访问的值不被修改时，是否传递引用未指定。
这些 API 接受的输入被视为正规表示(@5.8.5) ，但用于求值表达式时，依赖 NPLA1 的约定，输出不需要保证规约后的项是正规表示(@5.8.5) ，而通过这些 API 以外的正规化操作(@5.8.5.2) 保证（参见 @7.3.1.4 ）。
推论：正规表示以外的宿主值是否被保留以及保留的时机未指定。
从 @7.6.6 起本节余下的 API 中的规约函数(@6.5.3) 具有间接断言：第一参数指定的项是枝节点。

@7.10.1 间接值(@5.7.3) 访问：
除因 @7.1.3 保证内存安全(@5.2.4.3) 而消除引用值(@6.6) 的操作外，其它操作的求值结果(@5.8.1) 中的引用值被保留。
以间接值访问对象时，项的值类别(@5.5.1) 和根据其它语义规则（可能在以后添加，如是否可修改的限定符）确定是否可修改，可分别进行不同的操作。
直接区分参数的值类别分别进行处理的操作有：
绑定操作(@7.6.2) API ；
A1::ReduceCombined ；
A1::ReduceCombinedBranch ；
A1::ReduceCombinedReferent 。
部分 API 同时提供结果中消除引用值和保留引用值的版本，这些函数以 API 后缀名称区分：
以 At 和 Ref 的后缀表示保留未折叠和折叠(@5.6.3.2) 的引用值；
部分不带有特定后缀的函数为参数和返回值转发(@5.5.2.2) 操作（仅当参数指定引用值时保留参数值），同时以 Val 的后缀表示不保留引用值；
其它不带有特定后缀的函数不保留引用值。
保留的引用值若来自参数且被折叠，通常经过调用 NPL::Collapse(@6.4.4) 折叠。
此处保留引用值和对象语言中的定义(@8.6.1.5) 应保持一致。
显式涉及区分是否保留结果中的间接值的 API 包括：
求值规约操作(@7.6.1) API ；
元素和列表操作(@7.11.3) 。

@7.10.2 非上下文操作：
非上下文操作不依赖上下文，无 ContextNode(@6.9.2) 参数。

@7.10.2.1 记号操作：
Forms 提供以下和记号相关的函数，支持对象语言对符号的操作：
Forms::IsSymbol 判断字符串值是否可构成符号。
Forms::StringToSymbol 创建等于指定字符串值的记号值。不检查值是否符合符号要求。若能构成符号，则名称为指定字符串。
Forms::SymbolToString 取符号对应的名称字符串。

@7.10.2.2 保留(retain) 操作：
保留形式是特殊形式，对项进行空求值(@4.4.2) 。
Forms 提供以下函数实现对象语言中的保留形式或在其它本机实现(@5.2.1) 中进行子项数量的检查：
Forms::Retain 断言枝节点并返回 ReductionStatus::Retained(@6.5.1) 。
Forms::RetainN 断言枝节点并检查子项作为函数时的实际参数数(@7.5.3) 符合预期。
保留的项不一定被直接需要值的操作如 Forms::Lambda(@7.11.5) 支持，一般不在用户代码中直接使用。

@7.10.3 调用助手：
通过提供包装上下文处理器注册(@7.5.2) 的 API（以下都为函数模板），可简化需要的回调形式。
Forms 提供以下函数模板简化调用：
Forms::CallRawUnary
Forms::CallResolvedUnary 和 Forms::CallResolvedUnaryAs 调用 NPL::ResolveTerm(@6.4.5) 解析节点的子节点并调用一元函数。
Forms::CallRegularUnaryAs 访问节点的子节点，以正规值(@5.8.5) 调用一元函数。
使用 NPL::CheckRegular(@6.4.5) 访问正规值。
Forms::CallUnary 和 Forms::CallUnaryAs 访问节点并调用一元函数，支持设置对象语言返回值。
Forms::CallBinary 和 Forms::CallBinaryAs 访问节点并调用二元函数，支持设置对象语言返回值。
以 As 为后缀的版本使用模板参数指定节点转换的目标类型作为提供回调的参数类型；否则参数类型为 TermNode& 。
Forms::CallBinaryFold 访问节点并以指定的初始值为基础逐项调用二元函数。
Forms::UnaryExpansion 、Forms::UnaryAsExpansion 、Forms::BinaryExpansion 和 Forms::BinaryAsExpansion 提供对应的扩展调用，允许回调省略没有使用的 ContextNode& 类型的参数。
基于以上调用助手 API 和 A1::RegisterStrict(@7.5.2) 注册严格上下文处理器的 API 包括：
Forms::RegisterUnary
Forms::RegisterBinary

@7.11 语法形式对应功能的实现：
在 @7.10 的基础上，命名空间 A1::Forms 的 API 包含直接用于调用助手(@7.10.3) 注册的例程，可作为对应对象语言中的操作的本机实现(@5.2.1) 。
这些操作中的一部分可能通过不同的顺序和依赖关系在非本机实现中派生。

@7.11.1 内建谓词：
函数 Forms::EqualLeaf 比较项中的值数据成员(@5.4.2) 相等。
函数 Forms::EqualReference 和 Forms::EqualValue 分别支持通过引用和值分别比较。前者对引用值的判断满足 @4.2.3 的相等关系，其结果是准确的。除此之外，两者的语义接近 [RnRS] 的 eq? 和 eqv? 。
基于 YSLib::GHEvent ，上下文处理器(@7.5.1) 对未支持 == 比较的函数对象提供默认的相等实现，相同类型的函数对象的值视为恒等。
若需改变行为，需补充 operator== 。

@7.11.2 分支和逻辑操作：
Forms 提供以下函数实现对象语言中的控制和逻辑操作：
Forms::If 和 Forms::Cond 提供分支判断和条件选择的非严格求值形式。
Forms::And 和 Forms::Or 提供对子项非严格求值的逻辑与和逻辑或操作。
Fomrs::When 和 Fomrs::Unless 提供检查分支判断的顺序求值。

@7.11.3 列表操作：
Forms 提供以下函数实现对象语言中的列表操作：
Forms::Cons
Forms::ConsRef
Forms::ForwardListFirst
Forms::First
Forms::FirstAt
Forms::FirstRef
Forms::FirstVal
Forms::SetFirst
Forms::SetFirstAt
Forms::SetFirstRef
Forms::SetRest
Forms::SetRestRef

@7.11.4 环境和求值操作：
Forms 提供环境相关的操作，以支持对象语言中的环境（参见 @8.6.2 ）。

@7.11.4.1 求值操作：
Forms 提供以下函数实现对象语言中的求值：
Forms::Eval
Forms::EvalRef
Forms::EvalString
Forms::EvalStringRef
Forms::EvalUnit

@7.11.4.2 环境创建和访问操作：
Forms 提供以下函数实现对象语言中的环境创建和访问：
Forms::MakeEnvironment 创建以参数指定的环境列表(@5.4.3) 作为父环境的新环境。
Forms::GetCurrentEnvironment 取当前环境(@5.4.4) 的引用。取得的宿主值类型为 NPL::EnvironmentReference 。
Forms::LockCurrentEnvironment 锁定当前环境的引用。取得的宿主值类型为 shared_ptr<Environment> 。
Forms::ValueOf

@7.11.4.3 环境修改操作：
Forms 提供以下函数实现对象语言中的环境修改，包括定义和修改变量绑定：
Forms::DefineLazy
Forms::DefineWithNoRecursion
Forms::DefineWithRecursion
Forms::SetWithNoRecursion
Forms::SetWithRecursion
Forms::Undefine

@7.11.5 过程抽象：
过程使用 A1::FormContextHandler(@7.5) 实现。
后者包含的实际求值使用使用 A1::ReduceArguments(@7.3.6) 实现。当前实现中使用从左到右的子项规约，和 [Shu10] 实际使用的不同。
Forms 提供函数 Forms::Lambda 和 Forms::LambdaRef 支持 lambda 特殊形式创建以过程为基础的 λ 抽象(@4.5.2.2) 。
Forms 提供函数 Forms::Vau 、Forms::VarRef 、Forms::VauWithEnvironment 和 Forms::VauWithEnvironmentRef 支持更一般的 vau 抽象(@4.5.2.3) 。前者和 Kernel 的 $vau 操作合并子类似，而后者进一步支持指定静态环境。
Vau 抽象可包含的捕获(@7.11.5.1) 静态环境的数据结构，以非公开类型的对象存储，进一步初始化处理器类型 A1::ContextHandler(@6.2) 的值，被待规约的项或环境所有(@5.2.4) 。
Vau 抽象的应用在的新创建的空的但以上述静态环境为父环境(@5.4.3) 的局部环境(local environment) 中对抽象中指定的表达式（函数体）的副本求值，以包含局部环境(@4.6.1.1.2) 的数据结构作为活动记录帧(@5.2.4) 。
记号值(@5.6.1) 可表示待替换的符号(@5.6.1) ，用于实现形式参数(@7.11.5) 。
λ 抽象可通过 vau 抽象实现，但由于简单和性能原因，直接提供 API 支持。

@7.11.5.1 捕获：
环境中的变量被隐含地捕获。
捕获通过调用时设置在初始化保存的父环境(@5.4.3) 指针实现。
因为实际指称的确定发生应用中对表达式副本的求值时的名称查找(@4.3.3) ，所以这是延迟到应用的按名称捕获(capture by name) 。这也在引入抽象时实现递归指称。
由于使用 NPL::EnvironmentReference 值保证有效性 ，无效的父环境访问会出错，但行为仍可预测；详见 @7.11.5.2 。
被 A1::EvaluateIdentifier(@7.5.4) 求值的变量按引用捕获。
若修改被捕获的变量对应的对象，可引起调用过程的可观察行为的改变。

@7.11.5.2 内部数据所有权：
存储在 vau 抽象对象内的数据包括：
形式参数对象；
上下文原型；
捕获的静态环境；
作为过程实现的求值结构(evaluation structure) （对应表达式中可能被求值的函数体(@4.5.2) ）；
决定是否在调用后提升返回结果(@7.11.5.4) 的标记。
这些数据都是可被共享的。复制 vau 抽象的处理器对象共享这些数据。
其中，作为父环境(@5.4.3) 的静态环境以 NPL::EnvironmentReference 弱引用值保存，并附加 shared_ptr 实例以可选被 vau 抽象所有；其它数据都以 shared_ptr 的值保存，被 vau 抽象所有。
这允许调用(@7.11.5.4) 引用父环境时对之前确定的绑定（如捕获(@7.11.5.1) 时) 进行生存期检查，发现循环引用(@5.2) 等引起未定义行为的错误(@7.5.5) 。注意在对象语言中出错时未定义行为，不应依赖此行为。
除可选的静态环境 shared_ptr 实例，所有指针数据在 vau 抽象对象的生存期内都保持非空。
形式参数树(@7.6.2) 作为数据成员同 vau 抽象对象被项或环境所有，可能被不同值类别的表达式标识，但它作为表达式和子表达式时不被直接求值，且子表达式中的符号被复制而不是以间接值引用(@5.7.4.2) ，因此是纯右值(@5.7.3) 。

@7.11.5.3 参数绑定：
通过 vau 抽象引入的函数调用(@4.5.3.1) 在求值时，以 TermNode 的项而不是 ValueObject 的值对象替换上下文中的形式参数(@4.5.2) 树，用于在调用时被操作数树(@7.6.6) 作为实际参数替换。
绑定参数通过调用 A1::BindParameter(@7.6.6) 实现，其中对参数和操作数进行匹配。
按值传递时需使用效果等价返回值转换(@5.7.4.4) 的方式确保在被保存(@7.11.5.2) 前不再引用其它项对象而维护内存安全。
注意提升项不是递归的，按值传递的项的只提升直接子项。

@7.11.5.4 过程调用：
在调用过程时，求值结构(@7.11.5.2) 可能被其它的调用转移，因此先检查以确保存在。若不存在，则抛出 NPL::NPLException(@6.3) 异常。
调用创建局部环境，持有此调用的活动记录帧(@4.5.3.4) 。
若求值结构未被共享且被规约项(@5.4.2) 具有调用时设置的 TermTags::Temporary 标签(@7.5.4.1) ，则指定之后函数不会被再次调用，求值结构可转移。
求值结构的共享判断允许本机实现(@5.2.1) 直接复制 vau 抽象的处理器(@7.11.5.2) 。
在判断可转移后，第一个子项被移除。余下的子项即为参数绑定(@7.11.5.3) 使用的操作数。
被绑定的参数被添加到局部环境。
参数绑定后对求值结构的项或其副本进行规约，使函数体(@4.5.2) 被求值。这通过 A1::RelayForCall(@7.6.1) 实现。
之前判断可转移时，直接使用求值结构的项，否则使用副本。
规约在局部环境进行名称解析(@5.4.3) ，通过保存的 NPL::EnvironmentReference 值对静态环境的所有权进行检查，若失败则抛出异常。
保存在静态环境以外的对象的引用不受到以上机制保护，需要对形式参数对象可包含的对象进行限制以保证被规约项的所有权要求(@5.7.3) 。
因此，vau 抽象初始化时对形式参数对象检查，确保其中的非列表项中只存在调用 NPL::LiftTermRef 后也不引入间接值的对象的值，即记号值(@5.6.1) 。
恢复被切换的环境(@6.9.3) 时，环境内的对象被释放。
若需保证内存安全(@5.2.4.3)，返回值(@4.5.3.1) 不能是在调用后生存期结束的对象的引用值(@5.6.3) ，以避免引用被释放或之后被清理(@5.8.5.2) 的值引入未定义行为。
避免返回(@4.5.3.1) 引用值(@5.6.3) 的通用机制为提升返回结果，即求值后的求值结果(@5.8.1) 进行进行返回值转换(@5.7.4.4) ，同时消除引用值(@7.1.4) ，使返回值总是按值传递。

@7.11.5.5 相等性：
相等性作为弱函数应用规约等价谓词(@4.5.3.2) 提供，操作为对所有成员进行相等比较，当且仅当都相当时，结果为真。
其中，上下文相等由同一性决定；其它成员的比较由宿主环境(@2.7.1) 的相等操作决定。

@7.11.6 合并子类型转换操作：
Forms 提供以下在对象语言中实现合并子(@4.5.3.2) 之间的非规约函数(@6.5.3) 转换函数：
Forms::Wrap 包装(@4.5.3.2) 合并子为应用子(@4.5.3.2) 。
Forms::WrapOnce 包装操作子为应用子。
Forms::Unwrap 解包装(@4.5.3.2) 应用子为合并子。
其中后两者会对合并子按 @7.5.1 的约定进行类型检查(@4.6.2.3) ，若不满足条件则抛出异常。
当被解包装的应用子参数是引用时，构造具有非平凡非正规表示(@5.8.5.4) 的子对象引用(@5.6.3.5) 。

@7.11.7 错误检查：
Forms 提供以下可能抛出异常的错误检查函数：
Forms::ThrowInsufficientTermsError
Forms::ThrowInvalidSyntaxError
Forms::ThrowNonmodifiableErrorForAssignee
Forms::ThrowValueCategoryErrorForFirstArgument
Forms::CheckEnvironment 
Forms::CheckListReference

@7.11.8 封装类型操作：
Forms 提供以下实现封装类型操作的函数：
Forms::MakeEncapsulationType 创建封装类型操作的应用子(@4.5.3.2) 。
其中，结果第二项的应用子用于取被封装类型的值。
作用于右值时，使用引入不安全引用值(@5.6.3.1) 的项引用操作(@6.4.4) 而不提供检查(@5.2) 。
因为访问的是右值，不影响内存安全(@5.2.4.3) 。

@7.11.9 通用基本派生操作：
Forms 提供以下可通过对象语言派生的操作的对应本机实现的函数：
Forms::Sequence 序列有序参数规约：移除第一项后顺序规约子项，结果为最后一个子项的规约结果。
此操作对列表形式的操作数的子项有序求值，其顺序约定同 A1::ReduceOrdered 。
当操作数非空时，保证最后一项的规约是尾上下文(@4.4.7) ，允许 PTC(@5.2.6) 。
Forms::Apply 函数应用：应用参数指定的函数和作为函数参数的列表。
操作的语义同 [RnRK] ，但在可选参数多余 1 个时的错误情形抛出 NPL::ArityMismatch(@6.3) 异常。
保证最后一项的规约是尾上下文，允许 PTC 。
Forms::ListAsterisk 使用可选的参数指定的不定数量的元素和结尾列表构造新列表，不保留结果中的引用值。
Forms::ListAsteriskRef 使用可选的参数指定的不定数量的元素和结尾列表构造新列表，保留结果中的引用值。

@7.11.10 外部调用：
Forms 提供以下在对象语言中调用实现环境外部功能的函数：
Forms::CallSystem 实现到 YFramework 提供的 usystem 函数的调用转发，用于调用外部命令。

@7.12 依赖管理模块：
模块 NPL::Dependency 基于 NPLA1 提供 SHBuild 使用的一些 API 。
函数 Forms::LoadGroundContext 提供 SHBuild 初始 REPL 环境（包含的上下文称为基础上下文(ground context) ），其中支持：
字面量初始化，支持 #t 、#f 和整数等字面量；
使用 A1::SeparatorTransformer(@7.4.2) 启用预处理的分号和逗号转换，分别为有序和无序列表求值的语法糖。
上述语法糖实现为 REPL 对象内部的无状态的预处理器求值遍，仅包含中缀变换(@7.4.2) ，不需要向环境中添加名称。
变换后仍然具有 WHNF(@4.4.3.1) 形式，其中第一个子项是一个合并子右值，具有以下性质：
对之后的子项构成的序列有序或无序列表求值；
若存在操作数，有序求值保证最后一项是尾上下文（实现同 @7.11.9 ）；
不保证是真合并子(@4.5.3.2) 。
因为不直接公开合并子的实现（如 @7.10 ），其中不需要有项检查（如 @7.10.2.2）；但可能仍有遍处理器的检查(@7.5.1.3) 。
相关对象语言的相关接口参见 @9 。
NPL::Dependency 还提供其它一些接口，调用函数 Forms::LoadGroundContext 初始化上下文后继续调用，初始化特定操作的环境：
函数模板 Forms::GetModuleFor 加载代码作为模块(@1.4.6.4) 以提供特定集合的对象语言实体的定义。
函数模板 Forms::LoadModule 和 Forms::LoadModuleChecked 加载模块为变量。后者在指定名称的绑定已存在时抛出异常。
函数 Forms::LoadModule_std_environments 提供环境操作(@10.1) ；
函数 Forms::LoadModule_std_promises 提供延迟求值等操作(@10.2) ；
函数 Forms::LoadModule_std_strings 提供字符串操作(@10.3) ；
函数 Forms::LoadModule_std_io 提供输入/输出操作(@10.4) ；
函数 Forms::LoadModule_std_system 提供系统操作(@10.5) ；
函数 Forms::LoadModule_SHBuild 提供其它一些供 SHBuild 间接调用的操作(@11.1.1) 。

@7.13 实现注记：
本节指定当前不作为公开接口的一些实现具有的性质和修改实现的导引。

@7.13.1 性能优化：
NPLA1 预留分配器支持(@5.7.1) ，但未直接指定使用分配器。派生实现可使用分配器并预期提升整体性能，但并非使用分配器总是在任意情形的局部提升性能。
作为原型实现(@5.1) ，相较性能，NPLA1 在语言设计和实现上都强调扩展性。即使替换扩展实现实现对象语言语义等价但削弱 NPLA 和 NPLA1 API 的 变体(@5.1.2) ，一般也不能预期能和常见其它典型动态语言的解释器实现。这主要是由于：
使用了解释开销较大的 AST 解释器(@5.1.2) ；
缺乏清单类型(@4.6.2.2) 等提供支持更明确执行路径的元数据；
使用异步规约(@5.8.7) 保证嵌套调用安全(@5.2.7) ；
为支持合并子可能具有的动态环境，规约合并时(@7.5.4.1) 没有优化，可能有不必要的重复开销。
进一步优化的一般目标是寻找更多可消除的解释开销，这一般可通过以下方法（可能不再使用 NPLA ）：
派生实现提供契约(contract) 和类型标注(type annotation) 等附加元数据，使对象语言程序可利用这些设施提供更利于优化执行的实现；
在特定的函数构造器（如通过 @7.11.5 实现的对象语言操作符(@4.4.3.1) ）支持缓存等调用优化；
实现直接接近机器表示的翻译，通常为 JIT(just-in-time) 编译；
使用和 NPLA 不同的表示以支持特定体系结构相关优化。

@7.13.2 TCO 动作实现和限制：
当前在 TCO 动作中被分配的临时对象(@5.2.4.2) 的操作都针对作为 WHNF 的第一项的合并子，其中合并子相等性由 @7.11.5.5 或其它宿主实现提供的 == 操作确定。
由 @7.11.5.5 ，捕获不同环境的 vau 合并子不相等；不论是否具有相等的外部表示和来源，其右值不会被直接操作压缩(@7.9.3.2) 避免多次添加而被 TCO ；若其嵌套调用因为捕获不同的存在引用关系的环境，不支持其它形式的 TCO ；因此，不支持 PTC 。
注意上述情形在其它语言中因为可达性分析等可能具有实现缺陷也不会释放存储，如 Kernel 程序 ($sequence ($define! f ($lambda (n) ((($vau (x y) e (eval ($sequence x y) e)) n (f n))))) (f 1)) 在 klisp 中实测不支持 PTC 。
当前 TCO 操作压缩不支持回收非 #ignore 的动态环境。这实际上较 [RnRK] 的保证弱。但 klisp 同样没有很好地支持此特性，如 Kernel 程序 ($sequence ($define! $f ($vau () #ignore (($f)))) ($f)) 在 klisp 中实测不支持 PTC 。
（关于以上 klisp 的问题，参见 https://bitbucket.org/AndresNavarro/klisp/issues/12/a-problem-of-proper-tail-call 。）
但是当前实现中，对应的 NPLA1 程序支持 PTC ：
$sequence ($def! f ($lambda (n) ((($vau (x y) e (eval ($sequence x y) e)) n (f n))))) (f 1)
实现依赖 Environment::IsOrphan(@6.9.1) 等判断确保内存安全(@5.2.4.3) 。
忽略非平凡析构判断（假定所有对象都可平凡析构），允许移除可证明不被继续引用(@5.2.6) （如被总是新的环境隐藏）的变量。
被移除的对象生存期提前结束(@5.2.6) 。
除被隐藏的变量被单独移除外，若一个活动记录帧（环境）内存在任意不满足可证明幂等的操作的情形，整个帧的剩余部分都被保持存储（因为不支持对 NPL::TermReference(@5.6.3) 分别保存引用计数）。
当前实现并没有显式支持 evlis tail recursion(@5.2.6.3) ，但因为调用前切换环境时已提前进行了收集，所以以 TCO 动作为边界，保存的帧应与之等效。
尽管可能有更优的渐进复杂度，所需空间的大小仍取决 TCO 活动记录最终保留帧前分配对象和碎片所占空间大小之和的最大值；实现应该不依赖这项特性。
回收使函数对象在表达式求值外完毕之前结束，这仍然符合 @5.2.6 的要求。
当前 NPL::LiftToReturn(@6.6.3) 的调用非嵌套调用安全（参见 @6.1 ）。在项的嵌套深度依赖调用深度时，不满足 PTC 。

@7.13.3 元数据：
模块 NPL::NPLA1 提供特定可由函数 A1::QueryContinuationName 查询得到。
其中查询结果的名称和 A1::Continuation::Handler 的特定目标类型关联，包括：
eval-argument-list 关联非公开的内部类型；
eval-combine-operands 关联 ContextHandler ；
eval-combine-operator 关联非公开的内部类型。
上述名称和 klisp 0.3 中的部分续延名称一致。

@8 NPLA1 对象语言规则和一般实现导引：
以下实现中的 C++ 名称和项目模块命名空间的使用同 @7 。

@8.1 程序实现：
程序是语言的派生。实现程序即在语言的基础上指定派生规则。
使用 REPL API(@7.7) 创建 REPL 实例用于实现解释器。
使用 A1::Forms 的成员(@7.10) 指定需要内建支持的语法形式。
一般在初始化时自行绑定初始环境的名称。当前提供的实现参见 @9 。
NPL 是独立设计的，但其派生语言和其它一些语言有类似之处；这些语言和 NPL 方言之间并不具有派生关系。但为简化描述，部分地引用这些现有语言规格(@2.3.1.2) 中的描述，仅强调其中的不同。
NPLA1 和 Kernel （参见 Revised Report on the Kernel Programming Language ）的特性设计（如 vau(@4.5.2.3) 和作为一等对象的环境表达过程抽象(@7.11.5) ）有很多类似之处，因此许多概念是通用的；但从设计哲学(@1.4) 到本章介绍的各个细节（如默认求值规则(@8.4) ）都存在深刻的差异。
部分名称指定的操作和 [RnRS] 或 klisp (http://klisp.org/docs/index.html) 指定的类似。
以下接口主要介绍和 Kernel 约定不同的设计。各节的通用约定不再在之后的各个接口单独说明。

@8.1.1 外部环境(@2.3.2) ：
基于 @5.2 约定，由 @2.7.1 ，NPLA 的实现不假定存在多线程执行环境。
但是，宿主语言可支持多线程环境执行，在没有适当同步下可引起宿主语言的未定义行为(@5.2.2) 。
作为 NPLA 的派生，NPLA1 对象语言程序也具有相同的性质，除非另行指定需要和外部环境交互的特定操作，不需要假定 NPLA1 引入存在多线程执行环境。

@8.1.2 附加元数据(extra metadata) ：
NPLA1 实现可提供和实现环境(@2.3.2) 或具体 NPLA 对象关联的附加的资源，用于提供程序运行时可得到的附加信息，如源代码位置。
是否存在附加元数据和附加元数据的具体内容可影响特定的行为，如符合 @8.4.3 中要求的实现的具体行为。
这些影响是未指定的，但除 NPLA1 程序直接依赖具体数据而进行的操作外，不应影响程序的其它语义（例如，引起程序终止）。

@8.2 规约文法约定：
为描述语言规则，约定适用 @8 的文法(@2.3.2) 形式。注意这不需依赖 NPL 语言的基本文法(@3) 。
规约操作中项的约束通过以 <> 中的同类名称表示。

@8.2.1 元文法基本约定如下：
... ： Kleene 星号，重复之前修饰的项 0 次或多次。
+ ： 重复之前修饰的项 1 次或多次。

@8.2.2 实体元素文法约定：
指定函数的文法中，第一项以符号(@5.6.1) 的形式在所在的环境中提供，指定求值结果指称为合并子(@4.5.3.2) 的函数名称（）；
其后指定的文法中不同的元素对应合并子的操作数。
名义不同相同的约束可能仅要求相同的检查，可用于区分特定的含义，便于被实现优化。
表达式形式的结果指表达式的求值结果(@4.1) 。
文法形式上，使用本节约定指定应用子的操作数(@8.2.2.2) 时，指定表达式形式求值的结果。
这和 [RnRK] 和 [Shu10] 中的斜体标识符的标记不同，但含义（表示语义变量(semantic variable) ）和效果实质相同。
操作数可能是左值或右值，参见 @8.7 、@9.4 和具体操作的约定。
本节约定的不同类型的操作数构成的集合之间不相交。一般规则参见 @8.4.7 。
根据是否可作为操作子中不要求被求值的操作数，本节的操作数分为未求值的操作数(@8.2.2.1) 和求值得到的操作数(@8.2.2.2) 。

@8.2.2.1 未求值的操作数：
未求值的操作数作为数据结构和 AST(@5.3.2) 同构，是符号(@5.6.1) 或未求值操作数构成的真列表(@8.6.3) 。
未求值的操作数的文法约定如下：
<symbol> ：符号。基于 @5.6.1 ，内部使用和 <string>(@8.2.3) 一一对应的表示，不提供符号和外部表示的其它映射关系。
<symbols> ：元素为 <binding> 的列表，形式为 (<symbol>...) 。
<eformal> ：表示可选提供的环境名称或 #ignore 的符号。使用和 <symbol> 相同的表示。通常为动态环境。
<expression> ：待求值的表达式。
<expressions> ：形式为 <expression>... 的待求值形式。求值时被作为单一表达式（即视为 (<expression>...） ），代替 <expression> 可避免语法中要求谁过多的括号及 eval(@9.5.5) 等求值形式中显式构造列表的需要。
<binding> ：绑定列表，形式为 <symbol> <expressions> ，用于指定被求值的表达式和绑定参数的符号。和 Kernel 不同，<symbol> 后不要求是整个 <expression> 。
<bindings> ：元素为 <binding> 的列表，形式为 (<binding>...) 。
<body> ：出现在元素的末尾 <expressions>? 形式，用于函数体(@7.11.5) 等替换求值的目标。
<expression-sequence> ：同 <body> 但蕴含顺序求值。
<consequent> ：同 <expression> ，仅用于 <test> 求值为 #t 时。
<alternate> ：同 <expression> ，仅用于 <test> 求值不为 #t 时。
<definiend> ：被绑定项的目标，是包含符号的 DAG(@4.2.4) 表达式。详见 @8.6.3.1 。
<formals> ：形式参数形式。同 <definiend> 但允许派生实现定义更多检查。
<clauses> ：元素为条件分支的列表，形式为 (<test> <body>)... 。
<variable> ：变量。用于表示被定义的名称。同 <symbol> ，其中的处理与作为叶节点时的 <formals> 相同。

@8.2.2.2 求值得到的操作数：
求值得到的操作数的文法约定如下：
<object> ：一般对象，包括引用对象的引用值(@8.6.1) 。
<reference> ：对象引用值。
<list> ：列表。参见 @8.6.3 。
<bool> ：布尔值，值为 #t 或 #f 的集合。
<test> ：类似 <object> ，通常预期为 <bool> ，作为条件。和 Scheme 类似但和 Kenerl 不同，非 #t 的值在决定分支时视同 #f 。
<combiner> ：合并子。
<applicative> ：应用子(@4.5.3.2) 。
<predicate> ：谓词，用于计算二元判断，是应用操作数的求值结果的值为 <bool> 的 <applicative> 。通常实现为纯求值(@4.4.2) 。
<environment> ：表示环境的宿主值(@6.9.1) 。

@8.2.2.4 文法形式补充约定：
和 [RnRK] 不同，<definiend> 和 <formals> 不要求重复符号检查。另见 @8.6.3.1 。
[RnRK] 和 [Shu10] 都没有显式区分 <definiend> 和 <formals> ，两者在上下文中实质可互换，差别仅在 [RnRS] 中的 define 形式中定义的位置可具有和 <formals> 不兼容的扩展形式。
本文档补充约定，使用 <formals> 的情形包括合并子基本操作(@9.5.6) 和可通过这些操作派生的操作在对应位置的操作数。
针对这个假设，派生实现可进行附加的语义检查。在 NPLA1 的当前实现（特别地，使用 @7.6.6 的 API ）中，没有这样的检查。
这实质等价使用 [Shu09] 中的记法，即 <formals> 用于除和 [Shu09] 的 $define! 类似外的所有操作（包括 $set! 和 $let 等，而不论是否对应 <body> ）。这些上下文中总是隐含了上述的可派生实现的要求。

@8.2.3 派生实现类型：
部分库中使用的特定类型的项如下：
<box> ：箱(@4.2.3.5.3) 。
<promise> ：求值代理：表示可被求值的封装结果。
<string> ：字符串，宿主值类型为 string(@5.6.1) 。
<regex> ：正则表达式。
字符串以 string 类型表示，编码和表示要求同 YFramework 默认约定([Documentation::YFramework @@3.3.1]) 。
正则表达式以 std::regex 类型表示，实现保证可通过 string 初始化。

@8.3 对象语言语法：
基于 NPLA 基本语法约定参见 @5.2 。
表达式的语法符合 @3.4.2 。

@8.3.1 字面量(@3.3.3) ：
由 @5.2 、@5.6.1 和 @8.2.3 ，字符串字面量的类型为 <string> 。
NPLA1 支持以下扩展字面量(@3.3.3) ：
#t ：类似 Kernel 的 #t 字面量，类型为 <bool> 。
#f ：类似 Kernel 的 #f 字面量，类型为 <bool> 。
#true ：同 #t 。
#false ：同 #f 。
#inert ：类似 Kernel 的 #inert 字面量，宿主值为 ValueToken::Unspecified(@7.2.2) 而不具有单独的类型（因此也不需要定义 inert? 谓词）。
另见 @9.3 。
NPLA1 字面量都是纯右值(@5.5.1) ，但总是允许实质化转换(@5.5.4) 为消亡值并引入可互操作的临时对象(@5.5.5.3) 。
这和宿主语言的字符串字面量是左值不同。当前 NPLA1 对象语言不提供能引起互操作差异的接口（字符串字面量不被修改），以后可能改变。

@8.3.2 函数合并(@4.5.3) ：
和 Scheme 及 Kernel 不同，求值算法决定求值为函数合并表达式的语法表达不需要括号，且具有不同的函数合并形式(@7.7.1) 。
以下使用 ...(@8.1) 作为函数的操作数时，可支持没有操作数的函数合并。此情形下应用表达式仍需要前缀 () ，但不在以下规约文法中显式地表示。

@8.4 基本语义规则和约定：
除非另行指定，约束(@8.2) 名称后的整数序数仅用于区分允许的同类约束项不同，无其它附加含义。
本节中除循环引用(@8.6.1.1) 的限制外，不支持的特性可能会在之后的实现中扩展并支持。
NPLA1 对象语言程序中的未定义行为(@2.3.2) 包括 NPLA 未定义行为(@5.2.2) 和以下扩展 NPLA 未定义行为：
特定情形下访问被修改的环境中绑定的对象(@8.6.2) 。

@8.4.1 求值算法：
除非另行指定，NPLA1 对象语言的求值总是使用规范求值算法(@7.7.1) 。
在 REPL(@7.7) 中输入求值算法接受的语法形式之前，求值可使用基于中缀变换(@7.4.2) 识别的 ; 和 , 分隔符，分别表示对被分隔的序列参数进行有序和无序列表求值（替换后合并子功能对应参考实现环境中函数 $sequence(@9.6.1) 和 list%(@9.5.4) 求值后的合并子）。
其中，分隔符 , 优先组合。
对分隔符的处理使用和组合顺序相反的两遍分别对 ; 和 , 遍历替换，实现参见 @7.12 。
由此引起的其它语法差异参见 @8.5.2 。
为避免可能引入非真合并子(@8.6.4)，参考实现对分隔符的使用附加限制，参见 @9 。
和 Scheme 不同而和 Kernel 类似，求值显式的风格（详见 Fexprs as the basis of Lisp function application or $vau : the ultimate abstraction by John N. Shutt ），这和不需要括号的语法特性无关。
NPL 仍提供 $quote(@9.6.1) 以避免用户可能的不必要的冗余代码；参考实现的限制参见 @9 。

@8.4.2 对象语言内存安全保证：
对象语言的内存安全保证及违反内存安全的（不完全）检查的基本机制基于 NPLA1 关于被规约项的约定(@7.1) 。
引用持有者及其访问操作仅在有限的不保证内存安全的上下文中引入，其它限制同 @7.1.4.3 。被引入的引用持有者仅用于互操作，在对象语言中不可见。
不进行引起内存安全以外的未定义行为的操作（包括 @8.6.1.1 等）且不存在通过无效引用值(@8.6) 的访问（如 @8.4.8.3 中的情形）时，对象语言保证内存安全。
不保证内存安全的引用值的访问即访问超出生存期的被引用对象，可由以下情形引入：
和实现进行（通常无法保证内存安全的）互操作；
绑定列表(@8.2.2.1) 传递引用(@8.6.3.1) 且传递的引用值被求值(@5.7.4.1) 使用时，被引用的对象不在生存期内；
调用可能返回引用值的合并子（通常通过 @7.11.5.4 实现），且返回值(@4.5.3.1) 对应的对象不在生存期内（另见 @9.4.1 ）；
使用其它不保证内存安全的操作（可由 NPLA1 参考环境提供，参见 @9.1.2 ）引入的不具有内存安全保证的间接值访问实体。
绑定到形式参数的右值(@5.5.1) 保存在过程调用的局部环境(@7.11.5) 中，因此退出函数体(@7.11.5) 求值（局部环境被释放后）返回其引用总是无法满足安全保证；
绑定到列表形式参数上的实际参数列表总是右值；
对返回值中涉及到的安全保证机制，参见 @8.6.1.4 。

@8.4.3 诊断(diagnostics) ：
NPLA1 的特定求值(@8.4.1) 步骤可引起诊断(@2.3.2) ，包括：
抽象求值(@4.1) （如 REPL 中进行的翻译）的失败；
在环境(@8.4.2) 中访问指定名称的对象失败时；
特定的函数应用。
引起诊断时，求值被终止，或在失败可被恢复时，以其它派生实现定义的方式继续求值。
其它求值条件详见具体操作的规定。
其它引起诊断的条件可被派生实现补充指定。
注意未定义行为(@2.3.2) 取消对诊断的要求。
本节以外的诊断消息(@2.3.2) 的其它形式未指定。

@8.4.3.1 错误(@2.5.2) ：
NPLA1 中的错误是按接口的约定不符合预期的正常条件（如不被正常处理的操作数类型(@8.4.3.4) ）引起的诊断。
求值特定的表达式可引起错误，包括语法错误(@7.7.1) 和其它的语义错误。
其它错误包括求值特定的函数应用(@8.4.3) ，由具体操作指定（参见 @9.4.1 ）。
程序可通过引发(raise) 错误对象(error object) 指定引起诊断。
除非另行指定，NPLA1 的错误对象不需要是 NPLA1 支持的对象，而可以仅在宿主实现中可见。
因果性引起的错误可构成错误的依赖。
错误对象的其它具体形式由派生实现指定。

@8.4.3.2 异常(@4.7.1) ：
NPLA1 的当前诊断使用的异常执行机制由宿主语言支持，通过宿主语言中的异常类型区分不同的异常条件。其异常类型由 NPLA 提供，参见 @6.3 。
NPLA1 约定的所有要求引起异常的诊断情形都是错误（但用户操作引起异常不一定是错误）。
不引起未定义行为的翻译失败应抛出异常。
引发错误对象(@8.4.3.1) 可能通过抛出异常实现。被抛出的宿主语言异常对象是错误对象。被抛出的异常类型可具有被显式指定的 public 基类，这些基类应无歧义以允许宿主语言捕获。
若存在依赖错误(@8.4.3.1) 且引发被依赖的错误对象使用抛出异常实现，使用宿主语言标准库的嵌套异常(nested error) 机制实现依赖错误。
除非由宿主环境(@2.7.1) （包括 @8.4.3.3 中指定的情形）、对 TermNode(@5.4.2) 的操作内部实现或另行指定的来源，被抛出的异常对象的类型总是 NPL::NPLException(@6.3) 或其 public 派生类。
若语法错误(@7.7.1) 使用抛出异常实现，则异常对象的类型是 NPL::InvalidSyntax(@6.3) 或其 public 派生类。
除显式指定的情形，抛出的具体异常类型未指定。通常实现可根据接口的含义使用 @6.3 中最合适的异常。

@8.4.3.3 运行时(@2.4.1) 错误条件(@2.5.2) ：
除非另行指定，实现应对以下全局的错误条件按要求引起诊断。
资源耗尽(resource exhastion) 时，引发特定于资源耗尽的错误对象。
除非另行指定，上述表示资源耗尽的错误对象满足宿主语言的以下类型的异常对象：
宿主资源耗尽时，异常类型满足常规宿主资源分配要求(@5.2.2.1) 的类型；
否则，同 @8.4.3.2 。
若规约不符合资源耗尽条件，则在满足 @8.4.8 时继续规约可能符合的资源耗尽条件应保证与继续规约的次数无关。

@8.4.3.4 检查(check) ：
检查是限定成功的操作应满足的（必要非充分）条件引起诊断的操作。检查失败时要求引起诊断。
良定义的(well-formed) 检查应具有强规范化性质(@4.4.3) ，以保证有限数量的检查总在有限的计算步骤内终止。在进行检查的上下文，实现不需在此之前对检查的这个性质附加检查。
检查条件限定检查的通过或失败。除非另行指定，通过的检查没有作用，失败时总是具有作用（通常可引起副作用）。
NPLA1 要求在特定上下文进行要求的类型检查(@8.4.3.4.1) 。派生实现可定义其它检查。
函数操作的语义可单独指定检查，具体形式由具体操作指定。

@8.4.3.4.1 类型检查：
基于 @5.5.6 ，对应对象语言表达式的表示实体的元素可用于表示操作中的名义(nominal) 类型检查。
对求值得到的操作数(@8.2.2.2) ，若操作的语义需要，则总是进行类型检查；其它检查在不违反语义要求时可选添加。
部分实体从属于其它实体类型而构成子类型(subtyping) 关系；部分的规约操作取得求值结果保证结果中的值可能具有的特定类型集合，这些类型也一并在以下描述中给出；其它情形不指定类型。
规约预期符合约束。若违反由项的值对应的动态类型(@5.5) 不匹配导致，则求值失败；否则，行为未指定。
除非另行指定，不同类型检查的作用的顺序未指定。
类型检查失败引发错误(@8.4.3.1) ，称为类型错误(type error) 。

@8.4.4 外部表示：
同 @4.1.1 ，外部表示由派生实现约定。
和 Kernel 不同，NPLA1 不要求对象和其它实体存在外部表示，也不要求外部表示唯一。
NPLA1 当前不提供可移植的互操作接口（包括 I/O 操作），也不约定其涉及的外部表示形式。用户可自行通过调用 NPLA1 宿主语言中的实现的 API(@7) 扩展。

@8.4.5 对象同一性(@4.1) ：
NPLA1 的对象是一等对象(@4.1) 。由定义，NPLA1 的对象默认确保同一性。

@8.4.5.1 对象的修改和变化 ：
对象作为实体，其修改和变化的基本概念参见 @4.1.4.2 。
NPLA 约定(@5.2) 对象的表示同宿主实现的对象，其修改也同宿主对象的修改。
类似 Kernel ，对明确不可变的对象进行变化的操作引起错误(@8.4.3.1) 。
类似 Kernel ，对象可能隐藏作为非一等状态(@4.2.2.1) 的管理状态(administrative state) 。引起对象内的管理状态的改变的操作不一定是改变对象的操作。
管理操作在宿主语言可以类的 mutable 数据成员实现，但 NPLA1 不提供特性使子对象的可修改性的限制会如宿主语言的 const 限定符自动传播(propagate) ，因此也不需要提供对应的类型检查修改机制。
类似地，对象还可能具有对外部不引起可观察行为(@4.1.3) 差异的隐藏的可变状态。引起这些对象内的可变状态的改变的操作不一定是修改操作。
管理状态和不引起可观察行为的隐藏状态在针对对象语言的的讨论中被排除；除非另行指定（由具体操作的语义蕴含），所有可变状态都不属于这些被排除的状态。
类似宿主语言（如关于 const 限定符的语义），生存期开始前或结束后的（可能并未完成构造的）对象中的子对象的修改不是对象的修改；对应地，此处的子对象的变化也不是对象的变化操作。
改变上述被排除的状态的修改操作不被视为对象语言中的对象的变化操作(@4.1.4.2) 。
和 Kernel 不同，NPLA1 允许直接修改对象而非通过指定子对象引用(@5.6.3.5) 的对象的变化操作。
对包含所有权的子对象(@8.6) 的修改是对所在对象的修改。
除非另行指定，NPLA1 不限制任意对象不可修改。
等价关系和限制不可修改性的方法的方式不唯一，因此不可修改性也不唯一。
因为外部表示不唯一(@8.4.4) ，不需要基于此定义一种正规的关于外部表示的等价判断形式。
开放类型映射(@5.2.3) 不保证非特定对象之间的不可修改性具有唯一的定义。

@8.4.5.1.1 赋值(assignment) ：
NPLA1 的赋值操作专指以引用值操作数指定对象且不引起同一性改变的对象修改(@8.4.5.1) 。
注意这和 Kernel 的赋值操作包含以特定对象进行替换（可使用项的转移(@5.5.3) 实现）而使对象被修改的情形不同。
注意避免使用引用值作为操作数的自赋值(self assignment) 引起循环引用(@8.6.1.1) 。
类似宿主语言，除非另行指定，赋值操作不保留源操作数的值类别(@8.5.1) 和可修改性。

@8.4.5.1.2 转移：
转移可导致被转移对象的外部可见的修改。
转移不需要是直接显式求值特定的函数调用的副作用。
例如，使用唯一引用(@5.4.2.2) 初始化对象，可转移被引用对象对应的项(@5.5.3) 。
和宿主实现不同，当前实现不直接通过初始化转移宿主对象(@5.5.2.3) 。

@8.4.5.2 驻留(interning) ：
出现在表达式中多个位置的值在实现中可共享一个对象作为内部表示。这个对象被驻留(interned) 。
因为子对象允许通过引用值被直接修改(@8.4.5.1) ，驻留对象创建的共享可能影响可观察行为。
因此兼容 NPLA1 语义的驻留要求排除可修改的操作(@8.4.5.1) ，且被驻留的值对应的对象的同一性不被外部依赖。
当前实现不使用对象驻留，以简化存储对象的互操作(@5.2.4) 。

@8.4.5.3 等价比较：
和 Kernel 不同，一些类型的对象若可修改(@8.4.5.1)（如环境(@8.4.2) ），不保证 eq? 和其它等价谓词(@9.5.1) 的比较结果等价。
但是，基于 @6.9.1 已约定宿主值的类型，在对象语言中传递环境引用(@5.4.3) 不改变环境的这些等价性。
为了满足不依赖引用的一等对象，区分引用和被引用的对象都作为一等实体，这是必要的。
一般地，谓词 eq? 用于判断两个参数对象的同一性。

@8.4.5.4 无效化(invalidation) ：
若对象的引用值保持有效(@8.6.1) ，则指称的左值的对象同一性不变。
类似实现中项的无效化(@5.4.2) ，引用值可能被指定无效化(invalidate) ，不再保证有效，为无效(invalid) 的值，包括以下情形：
被引用的对象生存期已结束（此时引用值是悬空引用(@5.6.3) ）；
对象被除通过重绑定(@8.6.2.1) 、赋值(@8.4.5.1.1) 和另行指定的情形以外的方式修改(@8.4.5.1) ，而引起对象同一性的改变。
使用被无效引用值访问对象的行为未定义。
对项的赋值(@8.4.5.1.1) 仍可能因为对子项的修改而使其表示的对象的引用无效化。

@8.4.7 类型分类：
和 Kernel 不同，NPLA1 不要求支持任意类型的不相交集合即分区(partition) 。
和 Kernel 不同，NPLA1 的类型判断谓词是一元谓词，接受一个参数。这也避免对 map(@9.6.2) 等库函数的依赖。
和 Kernel 不同，列表类型只包括真列表(@8.6.3) 。列表节点的实现的表示详见 @5.4.2.1 。

@8.4.8 一般 TCO/PTC(@7.9) 保证和限制：
一般实现策略参见 @7.9.1 。部分实现限制参见 @7.13.2 。
当前实现的规约（如 A1::Reduce(@7.3.4) ）直接递归规约子表达式支持的尾上下文(@4.4.7) 较少（详见 @8.4.8.1) ，和 Scheme 对大量特定的形式提供明确的尾上下文上的 PTC 保证不同。
和 Kernel 类似，这是由于缺少针对特定的特殊形式(@5.2) 的特设规则。但因为程序实现(@8.1) 等限制，当前设计和实现支持的非调用的上下文(@8.4.8.3) 较 Kernel 少。
虽然不保证在所有情形下支持 PTC ，当前的实现一般支持使用自由存储分配，以尽可能地避免宿主语言的未定义行为(@5.2.2) ：
其中，异步规约(@7.8) 实现使分配以环境（@5.4.3）表示的活动记录失败时满足常规宿主资源分配要求(@5.2.2.1) 。
类似地，另见 @5.3.2 和 @7.6.6 关于的资源分配失败时的约定。
满足 @4.1.3 的前提下，实现可能实际支持更多的 TCO 和 PTC 尾上下文。

@8.4.8.1 支持 PTC 的尾调用尾上下文：
当允许忽略非平凡析构(@7.9.3.2) 时，可以在尾上下文求值中进行 TCO 并支持 PTC 。
注意尾上下文中被求值的子表达式中的对象生存期可被调整(@5.2.6) ，是否调整和具体调整的方式未指定，不同的实现可能不同。
提供 PTC 保证的尾上下文和 Kernel 类似，当前仅包括 PTC 不改变可观察行为时的：
函数调用(@4.5.3.1) 中，（使用 $vau 和 $lambda 等合并子抽象引入的）合并子(@8.6.4) 的调用（注意不包括其它途径引入的外部函数的调用）；
对 <body>(@8.2.2.1) 的求值；
函数 eval(@9.5.5) 、eval%(@9.5.5) 、$quote(@9.6.1) 、id(@9.6.1) 、idv(@9.6.1) 、eval-string(@10.1) 和 eval-string%(@10.1) 对 <expression> 的求值或替换；
函数 apply(@9.6.1) 对 <applicative> 和 <object> 在 <environment> 或默认的动态环境中的应用；
由 <test>(@8.2.2.1) 控制或连续求值多个表达式中最后被求值的子表达式求值，包括 $if(@9.5.2) 、$sequence(@9.6.1) 、$and?(@9.6.1) 和 $or?(@9.6.1) 。

@8.4.8.2 支持 PTC 的非调用尾上下文：
通过环境(@8.6.2) 支持的名称解析(@5.4.3) 的实现在符合嵌套调用安全的约定(@6) 。
名称解析可能是尾上下文。

@8.4.8.3 未绑定对象：
按 @5.2.6 的约定，项上未被绑定到活动记录上的项中的对象生存期可提前结束。
实现 PTC 时被规约时替换结果的清理(@5.7.4) 若实现支持 TCO(@7.3) 且没有实现保存未绑定操作数引起这种情形。
当前通过参考实现环境(@9) 引入的合并子已经支持了保存操作数，但若互操作没有保存操作数，则可能产生问题。
应注意合并子的参数绑定引用值(@8.6.3.1) 在同一个尾上下文求值引起清理导致悬空引用(@5.6.3) 破坏内存安全(@5.2.4.3) 。
这里的求值典型地可通过显式求值引入。具体地，这主要包含使用引用值作为函数 eval 或 eval%(@9.5.5) 的参数的进行函数应用表达式求值的方式。
对合并子的直接的函数调用求值较不容易引起这种情形，因为 <body> 内使用的参数是被绑定的，其中临时对象即便传递引用也会被转移值(@8.6.3.1) 。悬空引用通过其它方式（如在合并子的动态环境内显式求值）才被直接引入。
考虑在调用前使用总是不保留引用值(@8.6.1.5) 的 list 和 list* 而不是保留引用值(@8.6.1.5) 的 list% 和 list*%(@9.6.1) ，或单独调用 idv(@9.6.1) 提升被传递项中的值避免此类问题。

@8.4.8.4 限制影响：
在不保证支持 PTC 时，实现循环可控制结构的程序应注意避免无限递归。如以下 Kernel 程序：
($define! (f g) (list ($lambda (x) (g (- x 1))) ($lambda (x) (f (- x 1)))))
对应 NPLA1 程序（设 - 是保证能终止计算的减法）：
$def! (f g) (list ($lambda (x) (g (- x 1))) ($lambda (x) (f (- x 1))))
使用任意数值作为参数调用 f 时，若实现不支持 TCO ，以数值调用函数 f 或 g 可引起宿主语言的未定义行为（非异步规约(@7.8) ）或最终无法分配存储（异步规约）而不是保持不终止求值。
实际实现当前支持这个例子的 TCO 。

@8.5 表达式(@4.1) 语义：
表达式具有和语法(@3.4.2) 构造不直接相关的且可能上下文相关的语义。
部分语义不需要通过求值(@4.1) 体现。

@8.5.1 值类别和类型：
基本内容参见 @5.5.1 和 @5.5.6 。
特定的表达式维护可修改性(@8.4.5.1) 。这类似宿主语言的 const 类型限定，但只适合左值(@5.5.1) 且仅使用隐式类型。

@8.5.2 绑定构造(binding construct) ：
部分函数合并的求值用于表示在环境(@8.6.2) 中引入绑定，其调用指定绑定操作(@7.6.2) 。这样的表达式是绑定构造。
绑定构造包含形式参数树(@7.6.2) ，通过绑定规则(@7.6.2) 引入绑定。绑定在符号上的值引入变量(@4.1) 。另见 @5.5.2 。
对绑定项的处理和 [RnRK] 的不同参见 @8.2.2.4 。
按 @5.2 的要求以及 @7.6.2.1 的约定，操作数树(@7.6.2) 的子节点初始化被绑定的形式参数树的对应子节点。
另见 @7.6.6 的 API 。

@8.5.2.1 强递归绑定：
除类似 Kernel 的常规绑定外，NPLA1 的部分绑定构造支持延迟附加的绑定的形式。
强递归绑定支持若同时绑定的递归符号构成循环引用(@8.6.1.1) ，则递归绑定的值都是中间值(@5.3.1.1) 而不引起错误(@8.4.3.1) 。

@8.5.2.2 参数转发：
绑定构造可支持参数转发，类似宿主语言中的转发引用(forwarding reference) 参数，保留值类别和可修改性(@8.5.1) 。

@8.5.2.3 作用顺序(@4.4.1) ：
绑定构造引起的绑定初始化的作用顺序满足 @5.5.2 的约定。
若其中存在的副作用，其顺序还满足：
若存在同一形式参数树子节点的不同绑定的操作，则这些操作的副作用之间非决定性有序(@4.4.1) ；
不同符号的形式参数树子节点的绑定操作的副作用之间无序(@4.4.1) ；
形式参数树的子节点绑定的副作用先序(@4.4.1) 枝节点的副作用。

@8.6 对象语言数据结构：
本节指定在 NPLA1 允许以一等实体(@4.2) 被使用的基本元素。
部分设计原则和规则和 Kernel 不同。
关于存储和对象模型，基本内容参见 @5.2.4 。另见 @8.4.2 。
子对象(subobject) 同宿主语言的约定；在宿主语言的表示中表现为子对象的对象语言中的对象，也是对象语言的子对象。

@8.6.1 引用：
NPLA1 基于 NPLA 项的引用(@5.6.3) 支持实体的左值引用(@5.7.4.1) ，和 Kernel 等的引用概念类似。
NPLA1 语义中对广义实体(@2.3.2) 的构成依赖的使用也被称为引用，这不限被对象语言中的引用值表达。
和 Kernel 不同，NPLA1 明确允许不通过对象的引用保存对象，但是也允许使用对象引用；即对象和对象的引用都是一等对象(@4.1) 。详见 @4.2 。这也允许子对象直接被所在的对象蕴含。
使用项引用（宿主类型为 NPL::TermReference ）表示（使用 TermNode 表示的）其它对象的引用，即引用值(@5.6.3) 。
按 NPL::TermReference 初始化时保存的引用来源可区分被引用的对象是否是左值。
左值(@5.5.1) 都通过引用值（参见 @5.7.4.1 ；另见 @4.1 和 @5.2.4 ）表示。
引用值在创建时即引用在生存期内的对象。
有效的(valid) 引用值能安全地访问对象而不引起未定义行为。其它引用值是无效的(invalid) 。
不安全引用值(@5.6.3.1) 可以是有效的引用值，但运行时无法通过元数据验证其有效性。

@8.6.1.1 循环引用：
除非另行指定，对象中的循环引用引起 NPLA 未定义行为(@5.2.2) 。
典型实现中，循环引用可引起资源泄漏如内存泄漏(@5.2.4.4) 。
例如 NPLA1 参考实现环境(@9) 下求值以下表达式：
$let ((nenv () make-environment)) $set! nenv self nenv
可引起被捕获的环境中存储的对象无法释放。
能同时保证避免资源泄漏的实现引起一般意义上更根本的设计限制，因此不被使用。详见 @4.2.4 。
此外，为了避免 $lambda 等引起不经意的循环引用误用，根据易预测性原则(@1.4.5.2) ，这些组合子的构造器默认不使用强引用作为静态环境。若需保持静态环境的所有权，使用显式指定静态环境的构造器（如 $lambda/e ） 和 lock-current-environment 等。
否则，容易引起循环引用，如以下表达式：
$def! f $lambda ()
会相当于当前设计的：
$def! f $lambda/e (() lock-current-environment)
此处锁定的当前环境(@5.4.4) 的强引用被作为闭包的一部分绑定到当前环境中，引起循环引用。
而求值当前设计中等价的：
$def! f $lambda/e (() get-current-environment)
不引起未定义行为。
同时，若访问悬空引用(@5.6.3) ，实现可利用 NPL::EnvironmentReference(@6.9.1) 在闭包中对引用进行检查，使用户无需像 lock-current-environment 一样特别关照 get-current-environment 引起的风险。

@8.6.1.2 自引用(self-referencing) 数据结构：
因为不支持循环引用(@8.6.1.1) ，不支持引用自身的自引用数据结构。
详见 @4.2.4 。

@8.6.1.3 引用值作为实际参数：
除非另行指定（如 @8.8.2 和 @9.4.2 ），一般地，函数接受左值引用操作数，使用引用的对象的值和直接使用右值作用相同，但不会修改被左值引用的对象。
这等价隐含无副作用的左值到右值转换(@5.5.4) 。此处的左值引用和宿主语言中的（非 volatile ）左值作用类似。
另见 @8.8.4 。

@8.6.1.4 返回非引用值：
为提供内存安全保证(@8.4.2) ，部分操作总是返回非引用值。
返回非引用值的行为应等价返回值转换(@5.7.4.4) ，其实现未指定（可使用消除引用值的本机实现(@7.10.1) ）。
其它操作可返回引用值。

@8.6.1.5 保留引用值：
返回引用值的操作保留返回值的引用值。
返回包含引用值的对象（如列表(@8.6.3) ）由参数决定时，保留参数的引用值。
保留返回值的引用值或保留参数的引用值的函数保留引用值。
保留的引用值可能被引用折叠(@5.6.3.2) 。
函数是否保留引用值以及保留引用值是否被折叠的要求，参见常规函数约定(@8.7) 、函数名称约定(@8.9) 和 NPLA1 参考实现环境(@9) 中的函数名称的约定(@9.4.2) 。
保留引用值的过程返回值可能引入非内存安全操作(@7.1.4.2) 。

@8.6.2 环境：
和 Kernel 类似，NPLA1 支持一等环境(first-class environment) 。
和 Kernel 不同，环境绑定(@4.1) 的抽象不依赖对象语言中表达的引用的概念，允许直接关联一个没有引用的值。另见 @4.2.3 和 @5.4.3 。
和 Kernel 不同，环境对象符合默认的等价比较规则(@8.4.5.3) ，不提供不同等价谓词的结果一致性。
和 Kernel 不同，环境不明确具有封装性。环境中的绑定的对象可以在引入后通过对象的引用(@8.6.1) 被修改(@8.4.5.1) 。
但环境仍保证稳定性(stability) ，即总是可假定绑定维持一定意义的等价性：
绑定保持有效（不被移除或重绑定(@8.6.2.1) ），否则访问修改后的绑定的对象违反内存安全而引起 NPLA 未定义行为(@8.6.2.1) ；
被绑定的同一(@8.4.5) 对象若被修改，修改后的值应满足可保证不论通过可访问的对象引用还是环境进行名称查找对值进行访问，可观察行为都保持等价（例如修改后的值和修改前的值等价或修改操作后只可能通过引用访问对象），否则访问修改后的绑定的对象引起扩展 NPLA 未定义行为(@8.4) 。
和 Kernel 不同，环境(@9.5.5) 和合并子操作(@9.5.6) 及基于这些操作的一些派生操作(@9.6) 的操作数树(@7.6.2) 构造不检查其中的非列表项是否都为符号或 #ignore ；匹配时不检查符号重复；若形式参数中的符号重复，则绑定的目标未指定。
此外，NPLA1 提供单独的递归绑定符号的机制，且明确支持在操作数中同时递归绑定之前未被绑定的多个符号(@8.5.2.1) 。
环境可能具有多个宿主值类型。
关于环境的比较，另见 @8.4.5.3 。
环境绑定中的对象是环境对象的子对象。
关于引入绑定的表达式，参见 @8.5.2 。

@8.6.2.1 重绑定(rebinding) ：
和 Scheme 类似，环境中允许变量被重新绑定，但被重新绑定的变量替换的对象会直接失效，但对象的引用(@8.6.1) 不因此被无效化(@8.4.5.4) 。
若继续访问已被求值（经过名称解析）指称的失效对象，则超出生存期访问而引起 NPLA 未定义行为(@5.2.2) 。
因为设计原则禁止无法避免的实现开销，这里没有检查而直接指定为无法满足保证所有权条件的未定义行为(@5.7.4.2) 。

@8.6.2.2 环境生存期：
引用环境中的名称时，应确保环境在生存期内。
特别地，应注意使用函数时引入父环境的生存期。
当前实现对环境引用是 NPL::EnvironmentReference(@6.9.1) 的情形提供一定程度的检查，这通过引用环境时锁定 NPL::EnvironmentReference 的弱引用实现。
特别地，这可针对在 vau 抽象(@7.11.5) 中捕获的静态环境。
如以下程序（假设 + 是可接受 2 个整数值的应用子）引起无效引用错误（抛出 NPL::InvalidReference 异常(@6.3) ）：
$def! addn ($lambda (a) ($lambda (n) + a n)); (addn 1) 2;
正确的参考实现为：
$def! addn ($lambda (a) ($lambda/e (() lock-current-environment) (n) + a n)); (addn 1) 2;
其它情形不受检查。
注意正常的操作不应有生存期错误。
引起这些错误时应已导致未定义行为如循环引用(@8.6.1.1) ，因此程序行为不应依赖检查(@7.11.5.2) 。
另见 @8.4.2 。

@8.6.3 列表：
和 Scheme 及 Kernel 不同，基于 @4.2.4 ，NPLA 支持的列表都是真列表(@5.4.2.1) ，元素有限且不存在环。
作为真列表，列表直接被表示为子项元素的列表节点的序列，其宿主类型为 TermNode(@5.4.2) 。
利用 TermNode 中可选的值数据成员(@5.4.2) ，列表节点可以退化为非列表的值的表示；列表自身也可作为其它列表的节点。列表节点的实现的表示详见 @5.4.2.1 。
由 TermNode 的性质，列表的元素是列表的子对象，列表对作为元素的节点具有所有权。同一个列表的元素节点之间没有所有权关系。
这些特性确保基于列表的数据结构在对象语言逻辑上的简单性。也因此 NPLA1 对应的操作中，没有对环存在性的检查。
没有环的结构能保证所有权语义能按需嵌入(embed) 到列表中，即列表可保证表示为同构的具有对节点所有权的嵌套 cons 对，即便当前实现不使用(@7.6.6) 。
但是，这些特性也带来对元素引用的一些限制：列表的引用(@8.6.1) 只限引用完整的列表对象，而不引用部分列表（如 cons 的组成部分）。
绑定构造(@8.5.2) 的形式参数树(@7.6.2) 是可能是符号或真列表。

@8.6.4 合并子：
Kernel 的合并子对应 NPL 的真合并子(@4.5.3.2) 。
为维护语言规则的简单性(@1.4.3) ，除非另行指定，对象语言中的所有合并子都是真合并子。
尽管没有要求(@4.2.6) ，这种规约也更符合 [RnRK] 原则 G1b ；同时，这易于移植 Kernel 代码。
NPLA1 对象语言不提供其它合并子的普遍操作（不满足类似 G1b 的原则(@1.4.5.1) ），但 NPLA1 API 可支持其它合并子。
可能直接引入非真合并子的 API 包括项变换 API (@7.5.3) 。
NPLA1 的合并子使用包装数(@7.5.1.1) 存储可能需要求值操作数的次数。
因为包装操作(@4.5.3.2) 不符合 TCO/PTC 的条件(@8.4.8) ，包装操作允许具有附加的开销。包装数使用的宿主类型的上限(@7.5.1.1) 足以保证修改包装数的开销严格不大于直接实现。
在不出错时行为，这和直接实现的行为完全一致，但在到达包装数时继续包装即包装数溢出(wrapping count overflow) ，行为可能不相同：
若某个操作使合并子超出上限，则符合非宿主资源耗尽的错误条件(@8.4.3.3) 。

@8.6.5 数值类型：
NPLA1 不要求支持数值计算。数值类型和操作由派生类型提供。
和 Kernel 不同，NPL 不提供依赖数值的接口（用于描述列表长度等）；核心库函数(@9.6.2) 的实现也不需要依赖数值。

@8.7 常规函数约定：
本节适用参考实现环境(@9) 、NPLA1 参考实现扩展环境(@10) 和 SHBuild 实现环境(@11) 以函数(@4.5.2) 形式提供的操作。
这些环境以指定名称的变量的形式提供若干操作，求值为可参与函数合并(@4.5.3) 的一等实体（但函数合并不一定保证是合式的(@2.5.1) 可求值的表达式）。
一般实现建议参照本节约定。
引用值的基本使用规则参见 @8.6.1 。
引入函数时需避免 @8.4.8.3 的问题以维护内存安全；另见 @8.6.3.1 。
除非另行指定，函数作为表达式，求值为合并子(@4.5.3) ，其函数合并的求值蕴含函数调用(@4.5.3.1) 。

@8.7.1 函数值(@4.5.2) 约定：
除非另行指定，函数值不是引用值(@5.6.3) ，以便通过保证满足间接值生存期规则(@5.7.4) 维护内存安全(@5.2.4.3) 。
除非另行指定，函数值是经过返回值转换(@5.7.4.4) 的值，不保留引用值(@8.6.1.5) 。注意保留引用值时，函数值仍可能是非引用值。
除非另行指定，若函数值保留引用值，引用值被折叠。关于引用值是否被折叠的操作分类，详见 @8.9.1 。

@8.7.2 实际参数约定：
除非另行指定，函数的实际参数的传递(@4.4.4.5) 不具有影响可观察行为(@4.1.3) 的作用。（这一般要求避免复制宿主语言中的对象。）
除非另行指定，函数的实际参数若被求值，则隐含左值到右值转换(@8.6.1.3) 。

@8.7.3 错误处理：
除非另行指定，若函数合并(@4.5.3) 指定的操作的约束(@8.2) 或要求检查(@8.4.3.4) 的条件不被满足，引起错误(@8.4.3.1) 。
除非另行指定，引起错误抛出异常(@8.4.3.2) 。
求值时引起的错误使求值中断可产生副作用，这样的副作用总是后序(@4.4.1) 于已被求值的表达式中产生的副作用。

@8.7.4 非常规函数：
不符合常规函数约定的例外的一个例子是续延(@4.5.2.1) 。
类似 [RnRK] ，作为一等对象的续延和控制参数是否求值无关，因此不是合并子，且默认求值算法不支持续延作为函数合并被求值；但续延可通过特定的操作转换为应用子。
（当前未提供作为一等续延的正式支持；续延仅在非一等对象的情形(@4.5.3.3) 调用。）

@8.8 函数参数和函数值传递(@4.4.4.5) 约定：
函数可能接受引用值参数和返回引用值，是对函数的形式参数或函数值的初始化(@5.5.2) 。
在复制初始化形式参数和函数值时，部分函数保证被初始化的值和初值符(@5.5.2) 的值类别(@5.5.1) 和可修改性一致。这些初始化是转发(@5.5.2.2) 操作。

@8.8.1 传递非引用值参数：
一些函数的参数进行左值到右值转换(@5.5.4) ，实现参数的按值传递(@4.4.4.5) 。
这类似宿主语言中直接使用对象类型的形式参数。

@8.8.2 函数参数转发：
一些函数的部分参数也可不进行左值到右值转换(@5.5.4) 。
这些参数的转发类似绑定构造支持的参数转发(@8.5.2.2) 。
参数转发的实现可判断值类别(@8.5.2) 后分别对传递非引用值(@8.8.1) 或直接传递引用值提供实现，或直接使用绑定构造。前者支持本机实现。

@8.8.3 返回非引用值：
返回非引用值和参数的按值传递(@4.4.4.5) 类似，若初值符是引用，复制或转移被引用的对象的值而不是引用值。
这类似宿主语言中返回 auto 类型。
假定参数进过至多一次折叠(@8.9.1) ，其它操作保证总是返回非引用值。

@8.8.4 函数值转发：
一些其它保留引用值的操作中的引用值来自参数，且难以通过操作自身的逻辑决定可否安全地直接返回引用值，因此在返回之前根据决定返回值的参数是否为引用值，可选地转换结果以确定是否保留引用值，即进行转发。
显式转发临时对象的引用值使临时对象被转移，以转发的值作为返回值，可不同于使用返回值转换(@5.7.4.4) ：
同返回值转换，转发转移右值，复制左值；但当转发临时对象可确定唯一使用时，也转移临时对象（实现参见 @5.6.3.4 ）。
确定是否保留引用值的机制类似 ISO C++14 中从没有括号的 id-expression 上推断返回 decltype(auto) 类型是否为引用类型。
函数值转发使某些操作在默认情况下满足间接值生存期规则而保持内存安全，符合易用性原则(@1.4.5.2) 。
函数值转发的实现可通过判断是否需要转发引用而按需决定返回引用值(@8.6.1.4) 或返回非引用值(@8.8.3) ，或使用 @9.4.2.4 的方式。前者支持本机实现。

@8.8.5 创建和访问对象的函数：
构造器(constructor) 是用于创建对象的函数，返回非引用值(@8.8.3) 。
部分操作涉及对其它对象具有所有权的对象。
一部分对象的构造器(@8.8.3) 创建的对象完全通过其它对象的引用或对象的值作为构造器的参数而决定，且创建的对象对这些参数具有所有权，这样的对象称为容器(container) 。
容器构造器的参数作为容器的子对象(@8.6) ，是容器的元素(element) 。
一些不是容器的对象（如真合并子(@8.6.4) ）可通过非容器形式的构造器创建。
以容器对象或其引用作为参数，取得容器元素对象或其引用的函数是容器元素访问器(accessor) 。

@8.9 函数名称约定：
除非另行指定，以指定名称的函数表示的操作时，其命名由本节的规则约定。
修改(@8.4.5.1) 一个对象而不要求第一参数是引用值且不改变被赋值对象类型的赋值操作(@8.4.5.1.1) 以 <- 结尾。这通常和宿主语言的赋值操作对应，可能有附加的副作用而不是简单地替换值。
类似 Kernel ，谓词的名称使用 ? 结尾，除 <- 结尾外的用于（不直接通过求值操作数或其子表达式产生的副作用的）修改(@8.4.5.1) 的函数的名称使用 ! 结尾。
和 Kernel 类似，管理状态(@8.4.5.1) 的变化不需要指示可修改；此外，类似地，可观察行为的隐藏状态的修改不属于上述可修改。
和 Kernel 不同，不使用以上可修改的操作仍可引起对象修改，如隐式的转移操作(@8.4.5.1.2) 。
和谓词使用未指定值惰性(inert) 值的 Kernel 不同，后者的结果的类型未指定，因此用于修改的函数可能返回 A1::ValueToken::Unspecified(@7.2.2) 外的其它值；但应满足 @9.2 。
除去以上后缀，以引用标记字符(@7.6.2.4) 结尾的表示涉及引用的操作。
一些操作以结尾引用标记字符和不以引用标记字符结尾的名称提供多个版本。其中不含结尾的引用标记字符的表示操作的结果不是引用值，要求按值传递(@7.11.5.4) 。
其它一些操作可能只提供以 % 结尾的版本。
不使用引用标记字符的函数及其函数值时，不因引入引用值违反内存安全。这允许通过避免公开带有引用标记字符后缀的操作提供一个内存安全的子集，以在派生实现对语言进行裁剪。
具体规则详见以下描述。

@8.9.1 可提供以引用标记字符结尾版本的操作：
为满足易用性(@1.4.5.2) ，同时考虑维护内存安全、避免误用和允许使用引用避免复制，这些操作需显式使用以 % 或 & 结尾的函数名称以得到特别关注。
对以求值 <body> 作为尾上下文的操作(@8.4.8.1)，以 % 结尾表示 <body> 所在的函数返回时不要求返回非引用值(@8.6.1.4) ，尽管这些操作不返回引用值。
对其它提供不同引用标记字符的多个版本的操作：
以 % 结尾表示函数可使用不进行左值到右值转换(@5.5.4) 的折叠(@5.6.3.2) 的引用值参数，或可返回折叠的引用值；
以 & 结尾表示函数使用不进行左值到右值转换的折叠的引用值参数，或返回折叠的引用值；
以 @ 结尾表示函数使用不进行左值到右值转换的未折叠的引用值参数，或返回未折叠的引用值。
以上函数调用结果中的折叠的引用值对调用时引入的引用值有效。
除非另行指定，不要求函数折叠（调用前的）参数中包含的引用值，依赖这些参数的函数结果仍可因此包含未折叠的引用值。这允许函数的内部实现引入一次引用值时，对来自每个参数的引用值至多只需要实现一次折叠。
推论：若参数都不是未折叠的引用值，调用不以 @ 结尾的函数不引入未折叠的引用值。
引用标记字符可弱化内存安全保证，参见 @7.11.5.4 和 @8.4.2 。
若指定的操作按不同操作数可涉及或不涉及和当前不同环境下的求值，提供不保留引用值和保留引用值的多种版本的操作以便保证内存安全，包括 @9.4.1 和 @9.4.2 指定的操作。
可提供不同版本的操作被严格限制，以避免过度区分造成在使用上不必要的复杂性。

@8.9.2 不提供结尾引用标记字符对应名称的操作：
若指定的函数值直接来自操作数或其子对象(@8.6)（和以 % 结尾操作的情形类似），可返回和参数对应的引用值，满足：
函数的名称不含 % 或 & 结尾；
不提供避免涉及引用的对应操作，或仅在此基础上提供总是包含等价返回值转换(@8.6.1.4) 的对应操作。
否则，不提供结尾引用标记字符对应名称的函数不返回引用值。
这些操作不会使用临时对象作为环境，所以不需要使用以引用标记字符结尾的版本要求注意区分返回引用值而避免误用。
因此，不提供区分涉及引用的版本，这也使接口设计更清晰。
这些操作包括 @8.9.3 的情形，并在 @9.4.2 明确指出。
其它不提供结尾引用标记字符对应名称的操作暂不保证支持保留引用值。

@8.10 实现注记：
NPLA1 中提供的一些名称以及实现架构和 klisp 相似，且都为 AST 解释器，但实现方式略不同。
作为比较实现的备注，以下是 klisp 中（除当前不支持的 [RnRK] 特性外）相较 NPLA1 的一些主要实现差异：
使用跟踪 GC ，被 GC 管理的对象都支持跟踪回收，不特别处理 TCO（另见 @7.13.2 ）；
使用紧凑的（类似 lua ）的对象布局，依赖体系结构的数据模型假设（只实现了 32 位）；
使用 C 函数且支持 FFI ；
使用 setjmp/longjmp 恢复跳板中的上下文；
使用 C 函数调用产生对象语言错误，不直接使用和支持本机的其它机制（如 setjmp/longjmp 和 C++ 异常）的交互；
在全局上下文中支持名称表；
在上下文中支持当前续延（和 NPLA 当前动作对应的数据结构被拆分为 next_function 等 C 数据结构）；
分离续延应用和合并子调用操作（而非组合到当前动作的调用中）。

@9 NPLA1 参考实现环境：
NPLA1 提供参考实现环境，其实现可在内部使用 NPLA1 特性，提供给实现外的 NPLA1 用户程序(user program) 。
NPLA1 参考实现环境和用户程序遵循部分不同的要求和约定，如 @9.2 。
和 Kernel 的基础环境(ground environment) 类似，NPLA1 提供基础环境的实现，称为根环境(root environment) 。
和基础环境不同，根环境不保证唯一，且当前允许直接在用户程序中修改，直至被实现初始化参考环境的特定用户程序封装而避免进一步修改。
如有必要，用户程序可提供其它不是基础环境的根环境。
以下实现中的 C++ 名称和项目模块命名空间的使用同 @7 。
通过 Forms::LoadGroundContext(@7.12) 初始化基础上下文(@7.12) 蕴含的根环境是求值(@8.4) 默认使用的求值环境(@4.6.1.1)，初始化后可直接封装为基础环境使用。
以上初始化同时提供扩展字面量(@8.3.1) 支持。

@9.1 操作约定：
NPLA1 参考实现环境以符合常规函数约定(@8.7) 的方式提供操作作为用户可使用的可编程特性的基础之一（另见 @9.3 ）。
这表示可实现的操作可以是本机实现(@5.2.1) 的宿主语言函数或由现有操作派生的合并子(@8.6.4) 。
除此之外，派生实现可指定对操作提供对应的非常规函数(@8.7.4) 。
这些操作中的大部分具有特定的名称。这些名称符合 @8.9 的约定；其分类详见 @9.4 。
其它操作不具有特定名称，可由上述操作间接地提供，如蕴含在某些操作涉及的函数值(@4.5.3) 中。
同 [RnRK] ，操作被分组归类为模块(@1.4.6.4) ，可通过 @7.12 实现。
同 @7.10 ，操作按实现方式分为基本操作和派生操作。这类似 [RnRK] 中的基本和库(library) 特性(feature) 。
因不预期通过派生实现，基本操作总是通过本机实现提供。
@9.5 提供在基础上下文(@7.12) 初始化的基本操作，作为单独的模块。
@9.6 起的各节提供其余要求 NPLA1 实现直接支持的各个模块的操作。

@9.1.1 限制：
为避免依赖逻辑上复杂的形式，一些操作当前被核心功能排除。例如，依赖一阶算术的操作、其硬件加速形式的 ISA 表示的整数操作及依赖这些操作实现的数值塔(numerical tower) 被整体忽略。
上述忽略的操作可由派生(derived) 实现(@9.6) 补充，在派生根环境后按需进行 AOT(ahead-of-time) 优化（如 Kernel 的 $let-safe! 中包含的内容，其中引用基础环境的符号不再可变），然后组成类似基础环境。
派生实现不依赖非真合并子(@8.6.4) ，因此其中不使用分隔符(@8.4) ，也不需要实现在初始化时支持中缀变换(@7.4.2) 。

@9.1.2 不安全(unsafe) 操作：
除非另行指定，以下操作是不安全操作：
使用 @8.9 约定命名的带有后缀的操作，保留参数的引用值的操作，或引入其它间接值的操作，不具有内存安全保证(@8.4.2)，是不安全操作；
引入引用现有环境(@8.6.2) 的 shared_ptr<Environment> 宿主值而可能通过循环引用等引起未定义行为(@8.6.1.1) 的操作；
引入共享持有者的值数据成员(@5.4.2) 而可能通过循环引用等引起未定义行为操作。
第一类不安全操作和引用值的使用（特别是保留引用值(@8.6.1.5) ）相关，具体规则参见 @9.1.2.1 、@9.4.1 和 @9.4.2 。
其中，可引起扩展 NPLA 未定义行为(@8.4) 的操作包括以下可能破坏引用稳定性的第一类不安全操作(@9.1.2.1) ：
赋值操作(@9.4.1.3) ；
move(@9.5.3) 。
第二类不安全操作可能通过非引用的操作引入循环引用破坏环境的资源所有权，其中的基本操作在 @9.5.5 提供，对应的函数名如下：
copy-environment
lock-environment
第二类不安全操作中的派生操作在 @9.6.1 提供，对应的函数名如下：
lock-current-environment
第三类不安全操作支持强递归绑定(@8.5.2.1) ，对应的函数名如下：
$defrec!(@9.5.5)
$setrec!(@9.6.1)
不安全操作中，在参数以外直接引入间接值的操作有：
ref&(@9.5.3) ；
第三类不安全操作的强递归绑定过程中引用共享对象（参见 $defrec!(@9.5.5) ）的中间值。
NPLA1 参考实现环境中，仅有第三类不安全操作的实现内部可能引入引用持有者；参见 @8.4.2 。

@9.1.2.1 第一类不安全操作的子类：
第一类不安全操作按被保留的引用值的来源分为以下两个子类：
直接保留引用值操作：接受引用值参数并直接保留引用值；
间接保留引用值操作：可涉及不同的环境，参数在这些环境中被求值得到引用值。
间接保留引用值操作可包含部分直接转发引用值(@8.8) 的操作。整个操作不因此被视为直接保留引用值操作，即便部分引用通过直接转发引用值被保留。这保证以上两个子类不相交。
直接保留引用值操作覆盖常规函数约定的实际参数约定(@8.7.2) ，指定参数不隐含左值到右值转换，可按引用值直接访问。
直接保留引用值操作可配合 idv(@9.6.1) 指定个别参数不保留引用值。
第一类不安全操作的子类和对应不带有引用标记字符的操作的两个并集之间不相交，类似具有分类：
可能直接保留引用值的操作：结果(@4.1) 和副作用由实际参数（需要时经过隐含的左值到右值转换）的值确定；
可能间接保留引用值的操作：可涉及不同的环境，结果和副作用由实际参数（需要时经过隐含的左值到右值转换）在这些环境中被求值后确定。
通过引用进行的修改(@8.4.5.1) 操作可因破坏环境稳定性(@8.6.2) 而引起未定义行为（不一定违反内存安全）。

@9.2 实体实现约定：
本节约定对 NPLA1 参考实现内部有效，不作用在用户程序。
类似 [RnRK] ，派生操作可通过基本操作及派生操作实现。
除非另行指定，NPLA1 参考实现环境作为公开接口的提供变量在根环境中绑定。
除非是语义蕴含的操作结果或另行指定，所有作为函数值的操作(@9.1) 的结果(@4.1) 未指定。未指定的值可等于 #inert(@9.3) 或其它值，但满足忽略值时不引起可观察行为的改变（这排除了引入 volatile 类型或非平凡析构的宿主值）。
若操作(@9.1) 在 Kernel 或 klisp 中存在结果为 #inert 的对应的操作，且未指定作为函数值的结果，则返回等于 #inert 的右值。
约定的接口通过绑定在根环境中的名称提供，参见以下各节。
这些名称可能是本机实现(@5.2.1) ，即直接调用 NPLA 或 NPLA1 API(@7) 绑定定义；也可能是非本机的派生的(derive) 实现(@2.3.1.2) ，即通过在当前的基础上求值特定的对象语言代码引入。
变量的绑定(@4.1) 的引入是否由本机实现未指定。以下的派生操作(@9.6) 应能以派生的方式提供。
派生不依赖隐式求值风格(@8.4) ，除非语义明确要求避免操作数的求值（如 $deflazy!(@9.6.1) ）且对实现可提供必要的简化，应避免依赖 $quote(@9.6.1) ；$quote 自身通过派生实现引入。
除非另行指定，这些名称指称的实体构成的接口没有严格的兼容性保证，但一般可预期在 YSLib 发布版本([Documentation::ProjectRules @@2.2.4.5]) 之间保持向后兼容。
作为 @7.1.2 的扩展，函数的非本机也实现允许假定纯右值(@5.5.1) 的项不包含不被 @7.1.2 约定直接使用的标签。

@9.2.1 函数实现使用约定：
名称使用 $def 起始的函数用于在当前环境(@5.4.4) 引入绑定。
需引入绑定时，优先使用 @9.6.2 中的函数；当使用这些函数并不能简化实现时，使用 $def!(@9.5.5) 。
其中优先使用函数名中没有 % 的函数，仅当语义要求时，使用 %! 结尾的函数，以减少不安全操作(@9.1.2) 并明确函数值是否可能只是非引用值（此时两者效果应一致）。
这对应宿主实现中，使用 auto 而不是 auto&& 作为返回值；但宿主语言中返回非引用类型的表达式两者含义不同。
尽管设计时没有参照，使用函数结尾的引用标记字符和其它一些语言的类似特性的使用惯例也一致，如 PHP 的 function & 语法：
https://www.php.net/references.return
应注意 NPLA1 的名称表达式解析(@6.9.3) 的结果保证求值为左值(@5.5.1)（参见 @8.4.1 ）。强调使用没有 % 或 %! 结尾的函数避免过于容易地返回局部创建的变量的悬空引用(@5.6.3) 引起未定义行为，在此为避免误用而符合 @1.4.5.2 。
与引入绑定不同，实现内部不要求类似的优先使用，在需要明确实现需要符合的要求或减小实现开销时，可使用提供以引用标记字符结尾版本的操作(@8.9.1) 替代其它操作。

@9.3 预定义对象：
特定名称的预定义对象以变量的形式在基础上下文(@7.12) 的根环境中初始化，提供具有预设目的的可编程特性。
ignore ：类似 Kernel 的 #ignore 字面量，但不作为字面量而是普通对象，关联的值是记号值(@5.6.1) 。
注意 ignore 是一等对象(@4.1) ，和 Kenerl 为 #ignore 单独提供值域仅有一个单元类型(unit type) 不同。
原理：按 @1.4.2.3 ，提供单独的类型是不必要的。
从表达上，#inert(@8.3.1) 和 ignore 仍都可以被视为特定单元类型的值：等价的类型判断谓词可以直接使用值的相等关系确定。
#inert 的值是 ValueToken 宿主类型唯一直接在对象语言中提供的宿主值。
ignore 的值是完全作为标签使用的记号，具有记号值类型。

@9.4 函数分类：
本节对函数按名称和其它不同性质进行分类。
在 NPLA1 参考实现环境提供的函数具体详见 @9.5 和 @9.6 。
除非另行指定，本节约定的函数属于 NPLA1 参考实现环境。
本节约定的函数提供的部分操作属于转发(@8.8) 。
绑定的变量名是符号构成的名称表达式(@4.5) ，解析(@6.9.3) 的结果总是左值(@5.5.1) ，转发其指称的对象可使用 forward(@9.6.1) ，或（仅对参数转发）使用标记字符 % 的参数绑定(@7.6.2.4) 的变量实现。
其它情形不需使用 forward 。特别地，被转发的函数值若需支持 PTC(@8.4.8.1) ，则不能作为 forward 或其它应用子的实际参数以避免不满足在尾上下文(@4.4.7) 求值的条件。

@9.4.1 可提供以引用标记字符结尾版本的函数：
一些函数区分引用值的使用，以引用标记字符结尾提供不同的版本。
可能存在的结尾的引用标记字符用于强调无法总是保证内存安全(@8.4.2) 的危险操作(@1.4.5.2) ，参见 @8.9.1 。
不带有引用标记字符结尾的操作通过避免保留引用值(@8.6.1.5) 提供一定的内存安全保证，而带有引用标记字符结尾的操作较容易引起注意。这符合易预测性(@1.4.5.2) 。
带有引用标记字符结尾的不安全操作属于第一类不安全操作(@9.1.2) 。
第一类不安全操作实际不满足内存安全的一个主要的必要非充分条件是操作保留引用值，且引用值在被引用对象的生存期外被使用。
这主要包括直接使用标识符求值为引用值的情形：因为标识符直接指称左值（通过名称解析(@4.3.3) 引入）。
保留引用值操作的内存安全(@8.4.2) 依赖所有被保留的引用值在之后的使用中都满足内存安全。
若保留引用值操作不返回引用值，则返回的值等价经过返回值转换(@8.6.1.4) 。
一般仅在明确需要引用时，使用以引用标记字符结尾的版本的函数（特别是环境可能作为参数被使用时）。
本节约定的函数提供的操作属于 @9.1.2.1 定义的可能直接保留引用值的操作和可能间接保留引用值的操作之一。
可能直接保留引用值的操作中，不带有引用标记字符的操作转发参数(@9.4.2.3) 。
可能直接保留引用值的操作包括容器构造器或访问器(@8.8.5) ，以及可能使对象中包含引用值的修改操作(@8.4.5.1) 。
（引入非容器对象的操作另见 @9.4.1.4 。）
对构造器的转发操作以及部分修改操作区分是否存在引用标记字符结尾可强调一些非预期保留引用值的容易误用情形：
尽管总是返回非引用值，转发参数保留的引用值不会被返回值转换(@8.6.1.4) 影响，在构造的容器对象作为非引用值返回仍会保留引用值(@8.6.1.5) 。
（对应宿主语言中，可有更显著的差异，如构造器对应的 std::tuple 的 std::make_tuple 和 std::forward_as_tuple 。） 
本节内的以下分类不相交，但部分分类中函数名不带有引用标记字符结尾的操作可能和 @9.4.2 中的操作相交。

@9.4.1.1 可能使结果包含引用值的容器构造器：
以下操作是容器构造器，包括：
cons(@9.5.4)
cons%(@9.5.4)
wrap(@9.5.6)
wrap%(@9.5.6)
list(@9.6.1)
list%(@9.6.1)
list*(@9.6.1)
list*%(@9.6.1)
box(@9.6.2)
box%(@9.6.2)
这些操作的结果由实际参数（根据是否存在引用标记字符 % 指定是否不经过隐含的左值到右值转换）的值确定。
其中，带有引用标记字符结尾的操作是直接保留引用值操作。
容器构造器可保留元素中的引用值，作为结果的容器总是作为非引用值返回(@8.6.1.4) 。

@9.4.1.2 可能使结果包含引用值的容器元素访问器：
以下操作是容器元素访问器，包括：
first(@9.6.1)
first&(@9.6.1)
first@(@9.6.1)
rest(@9.6.2)
rest&(@9.6.2)
rest%(@9.6.2)
其中，带有引用标记字符结尾的操作是直接保留引用值操作；函数名不带有标记字符结尾的访问器属于参数转发操作(@8.8.2) 和函数值转发操作(@8.8.4) 。
因为正规表示(@5.8.5.4) 的限制，rest 、rest& 和 rest% 重新构造列表，并不直接返回子对象；其它访问器若带有引用标记字符，可直接返回引用值。
此外，@9.4.2.4 中部分函数也符合容器元素访问器的要求，但当前不提供带有后缀标记字符的版本。这些函数包括：
unwrap(@9.5.6)
unbox(@9.6.2)

@9.4.1.3 可能使对象中包含引用值的修改操作(@8.4.5.1) ：
以下操作的内存安全(@8.4.2) 依赖所有参数都满足内存安全：
简单赋值(simple assignment) （包含于赋值操作(@8.4.5.1.1) ），包括：
assign@!(@9.5.3)
assign%!(@9.6.1)
assign!(@9.6.1)
列表元素改变器(mutator) ，包括
set-rest!(@9.5.4)
set-rest%!(@9.5.4)
set-first!(@9.6.1)
set-first@!(@9.6.1)
set-first%!(@9.6.1)
修改的结果由实际参数（需要时经过隐含的左值到右值转换）的值确定。
以上操作都要求检查表示被修改的参数是左值。
以上操作中，带有引用标记字符结尾的操作是直接保留引用值操作。

@9.4.1.4 可能间接保留引用值的操作：
一些操作可涉及不同的环境，参数在这些环境中被求值可能得到引用值。
这些操作包括求值为操作子的以下函数：
以求值 <body> 作为尾上下文的操作(@8.4.8.1) ，包括结果是合并子或用于在环境中绑定合并子的构造器操作，以及核心库函数(@9.6.2) 中的绑定操作；
以求值 <expression> 作为尾上下文的函数 eval 和 eval%(@9.5.5) 。
以上操作中，带有引用标记字符结尾的操作是间接保留引用值操作，表示求值结果不要求按值传递并可返回引用值，参见 @9.5.5 和 @9.6.2 。
以上操作中的求值符合词法闭包(@4.6.1.1.2) 规则，可使用 A1::RelayForEval 或 A1::RelayForCall(@7.6.1) 实现。
注意和此处直接在参数中给出被求值表达式不同，如 apply(@9.6.1) 等应用子中的求值的操作不属于上述操作(@9.4.2.5) 。

@9.4.2 不提供结尾 % 或 & 对应名称的函数：
一些函数命名不提供结尾 % 或 & ，函数值是否保留引用值通过本节内的分类确定，符合 @8.9.2 。
本节内部分操作涉及参数转发(@8.8.2) 和函数值转发(@8.8.4) 。
本节约定的涉及参数转发或函数值转发的函数不提供引用标记字符(@8.9.1) ，但已在 @9.4.1 中的除外。
尽管可能因为对左值进行求值而使用引用，不使用 @9.4.1.4 中的第一类不安全操作(@9.1.2) 仍能保证这些引用不逃逸(@7.1.4) 。
通常使用 forward(@9.6.1) 转发实现上述保证(@8.8.2) 。
部分操作的内存安全性和 @9.4.1 类似，也是第一类不安全操作，但仅在引用值参数被保留且在之后体现。
和 @9.1.2.1 类似，包括直接保留引用值和间接保留引用值的不同情形。
除 @9.4.2.1 和其它节的操作不相交，以下分类对操作的参数和函数值分别约定，可能相交。

@9.4.2.1 可直接返回引用值的操作：
一些求值为操作子提供的函数选取特定的参数进行求值，作为控制操作。
被求值的操作数直接决定是否为引用部分操作直接返回引用值，除 <test> 外不进行左值到右值转换，调用者需负责决定是否求值其它操作数。
这类似宿主语言中参数传递和返回 auto&& 类型。
这些操作当前包括：
$if(@9.5.2)
$sequence(@9.6.1)
$cond(@9.6.1)
$when(@9.6.1)
$unless(@9.6.1)

@9.4.2.2 返回非引用值的操作：
部分操作类似容器构造器(@9.4.1.1) 保证返回非引用值(@8.8.3) ，但并非直接以参数实现决定函数值：
若非构造器的操作总是返回列表、箱(@8.2.3) 或其它的封装类型(@9.5.8) 对象，返回的对象总是按值传递。
和作为构造器的操作不同，后者需区分结果中是否可能包含引用值(@9.4.1.1) ：
没有引用标记字符的操作(@8.9) 表示（假定一次折叠(@8.9.1) 后）不包含引用值的构造器；
带有引用标记字符的操作表示可能包含引用值的构造器。
而此处的情形的结果可能包含引用值。
为简化接口以及满足其它分类（如 @9.4.2.3 ），不提供不保留引用值的操作。
若需要排除通过参数引入的引用值，应进行适当处理使参数中不含有会使这些操作引入引用值的构造。
这些操作包括核心库函数(@9.6.2) 中的：
map1
list-concat
append
类似列表构造器，这些函数可在结果中保留引用值。

@9.4.2.3 直接参数转发操作：
部分不带有引用标记字符的直接参数转发操作是可能直接保留引用值的操作(@9.1.2.1) 。
函数名不使用引用标记字符，和 @9.4.1.1 的函数名使用引用标记字符不一致：
本节约定的函数和 @9.4.1.1 中函数名中带有 % 结尾的函数同属参数转发操作，但后者同时有不带有引用标记字符的版本；
本节不约定和 @9.4.1.1 中函数名中不带有引用标记字符结尾的函数对应的操作。
这种不一致（和 @9.4.2.4 不同）是预期的特性：
和 @9.4.1.1 不同，这些操作并非用于构造对参数具有所有权的对象，不适合提供不保留引用值的操作；
为简化接口及满足其它分类（如 @9.4.2.2 ），不适合提供不保留引用值的操作；
和 @9.4.1.2 不同，这些操作并非用于取子对象，返回值不一定是引用值，和具体操作相关，不适合使用引用标记字符区分。
本节约定的函数对引用标记字符的使用和 @9.4.1 的函数名的使用不一致，而相当于结尾的 % 。
本节约定的函数包括合并子基本操作中的合并子访问器 unwrap(@9.5.6) 。
非构造器函数参数支持转发操作的这些操作还包括核心库函数(@9.6.2) 中的：
accl
accr
foldr1
map1
核心库函数(@9.6.2) 中的绑定操作的非 <environment> 的形式参数支持转发。
注意 map1 同时返回非引用值(@9.4.2.2) 。
参数形式上被转发但操作的语义并非总是转发到其它操作的操作不使用本节的名称约定，如以下仅有第二参数支持转发的操作是提供结尾 % 或 & 对应名称的函数(@9.4.1) ，有对象基本操作(@9.5.3) 中的：
assign%!
assign@!
此外，@9.4.2.4 中的函数值转发操作同时也是直接参数转发操作。
其它函数的参数传递的一般规则参见 @8.6.1.3 、 @8.7.2 和 @8.8 。

@9.4.2.4 函数值转发操作：
注意 @9.4.1.4 中的操作不提供具有转发返回值的形式，因为总是转发（提升后的）值比转发引用具有更严格的安全保证（因而通常不需要调用 idv(@9.6.1) 避免悬空引用(@5.6.3) ），而直接返回可能是引用值的值具有更简明的语义。
若其它情形确需非转发操作取得引用值，可使用 @9.4.1 中带有 % 或 & 结尾的操作及 @9.4.2.1 中的操作替代实现。
本节约定的函数不使用引用标记字符，和 @9.4.1.2 的函数名不使用引用标记字符一致：
本节约定的函数和 @9.4.1.2 的函数名中不带有引用标记字符结尾的函数同属函数值转发操作，但后者同时有带有引用标记字符的版本。
和 @9.4.1.1 引入引用值的情形不同，不带有后缀 % 相对不容易引起误用，因为返回值保留的引用可以继续被返回值转换(@8.6.1.4) 影响。
例如，使用保证返回非引用值的涉及环境中求值的操作(@9.4.1.4) ，引用值会在引用的对象生存期结束前被返回值转换而不影响内存安全。
NPLA1 参考实现环境的函数值转发操作包括以下访问对象或被引用对象自身或子对象的函数：
unwrap(@9.5.6)
id(@9.6.1)
forward(@9.6.1)
unbox(@9.6.2)
基本操作(@9.5) 的不具有名称的相关操作中参数和函数值原生支持的转发操作包括：
使用 make-encapsulation-type(@9.5.8) 返回的访问器合并子。

@9.4.2.5 间接保留引用值的操作：
部分不带有引用标记字符的操作是可能间接保留引用值的操作(@9.1.2.1) 。
由类型为合并子的参数（而非 <body> 或 <expressions> ）决定是否保留引用值同时对其它参数进行转发的操作有：
apply(@9.6.1)
由特定的参数在特定环境中的求值的结果决定是否保留引用值的操作有核心库函数(@9.6.2) ：
$provide!
$provide/d!

@9.4.3 引用值构造：
当前构造子对象引用(@5.6.3.5) 的操作有：
基本操作中的 unwrap(@9.5.6) 。
子对象引用具有非平凡非正规表示(@5.8.5.4) 。

@9.5 基础基本操作(grounded primitive operations) ：
基础基本操作在基础上下文(@7.12) 的根环境中初始化。
和 [RnRK] 不同，为简化设计，不提供可选(optional) 的合并子，而提供可选的模块(@10) 。
派生实现可以通过提供不公开不安全操作(@9.1.2) 的根环境，但不符合此处的规格要求(@2.3.1.2) 。
若派生实现不提供第三类不安全操作(@9.1.2) ，可以简化部分 @9.5.3 中与之关联的操作的实现。
部分可选的 Kernel 合并子被直接提供。
和 Kernel 不同，一些函数显式地操作引用值(@5.6.3) ，包括未折叠的引用值(@5.6.3) 。
和 Kernel 不同，求值算法不直接处理对象的引用值(@6.5.3.3) 。 
为简化实现，部分提供 % 等后缀的函数(@9.4.1) 不被派生。
因为设计原因，不提供以下 Kernel 合并子对应的操作：
copy-es-immutable
inert?
ignore?
考虑（可变对象的）一等引用和绑定构造(@8.5.2) 绑定引用的的平摊复杂度，不提供需要同时转换不同层次子项的 copy-es-immutable 操作。
部分其它原理参见 @9.3 。关于引用值的处理另见 @9.4 。
其它没有包含在以下节中的 Kernel 操作可能会在之后的版本中被支持。

@9.5.1 等价谓词(@4.1.4) ：
等价谓词不应修改参数对象。
用户定义的类型提供等价谓词应满足和 NPLA1 提供的等价谓词的语义一致的等价关系，否则若谓词被求值，行为未指定。
开放类型映射(@5.2.3) 的类型系统(@4.6.2) 可能属于这种理论。不需要依赖序的等价谓词可以为名义类型(@4.6.2.1) 提供直接的支持。
NPLA1 提供默认相等为抽象相等(@4.1.4) ，对任意的值适用。
NPLA1 还提供对一等对象保证结果有意义的引用相等(@4.1.4) 操作。非一等实体的引用相等关系未指定。
当前 NPLA1 不支持 EGAL(@4.1.4) ，因为 EGAL 要求分辨对象是否可被修改的元数据。
NPLA1 提供的等价谓词包括：
eq? <object1> <object2> ：表示引用相等关系的应用子。
eql? <object1> <object2> ：表示项的值数据成员(@5.4.2) 相等关系的应用子。
eqr? <object1> <object2> ：表示项的值数据成员引用相等关系的应用子。
eqv? <object1> <object2> ：表示值相等关系的应用子。
使用 eq? 判断一般左值的标识，当且仅当为操作数比较同一个对象时比较结果为 #t 。
使用 eql? 比较忽略列表类型(@8.4.7) 时和 eqv? 相同，即仅比较宿主值 TermNode 的值数据成员(@5.4.2) 相等。
由 @5.8.5.3 ，列表和非列表之间的 eql? 结果总是为 #f ，列表之间的 eql? 的比较结果总是 #t 。
使用 eqr? 判断宿主值 TermNode 的值数据成员表示的左值(@5.5.1) 的标识，当且仅当为操作数比较同一个对象时比较结果为 #t 。
由 @5.8.5.3 ，所有列表在 TermNode 的值数据成员中的表示都一致，在 eqr? 等价关系下视为相同的对象。
使用 eqv? 比较项表示的值的相等关系：当项都是非空列表时，同 eq? ；否则，同 eql? 。
不同左值或 eqv? 比较结果为 #f 的操作数的 eq? 比较结果总是 #f 。
若右值之间 eqv? 比较结果为 #t ，eq? 比较结果未指定，以允许实现复用存储右值的驻留(@8.4.5.2) 对象。
因为对应等价的不变性(@2.3.1.1) 关系不具有唯一性，且可能允许不唯一的方式产生副作用（如缓存），和 Kernel 不同，不提供 equal? 对任意对象提供一般的相等操作。
不等价(@4.5.3.2) 的函数的 eqv? 比较结果为 #f 。
除以上规则确定的结果外，eqv? 对函数或列表的比较结果未指定。在互操作的意义上，当前其 eqv? 定义的函数的相等性由 @7.11.5.5 或其它宿主实现提供的 == 操作确定（关于合并子相等，另见 @7.13.2 的说明）。
类似 Kernel 和 Scheme 谓词的 equal? 可通过 eqv? 直接构造。因为列表的性质(@8.6.3) ，不需要支持循环引用(@8.6.1.1) ，可以直接派生。后者被视为基本的抽象而非实现细节。
通常，等价谓词比较的求值应保证能终止且对非列表项和 n 个子项的列表分别具有 O(1) 和 O(n) 平摊复杂度。但语言不需要约束这个性质。

@9.5.2 控制：
$if <test> <consequent> <alternate> ：条件分支，按条件成立与否返回 <consequent> 或 <alternative> 之一，可能是引用值。
$if <test> <consequent> ：省略第三操作数的条件分支，条件成立时返回 <consequent> 。
和 Kernel 不同而和 Scheme 类似，如 <test> 的求值结果非 #f 的都选择 <consequent> ，且支持省略第三参数。
若省略 <alternative> 且 <test> 求值为 #f ，则结果未指定(@9.2) 。
对 <test> 的处理的主要原理和 Kernel 的 $and? 不要求尾上下文的表达式求值检查类型一致。
若需要检查类型避免误用，可以派生提供其它函数；相反的派生无法利用更简单的实现。
和 R7RS 类似，但和 Racket 及 Kernel 不同，省略 <alternative> 被支持。
这避免用户必须引入 #inert 等具体的值实现相同隐式效果而违反关注点分离原则(@1.4.2.4) 。
和 [RnRK] 中的相关讨论结论不同，是否省略 <alternate> 的形式应是一致的。这是因为：
NPLA1 不假设作为基本控制操作的 $if 的作用（仅要 <consequent> 或 <alternate> 求值的结果，或仅为了副作用）；
$if 不假设用户对 <consequent> 和 <alternate> 顺序选择性偏好，以避免限制用户选择否定谓词简化 <test> ，从而支持 @1.4.2.1 。
此外， NPLA1 使用显式的 <expression-sequence>（而不是 <consequent> 和 <alternate> ）语法表示顺序求值，这不适合基本的控制操作子：
若分离二操作数和三操作数其它形式，则二操作数可以使用 <expression-sequence> ，即 $when(@9.6.1) 。
但依赖 <expression-sequence> 的 $when 不应是比具有 <consequent> 的二操作数形式更基本的操作。
因此，仍然需要有 $when 以外的省略第三参数的基本控制操作子。基于同一性(@1.4.5.1) ，对应函数名仍然为 $if 。（尽管使用了相同的原则，这和 Kernel 的结论恰好相反。）
与此类似，和 Racket 的理由（参见 https://stackoverflow.com/questions/10863192/why-is-one-armed-if-missing-from-racket ）不同，不因为 $when 提供只强调副作用的操作而取消 $if 的 <alternative> 。
NPLA1 不会如 Racket 一样在此避免遗漏 <alternate> 导致的非预期结果。这并不违反 @1.4.5.2 ，因为不使用 <alternate> 的结果非常显然，同时选择使用 $if 这样的基本控制操作而不是更特定派生控制操作或更高级的抽象已蕴含注意误用的必要性。
一般地，NPLA1 不提供强调只存在副作用的操作。返回未指定（而不要求被使用）的求值结果的情形并不表示只有副作用(@9.2) ，因为副作用是否存在原则上依赖具体操作。这和 Kernel 的 #inert 以及 Racket 的 #<void> 值即便在实现上都一致，但含义不同。
另见 $when 的说明。

@9.5.3 对象基本操作：
注意因为真列表(@8.6.3) 的限制，列表左值只能引用完整的列表的对象，而不支持部分列表。
这影响 set-rest! 和 set-rest%! 的 <list> 参数。
null? <object> ：判断操作数是否为空列表。
nullv? <object> ：判断操作数是否为空列表纯右值。
同 null? ，但不支持引用值。
reference? <object> ：判断操作数是否为引用值。
uncollapsed? <object> ：判断操作数是否为未折叠的引用值。
bound-lvalue? <object> ：判断操作数是否为被引用的被绑定对象左值。
绑定临时对象的引用类型的参数不被视为左值引用。
配合 $resolve-identifier 和 % 引用标记(@7.6.2.4) 绑定的变量，可确定实际参数是否为左值。
单独使用 bound-lvalue? 和 & 引用标记字符(@7.6.2.4) 绑定的变量，可确定实际参数是否为引用。
unique? <object> ：判断操作数是否为唯一引用(@5.4.2.2) 。
deshare <object> ：取指定对象取消共享的值。
同 idv(@9.6.1) ，但显式提升操作数中具有共享持有者的值数据成员(@5.4.2) ，且不转移宿主值。
因为提供第三类不安全操作(@9.1.2) ，这个区别是必要的。否则，使用 idv 替代应不影响可观察行为。
和通常的求值规约消除引用值（如 @7.6.1.1 ）不同，以 NPL::LiftTermRef(@6.6.2) 和确保创建值副本的 NPL::SetContentWith(@6.2.1) 实现。
expire <object> ：取指定对象的消亡值(@5.5.1) 。
同 id(@9.6.1) ，但当参数是引用值时，结果是和参数引用相同对象的唯一引用。
可用于显式地指定之后被转移的对象（参见 @8.4.5.1.2 ），而不需要直接转移参数，因此这个操作也不是修改操作(@8.4.5.1) ，函数名不以 ! 结尾(@8.9) 。
这个函数类似宿主语言作用在对象类型实际参数的 std::move ，可能减少没有经过复制消除(@5.5.5.3) 的复制或转移(@5.5.2.3) 而改变使用这个函数的结果对象的副作用。
特别地，指定列表的引用值被转移时，不需要立即转移列表的每个元素，而允许之后通过绑定构造(@8.5.2) 等方式选择转移的子对象(@8.6) 。
可能包含立即转移的操作如 forward!(@9.6.1) 。
move! <object> ：转移项。
若对象是不可修改的左值，则以复制代替转移；否则，直接转移对象的项(@5.5.3) 。
结果是不经返回值转换的项。
被转移对象后的项满足 @5.2.4.2 。
当前实现中项被转移后，表示的值为 () 。这和返回值转换(@5.7.4.4) 等引入实质化临时对象时可能具有的转移(@5.5.5) 的效果（仅在互操作时可见）不保证相同。
transfer! <object> ：转移对象。
同 move! ，但使用对象的转移(@5.5.2.3) ，而不是项的转移(@5.5.3) ，避免宿主对象转移消除而允许调用宿主对象的转移构造函数(@5.5.3.1) 。
项被转移后，和返回值转换等引入实质化临时对象时可能具有的转移的效果（仅在互操作时可见）相同。
ref& <object> ：取引用。
对引用值同 id(@9.6.1) ；对具有共享持有者的值数据成员的对象也视为左值。通过后者构造的引用值不被检查。
取得的引用值是不安全引用值(@5.6.3.1) 。
因为提供第三类不安全操作，对共享持有者的值数据成员的对象使用不同的处理。否则，对引用值参数的情形，使用 id 替代应不影响可观察行为。
以 NPL::LiftToReference(@6.6) 实现。
assign@! <reference> <object> ：赋值(@8.4.5.1.1) 被引用的对象为指定对象的值，且 <object> 不隐含左值到右值转换且不被折叠。
同 assign%!(@9.6.1) ，但 <object> 不被折叠。
检查 <reference> 是可修改的左值。
赋值对象直接修改(@8.4.5.1) 被引用的对象，但不无效化(@8.4.5.4) 参数指定的引用。
Scheme 的 set! 在 SRFI-17 提供具有类似作用的支持，但第一操作数限于 set! 且为特定的过程调用；Kernel 没有类似的操作。

@9.5.4 列表基本操作：
cons <object> <list> ：构造两个元素的列表。和 Kernel 不同，NPL 不支持列表中存在环，因此第二个操作数应为列表，否则出错。
cons% <object> <list> ：构造两个元素的列表，保留引用值。
同 cons ，但允许子项中有引用而不复制(@7.11.5.4) 子项的值。
set-rest! <list> <object> ：修改列表的第一个以外的元素。
和 Kernel 的 set-cdr! 类似，但检查列表是左值，且不保留被添加元素中的引用值。
set-rest%! <list> <object> ：同 set-rest! 但保留引用值。
和 Kernel 的 set-cdr! 类似，但检查列表是左值。
不检查修改操作(@8.4.5.1) 导致循环引用(@8.6.1.1) ，用户应自行避免未定义行为(@5.2.2) 。

@9.5.5 环境：
和 Kernel 不同，环境可使用环境强引用和环境弱引用(@5.4.3) 蕴含不同的所有权。
为避免引入过于容易引入循环引用(@8.6.1.1) ，仅通过个别操作引入环境强引用（另见 @5.4.3 ）：
make-environment
lock-environment
eval <expression> <environment> ：在参数指定的环境中求值，结果作为函数值。
注意按 @8.4 ，列表中的引用不会被特殊处理，不隐含左值到右值转换。
eval% <expression> <environment> ：同 eval ，但保留引用值。
$resolve-identifier <symbol> ：解析标识符。
直接保留解析结果中项的类型，不按成员访问规则确定值类别，因此和解析名称表达式的结果总是左值(@9.4) 不同，可保留消亡值(@5.7.4.1) 。
() copy-environment ：递归复制当前环境(@5.4.4) 。当前忽略父环境中的环境列表(@5.4.3) 。
结果为新创建的环境，具有宿主值类型 shared_ptr<Environment> 。
使用类似 @5.4.3 的 DFS 搜索操作数的父环境和绑定的对象，若非环境则直接复制值，否则创建环境并递归使用 DFS 复制值。
当前只支持复制具有 shared_ptr<Environment> 和 EnvrionmentReference 的宿主值的环境，其它对象直接视为非环境对象。
警告：这个函数仅用于测试时示例构造环境，通常不应被用户程序使用，且可能在未来移除。未确定环境宿主值时可引起未定义行为。
freeze-environment! <environment> ：冻结环境：指定中的对象不可修改。
当前不提供在已有环境撤销冻结的方法。
lock-environment <environment> ：锁定环境：创建环境强引用。
检查操作数的宿主值类型是 NPL::EnvironmentReference ，结果的宿主类型 shared_ptr<Environment> 。
强引用可能引起环境之间的不被检查的循环引用(@8.6.1.1) ，用户应自行避免未定义行为(@5.2.2) 。
make-environment <environment>... ：创建环境。
和 Kernel 不同，除对象类型外，没有对列表和绑定的附加检查。
结果为新创建的环境，具有宿主值类型 shared_ptr<Environment> 。
weaken-environment <environment> ：使用环境强引用创建环境弱引用。
检查操作数的宿主值类型(@6.9.1) 是 shared_ptr<Environment> ，结果的宿主类型 NPL::EnvironmentReference 。因为 NPLA1 需要精确控制所有权而不依赖 GC(@5.2) ，这可用于派生实现某些操作（如 $sequence(@9.6.1) 必要的）。
$def! <definiend> <expressions> ：修改绑定。
类似 Kernel 的 $define! ，修改环境中的绑定，但满足 @8.5.2 的约定。
和 Kernel 类似，对在 <expressions> 中某些未被直接求值的子表达式（如 $lambda(@9.5.6) 的 <body>），因为其中的求值依赖 $def! 表达式求值后的环境，在之后仍可以实现递归。
由于递归调用依赖环境中的绑定，修改以上定义引入的绑定后可影响被递归函数的调用。
对 <definiend> 中已存在的标识符的绑定，保证直接替换对象的值，对象的引用不失效(@8.6.2.1) 。
$defrec! <definiend> <expressions> ：修改绑定，类似 Kernel 的 $define! ，但在绑定时针对 <definiend> 指定的操作数树(@7.6.6) 中的绑定名称有附加的处理以支持直接递归。
除和 $def! 相同过程的常规绑定（求值 <expression> 和绑定符号）外，支持强递归绑定(@8.5.2.1) ，其操作数树的附加处理分为两阶段；每个阶段深度优先遍历 <definiend> 指定的操作数树，对每个符号进行附加处理：
在常规绑定前，每个遍历的待绑定符号在目标环境（被定义影响的环境）中预先进行绑定，保证指称一个对默认对象的弱引用，其中默认对象具有调用总是抛出异常的 A1::ContextHandler 类型(@7.2.1) 的值；和这个弱引用的共享的强引用被临时另行保存。
在常规绑定后，再次遍历操作数树，对每个 A1::ContextHandler 的值，替换之前在环境中保存的共享定义为默认对象的共享强引用，最后释放先前临时保存的默认对象的强引用。
调用默认对象时，若默认对象的强引用存在，抛出默认对象内置的异常；否则，抛出由对象实现提供的引用不存在的异常。和 vau 抽象对环境的检查(@8.6.2.2) 类似，后者在对象语言中已引起未定义行为，不应被依赖。
常规绑定后转移未被 <expressions> 求值影响的绑定中的默认对象的所有权到环境中，但不影响绑定目标在对象语言中指称的值。
在环境中未被 <expressions> 求值替换的绑定，在 $defrec! 求值仍指称默认对象（而不会是持有合并子的宿主类型(@7.5.1.1) 的值），若被作为合并子调用，则显示存在循环递归调用。
和 $def! 不同，常规绑定后的操作使 <expressions> 不在尾上下文求值；而因为保证操作数树中的名称已存在默认定义，求值 $defrec! 的 <expressions> 前时可使用绑定。
这允许递归定义的名称在绑定完成前指称对象，如：
求值表达式 $defrec! (a b) list b ($lambda (a) 1) 不需要 a 或 b 已被绑定（即便 b 并不在 $lambda 的 <body> 中），但求值后 a 为默认对象；
求值表达式 $defrec! (b &a) list ($lambda (a) 1) b 同上，但 a 求值后可能为默认对象（操作数树中的同级叶节点被未指定的绑定顺序影响）。
这也允许在 $vau/e(@9.5.6) 等表达式的 <environment> 指定的静态环境使 <body> 不能访问目标环境时，直接定义递归函数。
递归定义的对象中的值数据成员(@5.4.2) 可能具有共享的持有者。若为合并子，直接调用会利用替换的值重新访问所在的环境。复制和转移这样的值不会改变被访问的环境。若访问的环境失效，则抛出异常，或无限递归调用自身。
特定情形使用 deshare(@9.5.3) 可去除共享和避免以上可能非预期的行为。
另见 @8.6.2 。

@9.5.6 合并子：
和 Scheme 及 Kernel 不同，<body> 可以是多个项，而不在派生另外的版本支持顺序求值。
引入合并子的操作子不求值 <body> ，后者在被调用时替换操作数以后被求值。这允许安全地使用 $def! 而不需要 $defrec! 进行递归绑定(@9.5.5) 。
创建合并子时对参数指定的求值环境 <environment> 进行类型检查(@8.4.3.4.1) 外，还进行内部的检查确保宿主值非空。
检查失败的错误(@8.4.3.1) 是（可能依赖(@8.4.3.1) 类型错误(@8.4.3.4.1) 的）语法错误(@7.7.1) 。
$vau/e <environment> <formals> <eformal> <body> ：指定静态环境的 vau 抽象(@4.5.2.3) 。
类似 $vau(@9.6.1) ，但支持额外的求值环境作为静态环境。
和 Kernel 不同，因为支持保存环境的所有权，$vau/e 被设计为比 $vau 更基本的操作。
不考虑所有权时，eval(@9.5.5) 和 $vau 可派生 $vau/e 。
$vau/e% <environment> <formals> <eformal> <body> ：同 $vau/e ，但保留引用值。
wrap <combiner> ：包装(@4.5.3.2) 合并子为应用子。
包装应用子可能符合包装数溢出的错误条件(@8.6.4) 。
wrap% <combiner> ：同 wrap ，但参数不隐含左值到右值转换，在结果保留引用值。
unwrap <applicative> ：解包装(@4.5.3.2) 应用子为合并子。
和 Kernel 不同，参数是右值时子对象被复制，由这些合并子创建的操作子当前仍不足以取代内置的一等操作子，因为不支持只能转移而不能复制的对象。传递这些对象作为操作数会引起构造失败的异常。

@9.5.7 错误处理和检查：
raise-invalid-syntax-error <string> ：引发包含参数指定的字符串内容的语法错误(@8.4.3.1) 。
当前实现中引发的错误对象以抛出异常实现，其中异常对象类型具有 public 基类 NPL::InvalidSyntax 。
check-list-reference <object> ：检查对象是否是列表引用，若检查通过返回参数，否则引发错误对象(@8.4.3.1) 。
当前实现中引发错误对象以抛出异常实现，其中异常对象类型是 NPL::ListTypeError(@6.3) 或 NPL::ValueCategoryMismatch(@6.3) 。

@9.5.8 封装：
() make-encapsulation-type ：创建封装类型。
和 Kernel 类似，返回三个合并子组成的列表，其元素分别表示用于构造封装类型对象的封装(encapsulate) 构造器、判断封装类型的谓词和用于解封装(decapsulate) 访问器。
构造器直接使用参数，类似(@9.4.1.1) 中带有 % 的容器构造器；
访问器根据参数的值类别转发被封装的值。
和 [RnRK] 不同，被封装的对象具有被装箱值的所有权，因此需要注意保存被构造的封装对象。

@9.6 基础派生操作(grounded derived operations) ：
剩余基础环境(@9) 操作可以从基本操作组合实现，或依赖其它实现特定的互操作接口的本机实现(@5.2.1) 组合实现。
这些可组合的实现是派生操作，在基础上下文(@7.12) 的根环境中初始化。
@9.6.1 和 @9.6.2 的少量操作可使用派生实现（可能需要使用 @9.6.2 中的函数或 @9.6.1 中的部分非派生实现），但因为性能等原因在 NPLA1 API 中提供直接支持的本机实现(@9) 。
这些操作的派生实现同时在 NPL::Dependency 模块内被给出作为替代实现。
不直接使用本机实现的替代实现仅供参考，可能引入和本机实现不同的未指定行为，且可能有和核心特性实现相关的限制，如：
可使用不同的类型检查顺序(@8.4.3.4.1) ，多次失败的类型检查可能引发不同的诊断(@8.4.3) ；
使用 TCO 实现 PTC(@8.4.8) ，可能具有不同的支持(@8.4.8.1) 。
注意和 [RnRK] 合并子的派生完全省略错误处理而允许不同的诊断不同，NPLA1 中的操作的替代实现的没有被以上例外或操作自身的语义指定的其它行为（如诊断(@8.4.3) ）仍应和本机实现保持一致。

@9.6.1 基本派生操作：
引入合并子的操作子对 <body> 的约定同 @9.5.6 。
因为互相依赖，一些操作实现为派生操作时，不能用于直接派生特定一些其它操作。
和 $vau/e 或 $vau/e%(@9.5.6) 不同，不指定静态环境的合并子构造器隐含总是使用环境弱引用(@5.4.3) 形式的静态环境，以避免过于容易引入循环引用(@8.6.1.1) 。另见 @5.4.3 。
() get-current-environment ：取当前环境(@5.4.4) ，具有宿主值类型 NPL::EnvironmentReference 。派生需要非派生实现的 vau/e 。
() lock-current-environment ：取当前环境，具有宿主值类型 shared_ptr<Environment> 。
$vau <formals> <eformal> <body> ： vau 抽象(@4.5.2.3) 。
和 Kernel 不同，可通过 $vau/e(@9.5.6) 和（非派生的）get-current-environment 派生，不是基本操作(@9.5) 。
$vau% <formals> <eformal> <body> ： 同 $vau(@9.6.1) ，但保留引用值。
$quote <expression> 引用操作。结果为返回值转换(@5.7.4.4) 后的未被求值的操作数。
考虑通常引用操作对符号类型未被求值的左值操作数使用，保留引用值没有意义，因此不提供对应保留引用值的操作。
id <object> ：结果为不隐含左值到右值转换的参数，在结果保留引用值。
其作用等价返回值转换，可能引起对象转移(@5.5.5.2) 。
idv <object> ：同 id ，但结果为返回值转换(@5.7.4.4) 后的值。
list <object>... ：构造列表（类型为 <list> ）对象。
list% <object>... ：同 list ，但每个参数都不隐含左值到右值转换，在结果保留引用值。
$deflazy! <definiend> <expressions> ：修改绑定。
同 $def! ，但不对操作数求值。
$set! <environment> <formals> <expressions> ：修改指定环境的绑定，绑定效果同使用 $def!(@9.5.5) 。
类似 Kernel 的 $set! 。注意 <expressions> 的形式不同。允许的递归操作参见 $def! 。
$setrec! <environment> <formals> <expressions> ：修改指定环境的绑定，绑定效果同使用 $defrec!(@9.5.5) 。
同 $set! ，但允许不同的递归操作，参见 $defrec! 。
$lambda <formals> <body> ： λ 抽象(@4.5.2.2) 。
可通过 vau 抽象或 $lambda/e 和（非派生的）get-current-environment 派生。
表达式项的用法和 vau 抽象类似。
和 $lambda/e 不同，隐含总是使用弱引用的静态环境，以避免过于容易引入循环引用(@8.6.1.1) 。另见 @5.4.3 。
$lambda% <formals> <body> ：同 $lambda ，但允许函数体求值返回引用值。
$sequence <expression-sequence> ：顺序求值。操作数非空时返回最后的参数，可能是引用值。
类似 Kernel 的同名操作。
求值每个 <object> 的副作用包括其中临时对象的销毁都被顺序限制，类似宿主语言的语句而不是保证子表达式中的临时对象的生存期延迟到完全表达式求值结束的逗号表达式。这也允许实现和 [RnRK] 同名操作类似的 PTC 要求。 
collapse <object> ：折叠可能是引用的值。
forward <object> ：转发(@8.8.4) 可能是引用的值(@9.4.2.4) 。
按在所在的环境中解析的操作数的类型可选地提升项(@6.6) 作为结果，其作用 id 或 idv 之一。
被转发的值若是作为形式参数树(@7.6.2) 中的变量，一般应以带有标记字符 & 的形式绑定(@7.6.2.4) ；否则，转发的不是对应的操作数，而可能是按值绑定的副本。
转移（而不是复制）可修改的右值操作数。注意若右值操作数不可修改（如本机实现引入带有 TermTags::Nonmodifying 标签(@5.4.2.2) 的引用操作数），复制不可复制构造的宿主对象会失败。
本机实现使用 NPL::MoveRValueToReturn(@6.6.3) 可简化操作。
forward! <object> ：同 forward ，但除转移右值操作数外，也转移（而不是复制）可修改的临时对象操作数。
其中，需转移时，使用使用项的转移(@5.5.3) 。这和对象的转移(@5.5.2.3) 不同，不保证调用宿主实现的转移构造函数。
本机实现使用 NPL::MoveRValueToForward(@6.6.3) 可简化操作。
这个函数类似宿主语言以对象类型参数和推断的函数参数类型作为模板参数调用 std::forward ，但若需转移，直接转移而非如 expire(@9.5.1) 返回指定结果是消亡值(@5.5.1) 的唯一引用(@5.4.2.2) 。
和宿主语言不同，直接转移允许区分消亡值和纯右值，同等地作为一等对象（如作为列表的元素）。
apply <applicative> <object> <environment> ：在指定环境中应用。
和 Kernel 的参考派生不同，检查 <environment> 确保为一个对象。
apply <applicative> <object> ：在新建的空环境中应用。
以上 apply 的函数值保留引用值。
list* <object>+ ：在列表前附加元素创建列表。
类似 cons ，但支持一个和多个操作数。
对一个操作数的情形返回原值，否则类似 cons ，检查最后一个实际参数是 <list> 。
为不需要如 Kernel 支持派生 $vau ，直接使用 apply 派生。
list*% <object>+ ：同 list* ，但创建的列表元素保留引用值。
forward-list-first% <applicative1> <applicative2> <list> ：取列表的第一元素并转发给指定的应用子。
对参数列表 (&list-appv &appv &l) ，结果同求值 ($lambda% ((&x .)) (forward! appv) ($resolve-identifier x)) ((forward! list-appv) l) ，其中调用 (forward! list-appv) 和 (forward! appv) 的动态环境同调用 forward-list-first% 的动态环境。
assign%! <reference> <object> ：同 assign@!(@9.5.3) ，但 <object> 是引用时被折叠。
assign! <reference> <object> ：同 assign%! ，但 <object> 隐含左值到右值转换。
set-first! <list> <object> ：修改列表的第一个元素。
和 Kernel 的 set-car! 类似，但可派生，检查列表是左值，且不保留引用值。
set-first@! <list> <object> ：同 set-first%! ，但保留未折叠的引用值。
set-first%! <list> <object> ：同 set-first! ，但保留引用值。
不检查修改操作(@8.4.5.1) 导致循环引用，用户应自行避免未定义行为(@5.2.2) 。
first <list> ：取列表第一个元素的值。
类似传统 Lisp 及 Kernel 的 car 。命名和 SRFI-1 及 Clojure 等现代变体一致。
当 <list> 是左值时结果是折叠的引用值，否则结果是返回值转换(@5.7.4.4) 后的值。
first@ <list> ：同 first ，但结果总是未折叠的引用值。
first& <list> ：同 first ，但结果总是折叠的引用值，且首先调用 check-list-reference(@9.5.7) 检查参数是列表引用，对右值的抛出异常。
firstv <list> ：同 first ，但结果总是返回值转换后的值。
check-environment <environment> ：检查环境。
检查环境通过的条件同创建合并子时的检查(@9.5.6) 。
若检查通过，返回转发的参数，否则引发错误(@8.4.3.1)。
引发的错误对象和创建合并子时环境检查失败引发的错误对象，或其依赖(@8.4.3.1) 的错误对象（后者保证不是语法错误(@7.7.1) ）。
$cond <clauses>... ：条件选择。
类似 Kernel 的同名操作，但 <test> 的判断条件和 <body> 形式不同。
$when <test> <expression-sequence> ：条件为 #t 时顺序求值。
类似 klisp 的同名操作，但若 <expression-sequence> 被求值，结果为 <expression-sequence> 的最后一个 <expression> 的求值结果，而不是 #inert 。
这类似 Racket 的 when 而和 [R7RS] 的 when 或 klisp 的同名操作不同，因为 $when 被作为和 $sequence 类似的操作处理（对应 Racket 中的 when 和 begin 并列）。
$unless <test> <expression-sequence> ：条件不为 #t 时顺序求值。
类似 klisp 的同名操作，但若 <expression-sequence> 被求值，结果和设计原理同上。
not? <object> ：逻辑非。
和 Kernel 不同而和 Scheme 类似，视所有非 #f 的值为 #t 。
$and? <test>... ：逻辑与。短路求值。操作数为空时返回 #f ，否则返回参数之一。结果保留引用值。
$or? <test>... ：逻辑或。短路求值。操作数为空时返回 #t ，否则返回参数之一。结果保留引用值。

@9.6.2 核心库(core library) 函数：
$defl! <variable> <formals> <body> ：绑定 λ 抽象，等价 $def! <variable> $lambda <formals> <body> 。
$defl%! <variable> <formals> <body> ：绑定 λ 抽象，等价 $def! <variable> $lambda% <formals> <body> 。
$defv! <variable> <formals> <eformal> <body> ：绑定 vau 抽象，等价 $def! <variable> $vau <formals> <eformal> <body> 。
$defv%! <variable> <formals> <eformal> <body> ：绑定 vau 抽象，等价 $def! <variable> $vau% <formals> <eformal> <body> 。
$defv/e! <variable> <environment> <formals> <eformal> <body> ：绑定指定静态环境的 vau 抽象，等价 $def! <variable> $vau/e <environment> <formals> <eformal> <body> 。
$defv/e%! <variable> <environment> <formals> <eformal> <body> ：绑定指定静态环境的 vau 抽象，等价 $def! <variable> $vau/e% <environment> <formals> <eformal> <body> 。
$defw! <variable> <formals> <eformal> <body> ：绑定 wrap 的 vau 抽象，等价 $def! <variable> wrap ($vau <formals> <eformal> <body>) 。
$defw%! <variable> <formals> <eformal> <body> ：绑定 wrap 的 vau 抽象，等价 $def! <variable> wrap ($vau% <formals> <eformal> <body>) 。
$defw/e! <variable> <environment> <formals> <eformal> <body> ：绑定 wrap 的指定静态环境的 vau 抽象，等价 $def! <variable> wrap ($vau/e <environment> <formals> <eformal> <body>) 。
$defw/e%! <variable> <environment> <formals> <eformal> <body> ：绑定 wrap 的指定静态环境的 vau 抽象，等价 $def! <variable> wrap ($vau/e% <environment> <formals> <eformal> <body>) 。
$lambda/e <environment> <formals> <body> ：同 $lambda ，但支持显式指定的求值环境作为静态环境。
$lambda/e% <environment> <formals> <body> ：同 $lambda/e ，但保留引用值。
$defl/e! <variable> <environment> <formals> <body> ：绑定指定静态环境的 λ 抽象，等价 $def! <variable> $lambda/e <environment> <formals> <body> 。
$defl/e%! <variable> <environment> <formals> <body> ：绑定指定静态环境的 λ 抽象，等价 $def! <variable> $lambda/e% <environment> <formals> <body> 。
rest <list> ：取列表第一个元素以外的元素值构成的列表。
rest& <list> ：同 rest ，但在返回的列表值中的元素是引用值，且首先调用 check-list-reference 检查参数是列表引用，对右值的抛出异常。
rest% <list> ：同 rest ，但在返回的列表值中的元素可能是传递的引用值。
() make-standard-environment 创建标准环境：创建没有其它绑定的环境。当前环境作为根环境(@9) 作为新创建环境的唯一父环境。类似 Kernel 的 make-standard-kernel-environment 。
box <object> 装箱：构造箱（类型为 <box> 的对象）。
box% <object> 同 box ，但参数不隐含左值到右值转换，在结果保留引用值。
box? <object> 判断是否为 <box> 类型的对象。
unbox <box> 拆箱：从箱中还原对象。作为传递操作，保留引用值。
以上 4 个函数除引用标记字符(@8.9) 对应处理引用值的差异外，功能和使用方式对应类似 SRFI-111 的 3 个过程 box 、box? 和 unbox 。
类型分区(@8.4.7) 使 box? 对 <list> 类型的参数的结果总是 #f 。若没有这个限制，用以下 <list> 的相关操作可整体替换进行功能等价的代替：
用 list 、list% 和 first 可代替 box 、box% 和 unbox 。
和 http://community.schemewiki.org/?scheme-faq-language 关于装箱的描述不同，这样的代替不一定保证有更好的性能。
以上这些函数可使用 make-encapsulation-type(@9.5.8) 实现。
和 Scheme 等不同，箱具有被装箱对象的所有权，因此使用 box% 和 unbox 时，需注意保存被构造的箱或被箱中引用值引用的对象。
first-null? <list> ：复合 first 和 null? 操作。可用于实现 unfoldable? 的检查中的单个项。
list-rest% <list> ：复合 list% 和 rest% 操作。可用于解析 <bindings> ，去除其中每个元素的符号项构成新的列表。
accl <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3> ：在抽象列表的元素上应用左结合的二元操作。
对 <object1> 指定的抽象列表进行处理，取得部分和。
当谓词 <predicate> 成立时结果为参数指定的对象，否则继续处理抽象列表中余下的元素。
处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。
accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3> ：在抽象列表的元素上应用右结合的二元操作。
操作方式同 accl 。
和 accl 不同，可保证合并操作是尾调用。
foldr1 <applicative> <object> <list> ：同 accr ，但指定谓词为 null? ，应用子分别为 first 和 rest 。
同 SRFI-1 的 fold-right ，但只接受一个真列表(@8.6.3) 。
list-concat <list1> <list2> ：取顺序连接的表。
append <list>... ：拼接列表。
map1 <applicative> <list> ：单列表映射操作，使用指定应用子对列表中每个参数进行调用，结果为调用结果的列表。
任意两个调用之间的相对求值顺序未指定。
类似 Kernel 的 map ，但只接受一个真列表(@8.6.3) 。
$let <bindings> <body> ：局部绑定求值。
类似 Kernel 的同名操作，但返回非引用值(@8.6.1.4) 。
$let% <bindings> <body> ：同 $let ，但保留引用值。
当前派生使用 $lambda% 而不是 $lambda 实现。
$let/d <bindings> <eformal> <body> ：同 $let ，但在 <body> 的求值前引入绑定到动态环境的变量 <eformal> 。
若 <eformal> 为 #ignore ，作用同 $let 。
$let/d% <bindings> <eformal> <body> ：同 $let/d% ，但保留引用值。
若 <eformal> 为 #ignore ，作用同 $let% 。
$let/e <environment> <bindings> <body> ：指定静态环境并局部绑定求值。
类似 Kernel 的 $let-redirect ，但使用 $lambda/e 而不是 eval 和 $lambda 实现，并返回非引用值。
这允许传递引用值并保证环境的宿主值类型（包含所有权）被正确传递作为求值的父环境，而无需支持扩展 <environment> 为右值时其中的环境临时对象的生存期。
注意此时 <environment> 中创建的环境对象在表达式求值后仍会因为 $lambda/e% 引入的合并子生存期结束而被销毁。
$let/e% <environment> <bindings> <body> ：同 $let/e ，但使用 $lambda/e% 而不是 $lambda/e 实现，保留引用值。
$let* <bindings> <body> ：顺序局部绑定求值。
类似 Kernel 的同名操作。
$let*% <bindings> <body> ：同 $let* ，但保留引用值。
$letrec <bindings> <body> ：顺序局部绑定求值，允许递归引用绑定。
类似 Kernel 的同名操作。
和 $let 及 $let* 不同，操作保证使用同一环境，因此可配合 lock-current-environment 传递具有所有权的环境。
$letrec% <bindings> <body> ：同 $letrec ，但保留引用值。
注意以上 $let 等函数的 <body> 形式和 Kernel 不同。
$bindings/p->environment (<environment>...) <binding>... ：转换绑定列表为以指定的环境列表为父环境的环境。
类似 Kernel 的 $binding->environment ，但指定父环境具有适当的所有权。使用 make-environment 而不是 $let/e 等绑定构造实现。
$bindings->environment <binding>... ：转换绑定列表为环境。
类似 Kernel 的同名操作，但因为要求对内部父环境环境所有权，使用 $binding/p->environment 而不是 $let/e 等绑定构造实现。
$provide! <symbols> <body> ：求值并绑定符号。
类似 Kernel 的同名操作，但返回创建的局部环境的强引用。
绑定后的符号可通过作为 vau 抽象的父环境(@8.6.2.2) 等形式依赖这个环境，因此用户需适当保存返回值使其生存期(@8.6.2.2) 覆盖在被使用的绑定符号指称的对象生存期。
$provide/d! <symbols> <eformal> <body> ：同 $provide! ，但在 <body> 的求值前引入绑定到动态环境的变量 <eformal> 。
若 <eformal> 为 #ignore ，作用同 $provide! 。
$import! <environment> <symbols> ：从环境导入符号。
类似 Kernel 的同名操作。
unfoldable? <list> ：判断参数是否可被映射。映射类似 Kernel map 操作可接受的列表参数。
list-extract <list> <applicative> ：以指定应用子在指定列表中选取并合并内容为新的列表。
对参数列表 (&l &extr) ，结果同求值 accr l null? () ($lambda% (&l) forward-list-first% expire extr l) rest% cons% 。
list-extract-first <list> ：同指定应用子为 first 的 list-extract 。
对参数列表 (&l &extr) ，结果同求值 list-extract ls first 。
list-extract-first-rest%! <list> ：同指定应用子为 rest% 的 list-extract 。 
对参数列表 (&l &extr) ，结果同求值 list-extract ls rest% 。
map-reverse <applicative> <list>... ：映射并反转结果。映射类似 Kernel map 操作。
for-each-ltr <applicative> <list>... ：从左到右映射取副作用。类似 Kernel 的 for-each 但保证顺序。

@10 NPLA1 参考实现扩展环境：
和 @9.5 和 @9.6 类似，NPLA1 以根环境的形式提供其它一些模块的操作。
因为可移植性和模块化等原因，这些操作不直接引入基础上下文(@7.12) 的根环境中。
这允许实现使用特殊的环境子类型延迟加载（当前 NPLA1 没有提供支持）。
这也允许作为实现的用户程序可选地支持这些操作。作为被加载的模块的环境的名称由具体用户程序决定。
修改(@8.4.5.1) 这些环境的程序行为未定义。
默认加载使用 . 分隔标识符得到的符号作为名称，类似 CHICKEN Scheme 的转换 R7RS 的标准模块名（参见 http://wiki.call-cc.org/eggref/4/r7rs#import ）。
@10.2 外在 SHBuild 使用默认加载。
加载的模块依赖根环境，需通过 Forms::LoadGroundContext(@7.12) 或等价的方式初始化。
当前实现中部分加载的环境依赖之前加载的环境，这些环境的名称是固定的。用户程序需要保证这些环境在加载时的静态环境中可用。
用户程序需保持加载为环境的模块具有适当的生存期(@8.6.2.2) ，以避免其中的合并子调用引起未定义行为。

@10.1 环境：
通过初始化基础上下文后调用 Forms::LoadModule_std_environments(@7.12) 初始化，默认加载为根环境下的 std.environments 环境。
当前实现要求 std.strings 环境(@10.3) 可用。
bound? <string> ：判断指定字符串对应的符号是否被绑定。
$binds1? <environment> <symbol> ：判断指定符号是否在指定表达式求值后指称的环境中绑定。
和 Kernel 中的 $binds? 类似但只支持判断一个符号。
value-of <object> ：求值标识符得到指称的实体。
若操作数是字符串，结果为求值标识符得到指称的实体；否则为 ValueToken::Null(@7.2.2) 。
() get-current-repl ：取表示当前 REPL 环境的引用值。
eval-string <string> <environment> ：在参数指定的环境中求值作为外部表示的字符串。
类似 klisp 的同名操作，参见 http://klisp.org/docs/Environments.html#Environments 。
eval-string% <string> <environment> ：在参数指定的环境中求值作为外部表示的字符串。
类似 eval-string ，但保留引用值。
eval-unit <string> <object> ：在参数指定的 REPL 环境中规约字符串表示的翻译单元以求值

@10.2 代理求值：
通过初始化基础上下文后调用 Forms::LoadModule_std_promises(@7.12) 初始化，默认加载为根环境下的 std.promises 环境。
除 $laze/e 外，同 [RnRK] 的 promises 模块，但当前不支持 PTC(@8.4.8) 。
promise? <object> ：判断是否为 <promise> 类型的对象。
memoize <expressions> ：记忆化求值。
$lazy <expressions> ：创建 promise 对象，延迟求值。
$lazy/e <environment> <expressions> ：同 $lazy ，但以指定环境替代动态环境。
force <promise> ：立即求值指定的 promise 对象。

@10.3 字符串：
通过初始化基础上下文后调用 Forms::LoadModule_std_strings(@7.12) 初始化，默认加载为根环境下的 std.strings 环境。
++ <string>... ：字符串串接。
string-empty? <string> ：判断字符串是否为空。
string<- <string1> <string2> ：字符串赋值(@8.4.5.1.1) 。
string-contains-ci? <string1> <string2> ：判断忽略大小写的字符串中前者是否包含后者。
symbol->string <symbol> ：转换符号为字符串。
string->symbol <string> ：转换字符串为符号。
不检查值是否符合符号要求。
regex->string <string> ：创建字符串初始化的正则表达式。
regex-match? <string> <regex> ：在字符串中搜索正则表达式指定的模式串

@10.4 输入/输出：
通过初始化基础上下文后调用 Forms::LoadModule_std_io(@7.12) 初始化，默认加载为根环境下的 std.io 环境。
puts <string> ：调用 std::puts 输出字符串。
load <string> ：加载翻译单元。
当前实现中的字符串为文件系统路径。
类似 klisp 的同名操作，但不使用 find-required-filename 机制，直接以宿主的运行环境为基准使用路径。

@10.5 系统：
通过初始化基础上下文后调用 Forms::LoadModule_std_system(@7.12) 初始化，默认加载为根环境下的 std.system 环境。
当前实现要求 std.strings 环境(@10.3) 可用。
() cmd-get-args ：返回宿主环境(@2.7.1) 程序接受的命令行参数列表。
其中参数数组保存在函数 YSLib::LockCommandArguments 访问的对象中。
传递给 REPL 的命令行参数通常是宿主程序中主函数的 argv 参数数组中处理后去除特定参数后的程序。
宿主程序复制 argv 到这个数组作为副本后，作为函数值的列表的来源。
env-get <string> ：取宿主环境的环境变量字符串。
env-set <string> ：设置宿主环境的环境变量字符串。
env-empty? <string> ：判断字符串指定名称的环境变量是否为空。
system <string> ：以 std::system 兼容的方式调用外部命令。使用 YSLib::usystem 实现。
system-get <string> ：调用命令，返回命令调用结果。
返回一个两个元素的列表，分别是管道输出字符串和命令返回的 int 类型的错误码。
调用命令和 system 的方式类似。
system-quote <string> ：检查参数，按需返回以半角双引号引用的用于命令行参数的字符串。
带空格或水平制表符的字符串、以半角引号开始或结束的字符串和空字符串会被引用。

@10.6 SHBuild 操作：
以下互操作接口用于 SHBuild 和外部脚本的构建。
通过初始化基础上下文后调用 Forms::LoadModule_SHBuild(@7.12) 初始化，加载为根环境下的 env_SHBuild_ 环境。
这些接口主要用于内部使用，不保证稳定。
SHBuild_BaseTerminalHook_ ：内部对象，用于终端控制。
SHBuild_BuildGCH_existed_ <string> ：判断参数指定路径的预编译头文件是否存在。
SHBuild_BuildGCH_mkpdirp_ <string> ：在预编译头文件构建时按需创建参数指定的路径父目录。
SHBuild_EchoVar <string1> <string2> ：在终端输出变量及其值。
SHBuild_Install_HardLink <string> ：以参数为路径安装硬链接。
SHBuild_QuoteS_ <string> ：为字符串添加单引号，以允许在 Shell 代码中使用。
处理时复用词法分析(@5.3.1) 和语法分析 (@5.3.2) 的部分实现。同 @3.3.4 ，不对空字符特殊处理。
SHBuild_RaiseError_ <string> ：引发包含参数指定的字符串内容的错误(@8.4.3.1) 。
SHBuild_SDot_ <string> ：替换字符串的点为下划线。
SHBuild_TrimOptions_ <string> ：清理选项字符串的空白符。

@11 SHBuild 实现环境：
SHBuild 实现环境是基于参考 NPLA1 实现环境(@9) 的用于 SHBuild 和外部脚本的构建的初始环境。
关于 SHBuild 的调用方式说明，详见 https://bitbucket.org/FrankHB/yslib/wiki/SHBuild.zh-CN.md 。
操作约定同 @9 ，包括 @8.7 和 @8.9 。

@11.1 NPL::Dependency 派生操作：
SHBuild 实现环境由 NPL::Dependency 提供初始的派生操作。
在基础环境(@7.12) 上，SHBuild 实现环境通过切换新环境并调用 Forms::LoadModule_SHBuild(@7.12) 初始化。
SHBuild 的基础环境(@9) 的子环境中提供对象引用 env_SHBuild_ ，其中包含这些接口。
部分 SHBuild 互操作接口在 YFramework 的 NPLA1 实现中提供，参见 @10.6 。
此外，NPLA1 在默认实现的 SHBuild_BaseTerminalHook_(@11.1.1) 的实现被覆盖，以使 SHBuild_EchoVar(@11.1.1) 等和 SHBuild 的其它输出兼容。

@11.2 派生接口：
以下 SHBuild 互操作及脚本调用接口可能在 NPLA1 、SHBuild 工具或外部脚本中实现。
因为名称保持稳定，也在此提供文档。
SHBuild_EchoVar_N <string> ：在终端输出环境变量及其值。
SHBuild_BuildGCH <string> <string> <string> ：构建参数指定路径的预编译头文件。
参数分别为目的路径、源路径和构建命令。

*/
////

